<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>存档Save&amp;Load</title>
  <subtitle>存档意味着放下包袱，搞砸了不过回来读档</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jaycechant.info/"/>
  <updated>2020-04-12T05:22:10.791Z</updated>
  <id>https://jaycechant.info/</id>
  
  <author>
    <name>Jayce Sigit Chant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>域名解析从 DNSPod 到 Cloudflare</title>
    <link href="https://jaycechant.info/2020/name-server-from-dnspod-to-cloudflare/"/>
    <id>https://jaycechant.info/2020/name-server-from-dnspod-to-cloudflare/</id>
    <published>2020-04-10T15:11:52.000Z</published>
    <updated>2020-04-12T05:22:10.791Z</updated>
    
    <content type="html"><![CDATA[<p>个人博客托管在 Github pages，居然也快 8 年了。省事，不花钱。<br>前几年我又给它配了域名，解析用的免费 DNSPod 。（被腾讯收购是后来的事）</p>
<p>近期折腾技术上的事，了解到 Cloudflare 也有免费域名解析，而且居然带免费 CDN 和 DDOS 保护，有点动心。</p>
<a id="more"></a>
<h2 id="换-Cloudflare-的念头"><a href="#换-Cloudflare-的念头" class="headerlink" title="换 Cloudflare 的念头"></a>换 Cloudflare 的念头</h2><p>必须说，CDN 可有可无。虽然 github.io 服务器在国外，有时访问确实有点卡，CDN 可能改善一下，但也没到非缓存不可。而且 CDN 的缓存，会让修改和发布时，生效有延迟，不能马上看到。</p>
<p>至于 DDOS，谁有空攻击我呢。</p>
<p>这多出来的功能，属于 <strong>鸡肋</strong>。为什么我还是动心，折腾了呢？</p>
<ol>
<li><p>Cloudflare （以下简称 CF）作为盛名在外的服务商，它的解析服务不至于太烂。</p>
<p> 我只用过 DNSPod （以下简称 DP）的服务，如果以后需要用别家的，容易抓瞎。花点时间换个差不多的免费服务，可以了解一下各家的差别。</p>
</li>
<li><p>CDN 和 DDOS 保护，暂时鸡肋，但是开了也不至于有害（搞不好真香）。那么体验一下，日后需要这些功能时，值不值得弄、要怎么操作心里也有底。</p>
</li>
</ol>
<p>说白了，这是我做事的习惯：在不紧迫时，多折腾不同方案，建立起判断的基线。最坏也不过得出一个『CF 真烂，DP 真香』的结论，然后迁回去。</p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><p>注册 CF 帐号，选择免费方案，输入域名，很快就导入了当前的 DNS 记录（但是不全）。</p>
<p>然后会提醒 Name-server 不是他们家，给出他们的两个 Name-server 地址。每个人拿到的地址可能不一样，以 CF 给的为准。据说不用他们家的解析，也能用 CDN，我没研究。</p>
<p>去到域名注册商，把 Name-server 改过来。等了一下，刷新，注册商那边显示生效了。</p>
<p>回到 CF ，因为注册时刚检测过 DNS，下一次自动检测还要好久，可以手动点一下检测，然后就开始排队。过了不久，检测之后发现 Name-server 记录已经指过来了，就显示域名已经在 CF 的保护下。</p>
<p>上面一排功能按钮，起码看起来是比 DP 厉害的样子（当然不排除 DP 也有类似功能，只是它没摆出来，我也没探索过）。</p>
<p>首先把 DNS 记录缺的照抄过来（已经忘了缺哪几条了），DP 那边的记录有这些</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>域名</th>
<th>目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNAME</td>
<td>@</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>*</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>www</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>qqmailxxxxx （这串码每个人不同）</td>
<td>mail.qq.com</td>
</tr>
<tr>
<td>MX</td>
<td>@</td>
<td>mxdomain.qq.com (priority:5)</td>
</tr>
<tr>
<td>MX</td>
<td>@</td>
<td>mxdomain.qq.com (priority:10)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>@</code> 代表根域名。同时注册 <code>@</code> , <code>*</code> , <code>www</code> ，是因为这个地址暂时只有博客，当时希望访客就算自动补上 www，或者输了随便哪个子域名，也能访问到（当然这个配置也是当年不求甚解抄网上的）。</li>
<li>也注册了域名邮箱。不要问我为什么一样的内容，要添加不同优先级的两条记录，QQ 邮箱教程这样写，照做而已。（现在 QQ 域名邮箱已经停止注册和新增邮箱了，已经注册的还能用，但新注册或者新增只能注册一个企业微信用企业邮箱。）</li>
</ul>
<p>把记录都抄过来之后，看起来差别只有两个地方：</p>
<ul>
<li>CF 有一项功能叫 CNAME flatterning，会自动把 <code>@</code> 替换成实际的根域名（<code>jaycechant.info</code> ，记录 Name 栏显示的就是完整域名），然后把指向的域名解析成实际的地址（但记录 target 栏显示的还是域名）。声称加快 30% 解析速度。只有根域名会这样做，相当于帮你生成了 根域名的 A 记录。</li>
<li>右边多了一列图标，点击在两种状态切换：箭头穿过黄色的云（Proxied）表示开启了 CDN 缓存，箭头绕过灰色的云（DNS only）表示关闭。MX 记录不能打开缓存。想体验一下，就把 CDN 打开了。</li>
</ul>
<p>配置完等了一会，博客还能访问。不确定是缓存还在起效，还是新的设置已经生效（其实也没差别）。于是去 DP 把原来的域名解析删掉。</p>
<h2 id="redirect-loop-和-1016"><a href="#redirect-loop-和-1016" class="headerlink" title="redirect loop 和 1016"></a>redirect loop 和 1016</h2><p>再等了一会，终于能看到差别：博客访问不了。错误是 ERR_TOO_MANY_REDIRECTS。</p>
<p>（参考 <a href="https://kinsta.com/blog/err_too_many_redirects/）" target="_blank" rel="external">https://kinsta.com/blog/err_too_many_redirects/）</a></p>
<p>按照 Chrome 提示和找到的建议，清浏览器缓存，清 CF 缓存，都没有用。可能是有 redirect loop。</p>
<p>于是我先关掉了 CDN，删了根记录（我也不知道当时为什么想到删根记录，可能当时还没理解好），好了，报新的错误了 Error 1016 ……</p>
<p>在好好学习，终于理解 1016 是什么意思之后，终于也知道根记录的重要性，加回去，继续 ERR_TOO_MANY_REDIRECTS……</p>
<p>问题似乎出在 通配符（wildcard）记录。根据查到的说法，每个服务商对 wildcard 的支持会不一样。我想，好像也没必要支持除了 www 以外的二级域名，就把这条记录删了（鬼知道当年跟哪里抄的做法），好了。</p>
<blockquote>
<p>注：敲下这些文字已经是第二天，我尝试找到背后的原因。重新按照之前的配置，加上 wildcard record，关掉 CDN ，清掉各种缓存，甚至尝试换个浏览器，用 curl 跟踪，都没能重现 ERR_TOO_MANY_REDIRECTS。</p>
<p>有可能这是两个 DNS 服务部分失效部分生效时产生的 edge case。可惜当时没想到跟踪 redirect ，了解具体是哪几个地址形成了 loop。</p>
<p>不过即使 wildcard record 不会引起错误，随便输一个子域名跳转到 <code>jaycechant.github.io</code> 还是 404，这条记录没有实际意义，最后还是删掉了。</p>
</blockquote>
<h2 id="Page-Rules"><a href="#Page-Rules" class="headerlink" title="Page Rules"></a>Page Rules</h2><p>然后测试 <code>www</code> 记录。（由于是默认主机名，有些人会习惯加，这条记录还是有用的）</p>
<p>结果是能访问，但会报安全提醒。这是因为证书是颁发给 <code>jaycechant.info</code> 而不是通配符域名 <code>*.jaycechant.info</code> ，<code>www.jaycechant.info</code> 不在范围内。</p>
<p>为什么不直接签一个通配符证书呢？因为证书不是自己申请的，而是在 Github pages 配置时，输入域名，Github 代为申请的。Github 官方的文档看这里：<a href="https://help.github.com/en/github/working-with-github-pages/about-custom-domains-and-github-pages。" target="_blank" rel="external">https://help.github.com/en/github/working-with-github-pages/about-custom-domains-and-github-pages。</a></p>
<p>这时发现了 CF 提供的 <strong>Page Rules</strong> 功能，可以编写规则，对满足特定条件的地址，应用某些功能，包括 Always Online （通过缓存实现）、Always use HTTPS （估计通过 301 实现）、Auto Minify 等等 20+ 个功能。</p>
<p>这里用到 Forwarding URL，可选 301（Permanent）和 302（Temporary）：</p>
<p><code>www.jaycechant.info/*</code>  -&gt;  <code>https://jaycechant.info/$1</code>，支持通配符，而且可以通过 <code>$1</code> , <code>$2</code> 这样的变量按顺序引用。</p>
<p>免费版仅提供 3 条规则，目前来看，不搞复杂的规则，够了。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>说回 CDN。</p>
<p>从我有限的尝试看，结果基本如我所料，开启 CDN 会让页面加载变快，同时修改应用有延迟。但必须说，这两个效果起码在这两天，差距都不算很大。</p>
<p>据官方说，国内他们是和百度 CDN 合作的，确实也是秒加载，不明显只能说原来直连 Github 还不够卡。</p>
<p>延迟方面，从上传完毕开始计时，一直刷新，到刷出更新的内容停止，大约 45 s。这个数字看着很大。但是要知道，上传完到 Github 发现变更，然后部署生效，也是有延迟的。而且 CF 还提供 Development Mode 开关，临时绕过缓存。（这个开关是 3小时自动关闭的，不用自己手动关。非要说麻烦的地方，就是还得登录 CF。）</p>
<p>总结下来，开没开 CDN 最明显的差异就是……证书不一样：没有 CDN 时，证书是颁发给 <code>jaycechant.info</code> 本身的，开了之后证书是颁发给 <code>sni.cloudflaressl.com</code> 。（那为什么证书地址和博客地址不一样居然能通过名称验证呢？这就要提到 SNI 了 ：<a href="https://zh.wikipedia.org/wiki/服务器名称指示" target="_blank" rel="external">服务器名称指示</a>）</p>
<p>综合下来最后还是没开 CDN。如果有一天直连 Github 卡得不行了，我再回来。</p>
<h2 id="Cloudflare-workers"><a href="#Cloudflare-workers" class="headerlink" title="Cloudflare workers"></a>Cloudflare workers</h2><p>最后提一个意外发现，Cloudflare 支持 edge computing workers，从一开始只有 js，到现在支持 js, Rust, C, C++，相当于一个 FaaS。提供了两种方案。</p>
<p>免费方案：</p>
<ul>
<li>Includes <strong>100,000 requests per day</strong> (UTC+0)</li>
<li>Up to 10ms CPU time per request</li>
<li>Lowest latency after the first request</li>
<li>Up to 30 Workers</li>
</ul>
<p>每个月花 5刀：</p>
<ul>
<li>Includes <strong>10 million requests per month</strong></li>
<li>Up to 50ms CPU time per request</li>
<li>Always lowest latency</li>
<li>Up to 30 Workers</li>
<li><strong>Key-value storage:</strong><ul>
<li>Up to 100 namespaces</li>
<li>1 GB of storage</li>
<li>10 million read operations, 1 million write, 1 million delete, and 1 million list operations</li>
</ul>
</li>
</ul>
<p>这能用来干嘛呢？要知道 Github pages 是静态托管，有限动态部分只能是浏览器端的 js，像评论这种功能就要引入额外的服务器和储存。所以第一反应就是可以运行一个评论服务，然后作为插件加入博客中。</p>
<p>它不限流量，限请求次数和每次请求的 CPU 时间。免费版每天 10 W requests ，完全够用了。</p>
<p>等等，带储存的吧，好像有 workers KV 服务。哦，KV 只有收费版才有啊，那打扰了，等我想到新的应用场景再回来……</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>最后列一下用到的工具和命令，备忘（如无备注，均是 Windows 下）</p>
<ul>
<li>清除 DNS 缓存 <code>ipconfig /flushdns</code></li>
<li>查找当前 dns 指向 <code>nslookup &lt;domain&gt;</code></li>
<li>输出详细解析和重定向过程 <code>curl -v -L &lt;domain&gt;</code> （Windows 不带，需要额外安装）</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人博客托管在 Github pages，居然也快 8 年了。省事，不花钱。&lt;br&gt;前几年我又给它配了域名，解析用的免费 DNSPod 。（被腾讯收购是后来的事）&lt;/p&gt;
&lt;p&gt;近期折腾技术上的事，了解到 Cloudflare 也有免费域名解析，而且居然带免费 CDN 和 DDOS 保护，有点动心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DNS" scheme="https://jaycechant.info/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>海恩 和 海因里希：记一件小事</title>
    <link href="https://jaycechant.info/2020/ohain-and-heinrich/"/>
    <id>https://jaycechant.info/2020/ohain-and-heinrich/</id>
    <published>2020-04-07T17:33:39.000Z</published>
    <updated>2020-04-08T16:49:31.452Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前，我就通过某些途径，对所谓的『海恩法则』有了印象。具体什么途径已经记不得，可能是公司组织的培训，也可能是纯粹在网上无意中浏览到。</p>
<p>它对生产安全的重视，还有强调在小问题中发现重大事故的隐患，给我留下了深刻印象。</p>
<p>不过这不是我真正想聊的内容。</p>
<a id="more"></a>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>它的概念给我留下深刻的印象，但因为没有实际应用，并没有特意去记忆，我并不能复述出它的细节，特别是 300-29-1 的这个比例，有时候甚至连名称都回忆不起来。</p>
<p>『我记得有个什么法则，说的是在重大事故发生之前，其实已经有多少个小事故发生过，以及更多的无伤害事故被忽视。』这个表述，连名字都不记得，到处是好像、大概的语气，说服力大打折扣。</p>
<p>所以当要总结自己的思考方法时，我想好好地学习一下这些影响我思考方式的 Laws，当然也包括这个 Ohain’s Law。</p>
<p>印象里模糊记得 海恩法则 和 Ohain’s Law （O is silent 也让我印象深刻），用中文一搜，果然有大量结果，各个百科、文库、门户网站的文章。（在写这篇文章时，重新搜了一下，有 百度百科、MBA 智库、360 百科、互动百科、搜狗百科、搜狐新闻（引用的 JieFangJun 报）、腾讯网、安全管理网 …… 现在认真再看一下，百科都是互相引用，文章也都没有查证。）</p>
<p>这些结果无不指向这样一些信息：帕布斯·海恩，德国人，涡轮喷射发动机发明者，航空界，安全飞行的法则</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前，我就通过某些途径，对所谓的『海恩法则』有了印象。具体什么途径已经记不得，可能是公司组织的培训，也可能是纯粹在网上无意中浏览到。&lt;/p&gt;
&lt;p&gt;它对生产安全的重视，还有强调在小问题中发现重大事故的隐患，给我留下了深刻印象。&lt;/p&gt;
&lt;p&gt;不过这不是我真正想聊的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="thought" scheme="https://jaycechant.info/tags/thought/"/>
    
  </entry>
  
  <entry>
    <title>go-bindata：go 语言的静态资源嵌入</title>
    <link href="https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/"/>
    <id>https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/</id>
    <published>2020-04-02T06:28:09.000Z</published>
    <updated>2020-04-03T16:48:54.728Z</updated>
    
    <content type="html"><![CDATA[<p>单文件无依赖发布，是 go 语言一项杀手级特性。看着不怎么起眼，但被应用发布和运维折磨过的朋友，会明白这意味着什么。</p>
<p>可没高兴多久，发现应用还是要引入各种静态资源。这时就要拿出 go-bindata 了。</p>
<a id="more"></a>
<blockquote>
<p>本文没有一开始给出最佳实践，而是从最简单的做法开始，展示一点一点改进的过程。长度尽量精简，希望你看到最后。</p>
</blockquote>
<h2 id="壹、是什么"><a href="#壹、是什么" class="headerlink" title="壹、是什么"></a>壹、是什么</h2><p>项目主页：<a href="https://github.com/go-bindata/go-bindata" target="_blank" rel="external">https://github.com/go-bindata/go-bindata</a></p>
<p>官方自述：</p>
<blockquote>
<p>This package converts any file into managable Go source code. Useful for embedding binary data into a go program. The file data is optionally gzip compressed before being converted to a raw byte slice.</p>
</blockquote>
<p>简单说，将 <strong>任意</strong> 文件转成 go 源码。它还可以帮你把数据 <strong>压缩一下</strong> 。常用于将数据嵌入程序。</p>
<p>这些资源文件变成源码之后，数据储存在字节切片中 (raw byte slice)，只需要导入生成的源码，调用几个简单的函数就可访问，反正比 文件IO 来得 <strong>简单和快</strong> 。因为是源码，也会加入编译，最后 <strong>包含在可执行文件中</strong> ，发布时也就不再需要带着资源文件。</p>
<p>原文写的是二进制数据，大概作者认为纯文本和字面量本身就可以在程序中声明。但下面你会看到，即使是这些数据，也有使用 go-bindata 的必要。</p>
<h2 id="贰、安装"><a href="#贰、安装" class="headerlink" title="贰、安装"></a>贰、安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get -u github.com/go-bindata/go-bindata/...</div></pre></td></tr></table></figure>
<p>一行命令，没什么好说的。三个点是指检查并安装所有子目录（如果有可以编译的 main 函数）。实际上提供的 CLI 工具在 go-bindata 子目录里，也就是 <code>github.com/go-bindata/go-bindata/go-bindata/</code> ，三个 go-bindata 从前到后分别是 organ 名、项目名、目录名。</p>
<p>你可能会发现，这里提供的地址，跟其他一些文章给的不一样。为了不把前面拖长，背后的故事放到了 <strong>最后</strong> 。</p>
<h2 id="叁、使用"><a href="#叁、使用" class="headerlink" title="叁、使用"></a>叁、使用</h2><p>先看帮助信息（当前版本 v3.1.2 。篇幅关系，省略了详细内容，你还是安装之后自己执行一遍吧。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">go-bindata --help <span class="comment"># 虽然参数列表里没有 --help, 但是确实起效了，-h 也有效</span></div><div class="line">Usage: go-bindata [options] &lt;input directories&gt;</div><div class="line"></div><div class="line">  -debug</div><div class="line">  -dev</div><div class="line">  -fs</div><div class="line">  -ignore value</div><div class="line">  -mode uint</div><div class="line">  -modtime int</div><div class="line">  -nocompress</div><div class="line">  -nomemcopy</div><div class="line">  -nometadata</div><div class="line">  -o string (default <span class="string">"./bindata.go"</span>)</div><div class="line">  -pkg string (default <span class="string">"main"</span>)</div><div class="line">  -prefix string</div><div class="line">  -tags string</div><div class="line">  -version</div></pre></td></tr></table></figure>
<p>最 <strong>基本的用法</strong> 是直接命令 + 目录，参数全部走默认（生成 <code>./bindata.go</code> ，包名 <code>main</code>），只包含目标目录，不包括子目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-bindata data/</div></pre></td></tr></table></figure>
<p>但这样用过于粗糙，特别是生成的源码直接放在根目录的 main 包下，不方便管理。</p>
<p>网上比较 <strong>常见的用法</strong> 是这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-bindata -o=asset/asset.go -ignore=<span class="string">"\\.DS_Store|desktop.ini|README.md"</span> -pkg=asset template/... theme/... doc/...</div></pre></td></tr></table></figure>
<p>做出的改进有：</p>
<ul>
<li>为了更好地管理生成的源码，（<code>-o</code>）指定输出的目录和文件名，（<code>-pkg</code>）给一个独立的包名（为了减少 import 时的认知负担，建议三者直接保持一致）。</li>
<li>目标目录可以有多个，三句点省略号表示 <strong>递归包含子目录</strong> 。</li>
<li>为了避免一些常见的文件被当作资源文件编译进去，（<code>-ignore</code>）添加一个 ignore pattern，注意用的是 <strong>正则表达式</strong> 。</li>
</ul>
<p>而我更 <strong>推荐的用法</strong> 是尽量把资源文件集中放在一个目录下面，避免这里放一点那里放一点，最后生成时遗漏。例如统一放 <code>assets</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-bindata -o=bindata/bindata.go -ignore=<span class="string">"\\.DS_Store|desktop.ini|README.md"</span> -pkg=bindata -prefix=assets assets/...</div></pre></td></tr></table></figure>
<ul>
<li><code>assets</code> 目录放了资源文件之后，为了避免混淆，也为了一眼能看出来是 go-bindata 生成的代码，源码路径、文件名 和 包名，都统一改为了 <code>bindata</code>。</li>
<li>资源既然统一放在 <code>assets</code> 目录下，增加 <code>-prefix</code> 参数，在生成的代码中去掉公共前缀。这样就可以直接用 <code>abc.png</code> 来引用 <code>assets/abc.png</code> 。</li>
</ul>
<p>执行这行命令得到的 <code>./bindata/bindata.go</code> 大概是这样子的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Code generated by go-bindata. DO NOT EDIT. @generated</span></div><div class="line"><span class="comment">// sources:</span></div><div class="line"><span class="comment">// assets/web.toml</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 被转换的文件清单...</span></div><div class="line"><span class="keyword">package</span> bindata</div><div class="line"></div><div class="line"><span class="keyword">import</span> (<span class="comment">/*...*/</span>)</div><div class="line"></div><div class="line"><span class="comment">// 私有结构体、函数定义</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 数据以私有 []byte 的方式保存</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 篇幅关系，只展示公共 API</span></div><div class="line"></div><div class="line"><span class="comment">// Asset 根据文件名读取文件内容的 []byte，出错返回 error</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Asset</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// MustAsset 跟 Asset 的区别只在于出错不返回 error ，直接 panic</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustAsset</span><span class="params">(name <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// AssetInfo 根据文件名返回文件信息</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssetInfo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(os.FileInfo, error)</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// AssetNames 返回所有文件名</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssetNames</span><span class="params">()</span> []<span class="title">string</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// AssetDir 返回指定目录下的所有文件，可以近似看作 ls / dir 命令</span></div><div class="line"><span class="comment">// 参数从根目录算起，空串 "" 当作根目录</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssetDir</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// RestoreAsset 将 name 指定的文件，恢复到 dir 指定的位置上</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">RestoreAsset</span><span class="params">(dir, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// RestoreAssets 是递归版的 RestoreAsset，如果 name 是目录，会递归执行下去</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">RestoreAssets</span><span class="params">(dir, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div></pre></td></tr></table></figure>
<p>除此以外，再了解一下 <code>-debug</code>  和 <code>-dev</code> 参数，就基本够用了，更多参数完全可以看着帮助信息自己试。</p>
<p>加了这两个参数（的其中一个），转换时不会真的把资源放进生成的源码，还是去原来的文件读，只是做了一层 API 封装。这样有利于开发和资源设计并行。</p>
<ul>
<li>代码已经生成，开发可以基于生成的 API 进行，背后究竟读硬盘上的文件还是内存里的切片，不影响调用。</li>
<li>各种资源文件还可以继续修改，只要在原有的文件上修改，没有新增文件或者重命名，就不需要重新执行 go-bindata 重新生成。频繁修改资源文件，调试时很容易忘掉是否有重新执行 go-bindata 。这个特性就特别有用。</li>
</ul>
<p><code>-debug</code> 和 <code>-dev</code> 之间的差别，仅仅是背后加载文件时，使用 绝对路径 还是 相对路径。这个看调试方便，差别不是特别大，正式的构建时时一定要关掉的。</p>
<h2 id="肆、自动生成"><a href="#肆、自动生成" class="headerlink" title="肆、自动生成"></a>肆、自动生成</h2><p>已经有固定的命令 + 参数搭配了，但是每次执行，不要说手敲麻烦又易错，就连复制粘贴都是体力活。</p>
<p>更不要说修改完资源容易忘掉重新执行转换。这时候就需要 go generate 和 make 出场了。</p>
<blockquote>
<p>关于 go generate 的详细介绍和用法，请自行搜索，或者等我后续介绍。</p>
<p>在 Windows 下配置 make 的方法，已经在前面几篇介绍 go 开发环境配置中写了。后续也考虑介绍 Makefile 的写法。</p>
<p>anyway，两个都只讲用到的，这里不详细展开。</p>
</blockquote>
<h3 id="go-generate"><a href="#go-generate" class="headerlink" title="go generate"></a>go generate</h3><p><code>go generate</code> 是 go 工具链自带的命令，自 go 1.4 之后提供。（写文章时最新是 1.14，我还在用 1.13）</p>
<p>只要在某个 go 源文件开头写（注意 <code>//go:generate</code> 前面和中间没有任何空格，冒号是半角冒号）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:generate go-bindata -o=bindata/bindata.go -ignore="\\.DS_Store|desktop.ini|README.md" -pkg=bindata assets/...</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> xyz</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"abc"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>这之后只要执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go generate</div></pre></td></tr></table></figure>
<p>工具链就会自行扫描项目所有源码里的 <code>//go:generate &lt;cmd&gt; [args]...</code> ，执行里面的 <code>cmd args</code> ，包括但不限于 go-bindata，任何在当前工作目录可以执行的命令，都行。</p>
<p>建议哪里的代码引用了资源文件，这行指令就放那个源码的开头。如果多处引用，则建议统一放程序入口。</p>
<h3 id="go-generate-make"><a href="#go-generate-make" class="headerlink" title="go generate + make"></a>go generate + make</h3><p>但 generate 只是解放了一长串命令 + 参数 的记忆负担，对强迫症来说，每次修改资源都要记得 <code>go generate</code> 仍然很难受。这时可以用 make 减轻负担。因为重点不是介绍 make，直接上结论：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: bindata build</span></div><div class="line"></div><div class="line">all: build</div><div class="line"></div><div class="line"><span class="comment"># build 依赖 bindata.go，这样构建时就不会忘掉生成</span></div><div class="line">build: bindata/bindata.go</div><div class="line">	go build # 真实项目中 go build 应该加上更多编译参数，这里不是重点，省略</div><div class="line"></div><div class="line"><span class="section">bindata:</span></div><div class="line">	go generate</div><div class="line"></div><div class="line">bindata/bindata.go: assets/*</div><div class="line">	go generate</div></pre></td></tr></table></figure>
<p>稍微解释一下 <code>bindata</code> 和 <code>bindata/bindata.go</code> 两个 target ：它们都是要执行 <code>go generate</code>  命令，生成转换后的源码，区别在于，前者是 <strong>伪目标</strong> ， 后者是真实文件。</p>
<ul>
<li><code>bindata</code> ：不存在这么一个文件，而且前面显式声明了它是一个伪目标 (phony target) ，意味着构建这个目标时，不需要判断文件是否存在和新旧，必定执行。可以用来在特殊情况下强制执行（如资源文件通过 <code>cp -p</code> 从别的地方拷贝过来覆盖过）。</li>
<li><code>bindata/bindata.go</code> ：是真实的文件。make 会比较 target 和 prerequisites 是否存在和修改时间先后判断是否执行。<code>bindata/bindata.go</code> 存在且最新时，是不会执行命令的。</li>
</ul>
<p>这个实际试一下就明白了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 前面已经生成了最新的 bindata/bindata.go</span></div><div class="line">make bindata/bindata.go</div><div class="line">make: <span class="string">'bindata/bindata.go'</span> is up to date.</div><div class="line"></div><div class="line"><span class="comment"># make bindata 仍然有效</span></div><div class="line">make bindata</div><div class="line">go generate <span class="comment"># 这行是 make 的 echo，说明 go generate 执行了</span></div><div class="line"></div><div class="line"><span class="comment"># 这时更新一下其中一个资源的时间</span></div><div class="line">touch assets/web.toml</div><div class="line">make bindata/bindata.go</div><div class="line">go generate <span class="comment"># 同上，这行是 make 的 echo</span></div></pre></td></tr></table></figure>
<h3 id="make-就够了"><a href="#make-就够了" class="headerlink" title="make 就够了"></a>make 就够了</h3><p>不过这样也还是有问题。</p>
<p>随着加入更多的代码生成工具，像 stringer （自动生成 String 方法），wire（自动生成依赖注入），protobufs（从 .proto 生成 .pb.go）等等，都要靠 <code>go generate</code> 触发。这时 <strong>粒度</strong> 就有点粗了，明明只是其中一种修改了要重新生成，偏偏一个 <code>go generate</code> 全部都触发。文件少的时候还好，多的时候就会平白增加生成和磁盘读写的时间。</p>
<p>而且分散在各个 go 文件注释中的 go generate 指令也增加了管理难度。</p>
<p>其实就大多数生成命令而言，make 就够用了。go generate 能做到的事情，make 基本都可以完成，还能定义宏和依赖关系，更加灵活。全局的生成指令建议 <strong>都放到 Makefile</strong>。只有个别生成指令跟某个 go 源文件高度相关、参数各处不一样，可以继续放在注释里，靠 go generate 调用。</p>
<p>修改之后的 Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里只是为了演示，实际中不改动的部分没有必要定义宏</span></div><div class="line"><span class="comment"># 或者定义一个 BINDATA_NAME 统一用它就好</span></div><div class="line">BINDATA_PATH = bindata</div><div class="line">BINDATA_NAME = bindata</div><div class="line">BINDATA_PACKAGE = bindata</div><div class="line">BINDATA_DIR = assets</div><div class="line"><span class="comment"># ignore list 还是建议定义一个宏，方便随时添加</span></div><div class="line">BINDATA_IGNORE = "\\.DS_Store|desktop.ini|README.md"</div><div class="line"></div><div class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: bindata build</span></div><div class="line"></div><div class="line">all: build</div><div class="line"></div><div class="line">build: bindata/bindata.go</div><div class="line">	go build</div><div class="line"></div><div class="line"><span class="comment"># 这两个 target 执行的命令一样，合并成一条规则</span></div><div class="line">bindata bindata/bindata.go: $(BINDATA_DIR)/*</div><div class="line">	go-bindata -o=<span class="variable">$(BINDATA_PATH)</span>/<span class="variable">$(BINDATA_NAME)</span>.go -ignore=<span class="variable">$(BINDATA_IGNORE)</span> -pkg=<span class="variable">$(BINDATA_PACKAGE)</span> -prefix=<span class="variable">$(BINDATA_DIR)</span> <span class="variable">$(BINDATA_DIR)</span>/...</div></pre></td></tr></table></figure>
<h2 id="伍、配置文件嵌入"><a href="#伍、配置文件嵌入" class="headerlink" title="伍、配置文件嵌入"></a>伍、配置文件嵌入</h2><p>回到文章开头提出的场景。</p>
<p>嵌入资源文件，是为了保持单文件发布的优势。各种资源嵌入源码后，不仅应用变成了单个可执行文件，数据还做了（Gzip）压缩。直接从代码区读取数据，也比磁盘 IO 要来的快捷可控。基本上只要文件不是非常巨大，资源嵌入都是利大于弊的。</p>
<p>而对于配置文件而言，要考虑得多一些。要允许用户修改配置，代码中的配置是无法修改的。这面临几个选择：</p>
<ol>
<li><p>应用单文件发布，配置文件让用户自行创建。</p>
<p> 开发角度看很方便。但对用户不友好，特别是开源项目。用户面对的只有可执行文件，只能尝试执行、启动，或者看一下 help 信息。对于如何、在哪创建配置文件，该怎么写，新用户 <strong>毫无头绪</strong> 。这样做需要项目文档相对完善，文档中有配置的章节，并且文档入口放在项目主页显眼的地方，最好在 help 信息里也有。</p>
</li>
<li><p>可执行文件带着默认的配置文件，打包发布。</p>
<p> 这种做法对用户友好一些。但首先享受不到单文件发布的便利。而且用户一旦不小心错误覆盖、或者删除了配置文件，仍然陷入了第一种情况，需要从头手敲配置。</p>
<p> 一种改进是将默认配置加上 <code>.sample</code> 后缀，用户启用了配置文件需要拷贝一份后去掉多余的后缀。这看起来是个好办法，把上述问题除了单文件发布都解决了。我用过这个方案。实际中发现哪怕仅仅拷贝重命名，对于小白用户而言还是 <strong>过于复杂</strong>，能产生各种开发者想象不到的问题。（Windows 上隐藏了后缀名，怎么改都不对；直接把 sample 文件覆盖了，出错了不知道拿什么做参考…）</p>
</li>
</ol>
<p>经过不同的尝试，我认为比较好的办法是：</p>
<ul>
<li>把默认配置嵌入代码，单文件发布；</li>
<li>在某个时机，将默认配置重新写回磁盘，用户在这个文件基础上修改配置；（这个时机可以是一个显式的 install 操作，也可以是启动时发现还没有配置文件，等等，根据需要实现）</li>
<li>如果因为某些原因丢失了配置，重新生成默认配置即可。</li>
</ul>
<p>代码实现（假定默认配置为 <code>assets/web.toml</code>，已经按上面最后的配置转换成 <code>bindata/bindata.go</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> config</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"path/filepath"</span></div><div class="line"></div><div class="line">	<span class="string">"playground/bindata"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	customDir  = <span class="string">"custom"</span></div><div class="line">	configFile = <span class="string">"web.toml"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">()</span> *<span class="title">Config</span></span> &#123;</div><div class="line">	maybeRestoreConfigFile()</div><div class="line">	<span class="keyword">return</span> loadConfigFromFile()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">maybeRestoreConfigFile</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !isFile(filepath.Join(customDir, configFile)) &#123;</div><div class="line">        <span class="comment">// 如果配置文件不存在，先将默认配置恢复到目标位置</span></div><div class="line">		bindata.RestoreAsset(customDir, configFile)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfigFromFile</span><span class="params">()</span> *<span class="title">Config</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;<span class="comment">/* 判断一个路径是不是一个文件 */</span>&#125;</div></pre></td></tr></table></figure>
<p>篇幅关系，这是一个非常精简的例子，省略了很多错误判断，不重要的函数也把实现删掉了。最后外部直接调用 <code>config.Load()</code> ，无论原本是否有配置文件，都能加载到配置。</p>
<p>如果配置比较复杂，不想静默地生成一个默认配置，可以显式地加入一个 <code>install</code> 之类的命令，引导用户填写一些配置，再结合默认配置生成。但总体上是这么个思路。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>提一下 go-bindata 项目之前的一些周折。</p>
<p>如果你搜索 go-bindata 的文章，会发现早期的文章指向的项目地址往往是：<a href="https://github.com/jteeuwen/go-bindata" target="_blank" rel="external">https://github.com/jteeuwen/go-bindata</a> 。那是最早的项目地址，<code>jteeuwen</code> 是原作者 Jim Teeuwen 的账号。</p>
<p>但不知道什么时候，因为什么原因，原作者把项目关闭了，连 <code>jteeuwen</code> 这个账号都删除了。（从现存线索推断，大约是 2018 年的事）</p>
<p>现在原地址也有一个项目，但已经 <strong>不是原项目</strong> ，也 <strong>不再维护</strong> 了。那是有人发现 go-bindata 删除后，为了让依赖它的项目不会报错，重新注册了 <code>jteeuwen</code> 这个账号，重新 fork 了这个项目 (真正原项目已删，是从一个 fork 那里 fork 的) 。因为初衷是让某个项目能够继续工作（据说是已经没法修改的私人项目，所以也不能指向新的地址），并没有打算继续维护，也不想冒充原项目，所以这个项目设为了 archived (read only)。详情可以参考以下讨论：</p>
<ul>
<li><p><a href="https://github.com/jteeuwen/go-bindata/issues/5" target="_blank" rel="external">https://github.com/jteeuwen/go-bindata/issues/5</a></p>
</li>
<li><p><a href="https://github.com/jteeuwen/discussions/issues" target="_blank" rel="external">https://github.com/jteeuwen/discussions/issues</a></p>
</li>
</ul>
<p>现在给出的项目地址，不确定跟原作者有没有关系——估计是没有的。那它不过是众多 fork 的其中一个。选它仅仅因为它最活跃、关注人数最多。这可能跟它挂在了同名 organization 下有一定关系，也可能里面有某个大牛。</p>
<p>理由并不重要，只需要知道它最活跃是一个共识，就够了。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单文件无依赖发布，是 go 语言一项杀手级特性。看着不怎么起眼，但被应用发布和运维折磨过的朋友，会明白这意味着什么。&lt;/p&gt;
&lt;p&gt;可没高兴多久，发现应用还是要引入各种静态资源。这时就要拿出 go-bindata 了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>渐进式图像加载</title>
    <link href="https://jaycechant.info/2020/progressive-image-loading/"/>
    <id>https://jaycechant.info/2020/progressive-image-loading/</id>
    <published>2020-03-20T11:30:39.000Z</published>
    <updated>2020-03-22T03:42:28.323Z</updated>
    
    <content type="html"><![CDATA[<p>网页上的图片，先加载一个模糊预览，然后逐渐变清晰，怎么实现的？</p>
<a id="more"></a>
<h2 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h2><p>之前文章多是折腾记录，宁可长篇大论，也懒得截 / 画图。前几天，发演示文档截图，一篇的配图是之前所有配图总量的 7 倍。博客托管在 Github pages，因不~明原因，访问速度越来越慢。图多 + 访问慢，居然偶尔能看到图片加载的过程 —— 就是那种等待投影幕放下来的效果，偏偏放得很慢，还卡顿。</p>
<p><img src="../../images/basiline-jpeg-load.png" alt=""></p>
<p>通过压缩图片大小算是初步解决。</p>
<p>可如果访问速度进一步恶化呢？这时想起之前见过另一种加载效果，不是下放幕布，而是类似对焦，先显示一幅非常模糊的图片，然后逐渐变清晰。于是有了开头一问。</p>
<p><img src="../../images/progressive-jpeg-load.png" alt=""></p>
<p>直觉技术上应该不难，之前居然没想过去了解。</p>
<h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><p>经过尝试不同的关键词组合，大概知道关键词应该是 ‘progressive image loading’ / 渐进式图像加载。看完网上讨论，发现可以分成两大类方案：</p>
<ul>
<li><p>代码方案</p>
<p>  具体实现方式很多，web 的 app 的，自己写代码，或者调用第三方库。但基本原理是相通的：</p>
<ol>
<li>先加载一个很小很模糊的预览图，拉伸到目标图像大小。这样会锯齿，没关系，加个高斯模糊（或者别的模糊算法）。</li>
<li>利用预览安抚用户的时间，把原图下载下来。</li>
<li>两图叠加前图透明也好，图片替换也好，换的同时，将模糊渐变到 0，看到原图。</li>
</ol>
</li>
<li><p>文件编码方案</p>
<p>  查到的有 interlace gif，progressive jpeg，interlace png 三种。实际上只是格式规范选用的术语不同，效果上都是 progressive 渐进显示。</p>
<p>  本质上是改变文件的数据块组织顺序，从原本的线性从左上到右下，变成按照某些特定的方式组织，让用户端在只下载了少量数据时，就能显示图片轮廓。然后随着下载的数据越来越多，逐渐清晰，直至显示原图。</p>
</li>
</ul>
<p>代码方案显然更灵活，可以根据需要实现不同的效果。而且因为加了模糊，不会出现难看的锯齿效果。</p>
<p>不过相对应地，代码方案开发和维护的负担也增加。如果平台支持图片格式的 progressive 特性（主要是 浏览器，暂时不考虑 app），直接改动文件显然是更省事的方案。</p>
<p>显然我不愿意为这么小的事情在博客模版加代码，格式自带的编码方案是当前首选。代码方案留待以后有需要再试。</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>据说常见的制图工具，导出选项里都有对应的选项。png 和 gif 格式的选项是 interlace（一般翻译成交错），jpeg(jpg) 的选项则是 progressive （翻译成 渐进）。</p>
<p>网上大家的截图证明 Photoshop 是可以的。我尝试 GIMP 2.8 是可以的。惊喜的是，常用的其中一个图片浏览器 XnView 也可以。用 XnView 打开图片，另存为 &gt; 选项 &gt; 选好格式和选项后保存。非常快捷，与之相比，特意打开一个大型的 编辑 / 设计 软件只修改文件的编码方式简直杀鸡牛刀。</p>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>问题又来了：怎么判断一个图片是否打开了 progressive 选项呢？</p>
<p>答案是：<strong>不知道</strong> 。试了不同的软件打开，然后查看图片详情和元信息，没有一个地方显示是否打开了 interlace / progressive 特性。</p>
<blockquote>
<p>注：在文章快写完时，才发现用 XnView 打开，显示『图像信息』，在格式一栏有显示，非常地不起眼（本以为会有一个独立字段显示）。</p>
<ul>
<li>png 会显示 <code>Portable Network Graphics (Interlaced)</code> ，多出括号里的 Interlaced。</li>
<li>gif 会显示 <code>Compuserve GIF (Version 89a - Interlaced)</code>，同样多了 Interlaced.</li>
<li>jpg 文件仍然没有看到区别。</li>
</ul>
</blockquote>
<p>看不出差别，意味着没法判断图片是否 progressive。正常网速下，肉眼根本无法看到加载过程。你也很难模拟一个特别卡的网络环境，去测试加载过程。</p>
<p>后来找到一个在线测试，可以测试网页引用的图片是否 progressive：<a href="https://webpagetest.org/。输入要测试页面的地址，点击开始测试即可。有很多测试项，其中" target="_blank" rel="external">https://webpagetest.org/。输入要测试页面的地址，点击开始测试即可。有很多测试项，其中</a> Performance Review 页可以看资源的加载情况。其他测试项对优化网页也有一定的参考意义。</p>
<p>不过，</p>
<ol>
<li>只支持 progressive jpg 检测。</li>
<li>需要先把网页发布到外网访问，测试后发现不对再优化。</li>
<li>这个测试使用了谷歌的 recaptcha 验证，很多朋友会用不了。</li>
</ol>
<p>就本文的目的而言，意义不大。</p>
<h2 id="格式规范-Specifications"><a href="#格式规范-Specifications" class="headerlink" title="格式规范 Specifications"></a>格式规范 Specifications</h2><p>考虑到博客配图以图表为主，多数是有清晰边缘的色块，很少实景照片，而且 png 支持 alpha 通道，显然选择 png 格式会得到更好的显示效果，压缩率也（大概率）不会比 jpg 差。所以下面主要研究 png 的格式。</p>
<h3 id="RFC2083"><a href="#RFC2083" class="headerlink" title="RFC2083"></a>RFC2083</h3><p>查维基可知，png 是 Portable Network Graphics 或 PNG is Not GIF 的缩写。1996 年由 IETF（Internet Engineering Task Force，互联网工程任务组）起草，并成为 W3C 建议，后成为 RFC2083。现行版本是 2003 年的国际标准 ISO 15948。</p>
<blockquote>
<ul>
<li>查询 RFC ：<a href="https://www.rfc-editor.org/search/rfc_search.php，可以用关键词或者编号查询" target="_blank" rel="external">https://www.rfc-editor.org/search/rfc_search.php，可以用关键词或者编号查询</a></li>
<li>RFC2083：<a href="https://www.rfc-editor.org/rfc/rfc2083.html" target="_blank" rel="external">https://www.rfc-editor.org/rfc/rfc2083.html</a></li>
<li>png 官网：<a href="http://www.libpng.org/pub/png/" target="_blank" rel="external">http://www.libpng.org/pub/png/</a></li>
<li>最新版规范：<a href="http://www.libpng.org/pub/png/spec/iso/index-object.html" target="_blank" rel="external">http://www.libpng.org/pub/png/spec/iso/index-object.html</a></li>
</ul>
</blockquote>
<p>规范很长，规定了格式的定义的方方面面。没打算实现一个 encoder 或者 decoder，直接搜 interlace 部分。</p>
<p>对比两版规范可以发现，interlace 在第一版就已经有了，而且基本没有改动。我们看最新的规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">8.2 Interlace methods</div><div class="line">Two interlace methods are defined in this International Standard, methods 0 and 1. Other values of interlace method are reserved for future (see 4.9: Extension and registration).</div></pre></td></tr></table></figure>
<p>大意：定义了 0 和 1 两种交错方式（分别是关闭和打开），剩下的值为未来保留。那这个值保存在哪里呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">11 Chunk specifications</div><div class="line">11.1 Introduction</div><div class="line">The PNG datastream consists of a PNG signature (see 5.2: PNG signature) followed by a sequence of chunks. Each chunk has a chunk type which specifies its function. ......</div><div class="line">......</div><div class="line">11.2 Critical chunks</div><div class="line">......</div><div class="line">11.2.2 IHDR Image header</div><div class="line">The four-byte chunk type field contains the decimal values</div><div class="line"></div><div class="line">73 72 68 82 // 注：49 48 44 52，其实就是 IHDR 的 ASCII 码。为了方便后续比较，列出十六进制值，下同。</div><div class="line">The IHDR chunk shall be the first chunk in the PNG datastream. It contains:</div><div class="line"></div><div class="line">Width	4 bytes</div><div class="line">Height	4 bytes</div><div class="line">Bit depth	1 byte</div><div class="line">Colour type	1 byte</div><div class="line">Compression method	1 byte</div><div class="line">Filter method	1 byte</div><div class="line">Interlace method	1 byte</div></pre></td></tr></table></figure>
<p>大意：一个 png 文件以 PNG 签名开头，然后是一系列数据块。第一号数据块是 IHDR（Image Header） 块，以 4 字节的 <strong>块类型</strong> 字段开头，然后是一系列字段，interlace method 是第 13 个字节。</p>
<p>再去看这里提到的 PNG 签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">5.2 PNG signature</div><div class="line">The first eight bytes of a PNG datastream always contain the following (decimal) values:</div><div class="line"></div><div class="line">137 80 78 71 13 10 26 10 // 注：89 50 4E 47 0D 0A 1A 0A，其中 50 4E 47 是 PNG 的 ASCII 码。</div><div class="line"></div><div class="line">This signature indicates that the remainder of the datastream contains a single PNG image, consisting of a series of chunks beginning with an IHDR chunk and ending with an IEND chunk.</div><div class="line">5.3 Chunk layout</div><div class="line">Each chunk consists of three or four fields (see figure 5.1). The meaning of the fields is described in Table 5.1. The chunk data field may be empty.</div><div class="line">LENGTH, CHUNK TYPE, CHUNK DATA, CRC</div><div class="line">OR</div><div class="line">LENGTH(=0), CHUNK TYPE, CRC</div></pre></td></tr></table></figure>
<p>略长挑重点：PNG 签名占据开头的 8 个字节。一个数据块则是 4 字节标数据块大小 LENGTH， 4 字节块类型，LENGTH 字节大小的数据，CRC 校验码。</p>
<p>这些信息足够做一个小学算术：8（PNG 签名）+ 4 （块长度）+ 4（块类型字段）+ 13（块数据内字节顺序） = 29。Interlace method 字段在 第 29 个字节。而且由于前面的数据都是固定不可省略的，所以这个顺序也是固定的。</p>
<h3 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h3><p>随便找了一张 png，用 XnView 生成一张 interlace 版本，分别用 十六进制编辑器打开：</p>
<p>标准版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52</div><div class="line">00 00 02 00 00 00 01 72 08 03 00 00 00 B4 A4 92</div></pre></td></tr></table></figure>
<p>交错版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52</div><div class="line">00 00 02 00 00 00 01 72 08 03 00 00 01 C3 A3 A2</div></pre></td></tr></table></figure>
<ul>
<li>开头 8 个字节：都是 <code>89 50 4E 47 0D 0A 1A 0A</code>，符合文档说明。</li>
<li>第二部分 4 个字节：都是 <code>00 00 00 0D</code> （13），符合 IHDR 数据长度是 13。</li>
<li>第三部分 4 个字节：<code>49 48 44 52</code>（IHDR），是块类型。</li>
<li>第四部分 13 个字节，直接看 第 13个：符合 标准版是 <code>00</code>，交错版是 <code>01</code>。</li>
</ul>
<p>再试了几个文件，都符合以上规律。说明对规范的理解是正确的。那么在没有找到工具支持查看 interlace 特性时，可以直接用 十六进制编辑器打开 判断：第 29 个字节，或者像这样每行 16 个字节排版的第 2 行倒数第 4 个字节。</p>
<h3 id="交错实现原理"><a href="#交错实现原理" class="headerlink" title="交错实现原理"></a>交错实现原理</h3><p>在文档 <code>4.5 Encoding the PNG image</code> 和 <code>8 Interlacing and pass extraction</code> 解释了 interlace 的原理。篇幅所限，就不贴原文了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1 6 4 6 2 6 4 6</div><div class="line">7 7 7 7 7 7 7 7</div><div class="line">5 6 5 6 5 6 5 6</div><div class="line">7 7 7 7 7 7 7 7</div><div class="line">3 6 4 6 3 6 4 6</div><div class="line">7 7 7 7 7 7 7 7</div><div class="line">5 6 5 6 5 6 5 6</div><div class="line">7 7 7 7 7 7 7 7</div></pre></td></tr></table></figure>
<p>核心其实就是这个 8x8 的顺序表。interlace 会把整个图像分割成 N 个 8x8 像素的小方块，每块上的像素按照这样的顺序编号。编码传输时，并非从左上到右下顺序进行，而是先把所有的 1 放前面，然后是所有的 2…… 以此类推。</p>
<p>假定现在有一张 16x16 的图，也就是会按上面分成 4 块进行编号。那么传输仅仅 4 个像素（1 / 64）之后，我们就能看到一个模糊的轮廓（这个只有 4 个像素的图会拉伸到原图大小，所以锯齿会非常明显）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 1</div><div class="line">1 1</div></pre></td></tr></table></figure>
<p>再传 4 个像素，变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 2 1 2</div><div class="line">1 2 1 2</div></pre></td></tr></table></figure>
<p>再传 8 个像素，变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1 2 1 2</div><div class="line">3 3 3 3</div><div class="line">1 2 1 2</div><div class="line">3 3 3 3</div></pre></td></tr></table></figure>
<p>以此类推。从 N 个像素开始构建一个最粗糙的缩略图（reduced image），然后每当传输的像素数量翻一番，清晰度就提高一倍，直到显示出原图。</p>
<h3 id="其他格式"><a href="#其他格式" class="headerlink" title="其他格式"></a>其他格式</h3><p>查找文档，理解文档，试验核实，花了一些时间，和占据了颇长的篇幅。考虑到主要用 png，就懒得折腾剩下两种格式了。把文档地址贴出来，有兴趣的朋友可以自己看看。</p>
<p>GIF Version 89a：<a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt" target="_blank" rel="external">https://www.w3.org/Graphics/GIF/spec-gif89a.txt</a></p>
<p>JPEG 官网：<a href="https://jpeg.org/" target="_blank" rel="external">https://jpeg.org/</a></p>
<p>大概扫了一眼，这两种格式要麻烦很多。</p>
<p>GIF 的 interlace flag 比较靠后，前面有好几个数据块，计算偏移会麻烦些。</p>
<p>更麻烦的是 JPEG。JPEG 实际上是一个组织名，<strong>联合图像专家组</strong>（Joint Photographic Experts Group），用作后缀时实际上是指 JFIF（JPEG File Interchange Format，JPEG 文件交换格式）。但除此之外，还有 JPEG-XT, JPEG Lossless, JPEG 2000, JPEG-XR……等等格式。虽然我知道这里面很多格式并不共享 <code>.jpeg</code> 这个后缀名，而是各自有专属的后缀。但是在全部看完他们的规范之前，还是无法确定他们跟 JPEG 的关系，以及 JPEG 从哪个版本开始支持 progressive 特性 —— 据了解第一版是不支持的，而 JFIF3 的规范文档里，也完全搜不到 interlace 或者 progressive 这些关键词。</p>
<p>好吧，这次就先到这里吧。以后有空，或者用到 JPEG 时再回来继续。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>其实目前对于 渐进式加载 的需要并没有那么急切。我只是惊讶于自己老早看过这种效果，居然没有想过去探究。感觉应该不复杂，想着了解一下就完了，没想到工具支持不算完善，中文互联网上的资料质量也很参差（基本是互相参考，抄来抄去连排版都不改）。</p>
<p>后面直接去读官方的规范文档，只看某一部分的话，加一点耐心查找和理解，并不难。</p>
<p>最后，前面用到了十六进制编辑器，选择不少；甚至一些文本编辑器，通过插件或者开关也可以支持。我使用的是以下这个，免费不开源，还挺好用，供参考：</p>
<p><a href="https://mh-nexus.de/en/downloads.php?product=HxD20" target="_blank" rel="external">https://mh-nexus.de/en/downloads.php?product=HxD20</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://jmperezperez.com/more-progressive-image-loading/" target="_blank" rel="external">https://jmperezperez.com/more-progressive-image-loading/</a></p>
<p><a href="https://www.hostinger.com/tutorials/website/improving-website-performance-using-progressive-jpeg-images" target="_blank" rel="external">https://www.hostinger.com/tutorials/website/improving-website-performance-using-progressive-jpeg-images</a></p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网页上的图片，先加载一个模糊预览，然后逐渐变清晰，怎么实现的？&lt;/p&gt;
    
    </summary>
    
    
      <category term="png" scheme="https://jaycechant.info/tags/png/"/>
    
      <category term="jpg" scheme="https://jaycechant.info/tags/jpg/"/>
    
  </entry>
  
  <entry>
    <title>我该学编程吗？</title>
    <link href="https://jaycechant.info/2020/should-i-learn-programming/"/>
    <id>https://jaycechant.info/2020/should-i-learn-programming/</id>
    <published>2020-03-17T17:29:21.000Z</published>
    <updated>2020-03-18T10:39:04.061Z</updated>
    
    <content type="html"><![CDATA[<p>有部分朋友面临这个困惑。</p>
<ul>
<li>一种是互联网行业的非技术岗，能接触到 IT 技术人员，对编程有一定认识，知道这个对工作有帮助，想学。但怕学不来，不知道怎么学。</li>
<li>另一种是完全没有接触，只是大概听说 IT 行业前（钱）景好。听说哪哪地方编程进课堂。然后碰见广告，或者大街上宣传学编程，产生了疑问：我（我的孩子）该学编程吗？</li>
</ul>
<a id="more"></a>
<blockquote>
<p>还有一种情况，已经是 IT 研发，可能非科班出身，基础薄弱，感觉补课补得有点吃力，萌生了退意。严格来说，不是目标读者，但也可以看一下一些观点，可能有一些启发。</p>
</blockquote>
<p>他们会咨询我，自己 / 孩子要不要学；也有我建议亲友了解一下之后，对方表示对此毫无概念。</p>
<p>与此同时，网络上充斥着各种对这个行业、这个群体的误解：</p>
<ul>
<li>程序员会自黑（压力大秃头、无情趣理工直男、工作时间长单身…），渲染得行业和岗位非常可怕。</li>
<li>各种少儿编程、成人培训班，会把编程渲染得无所不能，同时又非常容易学。（学会了这个，工作自动完成，学费只要9.9，一杯奶茶的钱…）</li>
</ul>
<p>作为一个从业者，也许可以说说我的看法，给大家做个参考。（做成文章 / 演示稿，也可以避免我面对不同的提问者反复说同样的内容。）</p>
<blockquote>
<p>这个演示稿为了通俗易懂，写的是口述稿，相对口语化，对于一些专业性强的内容作了简化，<strong>很多地方并不严谨</strong> 。请知悉。</p>
<p>部分内容借鉴了熊节 《<a href="https://gigix.github.io/2018/9/3/why-study-it/" target="_blank" rel="external">穷学IT</a>》中的观点。</p>
</blockquote>
<h2 id="一、学编程有用吗？"><a href="#一、学编程有用吗？" class="headerlink" title="一、学编程有用吗？"></a>一、学编程有用吗？</h2><p>毫无疑问地说，有。接下来我们看看都在哪些方面有用。</p>
<p><img src="../../images/should-i-learn-programming/sshot-003.png" alt=""></p>
<p>最直接的，就是收入。</p>
<p>这是国家统计局 2018 年的数据，2019 年的数据要 2020 年 5 月 才公布，所以在当前时间点（2020 年 3 月），这是最新的公开数据。</p>
<p>我印象中，应该是金融业第一，信息和软件产业第二。不知道从那一年开始，反超了。翻过 17 年的数据也是信息产业第一。篇幅所限，只取了最新数据。</p>
<p>国家统计局是分开 非私营 和 私营 统计的，分别都做了图表。</p>
<p><img src="../../images/should-i-learn-programming/sshot-004.png" alt=""></p>
<p>可以看到，前三和后四在 两边都一样。其中排第一的信息软件服务业，平均工资是最后的农业的 3 倍多接近 4 倍（非私营），私营也有两倍。也是所有行业平均值的两倍左右。比金融业还明显高出一截，差距有 1W4（私营） ~ 快2W（非私营）。</p>
<p>而且需要注意的是，这是按行业分的，不是按岗位。</p>
<p>在互联网和软件行业，这个高薪会编程的人可以享受到。负责编程的技术研发，属于比较核心的岗位，即使不是最高薪的岗位，起码也是高于平均值的。</p>
<p>与此同时，其他行业里，仍然有不少会编程的人在里面享受高薪。IT 的专业人才在各行各业都有需求。换句话说，金融业的高薪、科研行业的高薪，也有会编程的人能分到一杯羹。</p>
<p>网上有种说法，叫『富学金融，穷学IT』。金融 和 IT 是目前中国薪资最高的两个行业。但多数行业——包括金融——都一定程度需要依靠人脉。可能只有 IT 行业，至少目前为止，还是相对公平、开放、透明的行业，是一个穷人家的小孩不靠关系、不靠家底、不靠父母帮忙、甚至自己不用溜须拍马，也可以得到较高薪资，甚至实现阶级跃迁的地方。</p>
<p><img src="../../images/should-i-learn-programming/sshot-005.png" alt=""></p>
<p>然后，是跨行业和长时间的高需求。</p>
<p>现在各行各业，生活方方面面，哪个可以脱离开计算机（或手机）和软件。</p>
<p>页面大小限制，上面列这些是收入前几的行业。我们再看看人均工资靠后的行业。</p>
<p>住宿餐饮，现在多少店只收现金（不用移动支付），手动（按计算器）算账报税？还有外卖平台，多少是只靠接电话做外卖的？是不是都要接入收款、报税、外卖的软件系统。这里关键，是要理解计算机软件在处理数据的数量和速度上，都碾压人工。</p>
<p>什么叫碾压？就是完全不是一个数量级，不是两倍三倍，不是十几倍，而是千倍、万倍，乃至一般人无法想像的倍数。</p>
<p>听众 / 读者里可能有完全外行的，我们给个具体一点的概念。一个汉字，在计算机占两到三个字节（字节的缩写是 B）；一本两百万字的书，就是六到七百万字节，最多不超过 7 MB（大约一到两首歌的大小）；一个图书馆按一万种藏书算，也就不到 100 GB（大约几部高清电影的大小）。而今天，一个规模较大的企业一天产生的数据，一个前沿实验室一天产生的数据，就是 多少 GB，甚至到了 TB（1024 GB）或者 PB（100 多万 GB）。</p>
<p>少量的数据，靠纸笔手算。先进一点，用电脑表格（Excel），人工操作。几倍的数据，人勤快一点，找找技巧，累死累活通个宵，还是可能完成的。<strong>但当数据量跨了几个数量级，就不是慢而已了，而是人力忙活一辈子都不可能完成。</strong> 何况人工还容易出错。靠计算机软件是唯一的出路。</p>
<p>当一个行业里，多数企业开始用上计算机处理核心的数据，剩下的要么跟上，要么淘汰。</p>
<p>未来很多行业很多职业会严重过剩，会有大量的人失业。原因恰恰跟 IT 有关：软件的自动化、人工智能，这些技术会取代人的工作。比如司机会被无人驾驶取代掉，大多数常见的场景，无人驾驶可以胜任，只有少量特殊情况由司机来开。那么司机的人数和待遇，都会降低很多。甚至传统看起来很光鲜的职业，律师、医生、教师，都会受到 IT 技术的挤压。技术先取代各个职业 <strong>大量且单调重复</strong> 的部分；然后人工智能从大量过往数据里找到规律，把 <strong>需要经验</strong> 的部分也取代了。最后剩下的，是各个职业里，最需要创造力的部分。</p>
<p>整个社会趋势会变成，少数富有创造力的精英收益很高，大多数一般人压力越来越大、待遇越来越差。IT行业、特别是搞技术的职业，可能是唯一一个不太受技术挤压、反而因为技术发展对人才需求越来越旺盛的行业。（当然，IT 行业自身 那些 单调重复 和 没有创造力的岗位，也会逐渐受到挤压，但是这个行业里创造出的新岗位会更多。）</p>
<p><img src="../../images/should-i-learn-programming/sshot-006.png" alt=""></p>
<p>为什么编程这么厉害，编程究竟是什么？不用术语，口语化的解释就是上面这个。</p>
<p>（使用计算机）这一点，只要不是专业性很强的软件，相信从小接触计算机 / 智能手机 的年轻一代，都能对各种软件很快上手。而这对老一辈很晚接触的人来说，却难上了很多。差别是有没有在某个年龄，形成思维定势之前，在脑海里建立起 <strong>一个事物的概念模型</strong> 。</p>
<p>（编程）这一步，同样地，越早接触，就会理解得越好，越能建立先发优势。</p>
<p><img src="../../images/should-i-learn-programming/sshot-007.png" alt=""></p>
<p>将来这个标准会继续提高。</p>
<p>也许有一天，编程也变成了整个社会的基本素养之一。</p>
<p>只是那时候，编程的门槛可能变低，甚至不再叫编程。就像现在的电脑和手机，也比十几二十年前的更先进易用。<br>如果你不是坐着等那天到来，等着它变容易，而是现在就学会，那就建立了先发优势。</p>
<p>像上面说到的，学了编程，并不代表就去软件行业当程序员。很多其他行业和岗位，都对编程能力有需求。</p>
<p>甚至退一万步讲，以后未必从事编程工作，光学习的过程对于锻炼逻辑思维，发现问题、解决问题的能力，都有很大的帮助。</p>
<p><img src="../../images/should-i-learn-programming/sshot-008.png" alt=""></p>
<p>看到这里，看到我对编程评价如此之高。</p>
<p>是不是说，那些课程销售说的都是真的，我（我的孩子）应该赶紧去报一个班？</p>
<p>别急，继续看下去。</p>
<h2 id="二、不同人说的编程，可能不是一回事"><a href="#二、不同人说的编程，可能不是一回事" class="headerlink" title="二、不同人说的编程，可能不是一回事"></a>二、不同人说的编程，可能不是一回事</h2><p>课程销售说的、业内人士说的。</p>
<p>中小学老师说的、大学老师说的、培训班老师说的。</p>
<p>不同岗位说的。都不是一回事！</p>
<p><img src="../../images/should-i-learn-programming/sshot-010.png" alt=""></p>
<p>少儿编程班，绝大多数，说的是这种。</p>
<p>像积木一样，拖动，拼接，调一下数字。实现的效果多数受组件限制，创造性有限。小学低年级，感兴趣的前提下，还是推荐接触一下。培养兴趣，锻炼思维。但也就仅此而已。</p>
<p>从小用乐高积木拼汽车，也只是培养了兴趣，离长大了真的去做汽车非常遥远。积木学会的东西，能用来造真车的非常有限。</p>
<p>成年人、高年级的孩子、或者低年级但天赋超前的孩子，这个玩具就没有必要学了。</p>
<p>少儿编程这个市场，最鱼龙混杂。孩子太小，家长不懂。很多老师本质上就是临时培训了一下的销售。</p>
<p>这点少儿编程培训班说得大概和我不一样。他们鼓吹编程多重要之后，直接把学这个，等同于学编程，直接等于各种美好的未来。</p>
<p>当然这也算编程，但更多是玩具，离实际应用，有点远，更不会有人用来干活。</p>
<p><img src="../../images/should-i-learn-programming/sshot-011.png" alt=""></p>
<p>logo 是个很古老的编程语言 / 工具了。</p>
<blockquote>
<p>什么是语言？</p>
<p>可不是英语法语这些外语，而是跟计算机打交道的『编程语言』。</p>
<p>编程语言也有好多种，不同语言难度不一样，能完成的任务也有差别。 </p>
</blockquote>
<p>这是二十几年前我小学时候的启蒙。现在基本很少有人用了。</p>
<p>之所以提一下，是因为：</p>
<ul>
<li>跟前面的积木玩具比，它起码是个正经的编程语言，需要自己写，能实现各种复杂功能。</li>
<li>跟后面更新的工具比，它有一个画图的功能，对孩子来说，能看到自己写的效果，前期不那么枯燥，更容易坚持下来。（实际上，如果学的不是前端技术，学编程的初期要跟黑窗打很长时间的交道，完全看不到漂亮的软件界面。这种落差容易让一些朋友坚持不下去。）</li>
</ul>
<p>因为它太老了，现在很少人用了，学会了用处也不大，一般是不会推荐的。</p>
<p>但是有一些人，下一页的内容可能都觉得难，需要一些马上看得见的效果，来培养兴趣。那么我会推荐先试一下 logo 的画图部分，只学画图。等培养出感觉了，还是赶紧学新的。</p>
<p><img src="../../images/should-i-learn-programming/sshot-012.png" alt=""></p>
<p>从这一页开始，往后提到的语言，都是真家伙了。实际干活的人也用这些，学会了理论上也能干活了。</p>
<p>但是一上来就干活太难了，光学理论看不到效果又太枯燥。于是就有人把学习过程写成了游戏。</p>
<p>Swift playground 是苹果公司开发的，学的是苹果特有的 Swift 语言。软件本身是免费的，适合家里有 iPad 的朋友。不过用途比较受限，学会了只能在苹果的设备开发，开发出来的软件也只能在苹果的设备跑。</p>
<p><img src="../../images/should-i-learn-programming/codecombat_big.png" alt=""></p>
<p>CodeCombat 则可以学 Python、JavaScript 等多种语言，都是应用范围很广的语言。</p>
<p>这个软件是免费的，但是关卡不免费。现在国内是网易在代理，收费是 599/年（不带教学提示）和 899/年（带教学提示）。如果不买关卡，只有这个软件，那么你得找老师给你设计关卡。</p>
<p>编程这种技能，需要在实践中循序渐进地增加难度，通过不断练习学会，不是光说理论就能掌握的。而根据学习进度设计恰到好处难度的训练作业，恰恰是最麻烦的地方，一个老师可能需要教过大量的学生，在教学中逐渐调整作业难度，打磨出一套合适的习题（这里的游戏关卡，本质上就是习题）。这也是请一个好的老师贵的地方。如果还要他专门给你设计关卡，又耗时又贵，还不如直接买设计好的。599 还是 899，就要因人而异了。</p>
<p>自学能力特别强的，或者找了老师带的，599 就可以了。899 只是多了提示和新手关，不是真人教。当然不差钱加上提示，也挺好。</p>
<p><img src="../../images/should-i-learn-programming/sshot-014.png" alt=""></p>
<p>来到这页，又更接近实际工作中的应用了。</p>
<p>因为这些高强度的竞赛，本来就是为了筛选人才、培养人才，最后往各个工作岗位输送人才的。</p>
<p>在初中高中大学的语境里，学校老师讲的编程，就很可能是这些。</p>
<p>如果感兴趣，学习进度又跟得上，高年级的学生直接想办法学竞赛，或者参加学校的竞赛队伍，是最实际含金量最高的。出了成绩，或者仅仅有过竞赛经历，都会对后续成为职业开发者有帮助。</p>
<p>如果一下子达不到，可以先降低要求，报班或自学，逐渐提高到符合要求。水平够不着参加竞赛，也不要有压力，因为竞赛经历只是加分，对职业开发者都不是硬性要求，其他岗位要求就更低一些。</p>
<p><img src="../../images/should-i-learn-programming/sshot-015.png" alt=""></p>
<p>这些是互联网行业常见的需要用到编程技能的岗位。大概过目，不详细介绍了。</p>
<p>换句话说，差别特别大的岗位，虽然都是编程，但是互相未必能听懂对方说什么。</p>
<p>所以上面那么多页，都是编程。但是不同说话的场境，不同人说出来，差异是很大的。</p>
<h2 id="三、编程难吗？"><a href="#三、编程难吗？" class="headerlink" title="三、编程难吗？"></a>三、编程难吗？</h2><p><img src="../../images/should-i-learn-programming/sshot-017.png" alt=""></p>
<p><img src="../../images/should-i-learn-programming/sshot-018.png" alt=""></p>
<p>说编程没什么门槛，有一定道理。</p>
<p>2017年的苹果开发者大会的参加者，从最小 10 岁澳大利亚的 Yuma 小朋友（从 6 岁开始编程）到最大的 82 岁若宫雅子老奶奶（60 岁开始学计算机，81 岁开始学编程）。</p>
<p>业内比较有名的技术专家郝培强（网名 tinyfool），也讲过他前妻的故事，一个初中毕业的发廊小妹，到现在 IT 公司的高管。谷歌也有一个工程师，原本只是富士康流水线上的普通工人。</p>
<p>可以看到，没有硬性的门槛，跟贫富、人脉、学历、年龄，都没有硬性绑定。（完全不相关是不可能的，富裕的家庭、高学历、年轻必然有更多机会。但是在其他领域，穷人、低学历、老人，这些普通人可能连入场券都没有。）</p>
<p>但是，没有硬门槛，相对应一定会变成软实力的竞赛。如果一个技能一个岗位收入很高又毫无门槛，那么一定会有人大量涌入，最后变得不值钱。如果这种事情没有发生，说明一定有什么东西，阻拦了大多数想进入的人。</p>
<p>越晚起步，特别是过了大学之后，非科班起步，越往后，软性限制会越明显，你越是需要付出比别人<strong>数倍的时间和努力去弥补</strong> 。实际上大多数速成培训班里面出来的，基础都很差，在市场上竞争力不强，只有少数可以靠自己的毅力坚持学习，熬到好一点的岗位。</p>
<p>这是多数 <strong>培训班不会跟你说的</strong> 。他们为了招生，除了说编程重要，还会夸大学习的效果。他们会给你一个模板，把东西都做得差不多，你只要往里填点东西，或者照着做一遍，就能跑起来，让你产生学会了的错觉。但是等你离开培训班，自己从头做的时候，才发现要求稍变化一点点，你就不知所措了。这是没有打基础，没有学内功的原因，做不到举一反三。<strong>编程没有那么容易</strong>。</p>
<p>如果你条件不适合。如果你很容易就放弃。<strong>学编程技术这条路比想象中枯燥和艰苦，你有可能投入了时间精力最后一事无成。</strong></p>
<p>可是即使这样，我仍然强烈建议你尝试。</p>
<p>前面说了 IT 行业和相关岗位，有可能是未来唯一人才需求还会增长的地方。只有人才需求旺盛的行业，才会有公平的竞争、对员工的重视，才会有普通人不靠背景不靠关系靠自己努力一步步上升的可能性。</p>
<p>在阶层固化严重的行业、在人力过剩的行业，论资排辈苦熬日子已经算好的，你会看到更多的关系户、更多的拼爹、更多的溜须拍马、更多的人情世故。你可能说我不太擅长数学、我逻辑思维不好、我英语不行。但是这些跟社会上更多更艰难的事情比，不算什么，坚持一下智商正常都是可以学会的。</p>
<h2 id="四、怎么开始？"><a href="#四、怎么开始？" class="headerlink" title="四、怎么开始？"></a>四、怎么开始？</h2><p><img src="../../images/should-i-learn-programming/sshot-020.png" alt=""></p>
<p>计算机配置不算太过于老旧，能随时上网下载工具，和查阅资料。如果报了班，可能在线上课。</p>
<p>每周拨出固定的时间学习，坚持不断地练习，以及可能需要中途补一点 数学、逻辑、英语。</p>
<p><img src="../../images/should-i-learn-programming/sshot-019.png" alt=""></p>
<p>我的建议是，如果你确实感兴趣，也大致符合条件，尽早开始，并且做好长期投入的准备。</p>
<p>以我个人的经历来说，中间会经历一些瓶颈期，让你对自己产生怀疑。这个时候，不要轻易放弃，试着跟老师前辈交流一下，找靠谱的技术社区问问题，甚至换换教材，或者多尝试多练习。突然有一天你理解之后，回头看发现不过如此。</p>
<p>还好现在的资料多了很多，编程工具更易用，互联网也更发达。学习的曲线会平滑很多。</p>
<p>可能你今天会觉得，学计算机、编程，这些事情听起来太高深了，太难了，太不适合你。其实是陌生形成的印象，都是纸老虎。成为合格的 IT 技术人员，凭技术挣到一份不错的生活，需要的知识水平并不比其他行业更高，甚至还要低得多，因为这个行业太缺人了。你只要有好奇心、勤学苦练、英文稍加强到能看懂文档，就能做到。</p>
<p><img src="../../images/should-i-learn-programming/sshot-021.png" alt=""></p>
<p>这个话题每个人的情况不一样。上面列的，也不是唯一的选择。需要根据每个人的情况具体地讨论。</p>
<p>之所以提一下这个，是因为初学者一开始就面临学什么的困惑。然后你会发现这方面的讨论很多，网上甚至争论起来，各说各有理，互不相让。作为初学者，可能会感到无所适从。</p>
<p>早些年我也关注甚至参与这些口水仗。而现在我会说，你要做什么更重要。我们不会争论锤子好用还是扳手好用。你决定做什么了，自然有合适的工具。</p>
<p>当然，你可能会说，具体到某个方向大家还是在吵，没有答案。我的答案是，<strong>随便选一个多人提到的</strong> ，大概率不会错。多人用的，会有更多资料，讨论更充分，遇到问题容易找到解决方案。语言没那么重要，只要不是选中了一个已经被淘汰没人维护的语言，随便学好了哪门都能有所作为。等到你碰到语言的瓶颈时，大概已经有了自己选择的判断力，到那时再学一门新的，并不难。编程最后拼的，是 算法、数据结构、系统设计…… 这些内功，先练少林长拳，还是武当剑法，都是一个入口，反正最后熟练了，都很容易触类旁通。</p>
<blockquote>
<p>补充一个对业内人士来说是常识，但一般人可能不知道的事实：这些平台 / 语言，基本都是免费的。至于为什么免费，展开说太长，简单说就是 它们都是由专业人士的社区（可以近似认为是公益组织）在维护，有些是技术大牛一时兴起，做了个开头之后交给社区，有些是公司开发好之后，捐献给社区。</p>
<p>他们这样做，不是因为要做慈善，而是一个平台 / 一个语言，不是一个公司可以维护好的，维护好也没什么人会用，造成不了影响力。所以业界通行的模式，是开辟好一块荒地，让大家都能免费来玩，来的很多人本身也是大牛，看到它不够好，都会自发地添砖加瓦。这个地方更好之后，更多人来，更多人贡献，变成良性循环。大家都从这个地方获益，然后有能力的会主动地贡献力量。环境好了之后，来得人非常得多，就是每个人买瓶矿泉水，都能赚很多。如果收门票，荒地就一开始就不会有人来。</p>
</blockquote>
<p>所以一个人如果 <strong>自学能力够强、够自律</strong> ，实际上学习编程的成本可以非常非常地低。一台计算机、再买点打基础的书，几乎就是全部的支出。一旦熬过了最初啥也不懂的新手期，网络发达的时代，网上有大量免费的教程，有文字的，也有视频的，就是要花点时间去找。像我们哪怕科班出身的，工作几年之后也有大量的技能是过时需要更新的，多数是自学，没有花额外的钱。</p>
<p>但我并不鼓吹非要免费学。看具体的人，具体学什么，具体的培训班 /  老师靠不靠谱。</p>
<p>对于小朋友，或者 0 基础的人，完全靠自律自学，比较难。难点在于：一是找到合适难度的教材和作业，循序渐进地学。太容易就没有效果，太难就会有挫败感，产生畏难心理。可初学者自己没办法判断难度。二是越是初学者，越是需要引导、反馈、监督。一个知识点的学习，像一场马拉松，已经辛辛苦苦跑到终点附近，结果迷路了，看不到终点，特别容易产生『我是不是不适合学这个』的自我怀疑，很容易就放弃了。这时一点点点拨效果就会马上不一样。</p>
<p>所以初学者，一是需要跟自己水平差不多的人作为同伴，可以交流和参照；二是需要一个老师的点拨。这个阶段，花点钱报一个靠谱的班，我认为是值得的。等有了一定基础，再逐渐选择一部分知识点完全看书自学，只有自己搞不定的再报班。</p>
<hr>
<p>因为是口语化地聊，篇幅比较长，听（看）完后面，前面该忘了。我简单总结一下：</p>
<ul>
<li><p>学编程有用吗？  </p>
<p>  有，锻炼思维、工作高薪、岗位需求大。</p>
</li>
<li><p>Ta 跟我说学编程，是什么意思？  </p>
<p>  看什么语境，Ta 是谁，你又是谁，想用编程干什么。</p>
</li>
<li><p>学编程难吗？</p>
<p>  要正经做出水平，也难。起码没有某些培训班宣传的那么容易。  </p>
<p>  可世上任何事想做好，都是不容易的。编程不比学别的技能难，甚至相对性价比高，容易看到回报。  </p>
<p>  建议你试一下，再坚持一下。</p>
</li>
<li><p>怎么开始？  </p>
<p>  一台电脑、一根网线、一些教材、一点兴趣、一点坚持。  </p>
<p>  是否花钱找老师，因人而异。初学者找靠谱的老师更容易开始。</p>
</li>
</ul>
<p><img src="../../images/should-i-learn-programming/sshot-022.png" alt=""></p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有部分朋友面临这个困惑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是互联网行业的非技术岗，能接触到 IT 技术人员，对编程有一定认识，知道这个对工作有帮助，想学。但怕学不来，不知道怎么学。&lt;/li&gt;
&lt;li&gt;另一种是完全没有接触，只是大概听说 IT 行业前（钱）景好。听说哪哪地方编程进课堂。然后碰见广告，或者大街上宣传学编程，产生了疑问：我（我的孩子）该学编程吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="presentation" scheme="https://jaycechant.info/tags/presentation/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 踩坑流水账</title>
    <link href="https://jaycechant.info/2020/flutter-kickoff/"/>
    <id>https://jaycechant.info/2020/flutter-kickoff/</id>
    <published>2020-03-13T14:10:05.000Z</published>
    <updated>2020-03-13T17:04:52.428Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 作为前端一个发展方向大热，有必要了解一下。</p>
<p>踩坑流水账，遇到啥记啥，不求全；遇到的 <strong>弯弯绕绕，错误示范</strong> 也 <strong>如实记载</strong> 。当前 Flutter 还不太稳定，可能过一段时间操作细节就变了（希望是改进），这种记录可以跟将来做对比。</p>
<a id="more"></a>
<blockquote>
<p>我的水平远远够不上厉害，但在一些朋友看来可能有可取之处，当他们自学遇到困难时，偶尔会问我是怎么学的。记录这样的流水账，你可以看到，我遇到新事物，一样是一点点试错。相信真正的大牛，（至少曾经）也是这样过来。  只不过大牛可能悟性好，试错时间和次数少一些。自己试错多了，也会掌握试错的套路。</p>
<p>某个程序员朋友，连 help 和 man 都不知道，让人着急。可我高中时，明明已经学过简单的编程，对 Linux 居然连听都没听过，听同学讨论一头问号。我的反应是什么？放假第一时间让我的电脑变成 Windows / Ubuntu 双系统。他之前不知道 help，现在知道了。<strong>互联网时代，知道了关键词，就不能说你一无所知。起码要把公开资料看完吧？</strong></p>
<p>你看到的『最佳实践』的文章，其实已经是作者熟练之后提炼的结果。好处是读者不必再走一次弯路，坏处是读者可能会产生心理落差。</p>
<p>—— 这段文字跟本文内容关系不大，发散一下，算是呼应之前《<a href="../save-load-a-solution-for-ordinary-people/">S/L 大法——平凡人的做事方法</a>》的观点吧。</p>
</blockquote>
<p>后面如果觉得 Flutter 开发（在当前、对我而言）可以入坑，再来写经过整理总结的经验帖，否则就此一篇。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="获取-Flutter-stable"><a href="#获取-Flutter-stable" class="headerlink" title="获取 Flutter stable"></a>获取 Flutter stable</h3><p>考虑 flutter 还在快速开发中，为了方便更新，直接拉仓库的 stable 分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> -b stable https://github.com/flutter/flutter.git</div></pre></td></tr></table></figure>
<p>得到的版本是 <code>1.12.13+Hotfix.8</code> 。</p>
<p>然后运行 flutter_console.bat ，按提示，先执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutter doctor</div></pre></td></tr></table></figure>
<p>提示 powershell 版本太低，这时才想起，去看看依赖（这台老电脑买的时候预装 Win8，因为 Win8 只是个过渡产物很快升了 Win10。结果某个硬件驱动不兼容 Win10，干脆退回 Win7。）</p>
<blockquote>
<ul>
<li><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-windows-powershell" target="_blank" rel="external">Windows PowerShell 5.0</a> 或者更高的版本（Windows 10 中已经预装了）</p>
</li>
<li><p><a href="https://git-scm.com/download/win" target="_blank" rel="external">Git for Windows</a> 2.x，并且勾选<strong>从 Windows 命令提示符使用 Git</strong> 选项。</p>
<p>  如果 Windows 版的 Git 已经安装过了，那么请确保能从命令提示符或者 PowerShell 中直接执行 git 命令。</p>
</li>
</ul>
</blockquote>
<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p>git 作为最高频的工具，几乎是最新的。而平时不用的 Powershell，什么版本真的没概念，赶紧打开一个 Powershell，输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$PSVersionTable</span></div></pre></td></tr></table></figure>
<p>才 2.0，装个最新的吧。</p>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell" target="_blank" rel="external">installing-powershell</a></p>
<p>发现 6.0 以上不能直接安装，还得安装 Powershell Core （因为从 Win 专用变成跨平台了）。要不要装最新的呢？先不管，反正 .NET 4.5 以上是一定需要的，先看 .NET 的版本</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$DotNetVersions</span> = <span class="built_in">Get-ChildItem</span> HKLM:\SOFTWARE\WOW6432Node\Microsoft\Updates | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.name <span class="nomarkup">-like</span></div><div class="line"> <span class="string">"*.NET Framework*"</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">ForEach</span>(<span class="variable">$Version</span> <span class="keyword">in</span> <span class="variable">$DotNetVersions</span>)&#123;</div><div class="line">    </div><div class="line">   <span class="variable">$Updates</span> = <span class="built_in">Get-ChildItem</span> <span class="variable">$Version</span>.PSPath</div><div class="line">    <span class="variable">$Version</span>.PSChildName</div><div class="line">    <span class="keyword">ForEach</span> (<span class="variable">$Update</span> <span class="keyword">in</span> <span class="variable">$Updates</span>)&#123;</div><div class="line">       <span class="variable">$Update</span>.PSChildName</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是 4.7 ，够新了。</p>
<h3 id="WMF"><a href="#WMF" class="headerlink" title="WMF"></a>WMF</h3><p>然后是 WMF(Windows Management Framework)。</p>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/wmf/setup/install-configure" target="_blank" rel="external">wmf-install-configure</a></p>
<p>不同版本的 Powershell 和 WMF 的依赖关系如下：</p>
<table>
<thead>
<tr>
<th>Powershell 版本</th>
<th>PS 5.0</th>
<th>PS 5.1</th>
<th>PS 6.0+</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖的 WMF 版本</td>
<td>WMF 5.0 （已包含 PS 5.0）</td>
<td>WMF 5.1 （已包含 PS 5.1）</td>
<td>WMF 4.0+</td>
</tr>
</tbody>
</table>
<p>结论，不管我装不装 6.0+，安装一个 WMF 5.1 总是没错的。</p>
<p>下载，解压，按说明在 Powershell 里运行安装的 ps1 脚本。提示没有签名。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">get-executionpolicy</span> -list</div><div class="line"><span class="built_in">set-executionpolicy</span> remotesigned -scope <span class="keyword">process</span></div></pre></td></tr></table></figure>
<p>再运行一次，可以了。</p>
<p>这时再看 Powershell 的版本。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$PSVersionTable</span>.PSVersion</div><div class="line"></div><div class="line">Major  Minor  Build  Revision</div><div class="line">-----  -----  -----  --------</div><div class="line"><span class="number">5</span>      <span class="number">1</span>      <span class="number">14409</span>  <span class="number">1005</span></div></pre></td></tr></table></figure>
<p>Powershell 5.1 已经包含在 WMF 5.1 了，已经满足要求，就没啥动力继续折腾 6.0+ 了。</p>
<h3 id="Flutter-镜像"><a href="#Flutter-镜像" class="headerlink" title="Flutter 镜像"></a>Flutter 镜像</h3><p>回到 flutter_console ，继续 <code>flutter doctor</code> ，这回 Powershell 不报错，开始自动下载 Dart SDK 了（难怪没有要求先安装 Dart）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Checking Dart SDK version...</div><div class="line">Downloading Dart SDK from Flutter engine e1e6ced81d029258d449bdec2ba3cddca9c2ca0c...</div></pre></td></tr></table></figure>
<p>貌似因为网络不好，下载过程重试了几遍，还好最终成功了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Checking Dart SDK version...</div><div class="line">Downloading Dart SDK from Flutter engine e1e6ced81d029258d449bdec2ba3cddca9c2ca0c...</div><div class="line">Unzipping Dart SDK...</div><div class="line">Building flutter tool...</div><div class="line">Running pub upgrade...</div><div class="line">Error (<span class="number">69</span>): Unable to <span class="string">'pub upgrade'</span> flutter tool. Retrying <span class="keyword">in</span> five seconds... (<span class="number">9</span> tries left)</div></pre></td></tr></table></figure>
<p>同样的，<code>pub upgrade</code> 也重试了很多遍，不过次数太多，引起注意，先停掉。翻到</p>
<p><a href="https://flutter.cn/community/china" target="_blank" rel="external">在中国网络环境下使用 Flutter</a></p>
<p>扫了一眼，直接用 Flutter 社区的镜像。因为是 Windows，打开环境变量，加上这两个值：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PUB_HOSTED_URL=https://pub.flutter-io.cn</div><div class="line">FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</div></pre></td></tr></table></figure>
<h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p>重新打开 flutter_console.bat，再次 <code>flutter doctor</code> </p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">Doctor summary (to see all details, run flutter doctor -v):</div><div class="line">[√] Flutter (Channel stable, v1.<span class="number">12.13</span>+hotfix.<span class="number">8</span>, on Microsoft Windows [Version <span class="number">6.1</span>.<span class="number">7601</span>], locale</div><div class="line">    zh-CN)</div><div class="line">[X] Android toolchain - develop <span class="keyword">for</span> Android devices</div><div class="line">    X Unable to locate Android SDK.</div><div class="line">      Install Android Studio from: https://developer.android.com/studio/index.html</div><div class="line">      On first launch it will assist you <span class="keyword">in</span> installing the Android SDK components.</div><div class="line">      (or visit https://flutter.dev/setup/<span class="comment">#android-setup for detailed instructions).</span></div><div class="line">      <span class="keyword">If</span> the Android SDK has been installed to a custom location, set ANDROID_HOME to that location.</div><div class="line"></div><div class="line">      You may also want to add it to your PATH environment variable.</div><div class="line"></div><div class="line">[!] Android Studio (version <span class="number">3.6</span>)</div><div class="line">    X Flutter plugin not installed; this adds Flutter specific functionality.</div><div class="line">    X Dart plugin not installed; this adds Dart specific functionality.</div><div class="line">[!] Connected device</div><div class="line">    ! No devices available</div></pre></td></tr></table></figure>
<blockquote>
<p>作为一个前 Android 开发者，电脑上其实一直有 Android Studio 和 Android SDK。</p>
<p>开始这篇流水账之前，我已经把 Android Studio 升级到当下最新的 3.6，SDK tools 也升级到最新的 26.1.1。只是 Android Studio 能定位 SDK 的位置，所以没有设置 ANDROID_HOME。</p>
<p>因为 Android Studio 已经很稳定，下载很快，安装很傻瓜，就不提了。</p>
</blockquote>
<h4 id="SDK-version"><a href="#SDK-version" class="headerlink" title="SDK version"></a>SDK version</h4><p>新添加 <code>ANDROID_HOME</code> ，重开 console（以重新加载环境变量），再次 <code>flutter doctor</code> ，SDK 居然不是最新，而且也不是 Android Studio 里显示的 26.1.1，可能升级时漏了什么：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[!] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">27.0</span>.<span class="number">3</span>)</div><div class="line">    X Flutter requires Android SDK <span class="number">28</span> and the Android BuildTools <span class="number">28.0</span>.<span class="number">3</span></div><div class="line">      To update using sdkmanager, run:</div><div class="line">        <span class="string">"%ANDROID_HOME%\tools\bin\sdkmanager"</span> <span class="string">"platforms;android-28"</span> <span class="string">"build-tools;28.0.3"</span></div><div class="line">      or visit https://flutter.dev/setup/<span class="comment">#android-setup for detailed instructions.</span></div><div class="line">    X Android license status unknown.</div><div class="line">      <span class="keyword">Try</span> re-installing or updating your Android SDK Manager.</div><div class="line">      See https://developer.android.com/studio/<span class="comment">#downloads or visit</span></div><div class="line">      https://flutter.dev/setup/<span class="comment">#android-setup for detailed instructions.</span></div></pre></td></tr></table></figure>
<p>那就去跑一下 sdkmanager 吧</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">sdkmanager.bat</div><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.NoClassDefFoundError: javax/xml/bind/annotation/XmlSchema</div><div class="line">        at com.android.repository.api.SchemaModule<span class="variable">$SchemaModuleVersion</span>.&lt;init&gt;(SchemaModule.java:<span class="number">156</span>)</div><div class="line"></div><div class="line">        at com.android.repository.api.SchemaModule.&lt;init&gt;(SchemaModule.java:<span class="number">75</span>)</div><div class="line">        at com.android.sdklib.repository.AndroidSdkHandler.&lt;clinit&gt;(AndroidSdkHandler.java:<span class="number">81</span>)</div><div class="line">        at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:<span class="number">73</span>)</div><div class="line">        at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:<span class="number">48</span>)</div><div class="line">Caused by: java.lang.ClassNotFoundException: javax.xml.bind.annotation.XmlSchema</div><div class="line">        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:<span class="number">582</span>)</div><div class="line">        at java.base/jdk.internal.loader.ClassLoaders<span class="variable">$AppClassLoader</span>.loadClass(ClassLoaders.java:<span class="number">190</span></div><div class="line">)</div><div class="line">        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">499</span>)</div><div class="line">        ... <span class="number">5</span> more</div><div class="line"><span class="comment"># 改为写 go 之后好久没写 Java，难道是版本太旧？</span></div><div class="line">java --version</div><div class="line">java <span class="number">10.0</span>.<span class="number">1</span> <span class="number">2018</span>-<span class="number">04</span>-<span class="number">17</span></div><div class="line">Java(TM) SE Runtime Environment <span class="number">18.3</span> (build <span class="number">10.0</span>.<span class="number">1</span>+<span class="number">10</span>)</div><div class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM <span class="number">18.3</span> (build <span class="number">10.0</span>.<span class="number">1</span>+<span class="number">10</span>, mixed mode)</div></pre></td></tr></table></figure>
<p>虽然因为有一段时间没写 Java，并非最新的 LTS 版本（当前是 Java8 u241 或者 Java 11.0.6），但 Java 10 也不旧。我还特意看了 Java 10 的文档，确定有 <code>javax/xml/bind/annotation/XmlSchema</code> 。而且 sdkmanager 的版本也很迷。</p>
<p>（后来发现，Java 很可能是太新，而不是太旧，所以需要指定 JavaEE 包。据说 Java 11 已经移除了 JavaEE (变成了雅加达独立出去了)，更加运行不了。）</p>
<p>暂时没有兴趣深入了解哪里出了问题，直接卸载 Android SDK tools，然后下载最新的 SDK tools 压缩包。</p>
<p><a href="https://www.androiddevtools.cn/" target="_blank" rel="external">https://www.androiddevtools.cn/</a> 有收集。注意只是收集各个版本的地址而已，来源还是官方的，下完可以校验一下。这回的 SDK tools 在 Android Studio 显示 26.0.1，终于可以调用了。有一个可用更新 26.1.1，感觉这里就是问题所在，又给升了级，果然又出现上面的 <code>NoClassDefFoundError</code>。</p>
<p>先不管这个问题，退回到可用的 26.0.1。这是重新认真看 Doctor summaries，发现 <code>&quot;platforms;android-28&quot; &quot;build-tools;28.0.3&quot;</code> ，也就是它要求的所谓 SDK Version，并非我理解的 SDK tools 的 version，而是分别指 platform 和 build-tools 的版本，对应 Android 9(Pie)。为什么迟迟没有发现这点？因为在<a href="https://flutter.dev/docs/get-started/install/windows#set-up-your-android-device" target="_blank" rel="external">flutter 官方的引导</a>上面有这么一句话</p>
<blockquote>
<p>To prepare to run and test your Flutter app on an Android device, you’ll need an Android device running Android 4.1 (API level 16) or higher.</p>
</blockquote>
<p>被我理解为了开发的 API level 是 16+。</p>
<h4 id="license-status-unknown"><a href="#license-status-unknown" class="headerlink" title="license status unknown"></a>license status unknown</h4><p>再次 <code>flutter doctor</code>，这回 SDK 版本不报错了，只剩下 <code>Android license status unknown.</code> 。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flutter doctor --android-licenses</div><div class="line">A newer version of the Android SDK is required. To update, run:</div><div class="line">%ANDROID_HOME%\tools\bin\sdkmanager --update</div></pre></td></tr></table></figure>
<p>跟上面说的 <code>Try re-installing or updating your Android SDK Manager.</code> 一致。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdkmanager --update</div></pre></td></tr></table></figure>
<p><code>NoClassDefFoundError</code> 又出现了…… 本来不想在这上面耗时间，看来是躲不过了。</p>
<p>最后找到StackOverflow 的两个问题的回答： <a href="https://stackoverflow.com/questions/47150410/failed-to-run-sdkmanager-list-with-java-9" target="_blank" rel="external">StackOverflow 问题1</a> ，<a href="https://stackoverflow.com/questions/43574426/how-to-resolve-java-lang-noclassdeffounderror-javax-xml-bind-jaxbexception-in-j/43574427#43574427" target="_blank" rel="external">StackOverflow 问题2</a></p>
<p>编辑器打开 sdkmanager.bat，找到 DEFAULT_JVM_OPTS，在后面追加 <code>-XX:+IgnoreUnrecognizedVMOptions --add-modules java.se.ee</code> ，注意 Windows 环境不需要额外在外面加单引号，加了会导致变量扩充 <code>%~dp0\..</code> 出错，加完之后那一行变成了：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set DEFAULT_JVM_OPTS=<span class="string">"-Dcom.android.sdklib.toolsdir=%~dp0\.."</span> -XX:+IgnoreUnrecognizedVMOptions --add-modules java.se.ee</div></pre></td></tr></table></figure>
<p>然后再次执行</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sdkmanager --update</div><div class="line">done</div></pre></td></tr></table></figure>
<p>没有任何变化，版本没变，文件修改时间没变，然后 <code>flutter doctor --android-licenses</code> 依然说需要新版本。</p>
<p>然后尝试执行</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdkmanager --licenses</div></pre></td></tr></table></figure>
<p>提示有 licenses 还没 accept，赶紧一路 yes。</p>
<p>这时我试着再 <code>flutter doctor</code> 一次，居然通过了。说明版本旧不是根本问题。<strong>关键是 accept 掉 licenses</strong> 。</p>
<h4 id="升级-SDK-tools"><a href="#升级-SDK-tools" class="headerlink" title="升级 SDK tools"></a>升级 SDK tools</h4><p>本来这样就完事了，但还是有点好奇。记不记得 Android Studio 可以直接升级 SDK tools 到 26.1.1 ，那就升级看看。</p>
<p>Android Studio 确实可以升级 SDK tools，但是执行到最后，升级失败。因为升级靠的是打补丁，升级程序检查到 sdkmanage.bat <strong>有过修改，补丁失败</strong>。然后升级程序自动改为全量安装，不知道是不是因为打开了某些目录或者文件没管，继续失败。我猜 <code>sdkmanage --update</code> 也是因为类似的原因所以失败了，只是没有报错信息。</p>
<p>这时我想到两个选择：</p>
<ol>
<li>把 sdkmanager.bat 改回去，然后用 Android Studio 升级。</li>
<li>把修改之后的 sdkmanager.bat 改个名字，然后复制一份原名的改回去。然后执行修改过的 bat。</li>
</ol>
<p>（因为没有备份）这需要一字不差改回去，还好改动不多。我尝试了 1 ，成功了。2 就没有验证。</p>
<p>升级完 <strong>还得把参数加回去</strong> ，不然又会出现 <code>NoClassDefFoundError</code>。</p>
<p>继续 <code>flutter doctor</code> ，这回</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[!] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">28.0</span>.<span class="number">3</span>)</div><div class="line">    ! Some Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</div></pre></td></tr></table></figure>
<p>这次有了经验，我没有按它的来，而是 <code>sdkmanager --licenses</code> 。应该是升级过的 tools 还要再确认一遍 licenses。</p>
<h3 id="Android-Studio-Plugins"><a href="#Android-Studio-Plugins" class="headerlink" title="Android Studio Plugins"></a>Android Studio Plugins</h3><p>Settings &gt; Plugins 或者直接在打开项目的界面 Configure &gt; Plugins， 直接搜索 Flutter 安装，安装过程中会提示依赖 Dart 一起安装。</p>
<p>如果中间出现网络不好导致超时，就不要同时装，先装 Dart，再装 Flutter。</p>
<p>据说用 VSCode 开发也可以，我也有在用 VSCode。但是既然 flutter doctor 要求 Android Studio，就先按它的套路走通。</p>
<h3 id="真机-or-AVD"><a href="#真机-or-AVD" class="headerlink" title="真机 or AVD"></a>真机 or AVD</h3><p>最后一步就比较简单了，要么插个真机，要么创建一个 AVD。因为没有多余手机，随便选了一个 Pixel 3 + 奥利奥8.0 x86_64 的AVD。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Doctor summary (to see all details, run flutter doctor -v):</div><div class="line">[√] Flutter (Channel stable, v1.<span class="number">12.13</span>+hotfix.<span class="number">8</span>, on Microsoft Windows [Version <span class="number">6.1</span>.<span class="number">7601</span>], locale</div><div class="line">    zh-CN)</div><div class="line">[√] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">28.0</span>.<span class="number">3</span>)</div><div class="line">[√] Android Studio (version <span class="number">3.6</span>)</div><div class="line">[√] Connected device (<span class="number">1</span> available)</div><div class="line"></div><div class="line">• No issues found!</div></pre></td></tr></table></figure>
<p>这四个 ✔ 得来不易。</p>
<h2 id="第一个项目"><a href="#第一个项目" class="headerlink" title="第一个项目"></a>第一个项目</h2><p>安装 flutter 插件之后的 Android Studio ，New 菜单会多出一个 New Flutter Project，有引导，没啥值得说的，一路 Next。结果创建完之后，在生成项目的界面转了半天。第一次生成，对需要多长时间没有概念，以为是老机器卡，就先丢下去干别的。等我离开电脑半天，回来还在转，事情就不太正常了。</p>
<h3 id="flutter-lockfile"><a href="#flutter-lockfile" class="headerlink" title="flutter lockfile"></a>flutter lockfile</h3><p>试图强关 AS 无效之后，只好直接杀掉进程。这时去看 AS 的 workspace，项目看起来已经生成好了。试着重新打开 AS，可能是因为杀进程丢失了一些配置，需要重新指定 Android SDK 的位置。打开 AS 没看到新建的项目，就去打开前面生成的项目。</p>
<p>打开成功，没有提示缺这少那，说明项目生成是没什么问题的。但是初始化之后（自动生成的）代码一片红色，明显是缺少依赖引起的，同时 AS 也弹出提醒，还没有<code>run flutter packages get</code> ，旁边给了几个选项，分别是 Get dependencies 和 Update dependencies（第三个忘了）。</p>
<p>一次都还没获取依赖，自然点第一个，底下的 log 显示：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> myapp...</div><div class="line">Waiting <span class="keyword">for</span> another flutter command to release the startup lock...</div></pre></td></tr></table></figure>
<p>查了一下，flutter 有一个全局的 lockfile，在 <code>flutter/bin/cache/lockfile</code> ，每次只允许一个进程打开，作为全局锁。这种套路经常跟 Linux 打交道的应该很熟悉。按网上的说法，把它删掉（因为有进程占用，使用了 unlocker 释放句柄），然后再来。</p>
<h3 id="flutter-pub-get"><a href="#flutter-pub-get" class="headerlink" title="flutter pub get"></a>flutter pub get</h3><p>这回只是输出少了一行，然后又陷入了无尽的等待。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> myapp...</div></pre></td></tr></table></figure>
<p>没办法，退出 AS 再来（这次没有生成的对话框，可以正常退出），然后又提示锁的问题。死循环了。</p>
<p>锁的问题前面已经说了，是因为 dart 执行命令异常退出，没有释放锁，强制释放就行（后来发现 lockfile 不用删，释放掉就行。当然如果没有 unlocker 之类的工具，强删也行，反正就一个大小为 0 的文件，没有会自动新建）。问题在于为什么第一次会卡死。</p>
<p>pub 是 dart 的包管理器，如同 pip 于 Python，go mod 于 go，Maven 于 Java，npm 于 nodejs… 试了一下，pub 不能直接调用，大概因为没有独立安装 dart，而 flutter pub 是针对 flutter 的封装。</p>
<p>既然是获取依赖包这步卡了，那么大概率就是 GFW 的问题。还记得上面设置的镜像吗？这回释放完 lockfile，改在 flutter_console 里执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flutter packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">5.9</span>s</div></pre></td></tr></table></figure>
<p>不到 6 秒完事，还真就好了。代码里的各种错误也没了。</p>
<h3 id="Android-Studio-的环境变量"><a href="#Android-Studio-的环境变量" class="headerlink" title="Android Studio 的环境变量"></a>Android Studio 的环境变量</h3><p>可是每次都要手动执行命令也很烦。而且就算我愿意，AS 也不会每次执行命令停下来，告诉我对应的命令让执行；它一旦卡死，还得费劲去释放 lockfile。所以，是 AS 读不到设置的环境变量吗？</p>
<p>首先，<code>flutter help</code> 输出的指令里没有 <code>packages</code> ，然后 <code>flutter help packages</code> 告诉我们，<code>packages</code> 只是 <code>pub</code> 的别名。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">flutter help packages</div><div class="line">Commands <span class="keyword">for</span> managing Flutter packages.</div><div class="line"></div><div class="line">Usage: flutter pub &lt;subcommand&gt; [arguments]</div><div class="line">-h, --help    Print this usage information.</div><div class="line"></div><div class="line">Available subcommands:</div><div class="line">  cache       Work with the Pub system cache.</div><div class="line">  deps        Print package dependencies.</div><div class="line">  downgrade   Downgrade packages <span class="keyword">in</span> a Flutter project.</div><div class="line">  get         Get packages <span class="keyword">in</span> a Flutter project.</div><div class="line">  global      Work with Pub global packages.</div><div class="line">  pub         Pass the remaining arguments to Dart<span class="string">'s "pub" tool.</span></div><div class="line">  publish     Publish the current package to pub.dev</div><div class="line">  run         Run an executable from a package.</div><div class="line">  test        Run the "test" package.</div><div class="line">  upgrade     Upgrade packages in a Flutter project.</div><div class="line">  uploader    Manage uploaders for a package on pub.dev.</div><div class="line">  version     Print Pub version.</div><div class="line"></div><div class="line">Run "flutter help" to see global options.</div></pre></td></tr></table></figure>
<p>再 <code>flutter help packages get</code> 一下。三层命令 help 进来，都没有看到 <code>--no-color</code> 参数干嘛用，先不管它。</p>
<p>这次模仿 AS 的调用方式，不直接在 flutter_console 操作，而是直接调用 <code>flutter/bin/flutter.bat</code> ：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">flutter\bin\flutter.bat packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">0.6</span>s</div><div class="line"></div><div class="line">flutter\bin\flutter.bat packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">0.5</span>s</div><div class="line"></div><div class="line">flutter\bin\flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">0.5</span>s</div></pre></td></tr></table></figure>
<p>完全没问题。其实没问题是应该的，因为打开 flutter_console.bat 看就知道，里面只做了两件事，把 <code>flutter/bin/</code> 临时加入 PATH，然后打开一个 cmd，没了。</p>
<p>（好吧，其实是三件，前面还显示了 flutter 的 ascii-art 和 简单的说明。）</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">REM <span class="string">"%~dp0"</span> is the directory of this file including trailing backslash</div><div class="line">SET PATH=%~dp0bin;%PATH%</div><div class="line"></div><div class="line">CALL cmd /K <span class="string">"@echo off &amp; cd %USERPROFILE% &amp; echo on"</span></div></pre></td></tr></table></figure>
<p>会不会是因为依赖已经下载好了，根本没有触发网络访问？在 AS 再试一次，又卡了……（又要找 unlocker）</p>
<p>在 AS 里打开Terminal，从输出看其实就是一个 cmd，在这里再执行一次，又卡死了……</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里是 AS 里面的 Terminal</span></div><div class="line">echo %PUB_HOSTED_URL%</div><div class="line">%PUB_HOSTED_URL%</div></pre></td></tr></table></figure>
<p>环境变量实锤了。</p>
<p>在对着 AS 的 Terminal 一顿 echo 之后，发现绝大多数环境变量都能读到，无论是系统变量，还是用户变量。什么 <code>PATH</code>，<code>GOROOT</code>，<code>GOPATH</code>….. 都有值，唯独 <code>ANDROID_HOME</code> 和 两个镜像地址。然后想了想，这几个值好像都是这次新建的，并且中间没有重启过。呃，人家 cmd 都是关掉重开就可以加载到，难道就你 AS 非要重启计算机？（AS 都重启好多遍了）</p>
<p>试试吧。重启，第一时间打开 AS。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">echo %PUB_HOSTED_URL%</div><div class="line">https://pub.flutter-io.cn</div><div class="line">flutter\bin\flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">2.9</span>s</div><div class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>我x [口吐芬芳]，还真是！浪费时间。估计新建项目时也是卡在这里。有空研究一下 AS 的环境变量究竟是怎么加载的。这老电脑开关机慢，一堆文件也懒得关了重新打开，平时都是休眠的，改点啥都要重启真是为难人。</p>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p>接下来还剩一步，就是验证自带的模板程序能不能跑起来。</p>
<p>打开 AVD，启动前面创建的虚拟设备，然后选这个设备为 run target，然后 run。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Launching lib\main.dart on Android SDK built <span class="keyword">for</span> x86 <span class="number">64</span> <span class="keyword">in</span> debug mode...</div><div class="line">Running Gradle task <span class="string">'assembleDebug'</span>...</div><div class="line"><span class="comment"># 再等一下就能结束战斗了</span></div><div class="line"><span class="comment"># 啪，打脸</span></div><div class="line">FAILURE: Build failed with an exception.</div><div class="line"></div><div class="line">* What went wrong:</div><div class="line">A problem occurred configuring root project <span class="string">'android'</span>.</div><div class="line">&gt; Could not resolve all artifacts <span class="keyword">for</span> configuration <span class="string">':classpath'</span>.</div><div class="line">   &gt; Could not download kotlin-gradle-plugin.jar (org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="number">1.3</span>.<span class="number">50</span>)</div><div class="line">      &gt; Could not get resource <span class="string">'https://jcenter.bintray.com/org/jetbrains/kotlin/kotlin-gradle-plugin/1.3.50/kotlin-gradle-plugin-1.3.50.jar'</span>.</div><div class="line">         &gt; Connection reset</div><div class="line"></div><div class="line">* <span class="keyword">Try</span>:</div><div class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</div><div class="line"></div><div class="line">* Get more help at https://help.gradle.org</div><div class="line"></div><div class="line">BUILD FAILED <span class="keyword">in</span> <span class="number">8</span>m <span class="number">41</span>s</div><div class="line">Finished with error: Gradle task assembleDebug failed with <span class="keyword">exit</span> code <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这明显是 jcenter 的网络问题。侥幸认为应该只是慢，重试一遍，居然真的跑起来了。</p>
<p>下次还是换个 aliyun 的仓库镜像吧。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">maven&#123; url<span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span> &#125;</div><div class="line">maven&#123; url<span class="string">'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span>&#125;</div></pre></td></tr></table></figure>
<p>第一次的编译时间特别久，老机器可能加重了这个情况。后续的修改用 hot reload 应该会快很多。</p>
<p><br></p>
<p>到这，一行代码都没写，但写代码前的准备工作，算是告一段落。不知不觉居然记了这么长流水账，前后断断续续折腾了两天多。时间大部分是被地理位置下访问技术资源的可达性及网速（简称 Qiang）拖累的，少部分是因为 flutter 有些小坑且文档有误导性。</p>
<p>在等网络和命令执行的间隙，快速扫了一眼 dart 的语法，从不同的地方看到了 Java、Python 还有 Go 的影子，当然也有一些比较原创的语法糖（如级联调用）。刚好这三门语言都还算熟，希望写起来不费劲。</p>
<p>这篇太长了，就此打住。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 作为前端一个发展方向大热，有必要了解一下。&lt;/p&gt;
&lt;p&gt;踩坑流水账，遇到啥记啥，不求全；遇到的 &lt;strong&gt;弯弯绕绕，错误示范&lt;/strong&gt; 也 &lt;strong&gt;如实记载&lt;/strong&gt; 。当前 Flutter 还不太稳定，可能过一段时间操作细节就变了（希望是改进），这种记录可以跟将来做对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="https://jaycechant.info/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>配置 1.13+ 的 golang 环境（Windows 篇）</title>
    <link href="https://jaycechant.info/2020/golang-1-13-env-for-win/"/>
    <id>https://jaycechant.info/2020/golang-1-13-env-for-win/</id>
    <published>2020-03-10T15:07:44.000Z</published>
    <updated>2020-03-11T07:53:39.897Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间为 go 1.13 写了 <a href="../setup-golang-env-for-1-13-and-above/">《配置 1.13+ 的 golang 环境》</a> （注：现在go 1.14 都发布了），以区别于 1.9 还在用 GOPATH 时写的  <a href="../../setup-golang-env/">《配置 Golang 开发环境》</a> 。考虑到后者写了 Win 环境下的配置，于是前者就写一下 Linux 环境。</p>
<p>当下这个时间点，当然参考 1.13+ 那篇。可是在 Windows 配置怎么办？那就把文中系统相关的操作（主要是环境变量）换成 Win 的对应操作。两篇文章，分别涉及到了 “&lt; 1.13 &amp; Win” 和 “1.13+ &amp; Linux”，看完举一反三，应该新旧版本两个系统平台，都会配置了。</p>
<p>结果今晚让朋友看着新教程（1.13+）配置 Win 下 go 1.13+ 环境，证明我还是太天真：这些配置教程的目标读者很可能根本没有跨平台的经验，一个 Linux 的操作在 Windows 下对应着什么，他们完全没有概念 [摊手]。</p>
<p>一气之下，只好再发一篇。注意，这篇 <strong>没有任何新内容</strong>，纯粹是旧文的重新组合！（Windows &amp; go 1.13+）</p>
<a id="more"></a>
<p>不是我想水好吧，我也是被某些人气的。[摊手]</p>
<p>反正入门教程就不能对读者有期待，不然达不到 <strong>扔给 朋友 / 学生 之后不用管</strong> 的效果。本文遇到大段引用我其他文章的，不再只给链接，直接把内容贴过来，方便你们不用跳转，也方便我不用解释 [白眼]。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>重申，这篇讲 Windows 环境下，go 1.13 以上版本的配置。当下最新的是 1.14，但是配置方法没有变化。</p>
<h3 id="0x00-下载安装"><a href="#0x00-下载安装" class="headerlink" title="0x00 下载安装"></a>0x00 下载安装</h3><p><del>找下载链接请到官网 golang.org/dl ，如果国内不能访问</del>，请直接到国内的官方镜像站 golang.google.cn/dl 。</p>
<p>找到 Windows 的安装包，名字大概是 <code>go1.14.windows-amd64.msi</code> 。后续新版本出来，版本号会变大。如果你的操作系统是 32 位，就把 <code>amd64</code> 换成 <code>386</code> 。找到符合的链接，下载。</p>
<p>下载完了之后安装，安装路径随你的习惯。建议尽量短，不带空格和中文。个人习惯放到 <code>D:\Dev\go</code> 下。</p>
<h3 id="0x01-系统环境变量"><a href="#0x01-系统环境变量" class="headerlink" title="0x01 系统环境变量"></a>0x01 系统环境变量</h3><p>然后将可执行文件加入系统路径。</p>
<p>如果你对 Windows 下添加系统环境变量毫无概念，建议你先搜索一下 <strong>带图的教程</strong>，毕竟 Win7 和 Win10 还有点不同。已经耐着性子水这篇，不想把这种东西展开讲。</p>
<ul>
<li><p>先添加 <code>GOROOT</code>。检查环境变量里是否已经存在 <code>GOROOT</code>，没有就新建，值填上一步的安装路径。以我的为例，就是 <code>D:\Dev\go</code>。先设置 <code>GOROOT</code> ，后面引用，方便以后改安装位置时只改这里，不用到处修改。</p>
</li>
<li><p>再添加 <code>Path</code> 。<code>Path</code> 变量是原本就存在的。</p>
<ul>
<li>Win10 下 <code>Path</code> 是个列表，新建两项，分别填 <code>%GOROOT%\bin</code> 和 <code>%USERPROFILE%\go\bin</code>。</li>
<li>Win7 等只有一个 Path 值的，修改，在最后面追加 <code>;%GOROOT%\bin;%USERPROFILE%\go\bin</code> </li>
</ul>
</li>
</ul>
<p>注意涉及的标点都是英文半角符号。设置完一步步确认就好。</p>
<h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>惯例地检查一下是否配置正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go version</div><div class="line">go version go1.14 windows/amd64</div></pre></td></tr></table></figure>
<p>如果不能正确执行 <code>go version</code> ，把当前版本输出，请回头检查哪里出错。</p>
<p>跟老版本不同的是，只要把 go 本身的可执行路径 和 go bin 的安装路径加入 Path 就可以了，剩下的 go env 自行管理了。</p>
<h3 id="0x02-go-env"><a href="#0x02-go-env" class="headerlink" title="0x02 go env"></a>0x02 go env</h3><p>执行 <code>go env</code>，就会看到 go 内置的环境变量，以及部分默认值。</p>
<p>大家看自己的输出，我的已经改过，不是默认值，就不贴了。</p>
<p><code>go env -w key=value</code>  这样的形式，是将 key 变量修改成 value 这个值。</p>
<h4 id="必改"><a href="#必改" class="headerlink" title="必改"></a>必改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go env -w GO111MODULE=on</div><div class="line">go env -w GOPROXY=https://goproxy.cn,direct</div></pre></td></tr></table></figure>
<p><strong>GO111MODULE</strong> : </p>
<ul>
<li>auto : 自 1.11 实验性加入之后就是默认值。auto 意味着由工具链自动判断是否启用 go modules。在 1.13 以前的启用条件是『项目根目录有 go.mod 且项目不在 GOPATH 内』，1.13+ 去掉了 『不在 GOPATH 内的限制』，也就是只要有 go.mod 就会启用。</li>
<li>on : 如果你觉得上面这段话太长懒得看，或者害怕以后启用条件还会变，那么 1.13 已经准备好全面启用 go modules，直接设为 on 就好了。设为 on 之后无条件启用 go modules。</li>
<li>off :  关闭 go modules，回到 GOPATH 时代。</li>
</ul>
<p><strong>GOPROXY</strong> :</p>
<p>国内环境必备，原因你懂的。甚至可以说这是新版本为中国开发者做出的最大改进之一也不为过。在 dep 的时代是靠自建的代理熬过来的，那么不会代理的朋友就很麻烦了。改用镜像就友好太多了。</p>
<p>目前国内最早最好的代理是 七牛云提供的 <code>https://goproxy.cn</code> 。如果团队内部还有搭建私有代理，可以用 <code>,</code> 隔开，go 会依次尝试。最后记得加上 <code>direct</code> ，让镜像上找不到的依赖回源查找。（包括但不限于 镜像还没同步，私有仓库 等情况）</p>
<p>目前自建代理的开源方案貌似有以下几个。由于我暂时没有自建代理的需要，没有实测，请自行对比选择。</p>
<ul>
<li><a href="https://github.com/goproxyio/goproxy" target="_blank" rel="external">https://github.com/goproxyio/goproxy</a></li>
<li><a href="https://github.com/gomods/athens" target="_blank" rel="external">https://github.com/gomods/athens</a></li>
<li><a href="https://github.com/goproxy/goproxy" target="_blank" rel="external">https://github.com/goproxy/goproxy</a></li>
</ul>
<h4 id="推荐改"><a href="#推荐改" class="headerlink" title="推荐改"></a>推荐改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go env -w GOBIN=%USERPROFILE%/go/bin</div></pre></td></tr></table></figure>
<p><strong>GOBIN</strong> 如果没有设置，默认值为 <code>%GOPATH%/bin</code> ，是通过 <code>go get</code> 或 <code>go install</code> 安装的可执行文件的存放目录。不设并不影响使用，但考虑到 GOPATH 正在被边缘化，未来不知道哪个版本就取消了，所以建议还是单独设置一下比较好。我为了保持使用习惯，设置了跟默认相同的目录（因为 GOPATH 默认值是 <code>%USERPROFILE%/go</code>），区别只是这个值不依赖 GOPATH 的值。</p>
<p>值得 <strong>提醒</strong> 的是，这个目录也需要加入系统 PATH ，并且我已经在 系统环境变量 里加入（最后一个），如果你根据自己的习惯修改了 GOBIN 的位置，那么 0x01 里的配置也得相应修改。</p>
<p>更多的变量，推荐参考 《<a href="https://mp.weixin.qq.com/s/AsdCDodxZFxs2SkhSwOvpg" target="_blank" rel="external">干货满满的 Go Modules 和 goproxy.cn</a>》。</p>
<h4 id="确认-1"><a href="#确认-1" class="headerlink" title="确认"></a>确认</h4><p>到这里之后，建议安装任意一个 go 开发的工具测试 GOBIN 是否正确配置。这很重要，后续需要安装各种 go 编写的工具，并且需要在命令行调用。VSCode 的 go 插件，就依赖大量这样的工具。</p>
<p>如果在这里配置好了，VSCode 会自动安装到正确的地方，自动后台调用，你是几乎无感知的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">go get -u github.com/go-bindata/go-bindata/...</div><div class="line"><span class="comment"># 留意安装过程是否有报错</span></div><div class="line">go-bindata --help</div><div class="line"><span class="comment"># 如果安装好了，执行目录也加入了 Path，这里应该输出帮助信息</span></div><div class="line">Usage: go-bindata [options] &lt;input directories&gt;</div><div class="line">...</div><div class="line"><span class="comment"># 或者看版本信息</span></div><div class="line">go-bindata -version</div></pre></td></tr></table></figure>
<h3 id="0x03-cgo-和-build-tool"><a href="#0x03-cgo-和-build-tool" class="headerlink" title="0x03 cgo 和 build tool"></a>0x03 cgo 和 build tool</h3><p>go 语言的 cgo 特性允许 C 语言 和 go 语言互调，达到 <strong>复用已有的 C/C++ 庞大代码资源</strong> 的目的；又或者用 C 编写程序的一部分以达到某些 底层语言才能达到的目标。而要使用 cgo 特性，就需要有 C/C++ 的构建工具链 <strong>gcc</strong> 。</p>
<p>另一方面，随着项目规模变大，你会逐渐需要一个 <strong>构建工具</strong> （build tools）帮你管理构建细节，就像 ant / maven / gradle 之于 Java。由于 go 本身的构建比较简单（或者说 go 的构建规则比较清晰，自带的 build 命令够用），又有了现成的依赖管理（之前的 vgo / glide / dep，现在官方的 go modules），官方并没有一个专用的构建工具。这部分，因为依赖管理已有，管理额外的构建细节， <strong>Makefile (make) 足矣</strong> 。</p>
<p>gcc 和 make 在多数 Linux 发行版是自带的，你可以通过  <code>gcc -v</code> 和 <code>make -v</code> 来确认安装的版本。即使没有，视乎不同的包管理器，也就是一两句命令的事。Windows 下稍微麻烦一些，要安装 MinGW-w64 。注意必须是 <strong>MinGW-w64</strong> 。MinGW 不兼容 64 位系统，同时长期不更新；而 w64 可以同时兼容 32 和 64 位。</p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>下载：<a href="https://sourceforge.net/projects/mingw-w64/" target="_blank" rel="external">https://sourceforge.net/projects/mingw-w64/</a></p>
<p>下载得到的是安装器，在选择版本后，会自动下载对应版本并安装。建议不要改动任何选项，只需要确保 Architecture 对应你的计算机即可（Win64 选 x86_64）。</p>
<p>安装路径依然没有强制要求，无中文和空格，尽量短即可。参考：<code>D:\Dev\mingw-w64</code> 。</p>
<h4 id="创建-make-的软链接"><a href="#创建-make-的软链接" class="headerlink" title="创建 make 的软链接"></a>创建 make 的软链接</h4><p>安装完后进入 安装目录的 bin 目录，可以看到大量的工具，其中有 <code>gcc.exe</code>  和 <code>mingw32-make.exe</code> ，没有 <code>make.exe</code> 。其实 <code>mingw32-make.exe</code> 就是，但是用这个名字调用太长，也不利于其他工具用默认的名字调用，所以我们要创建一个名字叫 <code>make.exe</code> 的软链。</p>
<p>首先用管理员权限打开 cmd （右键菜单 &gt; 用管理员权限打开），然后按如下操作：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 请修改路径对应你的安装目录</span></div><div class="line">C:\Windows\system32&gt;cd /d D:\Dev\mingw-w64\bin</div><div class="line"></div><div class="line">D:\Dev\mingw-w64\bin&gt;mklink make.exe mingw32-make.exe</div><div class="line">为 make.exe &lt;&lt;===&gt;&gt; mingw32-make.exe 创建的符号链接</div></pre></td></tr></table></figure>
<p><strong>建议创建软链之后就关掉管理员权限的 cmd，避免因权限过高造成不可恢复的误操作。后续操作在普通权限下执行即可。</strong></p>
<p>完成后你会看到 bin 目录下多了一个 <code>make.exe</code> 文件，然后执行 <code>dir make.exe</code> ，会看到</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\Dev\mingw-w64\bin&gt;dir make.exe</div><div class="line"><span class="number">2018</span>/<span class="number">10</span>/<span class="number">04</span>  <span class="number">18</span>:<span class="number">17</span>    &lt;SYMLINK&gt;      make.exe [mingw32-make.exe]</div></pre></td></tr></table></figure>
<h4 id="Path-环境变量"><a href="#Path-环境变量" class="headerlink" title="Path 环境变量"></a>Path 环境变量</h4><p>跟 Go 安装类似的， MinGW-w64 的 bin 目录也要追加到 Path 变量的最后，详细可以参考 Go 的 系统环境变量部分。以我的设置为例，追加的是 <code>;D:\Dev\mingw-w64\bin</code> 。</p>
<p><strong>特别强调：mingw-w64 下面还有一套 mingw32，如果是 64 位系统，添加到 PATH 的是根目录的 bin，不是 mingw32 下面的！！</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mingw-w64</div><div class="line">├── bin <span class="comment"># 64位系统认准这个！！</span></div><div class="line">├── mingw32</div><div class="line">│   ├── bin <span class="comment"># 32位系统才选这个</span></div><div class="line">......</div></pre></td></tr></table></figure>
<h4 id="确认-2"><a href="#确认-2" class="headerlink" title="确认"></a>确认</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gcc --version</div><div class="line"><span class="comment"># 正常会输出 gcc 的版本，64位：x86_64, 32位：i686; 注意区分</span></div><div class="line">make -v</div><div class="line"><span class="comment"># 能调用就行，不需要留意位数</span></div></pre></td></tr></table></figure>
<h3 id="0x04-安装-VCS"><a href="#0x04-安装-VCS" class="headerlink" title="0x04 安装 VCS"></a>0x04 安装 VCS</h3><p>在使用 go get 命令之前，需要安装依赖托管服务对应的 VCS （Version Control System）。go get 会根据依赖所托管的网站反馈的信息，调用对应的工具 （git / hg / svn）拉取依赖。</p>
<p>就我的个人实践而言，绝大多数的第三方依赖都是基于 git 发布的（或者说直接就是放在 github 上），所以 <strong>直接安装 git 就好</strong> ，后面遇到基于其他工具的依赖，再安装不迟。</p>
<p>由于 git 本身就是一个大话题，基本的安装使用教程不难搜到，有时间时会另起文章讨论，这里只是提醒安装，不再展开。</p>
<h3 id="0x05-开始一个项目"><a href="#0x05-开始一个项目" class="headerlink" title="0x05 开始一个项目"></a>0x05 开始一个项目</h3><p>终于把环境都配置好了，然后就可以开始第一个 go 的项目了。由于 go modules 不再依赖 GOPATH，所以项目可以放在任何地方——这个 『任何』，是指可以不是 GOPATH ，但是要是习惯了，继续放在 <code>%GOPATH%/src</code> 也没问题。</p>
<p>好了，不管放在哪，现在新建一个项目的根目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir demo</div><div class="line"><span class="built_in">cd</span> demo</div></pre></td></tr></table></figure>
<p>然后执行 <code>go mod init &lt;module_path&gt;</code> ，生成 go.mod ，这个项目就算初始化完了，接下来就该敲代码了。随着开发的进行，还会自动生成 go.sum 文件，记录依赖的校验信息。注意 go.sum <strong>不是 lock 文件</strong> ，重现构建的信息已经包含在 go.mod 里，go.sum <strong>属于 checksum 文件</strong> ，用来 <strong>确保下载的依赖没有被篡改</strong> 。 go.mod 和 go.sum 需要一起提交<strong>参与版本控制</strong> 。关于 <code>go mod</code> 的详细用法，可以直接 <code>go help mod</code> 获取帮助信息，不展开。</p>
<p>关于 module path 的内容，以及 module 与 package 之间的关系，篇幅所限，另有一篇文章详细解释，请看《<a href="https://jaycechant.info/2020/golang-1-13-module-VS-package/">golang 1.13 - module VS package</a>》。</p>
<p>go 语法和开发，限于篇幅，也不是本文内容，后续可能需要开一个系列展开。</p>
<h3 id="0x06-IDE-推荐"><a href="#0x06-IDE-推荐" class="headerlink" title="0x06 IDE 推荐"></a>0x06 IDE 推荐</h3><h4 id="LiteIDE"><a href="#LiteIDE" class="headerlink" title="LiteIDE"></a>LiteIDE</h4><p>下载：<a href="https://github.com/visualfc/liteide/releases" target="_blank" rel="external">https://github.com/visualfc/liteide/releases</a> ，根据操作系统选择对应的下载</p>
<p>专门为 go 设计的 IDE，简单够用。</p>
<p>亮点：</p>
<ul>
<li>多套环境变量、编译参数的配置，方便交叉编译</li>
<li>支持直接搜索官方库的文档</li>
</ul>
<p>跟下面的 IDE 比，功能不算强，因为不能扩展插件。但是胜在简洁，没有多余功能干扰。</p>
<p>推荐初学者从它开始，熟悉 go 的工作流程。</p>
<h4 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h4><p>声名在外，不得不说真香。不同语言的开发，我都逐渐转移到这里了。</p>
<p>因为太过有名，地址和配置都不用写了，一搜一大堆。</p>
<p>默认是不支持 go 的。胜在有个强大的插件生态，装个插件就支持了。</p>
<p>优点：强大的插件生态，通过增加插件和个性化配置，可以不断变得更好用。</p>
<p>缺点：毕竟不是原生支持，初学者上来就安装配置插件，容易一开始就搞晕。而且因为不是专门开发 go，多余的功能会造成干扰。</p>
<h4 id="GoLand"><a href="#GoLand" class="headerlink" title="GoLand"></a>GoLand</h4><p>IntellJ 出品，本质上是 IDEA 的一个特化版本。</p>
<p>口碑很好，但是因为收费，然后 VSCode 已经够用，我没有用过。</p>
<p>如果你觉得好用，请购买授权。如果你觉得贵，那么免费本身就有很好的选择。</p>
<p>身为开发者却白Piao软件，而且还不是非用不可的软件，实在是不光彩的行为。希望你不会被甲方白Piao。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间为 go 1.13 写了 &lt;a href=&quot;../setup-golang-env-for-1-13-and-above/&quot;&gt;《配置 1.13+ 的 golang 环境》&lt;/a&gt; （注：现在go 1.14 都发布了），以区别于 1.9 还在用 GOPATH 时写的  &lt;a href=&quot;../../setup-golang-env/&quot;&gt;《配置 Golang 开发环境》&lt;/a&gt; 。考虑到后者写了 Win 环境下的配置，于是前者就写一下 Linux 环境。&lt;/p&gt;
&lt;p&gt;当下这个时间点，当然参考 1.13+ 那篇。可是在 Windows 配置怎么办？那就把文中系统相关的操作（主要是环境变量）换成 Win 的对应操作。两篇文章，分别涉及到了 “&amp;lt; 1.13 &amp;amp; Win” 和 “1.13+ &amp;amp; Linux”，看完举一反三，应该新旧版本两个系统平台，都会配置了。&lt;/p&gt;
&lt;p&gt;结果今晚让朋友看着新教程（1.13+）配置 Win 下 go 1.13+ 环境，证明我还是太天真：这些配置教程的目标读者很可能根本没有跨平台的经验，一个 Linux 的操作在 Windows 下对应着什么，他们完全没有概念 [摊手]。&lt;/p&gt;
&lt;p&gt;一气之下，只好再发一篇。注意，这篇 &lt;strong&gt;没有任何新内容&lt;/strong&gt;，纯粹是旧文的重新组合！（Windows &amp;amp; go 1.13+）&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>删除打开文件的正确方法（Linux）</title>
    <link href="https://jaycechant.info/2020/correct-way-to-delete-an-opened-file/"/>
    <id>https://jaycechant.info/2020/correct-way-to-delete-an-opened-file/</id>
    <published>2020-02-19T16:05:41.000Z</published>
    <updated>2020-03-05T19:04:56.500Z</updated>
    
    <content type="html"><![CDATA[<p>凭记忆复述一个坑，稍微带到 Linux 文件系统知识。时间久远，记忆可能存在差错。发现了错误请留言告知，感激不尽。</p>
<p>标题的中文断句上容易有歧义，重复一下英文：correct way to delete an opened file ，关键在 『打开了的文件』或者叫 『已经打开的文件』，怎么解释都比 opened 拗口。</p>
<p>（由于当时没有留下记录，文中 shell 输出均为写文章时 <strong>模拟重现</strong>，并非第一现场。）</p>
<a id="more"></a>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>惯例开头给结论</p>
<ul>
<li><strong>有进程引用</strong> 的文件在当下无法真正被删除，虽然 rm 之后 ls 等命令无法再看到文件，但是磁盘空间依然没有被释放，<strong>在 rm 之前就已经打开文件的进程</strong> 依然可以正常读写这个文件。</li>
<li>所以删除一个正在打开（rwx 都算）的文件，对打开的进程来说是安全的，并不会造成进程崩溃。这也是程序可以运行时更新的原因。rm 之后这个文件名（指包括路径在内的全名）被释放，可以新建同名文件，也可以把其他文件 mv、cp 过来，这时想办法重启进程，引用的就已经是新文件了。但注意，文件更新之后、进程重启之前，进程仍在 <strong>引用（已经看不见的）旧文件</strong>。</li>
<li>具体看删除的目的是什么：<ul>
<li>只是要删除文件，<strong>不关心磁盘空间什么时候释放</strong> ，直接 rm 即可，磁盘将在文件不再被引用之后释放。</li>
<li>只是为了释放磁盘空间，不关心这个文件名的释放，直接 <code>echo &gt; filename</code> 或者 <code>cat /dev/null &gt; filename</code> 清空内容是更有效的办法。</li>
</ul>
</li>
<li>如果像我一样，没想清楚就 rm 了，而磁盘还没释放，先 <strong>通过 lsof 找到打开的进程号</strong> ，有两种方法可以释放：<ul>
<li>进程可以重启，那就 <strong>重启进程</strong> ，释放文件句柄</li>
<li>进程不能重启，就在进程下找到被删除的文件的符号链接，通过这里把文件清空。（详细操作看正文）</li>
</ul>
</li>
</ul>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>还是去年 6 月的事，当时给熟人介绍的公司当远程技术顾问，帮他们实现一个服务。</p>
<p>考虑到远程调试的各种不便，服务用 go 实现，各种 feature 尽量做成了内置，同时预留了对接成熟组件的余地。例如数据库默认 sqlite3，但修改配置可以连接 MySQL。通过这样做到单文件部署即可测试，减少合作中的远程部署和沟通成本。（这段其实跟本文主旨无关，但是忍不住提一下 go）</p>
<p>不涉及数据的测试，项目组每个人在自己的电脑就能部署自测；涉及数据部分或者比较正式的测试、演示，甲方给了一个阿里云的服务器，服务部署在上面，然后大家一起测试，确保大家测试的是同一份配置，同一份数据。</p>
<p>这是背景。</p>
<h3 id="0x0-磁盘爆满"><a href="#0x0-磁盘爆满" class="headerlink" title="0x0 磁盘爆满"></a>0x0 磁盘爆满</h3><p>某天晚上，如常根据甲方反馈意见做了修改，部署，测试。</p>
<p>结果刚上线大家就反馈说，服务非常卡，完全没法用。</p>
<p>就这么几个人访问，不大可能有性能问题，根据以往经验，看了一下网络延时，正常。再去看日志，数据库一堆错误。这样顺藤摸瓜，最后得出结论 —— <strong>服务器磁盘满了</strong> ……居然满了！！？（当时内心小声嘀咕，贵司没有任何运维措施的吗？服务器上没有监控和告警的吗？）</p>
<p>询问甲方后，得知这是甲方一个即将到期的服务器，不打算续期，重要的服务都已经迁移到新的服务器。（不管好像也说得过去。）</p>
<p>浏览了一下磁盘，找到了几个比较大的文件，挑了最大的一个 <code>nohup.out</code> 去征求甲方意见，果然可以删。（不知道『 <code>nohup.out</code> 是什么，为什么大概率可以删』的童鞋，请自行了解，不展开。）</p>
<p>没细想，直接 rm 了。</p>
<h3 id="0x1-依然爆满"><a href="#0x1-依然爆满" class="headerlink" title="0x1 依然爆满"></a>0x1 依然爆满</h3><p>重新启动服务，测试，依然超卡。看日志，问题依旧。去看删掉的文件，不在。检查磁盘空间，<strong>依然是满的</strong> ……居然还是满的？！删了好几G东西，这么快又写满了？不可能啊。</p>
<p>然后有几秒陷入了沉思……（此处应有黑人问号脸）</p>
<p>（这里吐槽一下自己，明明前几天磁盘还有空间，今天突然就满了，数据写入的速度明显不是我写的服务能够造成的，下面的事情我就应该想得到，rm 前就应该 lsof 一下。）</p>
<p>还好，我很快反应过来是什么回事。</p>
<p>因为甲方说服务已经迁走了，想当然地认为这个服务器已经没有在跑什么应用，各种数据文件也应该是历史遗留。只是想当然，没有查进程，没有查文件的访问时间、修改时间。</p>
<p>现在的现象提醒我，文件应该是被进程打开了。</p>
<p>（如果在 rm 之前 lsof 一下，输出大概是这样。lsof 是 LiSt Open Files 的缩写。可惜当时没有先做这步。）</p>
<p>（再次提醒，以下 shell 输出是写文章时 <strong>写代码循环 print 模拟的</strong> ，真实情况当时没有保留。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># dummy 是为了模拟，写的一个只会循环向标准输出打印数字的程序，然后用 nohup 挂在后台运行，输出重定向到 nohup.out</span></div><div class="line"><span class="comment"># grep 之后不会输出表头，为了方便对比，特意把表头先打出来</span></div><div class="line">$ lsof | head -n 1</div><div class="line">COMMAND     PID   TID                USER   FD      TYPE             DEVICE  SIZE/OFF    NODE NAME</div><div class="line">$ lsof | grep nohup.out</div><div class="line">dummy     29627                jaycechant    1w      REG                8,7       287 3539805 /home/xxx/nohup.out</div><div class="line">dummy     29627                jaycechant    2w      REG                8,7       287 3539805 /home/xxx/nohup.out</div></pre></td></tr></table></figure>
<p>（从这个结果看，nohup.out 被 dummy 进程打开了。fd 部分 1 是标准输出，2 是标准错误，w 是只写打开。这里因为只有一个 nohup.out 被引用，所以 grep 直接以 nohup.out 为条件；实际上当时服务器上不止一个 nohup.out，所以用了更复杂的条件。但是这个没有模拟的必要，如果筛选出来的结果太多，再实时调整 grep 的搜索条件就好了。）</p>
<p>实际上当时直接就 rm 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm nohup.out</div></pre></td></tr></table></figure>
<p>rm 之后才反应过来，然后徒劳地用 重定向清空 挣扎了一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 完全多余的操作，inode 都不一样了</span></div><div class="line">$ cat /dev/null &gt; nohup.out</div><div class="line">$ ls -hail nohup.out</div><div class="line">3539813 -rw-rw-r-- 1 jaycechant jaycechant 0  2月 20 02:06 nohup.out</div></pre></td></tr></table></figure>
<p>新建的 nohup.out 是空白的（如果是 <code>echo &gt; nohup.out</code> 则有一个字节），但是磁盘依旧没有释放。留意 inode 已经不是同一个文件了。最后还是不得不 lsof。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ lsof | grep nohup.out</div><div class="line">dummy     29627                jaycechant    1w      REG                8,7      5030 3539805 /home/xxx/nohup.out (deleted)</div><div class="line">dummy     29627                jaycechant    2w      REG                8,7      5030 3539805 /home/xxx/nohup.out (deleted)</div></pre></td></tr></table></figure>
<p>可以看到，跟上面相比有两个变化：</p>
<ul>
<li>文件名后面多了 <code>(deleted)</code> ，表明文件已经被（标记）删除。</li>
<li>SIZE 变大了（因为进程还在持续写入），反正不是新建的文件大小。</li>
</ul>
<h3 id="0x2-找回文件句柄"><a href="#0x2-找回文件句柄" class="headerlink" title="0x2 找回文件句柄"></a>0x2 找回文件句柄</h3><p>这时进入了一个尴尬的境地：想删文件，结果被进程占用，只是标记删除，磁盘空间没释放；想清空文件大小，但是因为文件（实际上是文件的硬链接）已经被删除了，没有了操作的对象。现在任何对该目录下的 nohup.out 的操作，都指向了新文件。</p>
<p>这时只好请出 <code>/proc</code> 。</p>
<p><code>/proc</code> 是只存在于内存里的伪文件系统，通过文件的方式，提供访问内核和进程信息的接口。（Linux 一切皆文件）在上面，我们已经知道了 dummy 的进程号是 29627，那么我们就可以通过以下方式查找到它打开的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ls -hal /proc/29627/fd</div><div class="line">总用量 0</div><div class="line">dr-x------ 2 jaycechant jaycechant  0  2月 20 01:49 .</div><div class="line">dr-xr-xr-x 9 jaycechant jaycechant  0  2月 20 01:49 ..</div><div class="line">lr-x------ 1 jaycechant jaycechant 64  2月 20 01:49 0 -&gt; /dev/null</div><div class="line">l-wx------ 1 jaycechant jaycechant 64  2月 20 01:49 1 -&gt; /home/xxx/nohup.out (deleted)</div><div class="line">l-wx------ 1 jaycechant jaycechant 64  2月 20 01:49 2 -&gt; /home/xxx/nohup.out (deleted)</div></pre></td></tr></table></figure>
<p>注意这里的文件只是符号链接，所以大小都是 64，并非指向的文件的真实大小。</p>
<p>这些符号链接非常特殊，他们指向 <code>原文件名+空格(deleted)</code> （这个通过 <code>readlink /proc/29627/fd/1</code> 可以看到）， (deleted) 并非一个注释，而是实在的目标文件名的一部分。拿这个名字（中间有空格，所以要引号括起来）去访问，无论 ls、cat、stat 都访问不了（没有那个文件或目录）；而且这个名字可以创建新文件，inode 是新的。但是对符号链接重定向却起效了。估计内存引用做了特殊处理，只是我查了半天没有找到具体是什么处理，先把这个题外话搁下，不影响本文的主要内容。</p>
<h3 id="0x3-清空"><a href="#0x3-清空" class="headerlink" title="0x3 清空"></a>0x3 清空</h3><p>拿到了文件的句柄，就可以清空内容了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /dev/null &gt; /proc/29627/fd/1</div></pre></td></tr></table></figure>
<p>这时再看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ lsof | grep nohup.out</div><div class="line">dummy     29627                jaycechant    1w      REG                8,7        16 3539805 /home/xxx/nohup.out (deleted)</div><div class="line">dummy     29627                jaycechant    2w      REG                8,7        16 3539805 /home/xxx/nohup.out (deleted)</div></pre></td></tr></table></figure>
<p>文件大小就小很多了。为什么不是 0 呢？因为进程还在写入。[苦笑]</p>
<p>所以不用多久，很可能还是要再处理一次。如果确认进程已经没有用，还是停掉吧。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 正则式 /[d]ummy/ 和 /dummy/ 含义没有差别，但可以避免匹配自身</span></div><div class="line">$ <span class="built_in">kill</span> -9 `ps x | awk <span class="string">'/[d]ummy/&#123;print $1&#125;'</span>`</div><div class="line">$ lsof | grep nohup.out</div><div class="line"><span class="comment"># 没有输出，inode 彻底释放掉了</span></div></pre></td></tr></table></figure>
<h2 id="涉及的文件系统原理"><a href="#涉及的文件系统原理" class="headerlink" title="涉及的文件系统原理"></a>涉及的文件系统原理</h2><p>上面的内容要透彻理解，涉及到 Linux 的文件系统原理。直接上一张图</p>
<p><img src="../../images/linux_fs.png" alt=""></p>
<ol>
<li>首先目录本身也是文件，只是系统做了特殊处理。里面的内容非常简单，所有子文件的 <strong>文件名</strong> 以及对应的 inode 号，也就是 <code>ls -i</code> 输出的内容。</li>
<li>inode 储存 <strong>文件名 和 文件内容 以外</strong> 的所有信息（大小 / 所有者 / 分组 / 权限 / 时间戳 / 链接数 / 块的位置，基本上等于 <code>stat</code> 输出的内容）。访问文件时，根据文件名获取到对应的 inode，再从 inode 获取各个块的位置，从块里读取 <strong>内容</strong>。</li>
<li>访问一个文件，就是从根目录 <code>/</code> 的 inode 开始不断做 3 个操作： ① 读目录文件；② 找到对应的 inode； ③ 从对应的块读取内容。如果 ③ 读到的是一个目录文件，继续递归下去，直到读到目标文件为止。</li>
<li>inode 里储存了 引用计数（内存） 和 链接计数（磁盘）。只有两者都为 0 ，inode 才会被回收。而只有 inode 被回收，块才会被回收。</li>
<li>硬链接(hard link) 本质上是所有指向 inode 的文件名，记录在 <strong>目录文件</strong> 里，包括创建时第一个文件名。rm 本质是 unlink，删掉目录文件里的记录；每删除一个，<strong>链接计数</strong> 减 1。创建硬链接，就是在目标目录里加一条新记录，指向同一个 inode，链接计数 加 1。而在同一个文件系统里移动文件(mv)，等于在新旧目录分别做以上操作。</li>
<li>进程打开文件，则会增加 <strong>引用计数</strong>，并且在 <code>/proc</code> 中通过符号链接记录指向的文件。一旦完成了靠 文件名 查找 inode 的过程，在关闭重新打开之前，<strong>会直接访问 inode</strong> 。此时只针对文件名的操作，都不会影响进程访问文件。</li>
</ol>
<p>拿可能更多人了解的互联网打个不太准确的比方：</p>
<ul>
<li>文件名 相当于 域名，inode 相当于 IP，块相当于服务器。</li>
<li>硬链接相当于 A 记录，软链接相当于 CNAME 记录。不过软链接的类比不准确，因为软链接 <strong>不是在目录里直接指向目标文件的</strong> ，而是本身是一个普通文件，有 inode，有块；只是块里记录的是目标文件；相当于还是 A 记录，有 IP，有服务器，只不过服务器唯一的作用就是重定向到另一个域名。</li>
<li>访问文件时查询 inode 相当于 DNS 查询，一旦完成了，直接按 IP 通信。在断开重连之前，域名的修改不影响通信。</li>
</ul>
<p>大概是这样，继续深入还能写好长，篇幅所限先打住。</p>
<p>有些知识点我不是特别确定，所以行文期间参考了以下文章，如果想进一步了解，建议也看一下：</p>
<ul>
<li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="external">《理解 Linux 的硬链接与软链接》</a></p>
</li>
<li><p><a href="https://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="external">《理解 inode》</a></p>
</li>
<li><p><a href="https://blog.csdn.net/TheWindRisesll/article/details/86542137" target="_blank" rel="external">《Linux ： 文件系统（创建一个文件 inode号 、inode、数据块之间的关系）》</a></p>
</li>
<li><p><a href="https://www.linuxprobe.com/linux-proc-pid.html" target="_blank" rel="external">《简析Linux中 /proc/[pid] 目录的各文件》</a></p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;凭记忆复述一个坑，稍微带到 Linux 文件系统知识。时间久远，记忆可能存在差错。发现了错误请留言告知，感激不尽。&lt;/p&gt;
&lt;p&gt;标题的中文断句上容易有歧义，重复一下英文：correct way to delete an opened file ，关键在 『打开了的文件』或者叫 『已经打开的文件』，怎么解释都比 opened 拗口。&lt;/p&gt;
&lt;p&gt;（由于当时没有留下记录，文中 shell 输出均为写文章时 &lt;strong&gt;模拟重现&lt;/strong&gt;，并非第一现场。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="file-system" scheme="https://jaycechant.info/tags/file-system/"/>
    
  </entry>
  
  <entry>
    <title>golang 1.13 - module VS package</title>
    <link href="https://jaycechant.info/2020/golang-1-13-module-VS-package/"/>
    <id>https://jaycechant.info/2020/golang-1-13-module-VS-package/</id>
    <published>2020-01-20T08:50:37.000Z</published>
    <updated>2020-01-22T10:10:38.811Z</updated>
    
    <content type="html"><![CDATA[<p>在写 《<a href="https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/">配置 1.13+ 的 golang 环境</a>》时，花了大量篇幅解释 module 的概念，还有 module 与 package 之间的联系。眼看字数翻了一番，干脆把这部分另起一篇。</p>
<a id="more"></a>
<h2 id="module-与-package"><a href="#module-与-package" class="headerlink" title="module 与 package"></a>module 与 package</h2><h3 id="0x0-module-不是-package"><a href="#0x0-module-不是-package" class="headerlink" title="0x0 module 不是 package"></a>0x0 module 不是 package</h3><p>是的，他们不是同一个概念！！module（模块）是新引入的概念，一个 module 是 零到多个 package（包）的组合，不要把他们混为一谈。</p>
<table>
<thead>
<tr>
<th></th>
<th>package</th>
<th>module</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>本质</strong></td>
<td>一个目录下所有 go 源码的集合（不包括子目录，那是另一个 package）</td>
<td>同一个根目录下所有包的集合（包括子目录）</td>
</tr>
<tr>
<td><strong>共享</strong></td>
<td>代码 <strong>共享命名空间（包名）</strong>，包内可以 <strong>直接互相调用</strong>（包括小写开头的 unexported members）</td>
<td>同一个 module 下的 package <strong>共享 module path 作为 package path 的前缀</strong>，module 内可以 <strong>直接互相 import</strong></td>
</tr>
<tr>
<td><strong>单位</strong></td>
<td>（代码开头）<strong>import 的单位</strong></td>
<td>（go.mod）<strong>require 的单位</strong></td>
</tr>
</tbody>
</table>
<p><strong>package</strong>  具体体现为一个目录下所有 go 源码的集合（不包括子目录，那是另一个 package），它们 <strong>共享命名空间（包名）</strong>，包内可以 <strong>直接互相调用</strong>（包括小写开头的 unexported members）。package 是 <strong>import 的单位</strong> ，import 语句写在每一个 go 源码文件的开头。<br>包名跟目录名 <strong>可以一样也可以不一样</strong>。虽然允许不一样，但是大家习惯性认为目录就是包名；为了避免大家还要去查包名， <strong>没什么特别理由建议保持一致</strong>。<br>例如，<code>import path/to/pkg_dir</code> 中的 pkg_dir 是目录名，<code>package pkg</code> 和 <code>pkg.MyFunc()</code> 里的 pkg 是包名。</p>
<p><strong>module</strong> 则是同一个根目录下所有包的集合（包括子目录），它们 <strong>共享 module path 作为 package path 的前缀</strong>，module 内可以 <strong>直接互相 import</strong>。module 是 <strong>require 的单位</strong> ，require 语句在 go.mod 里。</p>
<h3 id="0x1-GOPATH-vendor-时代"><a href="#0x1-GOPATH-vendor-时代" class="headerlink" title="0x1 GOPATH + vendor 时代"></a>0x1 GOPATH + vendor 时代</h3><blockquote>
<p>这段解释 GOPATH 的机制，是为了对比，加深理解。</p>
<p>如果你不想了解已经被抛弃的 GOPATH ，可以直接跳过看 0x2 部分。</p>
</blockquote>
<p>在依赖 GOPATH 的时候，import 的查找范围如下：</p>
<ol>
<li><code>$GOROOT/pkg</code> 查找 <strong>内置包</strong></li>
<li><del>查找 <strong>相对路径</strong> 的包</del></li>
<li>项目根目录下的 vendor 目录查找 <strong>第三方包</strong></li>
<li><code>$GOPATH/src</code> 查找下载的 <strong>第三方包</strong> 和 <strong>本地包</strong>，如果不存在，尝试 <code>go get</code></li>
</ol>
<p>重点解释 2 和 4。</p>
<h4 id="相对路径-import？别用！"><a href="#相对路径-import？别用！" class="headerlink" title="相对路径 import？别用！"></a>相对路径 import？别用！</h4><p>假定有项目 A ，底下有两个包，分别为 A/alpha 和 A/beta。</p>
<p>为了方便，A/alpha 包使用相对路径引入 A/beta：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"../beta"</span></div></pre></td></tr></table></figure>
<p>如果 A 不在 GOPATH 里开发，换言之 A 不会被别的项目引用，那么是可以正常编译执行的。</p>
<p>可是如果 A 在 GOPATH 里开发，那么编译时会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">can<span class="string">'t load package: local import "../beta" in non-local package</span></div></pre></td></tr></table></figure>
<p>这是因为 go 使用全局递归 import，来确保每个用到的包都只 import 一次。（题外话，也因此，go 不允许循环 import，会死循环。）</p>
<p>假定有另一个项目 B，底下的 main 包引入了 A/alpha，那么就会触发以下 import 顺序：</p>
<ul>
<li>import “A/alpha”，递归 import “A/alpha” import 的包<ul>
<li>import “../beta”，（到这里会出错，因为 B 项目下找不到 “../beta”）</li>
</ul>
</li>
<li>运行 “A/alpha” 的 init()，然后 import 完成</li>
</ul>
<p>如果你觉得解释太啰嗦，记住 <strong>别用相对路径</strong> 就完了。</p>
<h4 id="一切靠-GOPATH"><a href="#一切靠-GOPATH" class="headerlink" title="一切靠 GOPATH"></a>一切靠 GOPATH</h4><p>既然相对路径会有各种问题，那么本地包的导入，就只剩下第 4 种 - GOPATH 一条路了。</p>
<p>这就导致了包管理高度依赖 GOPATH：</p>
<ul>
<li>为了本地开发的包 <strong>能被其它包引用</strong>，开发得在 GOPATH 下进行。</li>
<li>不仅引用其他项目包要经 GOPATH，<strong>连项目内的包互相引用</strong> ，也得经过 GOPATH。（实际上这时不存在 <strong>项目</strong> 的概念，即使共享一个项目根目录，还是不同的包。）</li>
<li>项目目录不能改名，一改，项目内外的引用全得改。（事实上，如果你要把项目托管到源码仓库，或者更换托管地址，项目目录是一定会改的。）</li>
</ul>
<p>这么打个比方，李明 爸爸叫 李雷，妈妈叫 韩梅梅，他们一家住 广东省广州市黄埔区。但是很奇怪，他们家互相称呼都得叫全名，而且是带地址那种。譬如 妈妈 喊老伴和儿子吃饭，就得喊『广东省 / 广州市 / 黄埔区 / VK花园10-204 / 李雷』和『广东省 / 广州市 / 黄埔区 / VK花园10-204 / 李明』。更诡异的是，如果他们过年回老家了，譬如说 长沙，然后妈妈忘记了改称呼，还按前面叫，明明都在一屋（项目）里，但他们俩都不知道在喊自己了。</p>
<p>根本原因，在于 import 中只有全局，没有本地（项目 / 模块）概念。全局以下就直接是包，包和包之间没有联系，哪怕我们在一个项目里，目录相邻。</p>
<p>如果你写过 Java，对比一下就发现，Java 的 classpath 默认为 <strong>当前目录</strong>；这个当前目录，是以执行 javac 的位置算的，其实就是项目的根目录。所以同一个项目下的包，用<strong>相对根目录的路径</strong> 就能 import，不管项目整体放哪、项目目录有没有改名。</p>
<h3 id="0x2-引入-module"><a href="#0x2-引入-module" class="headerlink" title="0x2 引入 module"></a>0x2 引入 module</h3><p>module 模式设为 on，背后主要是两个变化：<strong>引入 module （和 module path），放弃 GOPATH （和 vendor）</strong> 。</p>
<p>这个 module 就是介于 global 和 package 之间的概念，是 一系列的 package 集合。这个概念让在一个 module 里的 package 们产生了联系：整体管理， 互相可见。</p>
<h4 id="module-path-和-package-path"><a href="#module-path-和-package-path" class="headerlink" title="module path 和 package path"></a>module path 和 package path</h4><p>package path 具体来说，就是 import 后面那串路径；module path 则对应 require。</p>
<p>在使用上，package path 似乎没有任何变化，其实它的组成有了重要的变化：</p>
<h5 id="GOPATH-模式"><a href="#GOPATH-模式" class="headerlink" title="GOPATH 模式"></a>GOPATH 模式</h5><p>从 <code>$GOPATH/src</code> 起完整的路径。  </p>
<p>例如 <code>$GOPATH/src/github.com/jay/mymod/midware/router</code> 的 package path 是 <code>github.com/jay/mymod/midware/router</code> ，其它包（包括同一个项目<code>github.com/jay/mymod</code> 下的其它包）需要 import 这个路径。  </p>
<p>路径上的 <strong>任何变化</strong> 都要体现在 import 路径里，如果移出 GOPATH 则 <strong>直接找不到</strong> 。（是的，明明引用的包就在旁边目录都找不到。）</p>
<h5 id="module-模式"><a href="#module-模式" class="headerlink" title="module 模式"></a>module 模式</h5><p>module path + module 内的相对路径。（如果 package 在 module 根目录，也就是跟 go.mod 一个目录，当且仅当这种情况 module path 等于 package path。）  </p>
<p>例如 module path 是 <code>github.com/jay/mymod</code> ，module 内的 <code>midware/router</code>  的 package path 是 <code>github.com/jay/mymod/midware/router</code> ，其它包（包括同一个module <code>github.com/jay/mymod</code> 下的其它包）需要 import 这个路径。  </p>
<p>是不是感觉其实没啥差别，只是把路径截成了两段，把前面那段叫 module path。[苦笑]</p>
<p>差别在于：</p>
<ul>
<li>module path 是一个在 go.mod 内的声明，<strong>不需要是真实的路径</strong>。你的 module 可以放在任何地方开发，不需要放在 GOPATH 地下，路径里也不须包含  <code>github.com/jay/mymod</code> ！</li>
<li>基于这点，只要 go.mod 声明不改，<strong>挪位置，根目录重名，都不影响</strong> module 内 package 互相引用！</li>
</ul>
<h4 id="module-间引用"><a href="#module-间引用" class="headerlink" title="module 间引用"></a>module 间引用</h4><p>等等，这些便利都只是 module 内而已，那 module 之间的引用呢？</p>
<p>再来对比一下：</p>
<h5 id="GOPATH-模式-1"><a href="#GOPATH-模式-1" class="headerlink" title="GOPATH 模式"></a>GOPATH 模式</h5><p><strong>项目托管地址、本地存放路径、import 路径</strong> （的开头） 三者一致。  </p>
<p>仍然以上面的项目为例，三个都是 <code>github.com/jay/mymod</code> 。<br>具体到 托管地址是 <code>https://github.com/jay/mymod</code> ，<br>本地存放地址（无论手动新建项目，还是 go get 自动放）是 <code>$GOPATH/src/github.com/jay/mymod</code> ，<br>import 则是 <code>import &quot;github.com/jay/mymod/midware/router&quot;</code> （mymod 下面其中一个 package）。</p>
<h5 id="module-模式-1"><a href="#module-模式-1" class="headerlink" title="module 模式"></a>module 模式</h5><p>在上述三者基础上，加上 go.mod 声明的 module path 一致。   </p>
<p>也就是在 module 初始化时，执行 <code>go mod init github.com/jay/mymod</code> ，生成的 go.mod 里第一行就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module github.com/jay/mymod</div></pre></td></tr></table></figure>
<p>托管地址、import 路径都跟 GOPATH 一样。差别是本地存放路径：<code>$HOME/go/pkg/mod/github.com/jay/mymod</code> 。（<code>$HOME/go/pkg/mod</code> 叫 mod cache 目录）</p>
<p><br></p>
<p>看了这个对比，module 模式多了一个 go.mod 的声明要保持一致，存放路径还变长了，是不是又感觉根本没简化，还变复杂了。[苦笑]x2</p>
<p>关键在于，go.mod 里提供了一个关键字 <code>replace</code>。</p>
<h4 id="go-mod-里的-replace"><a href="#go-mod-里的-replace" class="headerlink" title="go.mod 里的 replace"></a>go.mod 里的 replace</h4><p>我们来设想一下 <strong>开发的不同阶段</strong> ：</p>
<ol>
<li><p>前期，<strong>一个人开发原型</strong> 。只有 module 内引用，爱放哪放哪。</p>
</li>
<li><p>继续前期，原型 <strong>新增了一个 mymod2</strong> ，而且 <strong>引用原来的 mymod</strong> ，有了 module 间引用，此时你有 <strong>两个选择</strong>：</p>
<ol>
<li><p><strong>继续随便放</strong> ，譬如 <code>~/mymod/</code> ，然后在 mymod2 根目录执行 <code>go mod edit -replace=github.com/jay/mymod@v=~/mymod@v</code> ，<code>@v</code> 是可选的。  </p>
<p> <code>go mod edit -replace=github.com/jay/mymod=~/mymod</code> 就是所有版本都替换。你也可以指定版本如 <code>@v1.0.1</code> 。</p>
</li>
<li><p>把 mymod 按照 module path  <strong>托管到对应地址</strong> ，mymod2 就会从托管服务下载 mymod 自动存放到 <code>$HOME/go/pkg/mod/github.com/jay/mymod@vX.Y.Z</code> 。下载过程是自动的，存放位置自动跟 “托管地址+版本” 映射，并不需要人工干预。  </p>
<p> <strong>需要注意</strong> 的是，mymod2 引用的是托管的代码，<code>~/mymod/</code> 下的最新修改如果没有push 到托管，是访问不到的。  </p>
<p> 如果 mymod2 后续也要发布或者跟其他开发者协作，<strong>建议一开始就选择这种方式</strong> 提供引用。否则按 2.1 处理，mymod2 在别人的环境无法获取 mymod 的依赖。</p>
</li>
</ol>
</li>
<li><p>中期，<strong>其他开发者加入</strong> 。为了其他开发者可以正常地访问依赖，需要把所有用到的 module 按 module path 放到托管服务上 。（同 2.2）</p>
<p> 托管服务可以是公共的，也可以是私有的。如果是私有的，需要配置 ssh 以达到免密访问。（ssh 配置不展开。）</p>
<p> 考虑到迟早需要发布到托管，最好初始化时就考虑 <strong>把托管地址作为 module path</strong> 。</p>
</li>
<li><p>后期，<strong>持续开发和维护</strong>。也许是 公共转私有（或者反过来，开源），又或者项目改名，或者某个公共托管撂挑子不干了——总之，有些 module 挪位置了。譬如说 <code>https://github.com/jay/mymod</code> 挪到 <code>https://bitbucket.com/jay/mymod</code>。  </p>
<p> 这时 replace 再次发挥作用，在所有引用这个 module 的 module 的根目录执行 <code>go mod edit -replace=github.com/jay/mymod=bitbucket.com/jay/mymod</code> ，那些 import 语句就不用一个一个修改了。  （原理同 2.1 ，只是映射的是 托管地址，不是本地，所以这个修改写入 go.mod 并提交之后， <strong>对其他开发者也能生效</strong> 。）</p>
<p> 不过 mymod 本身，除非你只挪托管不修改 go.mod 的 module path 声明（意味着 mymod 只作为依赖存在，自身没有 main 包需要编译执行），否则 mymod 内部的 import 语句还是得改为新的 module path。</p>
</li>
</ol>
<p><strong>需要注意</strong> 的是，replace <strong>只对当前 module 直接引用的依赖起作用</strong> ，对于间接引用不起作用。如果 mod1 引用 mod2，然后 mod2 引用 mod3；当 mod3 改动地址时，在 mod1 里 replace mod3 的地址，只会对 mod1 直接引用 mod3 起作用； mod2 对 mod3 的引用必须在 mod2 里改。</p>
<p>如果 mod2 是第三方的 module，而它引用的同样是第三方的 mod3 挪了位置之后，mod2 没有及时更新，那么可能你只能 fork 一个 mod2 自行修改了。</p>
<p>这个问题据说可以通过 <strong>自建 goproxy</strong> 来指定重定向解决。我还没到需要用到的时候，将来踩了自建 goproxy 的坑再回来写。</p>
<h3 id="0x3-semver-语义化版本"><a href="#0x3-semver-语义化版本" class="headerlink" title="0x3 semver 语义化版本"></a>0x3 semver 语义化版本</h3><p>要理解 go modules  的运作，还有一个是不得不提的，就是 Semantic Version - 语义化版本，缩写 semver。</p>
<p>关于 semver 是什么，请看 《<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0</a>》。</p>
<p>详细的解释，大家自己看官方文档，这里只强调格式：主版本号.次版本号.修订号</p>
<ol>
<li>主版本号：当你做了 <strong>不兼容</strong> 的 API 修改 (<strong>breaking changes</strong>)，</li>
<li>次版本号：当你做了 <strong>向下兼容</strong> 的功能性新增 (<strong>compatible features</strong>)，</li>
<li>修订号：当你做了 <strong>向下兼容的问题修正</strong> (<strong>compatible hotfixs</strong>)。</li>
</ol>
<p>譬如说当前版本号是 v1.2.3 ，在此基础上：</p>
<ul>
<li>fix 了个 bug，没有影响兼容性，v1.2.4</li>
<li>新增 / 改善了功能，依然没有影响兼容性，v1.3.0</li>
<li>任何影响兼容性的修改，无论是 fix bug （这 bug 得多严重），还是 API 签名（名字 or 参数）改动，或者干脆的删掉了 deprecated API，反正调用方会出错，必须跟着修改，v2.0.0</li>
</ul>
<p>一个特例是，主版本号为 0 的版本，被认为是初步开发的 <strong>不稳定版本</strong> ，可以不遵循兼容性的原则。</p>
<p>理解了这些，下面的一些做法就比较好理解了。</p>
<h4 id="导入兼容性原则"><a href="#导入兼容性原则" class="headerlink" title="导入兼容性原则"></a>导入兼容性原则</h4><p>一个 module 一定是 <strong>向下兼容</strong> 的。（又叫向后兼容 backwards compatible，指 newer 的版本兼容 older 的版本）反过来说，如果不兼容，会被视作 <strong>不同的 module</strong> 。</p>
<p>具体操作上，就是 2 以上的主版本号，会加入 module path，使得 <strong>module 声明、导入路径（包括 require 和 import）、缓存路径</strong> 都发生变化，从而被识别为不同的 module。唯独不变的是 托管地址，靠 tag 就可以区分，没有必要每个主版本新建一个项目。还是以 <code>github.com/jay/mymod</code> 为例：</p>
<table>
<thead>
<tr>
<th><strong>主版本号</strong></th>
<th>0 或 1</th>
<th>2 （3 或以上以此类推）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>module 声明</strong></td>
<td>module github.com/jay/mymod</td>
<td>module github.com/jay/mymod/v2</td>
</tr>
<tr>
<td><strong>require 列表</strong></td>
<td>github.com/jay/mymod v1.0.1</td>
<td>github.com/jay/mymod/v2 v2.0.2</td>
</tr>
<tr>
<td><strong>import 语句</strong></td>
<td>import “github.com/jay/mymod/midware/router”</td>
<td>import “github.com/jay/mymod/v2/midware/router”</td>
</tr>
</tbody>
</table>
<h4 id="选择最新版本"><a href="#选择最新版本" class="headerlink" title="选择最新版本"></a>选择最新版本</h4><p>在同一个主版本下，如果在添加依赖时你没有指定版本（也就是你没有手动 <code>go get github.com/jay/mymod@v1.0.1</code> ，或者只是指定了大版本 <code>go get github.com/jay/mymod@v1</code> 没有指定次版本），那么第一次获取依赖时，go 会自动 <strong>获取最新的版本</strong> 并将版本信息写入 go.mod。</p>
<p>在这之后，除非你手动更新，否则 go 会一直使用 go.mod 记录的版本，不会自动更新。</p>
<h4 id="最小版本选择"><a href="#最小版本选择" class="headerlink" title="最小版本选择"></a>最小版本选择</h4><p>依赖包括 <strong>直接依赖 和 间接依赖</strong>。mod1 依赖了 mod2，然后 mod2 又依赖了 mod3， mod2 是直接依赖， mod3 是间接依赖。间接依赖在 go.mod 里以 <code>//indirect</code> 结尾。</p>
<p>执行 <code>go mod graph</code> 可以输出所有 module 之间的依赖关系。如果项目稍大，内容会很长，长到超出 bash / cmd 的缓冲那种，建议重定向一个文件再搜索。或者 <code>go mod why &lt;package path&gt;</code> 查询某个 package 被谁依赖。</p>
<p>因为有 直接依赖 和 间接依赖，而且对某个 module 的间接依赖可能不止一处，就有可能出现依赖的版本不一致。这种不一致又分两种情况：</p>
<ul>
<li><p>主版本号不同：这个好办，参见上一个小节，主版本号不同直接被认为是不同 module，你依赖你的，我依赖我的，并行不悖。</p>
</li>
<li><p>主版本号相同：选择所有依赖里，<strong>最大的版本号</strong>。  </p>
<p>  例如 同时依赖 v1.0.1、v1.0.2、v1.1.3，那么选择 v1.1.3。因为同一个主版本下是向下兼容的，依赖 v1.0.1 和 v1.0.2 的代码，调用 v1.1.3 也是可以的；反过来说，v1.1.3 里可能增加了新功能，依赖它的地方再去调用老版本，很有可能会报错。  </p>
</li>
</ul>
<h4 id="伪版本"><a href="#伪版本" class="headerlink" title="伪版本"></a>伪版本</h4><p>go module 允许通过 commit-hash 指定版本 （可以通过 hash 前缀指定，有规定最小长度，但我忘了，这是不推荐的做法），但在获取时会自动跟 tag 比对，一旦命中会自动转换成 semver。</p>
<p>如果 module 完全没有打 tag，或者指定的 hash 不命中 tag，go 会生成一个伪版本号来记录，格式是 <code>vX.0.0-yyyymmddhhmmss-12位hash</code>。</p>
<h4 id="incompatible"><a href="#incompatible" class="headerlink" title="+incompatible"></a>+incompatible</h4><p>在 go.mod 里可以看见有些依赖后面带着一个 <code>+incompatible</code> 。这个标记的意思是，依赖的版本在 2 以上，但是这个 module 自身没有使用 module 模式（也就是根目录没有 go.mod），所以无法通过在路径添加版本来区分主版本。</p>
<p>更多版本选择的原理，请参考 《<a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="external">Minimal Version Selection</a>》。</p>
<h2 id="延伸：可重现构建"><a href="#延伸：可重现构建" class="headerlink" title="延伸：可重现构建"></a>延伸：可重现构建</h2><p>Java 从 ant、Maven 到 gradle，Python distutils、setuptools 到 pip，js 的 npm 和 yarn，go 经历了 vgo、glide、dep 到 内置 modules，再加上一系列 VCS 和 托管服务（目前是 git 和 github 统一了江湖），各种构建物仓库。</p>
<p>大家做了那么多工作，设计这么复杂的机制，本质上都是为了一个目的：<strong>构建过程可重复，构建产物可重现</strong> 。</p>
<p>在软件个人英雄主义的时代，这不成问题的，代码是大牛一个人开发的，构建所需要的代码和工具，都在大牛的电脑上。稍往后，多几个人加入，也是在一个公司、一个研究机构里，ftp 共享一下就完事了，最多搭建一个内部的 VCS 服务。</p>
<p>但是在软件开发网络大协作的年代，这就变成了一个工程难题。分布在世界各地，素未谋面的一群人一起开发，很多问题就会涌现。特别是开源的年代，即使是小公司的项目，一个学生的作业，也极少会从零开始开发，你不可避免地会引用其他人的工作成果。</p>
<p>哪怕只是和别人合作过一个简单的项目，你都大概率遇到过『你的代码在我这里 编译不过 / 运行报错。』『不可能，我本地一点问题都没有，是测试过才提交的。』这种对话。</p>
<p>上述那么多的 工具 和 机制，是为了保证分散各处的开发者（可能还有测试、运维团队），能够做到共享 <strong>一致的环境、一致的配置、一致的代码版本，一致的依赖，一致的构建脚本，重现一致的构建过程，得到一致的构建产物</strong> 。</p>
<p>话题很大，不是三言两语能够说清的，就到此为止。提那么一下，是希望帮助理解，为什么把事情搞得那么复杂。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写 《&lt;a href=&quot;https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/&quot;&gt;配置 1.13+ 的 golang 环境&lt;/a&gt;》时，花了大量篇幅解释 module 的概念，还有 module 与 package 之间的联系。眼看字数翻了一番，干脆把这部分另起一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>配置 1.13+ 的 golang 环境</title>
    <link href="https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/"/>
    <id>https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/</id>
    <published>2020-01-20T08:46:44.000Z</published>
    <updated>2020-03-10T15:10:25.969Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过《<a href="../../2018/setup-golang-env/">配置 Golang 开发环境</a>》（go &lt; 1.13, win64）。然后 1.13 是一个重大变更，大到需要原有的依赖管理要做迁移的程度（《<a href="../..//2019/golang-1-13-from-dep-to-mod/">golang 1.13 - 依赖管理从 dep 到 mod 踩坑</a>》）。</p>
<p>1.13 让原来的配置方式有了变化，撇开语言特性不谈，仅说和配置相关的，最大的变化，是 go module 的转正，和 GOPATH 和 vendor 的边缘化（1.13 仍然给你选择的余地，但是推荐选择 module，停用 GOPATH 和 vendor）。</p>
<p>那么如果你从 1.13 之后才刚刚开始接触 go， 那么前面两篇文章对你来说并不友好。</p>
<p>所以我找到了理由又水一篇。</p>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>之前的文章讲的 Win64 环境的配置，正好新版本重写，这次写 Linux 环境下。</p>
<h3 id="0x00-下载解压"><a href="#0x00-下载解压" class="headerlink" title="0x00 下载解压"></a>0x00 下载解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 为免你无脑复制黏贴，强迫你走一趟流程，也确保你下载最新版本，这不是有效的下载链接，请自行到官网找最新版本，替换掉版本号 x.y.z</span></div><div class="line">~ wget https://dl.google.com/go/gox.y.z.linux-amd64.tar.gz</div></pre></td></tr></table></figure>
<p>找下载链接请到官网 golang.org/dl ，如果国内不能访问，请到官方镜像站 golang.google.cn/dl 。</p>
<p>然后解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 记得改文件名里的 x.y.z</span></div><div class="line">~ tar -zxvf gox.y.z.linux-amd64.tar.gz</div><div class="line">mv -t /opt/ go</div></pre></td></tr></table></figure>
<p>个人习惯放到 /opt/ 下。</p>
<h3 id="0x01-系统环境变量"><a href="#0x01-系统环境变量" class="headerlink" title="0x01 系统环境变量"></a>0x01 系统环境变量</h3><p>然后将可执行文件加入系统路径。</p>
<p>在 <code>/etc/profile</code> 末尾加上，保存之后记得 source 一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># manually added</span></div><div class="line">GOROOT=/opt/go</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$HOME</span>/go/bin</div></pre></td></tr></table></figure>
<p>我是想全局生效所以丢这里，如果你只是想当前账户生效，可以加在 <code>~/.bashrc</code>。</p>
<p>惯例地检查一下是否配置正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~ go version</div><div class="line">go version go1.13.6 linux/amd64</div></pre></td></tr></table></figure>
<p>如果不能正确执行 <code>go version</code> ，把当前版本输出，请回头检查哪里出错。</p>
<p>跟老版本不同的是，只要把 go 本身的可执行路径 和 go bin 的安装路径加入 PATH 就可以了，剩下的 go env 自行管理了。</p>
<h3 id="0x02-go-env"><a href="#0x02-go-env" class="headerlink" title="0x02 go env"></a>0x02 go env</h3><p>执行 <code>go env</code>，就会看到 go 内置的环境变量，以及部分默认值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">go env</div><div class="line">GO111MODULE=<span class="string">""</span></div><div class="line">GOARCH=<span class="string">"amd64"</span></div><div class="line">GOBIN=<span class="string">""</span></div><div class="line">GOCACHE=<span class="string">"/home/jaycechant/.cache/go-build"</span></div><div class="line">GOENV=<span class="string">"/home/jaycechant/.config/go/env"</span></div><div class="line">GOEXE=<span class="string">""</span></div><div class="line">GOFLAGS=<span class="string">""</span></div><div class="line">GOHOSTARCH=<span class="string">"amd64"</span></div><div class="line">GOHOSTOS=<span class="string">"linux"</span></div><div class="line">GONOPROXY=<span class="string">""</span></div><div class="line">GONOSUMDB=<span class="string">""</span></div><div class="line">GOOS=<span class="string">"linux"</span></div><div class="line">GOPATH=<span class="string">"/home/jaycechant/go"</span></div><div class="line">GOPRIVATE=<span class="string">""</span></div><div class="line">GOPROXY=<span class="string">"https://proxy.golang.org,direct"</span></div><div class="line">GOROOT=<span class="string">"/opt/go"</span></div><div class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></div><div class="line">GOTMPDIR=<span class="string">""</span></div><div class="line">GOTOOLDIR=<span class="string">"/opt/go/pkg/tool/linux_amd64"</span></div><div class="line">GCCGO=<span class="string">"gccgo"</span></div><div class="line">AR=<span class="string">"ar"</span></div><div class="line">CC=<span class="string">"gcc"</span></div><div class="line">CXX=<span class="string">"g++"</span></div><div class="line">CGO_ENABLED=<span class="string">"1"</span></div><div class="line">GOMOD=<span class="string">""</span></div><div class="line">CGO_CFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_CPPFLAGS=<span class="string">""</span></div><div class="line">CGO_CXXFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_FFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_LDFLAGS=<span class="string">"-g -O2"</span></div><div class="line">PKG_CONFIG=<span class="string">"pkg-config"</span></div><div class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build089244508=/tmp/go-build -gno-record-gcc-switches"</span></div></pre></td></tr></table></figure>
<h4 id="必改"><a href="#必改" class="headerlink" title="必改"></a>必改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~ go env -w GO111MODULE=on</div><div class="line">~ go env -w GOPROXY=https://goproxy.cn,direct</div></pre></td></tr></table></figure>
<p><strong>GO111MODULE</strong> : </p>
<ul>
<li>auto : 自 1.11 实验性加入之后就是默认值。auto 意味着由工具链自动判断是否启用 go modules。在 1.13 以前的启用条件是『项目根目录有 go.mod 且项目不在 GOPATH 内』，1.13+ 去掉了 『不在 GOPATH 内的限制』，也就是只要有 go.mod 就会启用。</li>
<li>on : 如果你觉得上面这段话太长懒得看，或者害怕以后启用条件还会变，那么 1.13 已经准备好全面启用 go modules，直接设为 on 就好了。设为 on 之后无条件启用 go modules。</li>
<li>off :  关闭 go modules，回到 GOPATH 时代。</li>
</ul>
<p><strong>GOPROXY</strong> :</p>
<p>国内环境必备，原因你懂的。甚至可以说这是新版本为中国开发者做出的最大改进之一也不为过。在 dep 的时代是靠自建的代理熬过来的，那么不会代理的朋友就很麻烦了。改用镜像就友好太多了。</p>
<p>目前国内最早最好的代理是 七牛云提供的 <code>https://goproxy.cn</code> 。如果团队内部还有搭建私有代理，可以用 <code>,</code> 隔开，go 会依次尝试。最后记得加上 <code>direct</code> ，让镜像上找不到的依赖回源查找。（包括但不限于 镜像还没同步，私有仓库 等情况）</p>
<p>目前自建代理的开源方案貌似有以下几个。由于我暂时没有自建代理的需要，没有实测，请自行对比选择。</p>
<ul>
<li><a href="https://github.com/goproxyio/goproxy" target="_blank" rel="external">https://github.com/goproxyio/goproxy</a></li>
<li><a href="https://github.com/gomods/athens" target="_blank" rel="external">https://github.com/gomods/athens</a></li>
<li><a href="https://github.com/goproxy/goproxy" target="_blank" rel="external">https://github.com/goproxy/goproxy</a></li>
</ul>
<h4 id="推荐改"><a href="#推荐改" class="headerlink" title="推荐改"></a>推荐改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ go env -w GOBIN=<span class="variable">$HOME</span>/go/bin</div></pre></td></tr></table></figure>
<p><strong>GOBIN</strong> 如果没有设置，默认值为 <code>$GOPATH/bin</code> ，是通过 <code>go get</code> 或 <code>go install</code> 安装的可执行文件的存放目录。不设并不影响使用，但考虑到 GOPATH 正在被边缘化，未来不知道哪个版本就取消了，所以建议还是单独设置一下比较好。我为了保持使用习惯，设置了跟默认相同的目录（因为 GOPATH 默认值是 <code>$HOME/go</code>），区别只是这个值不依赖 GOPATH 的值。</p>
<p>值得 <strong>提醒</strong> 的是，这个目录也需要加入系统 PATH ，并且我已经在 系统环境变量 里加入（最后一个），如果你根据自己的习惯修改了 GOBIN 的位置，那么 0x01 里的配置也得相应修改。</p>
<p>更多的变量，推荐参考 《<a href="https://mp.weixin.qq.com/s/AsdCDodxZFxs2SkhSwOvpg" target="_blank" rel="external">干货满满的 Go Modules 和 goproxy.cn</a>》。</p>
<h3 id="0x03-cgo-和-build-tool"><a href="#0x03-cgo-和-build-tool" class="headerlink" title="0x03 cgo 和 build tool"></a>0x03 cgo 和 build tool</h3><p>go 语言的 cgo 特性允许 C 语言 和 go 语言互调，达到 <strong>复用已有的 C/C++ 庞大代码资源</strong> 的目的；又或者用 C 编写程序的一部分以达到某些 底层语言才能达到的目标。而要使用 cgo 特性，就需要有 C/C++ 的构建工具链 <strong>gcc</strong> 。</p>
<p>另一方面，随着项目规模变大，你会逐渐需要一个 <strong>构建工具</strong> （build tools）帮你管理构建细节，就像 ant / maven / gradle 之于 Java。由于 go 本身的构建比较简单（或者说 go 的构建规则比较清晰，自带的 build 命令够用），又有了现成的依赖管理（之前的 vgo / glide / dep，现在官方的 go modules），官方并没有一个专用的构建工具。这部分，因为依赖管理已有，管理额外的构建细节， <strong>Makefile (make) 足矣</strong> 。</p>
<p>gcc 和 make 在多数 Linux 发行版是自带的，你可以通过  <code>gcc -v</code> 和 <code>make -v</code> 来确认安装的版本。即使没有，视乎不同的包管理器，也就是一两句命令的事。Windows 下稍微麻烦一些，但仍然有解决方案，我在《<a href="https://jaycechant.info/2018/setup-golang-env/">配置 Golang 开发环境</a>》#2. gcc 和 make 部分有提及，go 的重大升级不影响这部分内容依然有效。</p>
<h3 id="0x04-安装-VCS"><a href="#0x04-安装-VCS" class="headerlink" title="0x04 安装 VCS"></a>0x04 安装 VCS</h3><p>在使用 go get 命令之前，需要安装依赖托管服务对应的 VCS （Version Control System）。go get 会根据依赖所托管的网站反馈的信息，调用对应的工具 （git / hg / svn）拉取依赖。</p>
<p>就我的个人实践而言，绝大多数的第三方依赖都是基于 git 发布的（或者说直接就是放在 github 上），所以 <strong>直接安装 git 就好</strong> ，后面遇到基于其他工具的依赖，再安装不迟。</p>
<p>由于 git 本身就是一个大话题，基本的安装使用教程不难搜到，有时间时会另起文章讨论，这里只是提醒安装，不再展开。</p>
<h3 id="0x05-开始一个项目"><a href="#0x05-开始一个项目" class="headerlink" title="0x05 开始一个项目"></a>0x05 开始一个项目</h3><p>终于把环境都配置好了，然后就可以开始第一个 go 的项目了。由于 go modules 不再依赖 GOPATH，所以项目可以放在任何地方——这个 『任何』，是指可以不是 GOPATH ，但是要是习惯了，继续放在 <code>$GOPATH/src</code> 也没问题。</p>
<p>好了，不管放在哪，现在新建一个项目的根目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~ mkdir testproj</div><div class="line">~ <span class="built_in">cd</span> testproj</div></pre></td></tr></table></figure>
<p>然后执行 <code>go mod init &lt;module_path&gt;</code> ，生成 go.mod ，这个项目就算初始化完了，接下来就该敲代码了。随着开发的进行，还会自动生成 go.sum 文件，记录依赖的校验信息。注意 go.sum <strong>不是 lock 文件</strong> ，重现构建的信息已经包含在 go.mod 里，go.sum <strong>属于 checksum 文件</strong> ，用来 <strong>确保下载的依赖没有被篡改</strong> 。 go.mod 和 go.sum 需要一起提交<strong>参与版本控制</strong> 。关于 <code>go mod</code> 的详细用法，可以直接 <code>go help mod</code> 获取帮助信息，不展开。</p>
<p>关于 module path 的内容，以及 module 与 package 之间的关系，原本是在这篇文章里接着继续写；结果发现这部分内容让字数足足翻了一番。为了避免让本文又臭又长，就另起了一篇文章，请看《<a href="https://jaycechant.info/2020/golang-1-13-module-VS-package/">golang 1.13 - module VS package</a>》。</p>
<p>go 语言开发不是（篇幅上也不可能是）本文的话题，另起系列展开。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>在写这篇文章时，留意到 gradle 的一个插件 <strong>gogradle</strong>，可以为 gradle 添加对 go 的支持。由于我没有使用过这个插件，所以不好评价；不过基于以下理由，我认为除非有什么困难只有它能解决，不然 make 足以完成绝大多数的任务，不推荐尝试：</p>
<ul>
<li>go 除了某些特性（如 cgo）编译时依赖某些二进制工具（如 gcc，二进制是区别于基于虚拟机的工具），基本是一个完全自给自足的语言，环境配置简单且基本一劳永逸，编译结果可以单执行文件零依赖部署，在某些情况下简直是杀手级的特性。（想想 C/C++ 以外多少语言能做到）而 gradle 是基于 groovy （一种 JVM 上的脚本语言），等于 <strong>给 go 的开发环境引入了 JVM 依赖</strong> 。即使我作为一个长期写 Java 的人，环境里一定有 JVM，仍然觉得这种依赖是别扭的。</li>
<li>gogradle 官方文档自荐的理由，是 make 学习曲线陡峭，和 make 基于 bash 的跨平台性不好。make 和 gradle 的学习曲线见仁见智，但是由于 go 自带的 build 已经完成了构建的大多数工作（包括依赖推导和文件新旧比较），也不需要处理依赖管理，make 的 <strong>工作任务非常轻</strong> ， 不会涉及太复杂的规则编写。至于跨平台，引入 MinGW-w64 已经可以解决大多数的问题。</li>
<li>go 1.13 自带 go modules 作为依赖管理，大方向是 <strong>淡化 GOPATH 和 vendor</strong>；而 gogradle 受 glide 启发，自带依赖管理，自称相当于 glide + make，依然使用 GOPATH 和 vendor，这 <strong>跟官方的发展方向冲突</strong> 。这可能是最关键的一点，如果你习惯了 gradle 的工作方式，有一天这种工作方式可能跟官方的最新版本不兼容。</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写过《&lt;a href=&quot;../../2018/setup-golang-env/&quot;&gt;配置 Golang 开发环境&lt;/a&gt;》（go &amp;lt; 1.13, win64）。然后 1.13 是一个重大变更，大到需要原有的依赖管理要做迁移的程度（《&lt;a href=&quot;../..//2019/golang-1-13-from-dep-to-mod/&quot;&gt;golang 1.13 - 依赖管理从 dep 到 mod 踩坑&lt;/a&gt;》）。&lt;/p&gt;
&lt;p&gt;1.13 让原来的配置方式有了变化，撇开语言特性不谈，仅说和配置相关的，最大的变化，是 go module 的转正，和 GOPATH 和 vendor 的边缘化（1.13 仍然给你选择的余地，但是推荐选择 module，停用 GOPATH 和 vendor）。&lt;/p&gt;
&lt;p&gt;那么如果你从 1.13 之后才刚刚开始接触 go， 那么前面两篇文章对你来说并不友好。&lt;/p&gt;
&lt;p&gt;所以我找到了理由又水一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>S/L 大法 —— 平凡人的做事方法</title>
    <link href="https://jaycechant.info/2020/save-load-a-solution-for-ordinary-people/"/>
    <id>https://jaycechant.info/2020/save-load-a-solution-for-ordinary-people/</id>
    <published>2020-01-01T16:41:47.000Z</published>
    <updated>2020-01-02T15:38:01.467Z</updated>
    
    <content type="html"><![CDATA[<p>博客和公众号改名了，改成了同一个。</p>
<p>这事儿值得说一下。</p>
<a id="more"></a>
<h2 id="壹"><a href="#壹" class="headerlink" title="壹"></a>壹</h2><p>最早在网上写字儿，得从 06 年 QQ 空间算起。中二少年，为赋新词强说愁。</p>
<p>在其他少年努力花钱让 Q-ZONE 更炫时，我想办法让它不那么晃眼，别抢文字的风头。后来百度空间出来了，支持自定义样式（CSS）。不花钱，风格却有更大自由度，于是逐渐挪了过来。高中为此专门自学 CSS 。大学时的师兄据说因为我会 CSS 把我招进 团委网络部，又是一段经历；可惜后面一直做后端，基本再也没有做前端 。</p>
<p>然后专门开了一个新的百度空间叫『片言断章』放那段时间酸腐的 诗词，开了一个新浪博客写游戏，在辩论队搞了一个网易群博 …… 毕业前搞了一个 Octopress 。</p>
<p>然后微博来了，没那么多人写博客了；再往后是微信，然后公众号。潮流一波一波来了又走，每次都是狂欢；而我，别说写出个名堂，那点字数，对自己都没法交代。对了，后来我也开了公众号。</p>
<h2 id="贰"><a href="#贰" class="headerlink" title="贰"></a>贰</h2><p>Octopress 托管在 Github pages 上，后来生成工具换成了 Hexo （插一句，如果你现在弄的话，推荐 Hugo），绑了自己的域名 <a href="https://jaycechant.info">https://jaycechant.info</a> 。在主动关了 Q-ZONE，百度空间 服务被下线之后，这里是写字最多的地儿了。因为源码在自己手，别说 Github 很难关门，就算它关了 pages 服务，静态页面放哪不行，这儿写的东西，能一直留住。</p>
<p>这个内容最多的博客，叫 『Jayce 的技术博客』，直白得没有解释的需要。之所以这么叫，除了当初想名字时偷懒，可能还存在一点人设幻想，希望读者有清晰的主题预期，好吸引同好：这里 Geek 风写技术，那里文艺风写诗（彼时『片言断章』还在），这个语言活泼写游戏 …… 当然，事实证明想得太多，都是挖坑不填。</p>
<p>应该先尝试写好一个博客。如果有一天，某个主题的文章已经多到和原来的博客格格不入，让读者发生困扰了，这时还有余力，就可以考虑新开一个，相关主题都挪过去。文章没几篇，既没有形成自己的风格，也没有读者群体，瞎操心。过早优化 都是瞎折腾。</p>
<p>不过就算是专注于写技术，这名字也没提供任何信息量。</p>
<h2 id="叁"><a href="#叁" class="headerlink" title="叁"></a>叁</h2><p>公众号的名字叫 『JayceIO』。 Jayce 是我名字，IO 是 Input / Ouput ，原意是 『以知识的输出促进输入』。当然，也可以事后诸葛地说，IO 像 1 和 0 ，IO 是致敬 Google I/O 的 『Innovation in Open』（开放中创新）。</p>
<p>公众号上只有 6 篇文章，而且都是旧文，没有一篇是专为公众号写的；就这样，排版就费了老大的劲，在 10 天冲刺拿到了原创认证之后，就泄了气，一停更就是一年。</p>
<p>写得这么少，懒，时间管理又差，当然是首要原因，得认。公众号出于它自身的考虑，功能做了很多限制，也给新手制造了一些难度。</p>
<h2 id="肆"><a href="#肆" class="headerlink" title="肆"></a>肆</h2><p>如果早些年，发现自己这么不争气，大概会给自己定一系列目标，列个详细计划，自灌几碗鸡汤，打几针鸡血。短期内狂飙一波，然后无法坚持，慢慢松懈，甚至比原来更糟。不仅写博客这样，很多事情都是这样运动式反复 —— <strong>码字只是困境的一个缩影。</strong></p>
<p>这些年过去，开始跟自己和解，不再跟人性作对。不再简单地强迫自己，开始去思考：<strong>做这件事初衷是什么？ 为什么没能做下去？ 阻力来自外部还是内部？ 是内心不愿意，还是害怕些什么？</strong></p>
<p>问初衷，是看这件事在当下是否依然有价值。</p>
<p>阻力来自外部，那就想办法绕过它，降低它；绕不过，降不了，就跟价值比较一下，是否值得，是不是时机不对。</p>
<p>这些都相对容易理清。难测的是心魔。</p>
<p>如果潜意识不想做这件事，或者害怕些什么，靠鸡血也许可以勉力『坚持』着；但这种坚持，需要消耗额外的注意力，去不断提醒自己。时间已经够宝贵了，注意力则是比时间更宝贵的资源，人没办法一直保持清醒，而即使是清醒时也未必能一直保持专注。有一天你太累了，或者突如其来的意外打乱了计划，那脆弱的『坚持』就会不堪一击。</p>
<p>如果是喜欢做一件事，本身是不需要坚持的。想想那些在被窝里打灯看小说的日子，想想年少时半夜翻墙去游戏厅、去网吧。</p>
<h2 id="伍"><a href="#伍" class="headerlink" title="伍"></a>伍</h2><p>玩过单机游戏的大概会知道 S/L 大法。</p>
<p>S/L 是 Save &amp; Load 的缩写，就是存档 / 读档大法。在艰难的关卡、BOSS 之前存个档，如果输了或者结果不好，读档再来。甚至在一些随机事件之前存档，譬如一个抽奖事件，本来只有 1% 的机会可以得到最好的奖品，用了 S/L 之后，只要你愿意耗，理论上一定能拿到。有些游戏一个选择能影响后面很久远的结果，那就存很多个档，不覆盖旧档；发现选错了，总能读到一个做选择之前的。</p>
<p>做到这种程度，在游戏设计者眼里，大概算是作弊了（所以才会有些游戏只许存一个档，而且重要事件过后自动保存覆盖）。努力提升游玩水平，一口气通关的体验多好。如果不慎进了糟糕的剧情分支，那就重头再来嘛，设计者鼓励你多体验不同故事线。</p>
<p>可我游戏水平不高，又没有那么多时间一次次重头再来，只好用这种办法，尽量往希望体验的游戏结局靠拢。</p>
<h2 id="陆"><a href="#陆" class="headerlink" title="陆"></a>陆</h2><p>生活与游戏有相似的地方。</p>
<p>我当然希望自己是个天选之子（难道你不曾想过？）。我也说过『长大要当科学家』，也曾烦恼过将来长大了应该报清华还是北大。新手村太容易，让我以为可以 一命、无伤、全成就收集、满分 拿到 Best Ending 。</p>
<p>然而世界服从正态分布，大多数人都是普通人，很快就卡关了。这时偷瞄一下周围的人，却有人遥遥领先，甚至已经通关——还很轻松的样子。</p>
<p>你身边也总能找到这些人，他站在了你无法想像路径的悬崖峭壁之上。</p>
<p>不，我没有强调悬崖的高度，我强调的是险，是无路可达。再高的山，只要给了路线，给了阶梯，山顶就是可以想像的，无论是笨鸟先飞，还是愚公移山。可他好像省略了过程，直接出现在无路峭壁顶上。你会想， <strong>这种事情，我大概是做不来的。</strong> 我只会走，又不会飞。 <strong>大概是天赋的差异。</strong></p>
<h2 id="柒"><a href="#柒" class="headerlink" title="柒"></a>柒</h2><p>有些事情，我到了后来才慢慢懂得。</p>
<p>那些惊世的画作，看 X 光扫描，原来也是打了草稿，反复纠结，反复修改。</p>
<p>那些浑然天成，没有半分修改余地的句子，等到公布作者原稿，原来也是在你我都能买到的普通稿纸上，涂涂抹抹出来的。</p>
<p>那些功能无比强大的开源软件，如果你愿意翻看提交历史，原来也是这么一行一行改了又改，偶尔重写把某块推倒重来，从很可能只是原作者的一时兴起，变成了今天的庞然大物。</p>
<p>……</p>
<p><strong>他们从来就不是突然出现在崖顶。只是走过的路，他们反反复复试错的痕迹，被隐去了。</strong></p>
<p>大多数人无意隐藏这点，只是他们没有机会说起，你也没有机会问，没有近距离去看。</p>
<p>这是生活中的 S/L 大法。</p>
<h2 id="捌"><a href="#捌" class="headerlink" title="捌"></a>捌</h2><p><strong>Q: 写博客初衷是什么？</strong></p>
<p>A: <strong>记录</strong>。<br>后来可能逐渐冒出诸如 与人交流、博得名气 等等越来越不靠谱的想法。<br>但最初，只是想记录走过的路，给未来的自己，提供一个坐标。<br>这个出发点，现在仍然具有意义。（或者说，随着儿子的出生，更有意义了！）</p>
<p><strong>Q: 为什么没能写下去？阻力在外部还是内部？</strong></p>
<p>A: 初期遇到困难，容易归结为外因。譬如说工作忙，譬如说工具不好用。但当把这些外因都改善乃至解决掉之后，事情仍然僵持，我就知道原因不在外部，起码不是关键。</p>
<p><strong>Q: 内心在抗拒记录吗？还是在害怕什么？</strong></p>
<p>我不抗拒记录。在回顾过去的时候，还往往遗憾当时做的记录太少。<br>准确地说，我在焦虑。</p>
<p>我在害怕自己写得不够好。明明只是写给自己看的记录，却过早萌生了杂念。明明并没有什么读者，却总觉得有眼睛在看着我，有着作者的包袱。</p>
<h2 id="玖"><a href="#玖" class="headerlink" title="玖"></a>玖</h2><p>我是一个缺乏安全感的人，总是感觉只有这一次尝试机会，而我很可能会把事情搞砸。于是总是处在一种『做好万无一失准备』的状态中——仿佛只要不轻易地开始，就没有人可以宣布我失败。</p>
<p>具体到生活中，就会表现为 完美主义、强迫症、拖延症。出门前要数几次随身物品；在重要事件前很可能会失眠；会梦到人生中经历过的人生节点，然后在梦里把它搞砸了——最常见的是考试，醒来之后庆幸自己不用重新经历。</p>
<p>具体到码字上，明明还在写，却忍不住冒出想象中读者的评价，去打断作为作者的思路。害怕『半成品』展现在他人面前，害怕会因此自我降低标准，或者让大家觉得你水平不过如此；但另一方面，也不知道『成品』该是什么样子，如果成果一直漂浮不落地，就如同从来没有过成果，大家、以及未来的自己，也无从去判断，没有记录，也就没有了进步的基线（Baseline）。</p>
<p>公众号的规则（每天只能发一篇，发了之后不允许修改）强化了只有一次机会的恐惧。这也是为什么虽然还是很少， Github pages 还是有几十篇水文，而公众号发旧文勉强坚持到拿到原创认证就放弃了。</p>
<p><strong>码字不过是烦恼的一个缩影。</strong></p>
<p>从不开始确实躲开了失败——但机会有其时效，成功的可能也随之流逝。</p>
<p>我并非一开始就想明白这些，而是过去的十多年，经历了一些事情，发现自己有轻微的强迫症，而且很容易焦虑。<br>中间经历过各种与自己、与父母、与爱人的对话，有过冲突、不解、歇斯底里，从对抗、到尝试接纳、和解。其中滋味，不足为外人道，只道天凉好个秋。特别感谢一直陪伴我多年的女友——现在是妻子和孩子他妈，在最艰难的时候，都没有放弃过我。</p>
<h2 id="拾"><a href="#拾" class="headerlink" title="拾"></a>拾</h2><p>与其简单粗暴地当自己的暴君，下达永远不可能完成的 KPI，不如好好跟自己谈谈，对症下药。 </p>
<ul>
<li>尽量在固定时间抽空写一小段，先不要求多少，养成习惯。</li>
<li>用 Markdown 写原稿，用排版插件自动排版，不搞花里胡哨，不增加排版负担。</li>
<li>既然原稿是纯文本，版本控制必须有，写乱了甚至全删了都可以读档重来。</li>
<li>先发 Github pages 再转到公众号，给自己修订的机会。</li>
<li><strong>改名</strong>。</li>
</ul>
<p>既然害怕搞砸，与其跟自己对抗，不如在技术手段上让自己不会搞砸——起码不可能全部搞砸。S/L 大法任意折腾的资本，在于那个存档。感谢 git ，起码在电子文档上，给了我们 S/L 大法的利器。</p>
<p>技术上做到了，名字也很重要。<strong>名不正则言不顺，言不顺则事不成。</strong> 有句话说，命名是程序员最头疼的两件事之一（变量、函数、类 等等，都要命名）。我认为这不是一句玩笑——命名是概念模型的外在体现，命名不对，意味着还没想透彻。</p>
<p>我花了一些时间梳理想法，也和朋友讨论过。一开始想就叫 『S/L 大法』，但是在很多地方，斜杠都是一个麻烦。最后定了现在的名字 『存档 Save &amp; Load』。</p>
<ul>
<li><p>首先明确了博客的性质， <strong>这是我的一份存档</strong> ，是回头看时的路标。不再以内容区分。无论是技术上的记录，让我不用解决重复的问题；还是生活记录和感悟，让我日后记得。在存档的意义上，并无差别。</p>
</li>
<li><p>其次用博客名提醒自己， <strong>做事有存档，搞砸了不过回到上一个存档</strong> ，不是清零重来，不必焦虑。</p>
</li>
<li><p>第三层意思，是希望以此为契机，摸索出一套易于遵循的做事方法，让像我这样资质平庸而又焦虑的人，减轻注意力负担——包括但不限于码字和写代码——姑且称之为『S/L 法』。以目前我的理解，可能会以纯文本文档记录 + 版本控制 作为技术基础，日后可以尝试梳理这方面的内容。</p>
</li>
</ul>
<p>既然我在这个问题上纠结过思考过， <strong>以蚌之痛，育彼珍珠</strong> ，能结出一些成果当然最好。 不过第三点只是一个延伸，是更长远的事情，留个可能性，不强求。没什么野心，不要想太多，单纯的记录，反而更有可能做好。</p>
<p>希望以博客为起点，我能在做不同的事情上，掌握（各种意义上）存档的技巧，出错了读档重来。时间和注意力放在『新关卡』的尝试上，胜过耗在对清零的恐惧上。既然时间不多，能前进一点是一点。</p>
<hr>
<p>P.S. 此文发端于 2019 年 3 月 5 日博客改名前，结果后面因为 赶项目、娃早产、家里装修，一直拖到现在。如果你读完了，你会知道，我并不责备自己，而是感激自己还能继续写完——用正面情绪激励，而非用负面情绪惩罚。我并非思路清晰了，才开始落笔；恰恰是行文至此，思路才算逐渐清晰，后续不排除继续修改，或另起一文。</p>
<p>P.S. 2 再次感谢我的爱人一直以来的理解和陪伴。她其实是个容易不耐烦的暴脾气，正因如此，在那些艰难时刻超乎寻常人的耐心，显得更加难能可贵。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-禁止演绎” 4.0 (CC BY-NC-ND 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-禁止演绎” 4.0 (CC BY-NC-ND 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，原文引用（不可发布基于本作品的二次创作），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客和公众号改名了，改成了同一个。&lt;/p&gt;
&lt;p&gt;这事儿值得说一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="https://jaycechant.info/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>golang 1.13 - 依赖管理从 dep 到 mod 踩坑</title>
    <link href="https://jaycechant.info/2019/golang-1-13-from-dep-to-mod/"/>
    <id>https://jaycechant.info/2019/golang-1-13-from-dep-to-mod/</id>
    <published>2019-10-16T16:37:07.000Z</published>
    <updated>2020-01-07T16:47:44.091Z</updated>
    
    <content type="html"><![CDATA[<p>接触 golang 很晚，实际用来开发大概在 1.9 左右，所以我的主要印象是在 1.9 、 1.10 上的，依赖管理经过一些尝试之后，选择了 『官方』（后来实际被抛弃了）的 dep（<a href="https://jaycechant.info/2018/glide-from-start-up-to-give-up/">《golang 依赖管理：glide 从入门到放弃》</a>）。<br><!-- https://mp.weixin.qq.com/s/dWDfu_9sV5WSkF9h27E4uA --></p>
<p>后来 1.11、1.12 推出了 module （亦即 go mod 命令），考虑到尚不稳定又有切换成本，就继续留守在 vendor 目录上。</p>
<p>2019 年 9月终于 1.13 出来了，做了几个比较大的改动，同时 module 也终于转正，所以我终于下定决心迁移到 1.13，并改用 mod 做依赖管理。</p>
<a id="more"></a>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>迁移过程主要参考了<a href="https://mp.weixin.qq.com/s/AsdCDodxZFxs2SkhSwOvpg" target="_blank" rel="external">《干货满满的 Go Modules 和 goproxy.cn》</a>（实操主要是 <strong>#快速迁移项目至 Go Modules</strong> 部分），讲得非常清楚，也推荐大家参考，一些细节就不再赘述，只强调我踩坑的地方。</p>
<p>简单来说是这么个过程：</p>
<ul>
<li><p>卸载原有的 go，并下载安装 1.13 版本。  </p>
<p>  官网 golang.org 因为是谷歌的服务器，也在屏蔽之列，部分同学可能连访问这个都有困难，其实国内有官方的镜像站 golang.google.cn 。</p>
</li>
<li><p>用 <code>go env -w</code> 重新设置你的环境变量 。  </p>
<p>  注意 go env 的内容保存在 <code>$HOME/.config/go/env</code> ，不会覆盖原来的系统环境变量。在读取环境变量时， go env 的值优先。为了避免后续增加判断环境变量的负担，建议 go env 里有的、只有 go 会读取的环境变量，在系统环境变量里删除。  </p>
<p>  因为国情特殊，一定要设置 GOPROXY。</p>
</li>
<li><p>针对依赖工具和项目情况迁移（以下主要讲这部分的坑）。因为我之前用的是 dep，下面全部是关于从 dep 的迁移。</p>
</li>
</ul>
<p>特别提一下一个细节，在安装好的 1.13 下获取 <code>mod</code> 子命令的帮助，下面有一段提醒：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;go <span class="built_in">help</span> mod</div><div class="line">Go mod provides access to operations on modules.</div><div class="line"></div><div class="line">Note that support <span class="keyword">for</span> modules is built into all the go commands,</div><div class="line">not just <span class="string">'go mod'</span>. For example, day-to-day adding, removing, upgrading,</div><div class="line">and downgrading of dependencies should be <span class="keyword">done</span> using <span class="string">'go get'</span>.</div><div class="line">See <span class="string">'go help modules'</span> <span class="keyword">for</span> an overview of module functionality.</div></pre></td></tr></table></figure>
<p>大意渣翻：</p>
<blockquote>
<p>注意对 modules 的支持已经内建在所有 go 子命令内，而不仅仅是 ‘go mod’ 。</p>
<p>举例说，每天添加、移除、升级、降级依赖，都应该使用 ‘go get’ 完成。</p>
</blockquote>
<p>也就是说所有跟依赖管理相关的命令，譬如 <code>go get</code> ，都是用新逻辑在处理。</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="坑01：GOPROXY-特定情况不起效"><a href="#坑01：GOPROXY-特定情况不起效" class="headerlink" title="坑01：GOPROXY 特定情况不起效"></a>坑01：GOPROXY 特定情况不起效</h3><p>本来直接在项目根目录敲 <code>go mod init &lt;mod_path&gt;</code> ，是可以自动从 <code>Gopkg.toml</code> 和 <code>Gopkg.lock</code> 导入依赖信息，自动完成迁移的。但是在国内直接这样做是会出错的，部分包获取超时（留意 <code>golang.org/x/</code> 开头的包）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;go mod init myapp</div><div class="line">go: creating new go.mod: module myapp</div><div class="line">go: copying requirements from Gopkg.lock</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> github.com/360EntSecGroup-Skylar/excelize@v2.0.0: github.com/360EntSecGroup-Skylar/excelize@v2.0.0: invalid version: module contains a go.mod file, so major version must be compatible: should be v0 or v1, not v2</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> golang.org/x/text@v0.3.0: unrecognized import path <span class="string">"golang.org/x/text"</span> (https fetch: Get https://golang.org/x/text?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time,</div><div class="line">or established connection failed because connected host has failed to respond.)</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> gopkg.in/russross/blackfriday.v2@d3b5b032dc8e8927d31a5071b56e14c89f045135: gopkg.in/russross/blackfriday.v2@v2.0.1: invalid version: go.mod has non-....v2 module path <span class="string">"github.com/russross/blackfriday/v2"</span> at revision v2.0.1</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> golang.org/x/net@9b4f9f5ad5197c79fd623a3638e70d8b26cef344: unrecognized import path <span class="string">"golang.org/x/net"</span> (https fetch: Get https://golang.org/x/net?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.)</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> golang.org/x/image@61b8692d9a5c9886248d7f96e0ba50ad77baab4c: unrecog</div><div class="line">nized import path <span class="string">"golang.org/x/image"</span> (https fetch: Get https://golang.org/x/image?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.)</div></pre></td></tr></table></figure>
<p>这其实是一个 bug，init 导入依赖部分没有引用 GOPROXY。已经有人向官方提交了 issue，只是修复不知道要等到哪个版本合入。当前可以创建一个空白的 <code>go.mod</code> 然后执行 <code>go mod tidy</code> 来绕过。</p>
<p>go.mod 只需要包含 module path 和 go 版本即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module myapp</div><div class="line"></div><div class="line">go 1.13</div></pre></td></tr></table></figure>
<h3 id="坑02：import-和-module-path-不一致"><a href="#坑02：import-和-module-path-不一致" class="headerlink" title="坑02：import 和 module path 不一致"></a>坑02：import 和 module path 不一致</h3><p>增加了 go.mod 之后，执行 <code>go mod tidy</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;go mod tidy</div><div class="line">go: finding github.com/mojocn/base64Captcha latest</div><div class="line">......</div><div class="line">go: myapp/model/data imports</div><div class="line">        github.com/go-xorm/core: github.com/go-xorm/core@v0.6.3: parsing go.mod:</div><div class="line">        module declares its path as: xorm.io/core</div><div class="line">                but was required as: github.com/go-xorm/core</div></pre></td></tr></table></figure>
<p>这个好解决，把项目里对这个 module 的引用，都指向它声明的路径即可。</p>
<p>下面梳理一下出错的原因：</p>
<p><code>xorm.io/core</code> 这个 module，同时在 github.com 和 xorm.io 都有提供访问。</p>
<p>在使用 dep 的时候，从哪个路径 import，都是可行的。当我从 <code>github.com/go-xorm/core</code> import 时，dep 就从 github 下载，并保存到 <code>vendor/github.com/go-xorm/core</code> 下。到编译的时候，到 vendor 下对应的路径去找。也就是无论选哪个，<strong>下载、保存、import 的路径，三者是对应的就行</strong>。</p>
<p>但是 mod 会读取 module 的 go.mod，它自称是 <code>xorm.io/core</code> ，那么从 github import 就是非法的。也就是现在要 <strong>加上跟 module 自身 go.mod 声明的路径一致</strong>。（当然，现在保存不在 vendor 目录了，而是在 <code>$HOME/go/pkg/mod/</code> 底下，从原来每个项目存一份，变成每个 module 的每个版本，全局只存一份。）</p>
<p>退一步讲，如果将来 xorm.io 因为某些原因不再提供访问，而 github 那份还在，可以在 go.mod 通过 replace 关键字将下载地址指向 github，但其余的路径，依然要跟声明的路径保持一致（主要是 import 路径，下载保存是自动的，并不需要人工干预）。</p>
<h3 id="坑03：最新版本-module-不兼容"><a href="#坑03：最新版本-module-不兼容" class="headerlink" title="坑03：最新版本 module 不兼容"></a>坑03：最新版本 module 不兼容</h3><p>好了，依赖的分析和获取终于不报错了，<code>go.mod</code> 和 <code>go.sum</code> 也成功生成了。接下来让我们编译一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;make build</div><div class="line">go build -ldflags <span class="string">'-s -w'</span></div><div class="line">go: finding gopkg.in/yaml.v2 v2.2.2</div><div class="line">// 省略若干行...</div><div class="line"><span class="comment"># myapp/model/data</span></div><div class="line">model\data\csv.go:59:6: xng.QuoteStr undefined (<span class="built_in">type</span> *xorm.Engine has no field or method QuoteStr)</div><div class="line">model\data\csv.go:61:6: xng.QuoteStr undefined (<span class="built_in">type</span> *xorm.Engine has no field or method QuoteStr)</div><div class="line">make: *** [Makefile:28: build] Error 2</div></pre></td></tr></table></figure>
<p><code>Engine.QuoteStr()</code> 是一个返回当前数据库引擎使用的引号的方法，我当时特意使用这个方法，用来同时兼容不同的数据库，避免额外的判断。所以我确定这个方法是存在的。</p>
<p>这很容易想到是版本兼容性的问题。查看 <code>go.mod</code> 里的是 v0.7.9，再翻看 <code>Gopkg.toml</code> 之前用的是 v.0.7.1 。坑爹的是，新版本居然删掉了这个方法。</p>
<p>这里稍微提一下 <strong>版本号的问题</strong> 。go mod 强制使用 SemVer（如果不知道什么是 SemVer，看这篇 <a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0</a>），默认大版本没有改动的话，一定是兼容修改。所以会自动获取当前大版本下最新的版本，并不会参考 <code>Gopkg.toml</code> 的版本。不过话说回来， 即使按照 SemVer 的语义，也没办法埋怨 xorm 的团队，1.0 之前的版本默认为不稳定版本，没有义务保持兼容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;go mod edit -require=github.com/go-xorm/xorm@v0.7.1</div></pre></td></tr></table></figure>
<p>这样就可以指定依赖的版本。如果你觉得敲命令太麻烦，直接手动改 go.mod 也可以。一般不推荐直接改，因为你的修改会在下次更新时被覆盖，唯独版本信息是会保留的。</p>
<p>改完再 tidy 一次。</p>
<h3 id="坑04：module-path-不统一"><a href="#坑04：module-path-不统一" class="headerlink" title="坑04：module path 不统一"></a>坑04：module path 不统一</h3><p>再编译一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;make build</div><div class="line">go build -ldflags <span class="string">'-s -w'</span></div><div class="line">go: finding github.com/go-xorm/xorm v0.7.1</div><div class="line">// 省略若干行...</div><div class="line"><span class="comment"># myapp/model/data</span></div><div class="line">model\data\engine.go:117:17: cannot use level (<span class="built_in">type</span> <span class="string">"xorm.io/core"</span>.LogLevel) as <span class="built_in">type</span> <span class="string">"github.com/go-</span></div><div class="line">xorm/core".LogLevel <span class="keyword">in</span> argument to xng.SetLogLevel</div><div class="line">make: *** [Makefile:28: build] Error 2</div></pre></td></tr></table></figure>
<p>还是 xorm 的错误。还记得我们在 坑02 中的修改吗，在 go mod 底下，要统一按照声明路径去 import。</p>
<p>因为 坑03 ，xorm 改回了跟我代码兼容的 v0.7.1 ，那与之关联的 core 呢？跟上面类似地，看前后的配置，之前用的 v0.6.0 ，现在的是 v0.7.2 。<strong>关键的一点是</strong>，在 2019 年 6 月，在这两个版本之间的 v0.6.3，module path 从 <code>github.com/go-xorm/core</code> 改成了 <code>xorm.io/core</code> ， xorm 对它的引用在那个时间也做了相应的修改。</p>
<p>为了跟 v0.7.1 的 xorm 兼容，必须使用 &lt; v0.6.3 的 core —— 实际上直接使用 v0.6.0 是最保险的。因为回退到了修改 module path 之前的版本，所以 坑02 的修改白改了，回退掉。</p>
<p>当然记录 坑02 仍然有意义，它提醒我 <strong>有时声明的 module path 未必和仓库地址一致</strong> 。</p>
<p>跟上面类似，core 包改回对应的 v0.6.0 ，重新 tidy。</p>
<h3 id="坑05：主版本号变更"><a href="#坑05：主版本号变更" class="headerlink" title="坑05：主版本号变更"></a>坑05：主版本号变更</h3><p>再一次编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;make build</div><div class="line">go build -ldflags <span class="string">'-s -w'</span></div><div class="line"><span class="comment"># myapp/api</span></div><div class="line">api\survey.go:189:9: assignment mismatch: 2 variables but ex.GetCellValue returns 1 values</div><div class="line">// 省略若干相似的错误...</div><div class="line">api\survey.go:216:9: too many errors</div><div class="line">make: *** [Makefile:28: build] Error 2</div></pre></td></tr></table></figure>
<p>依然是版本的兼容问题。</p>
<p>不过这次的错误跟前面的比，是反过来的：我的代码引用的是最新的 v2 代码，这在原来 dep 下是不需要区分包名的。但在 mod 里，大于 1 的大版本是需要体现在路径里的。</p>
<p>在 module 眼里，<strong>主版本号不同，相当于两个不同的 module</strong>。 这是因为根据 SemVer 的约定，大版本号的改变，意味着引入了 breaking changes。那么如果很不巧地，代码 直接 / 间接 依赖同一个包的不同大版本时，mod 是可以同时导入的，就不会存在依赖上的冲突。</p>
<p>把 import 里 <code>github.com/360EntSecGroup-Skylar/excelize</code> 改为 <code>github.com/360EntSecGroup-Skylar/excelize/v2</code> ，重新 tidy，这次编译就不再报错了，编译的结果也是可以正常运行的。到此，我踩的坑已经全部记录完毕。</p>
<p>临了 Mark 一篇文章 <a href="https://www.cnblogs.com/apocelipes/p/10295096.html" target="_blank" rel="external">《再探go modules：使用与细节》</a>。这篇文章对于 go mod 的一些细节做了分析，虽然发表于 1.12 发布前，但是现在来看仍然有效。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触 golang 很晚，实际用来开发大概在 1.9 左右，所以我的主要印象是在 1.9 、 1.10 上的，依赖管理经过一些尝试之后，选择了 『官方』（后来实际被抛弃了）的 dep（&lt;a href=&quot;https://jaycechant.info/2018/glide-from-start-up-to-give-up/&quot;&gt;《golang 依赖管理：glide 从入门到放弃》&lt;/a&gt;）。&lt;br&gt;&lt;!-- https://mp.weixin.qq.com/s/dWDfu_9sV5WSkF9h27E4uA --&gt;&lt;/p&gt;
&lt;p&gt;后来 1.11、1.12 推出了 module （亦即 go mod 命令），考虑到尚不稳定又有切换成本，就继续留守在 vendor 目录上。&lt;/p&gt;
&lt;p&gt;2019 年 9月终于 1.13 出来了，做了几个比较大的改动，同时 module 也终于转正，所以我终于下定决心迁移到 1.13，并改用 mod 做依赖管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 预置 json 包的值覆盖测试</title>
    <link href="https://jaycechant.info/2019/golang-json-overlaying/"/>
    <id>https://jaycechant.info/2019/golang-json-overlaying/</id>
    <published>2019-05-19T16:45:38.000Z</published>
    <updated>2019-05-20T16:02:48.506Z</updated>
    
    <content type="html"><![CDATA[<p>json 作为一种可读性高、跨平台的序列化手段，常用在持久化和网络间传输。一般情况下，只需考虑是否按照作者的意图序列化和反序列化；反序列化的目标一般是一个 <strong>空白的对象</strong>，供写入得到的值。</p>
<p>但有一些特殊情况，还要考虑反序列化过程中，值的覆盖性：用到的字段非常多，给每个都赋值很麻烦，所以提供一套默认值（注意默认值不一定是 0 值），只要 json 中没有指定，就转而使用默认值。这在 jQuery 中只需要使用 <code>$.extend(default, opts1, opts2...)</code>；而如果想递归合并，则只需要把 <code>true</code> 作为第一个参数。</p>
<a id="more"></a>
<p>这一般出现在用 json 写配置文件，还有传递运行参数时，要求调用方即使默认值也要写上非常麻烦；而通过检测读到的是否 0 值再设置默认值则更麻烦，而且不合理（因为没法区分缺省值还是设置值，在 go 中除非全部使用指针）。所以，如果可以以初始化了默认值的对象作为反序列化的目标，将 json 中有指定的值覆盖上去，就是最好的选择。</p>
<p>json 在 go 中只是字符串，不像在 js 中有原生身份可以直接合并，所以在 Unmarshal 时能顺便进行覆盖是最好的了。前面我做了一些简单的测试，发现在 go 中这个思路可行，所以就这样实现了；但随着实现深入，特别是我为调用方编写文档时，我才意识到准确的覆盖对应的值，并不简单。（指定的值有覆盖，不指定的值保留默认，slice 和 map 的 value 可以准确覆盖到正确的 index / key）</p>
<p>话不多说，直接先跑，然后看输出结合源码分析：</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">    <span class="comment">//json "github.com/json-iterator/go"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Inner <span class="keyword">struct</span> &#123;</div><div class="line">    A <span class="keyword">int</span></div><div class="line">    B <span class="keyword">float64</span></div><div class="line">    C <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Mid <span class="keyword">struct</span> &#123;</div><div class="line">    I  Inner</div><div class="line">    Ip *Inner</div><div class="line">    D  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Outer <span class="keyword">struct</span> &#123;</div><div class="line">    Inner</div><div class="line">    M    Mid</div><div class="line">    Mp   *Mid</div><div class="line">    Mids <span class="keyword">map</span>[<span class="keyword">int</span>]*Mid</div><div class="line">    Ins []*Inner</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    o := &amp;Outer &#123;</div><div class="line">        Inner: Inner &#123;</div><div class="line">            A: <span class="number">111</span>, <span class="comment">// 按同名 field 覆盖，不影响其他 field</span></div><div class="line">            B: <span class="number">222.22</span>,</div><div class="line">            C: <span class="literal">true</span>,</div><div class="line">        &#125;,</div><div class="line">        M: Mid &#123;</div><div class="line">            I: Inner &#123;</div><div class="line">                A: <span class="number">111</span>, <span class="comment">// 嵌套的 struct 也是按 field 覆盖</span></div><div class="line">                C: <span class="literal">true</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        Mp: &amp;Mid &#123;</div><div class="line">            I: Inner &#123;</div><div class="line">                A: <span class="number">111</span>, <span class="comment">// 指针指向的 struct 内部 field 同理</span></div><div class="line">                C: <span class="literal">true</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        Mids: <span class="keyword">map</span>[<span class="keyword">int</span>]*Mid &#123;</div><div class="line">            <span class="number">0</span>: &amp;Mid&#123; <span class="comment">// map elem 被整体覆盖</span></div><div class="line">                I: Inner &#123;</div><div class="line">                    C: <span class="literal">true</span>, <span class="comment">// 被覆盖为默认值</span></div><div class="line">                &#125;,</div><div class="line">                Ip: &amp;Inner &#123;</div><div class="line">                    B: <span class="number">333</span>, <span class="comment">// 被覆盖为默认值</span></div><div class="line">                &#125;,</div><div class="line">                D: <span class="number">444</span>, <span class="comment">// 被覆盖为默认值</span></div><div class="line">            &#125;,</div><div class="line">            <span class="number">1</span>: &amp;Mid&#123; <span class="comment">// 但是不影响 map 的其他 elem，值被完整保留</span></div><div class="line">                I: Inner &#123;</div><div class="line">                    A: <span class="number">555</span>,</div><div class="line">                &#125;,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        Ins: []*Inner &#123;</div><div class="line">            &amp;Inner &#123; <span class="comment">// slice elem 内部被按 field 覆盖</span></div><div class="line">                A: <span class="number">666</span>,</div><div class="line">                B: <span class="number">77.7</span>,</div><div class="line">            &#125;,</div><div class="line">            &amp;Inner &#123; <span class="comment">// 同上</span></div><div class="line">                A: <span class="number">888</span>,</div><div class="line">                B: <span class="number">99.9</span>,</div><div class="line">            &#125;,</div><div class="line">            &amp;Inner &#123; <span class="comment">// 但其他 elem 反而丢失了</span></div><div class="line">                A: <span class="number">1010</span>,</div><div class="line">                B: <span class="number">11.11</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">    b, _ := json.Marshal(o)</div><div class="line">    fmt.Println(<span class="string">"baseline:"</span>, <span class="keyword">string</span>(b))</div><div class="line">    </div><div class="line">    bv := []<span class="keyword">byte</span>(<span class="string">`</span></div><div class="line">&#123;</div><div class="line">    "A": 123,</div><div class="line">    "M": &#123;</div><div class="line">        "I": &#123;</div><div class="line">            "B": 222</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    "Mp": &#123;</div><div class="line">        "I": &#123;</div><div class="line">            "B": 222</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    "Mids": &#123;</div><div class="line">        "0": &#123;</div><div class="line">            "I": &#123;</div><div class="line">                "A": 234</div><div class="line">            &#125;,</div><div class="line">            "Ip": &#123;</div><div class="line">                "A": 777</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    "Ins": [</div><div class="line">        &#123;</div><div class="line">            "A": 456</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            "B": 765</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">`)</div><div class="line">    json.Unmarshal(bv, o)</div><div class="line">    b, _ = json.Marshal(o)</div><div class="line">    fmt.Println(<span class="string">"overlay:"</span>, <span class="keyword">string</span>(b))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<p>（重点看在 json string 里没有指定的值是否会被覆盖，以及 slice 、map 里其他成员的情况。为了更方便地看，我把对比的结果用注释写在了测试代码里。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">baseline: &#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:333,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:444&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:666,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:99.9,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:1010,<span class="string">"B"</span>:11.11,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div><div class="line">overlay: &#123;<span class="string">"A"</span>:123,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:234,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:777,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:0&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:456,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:765,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<h3 id="结合源码分析"><a href="#结合源码分析" class="headerlink" title="结合源码分析"></a>结合源码分析</h3><p>下面结合 <code>encoding/json/decode.go</code> 的源码，大概梳理一下结论：</p>
<h4 id="1-struct-内的基本类型-field"><a href="#1-struct-内的基本类型-field" class="headerlink" title="1. struct 内的基本类型 field"></a>1. struct 内的基本类型 field</h4><p>（struct 对应 json 中的 object，以 {} 包裹；基本类型对应 json 中的 字面量 literal，内容是一个数字或者字符串）</p>
<p>值按同名覆盖，没有指定的的 field 保留原值；这条即使是 嵌套的 struct 内部的 field 也成立，包括匿名嵌套，还有指针指向的 struct 的 field。</p>
<h4 id="2-slice-类型"><a href="#2-slice-类型" class="headerlink" title="2. slice 类型"></a>2. slice 类型</h4><p>（对应 json 中的 array，以 [] 包裹）</p>
<p>slice elem 按 index 一一对应， struct 内部 field 同规则 1；但是 slice 会调整长度跟 json 保持一致： json 多出的会添加，反之原 slice 多出的会因为长度调整被丢弃。从源码看，如果是 array，因为长度无法调整，json 数量比较少的话不会丢弃原 array 的内容；反之 json 多出的内容会被丢弃。不过很少使用 array，没有实际测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// array consumes an array from d.data[d.off-1:], decoding into the value v.</span></div><div class="line"><span class="comment">// the first byte of the array ('[') has been read already.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decodeState)</span> <span class="title">array</span><span class="params">(v reflect.Value)</span></span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">		<span class="comment">// Get element of array, growing if necessary.</span></div><div class="line">		<span class="keyword">if</span> v.Kind() == reflect.Slice &#123;</div><div class="line">			<span class="comment">// Grow slice if necessary</span></div><div class="line">			<span class="keyword">if</span> i &gt;= v.Cap() &#123;</div><div class="line">				newcap := v.Cap() + v.Cap()/<span class="number">2</span></div><div class="line">				<span class="keyword">if</span> newcap &lt; <span class="number">4</span> &#123;</div><div class="line">					newcap = <span class="number">4</span></div><div class="line">				&#125;</div><div class="line">				newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)</div><div class="line">				reflect.Copy(newv, v)</div><div class="line">				v.Set(newv)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> i &gt;= v.Len() &#123;</div><div class="line">				v.SetLen(i + <span class="number">1</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> i &lt; v.Len() &#123;</div><div class="line">			<span class="comment">// Decode into element.</span></div><div class="line">			d.value(v.Index(i))</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// Ran out of fixed array: skip.</span></div><div class="line">			d.value(reflect.Value&#123;&#125;)</div><div class="line">		&#125;</div><div class="line">		i++</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h4 id="3-map-类型"><a href="#3-map-类型" class="headerlink" title="3. map 类型"></a>3. map 类型</h4><p>（对应 json 中的 object，以 {} 包裹）</p>
<p>json 中指定的 key 会整个 elem 被覆盖；没有指定的 key 则完整保留。</p>
<p>其中最主要的差别是 struct filed 和 map elem 之间：虽然在 json 中同样以 object 表示，但 struct 设置时，获得的是 field 的 pointer，如果 field 本身也是一个 struct，那么就会递归处理，一直到最里层的基本类型才被覆盖；而 map elem 是直接覆盖， <strong>如果这个 map elem 本身是一个 struct，那么它原有的数据就会丢失</strong> 。</p>
<p>由于 map 和 struct 都对应 object，所以它们的代码是在一起的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// object consumes an object from d.data[d.off-1:], decoding into the value v.</span></div><div class="line"><span class="comment">// the first byte ('&#123;') of the object has been read already.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decodeState)</span> <span class="title">object</span><span class="params">(v reflect.Value)</span></span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">var</span> mapElem reflect.Value</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// Figure out field corresponding to key.</span></div><div class="line">		<span class="keyword">var</span> subv reflect.Value</div><div class="line">		destring := <span class="literal">false</span> <span class="comment">// whether the value is wrapped in a string to be decoded first</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> v.Kind() == reflect.Map &#123;</div><div class="line">			elemType := v.Type().Elem()</div><div class="line">			<span class="keyword">if</span> !mapElem.IsValid() &#123;</div><div class="line">				mapElem = reflect.New(elemType).Elem()</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				mapElem.Set(reflect.Zero(elemType))</div><div class="line">			&#125;</div><div class="line">            <span class="comment">// 如果是 map，subv 指向一个新初始化的 elem</span></div><div class="line">			subv = mapElem</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            subv = v</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// 如果是 struct，则得到对应 field 的指针</span></div><div class="line">            subv = subv.Field(i)</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// 解析下一层并把内容放到 subv，如果是 map，subv 指向一个空白的对象</span></div><div class="line">        &#123;</div><div class="line">            d.value(subv)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Write value back to map;</span></div><div class="line">		<span class="comment">// if using struct, subv points into struct already.</span></div><div class="line">		<span class="keyword">if</span> v.Kind() == reflect.Map &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// 把 subv 设置到对应的 key，该 key 对应的原有的数据全部丢失</span></div><div class="line">            <span class="comment">// struct 没有这步，因为 subv 直接就是指向 field 的指针</span></div><div class="line">            v.SetMapIndex(kv, subv)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>为什么 slice 可以直接 <code>d.value(v.Index(i))</code> 把对应的 elem 递归交给下一层去合并， 而 map 却不能直接 <code>d.value(v.MapIndex(key))</code> ，而是在这一层直接把 elem 给覆盖掉了？ 是因为什么原因做不到，还是出于什么考虑不这样实现？时间关系，我还没找到答案，这里先留一个问号。</p>
<h3 id="初步结论"><a href="#初步结论" class="headerlink" title="初步结论"></a>初步结论</h3><p>为了达到『指定值覆盖，缺省值保留』的效果：</p>
<ul>
<li>如果需要嵌套 struct，内层 struct 最好作为一个 field 存在，指针还是对象都可以；</li>
<li>如果是一组确定数量的 struct，最好以 array 的方式定义，并且确保 index 正确；缺省的 struct 传参时可以用空 objecct <code>{}</code> 占位以确保顺序对应；</li>
<li>如果是一组数量不确定的 struct，则要权衡 slice 和 map 的利弊：<ul>
<li>slice 内的 struct 可以正常合并，但是 slice 比 json 多出的 elem 会被丢弃；如果 json 的数量比默认数量少，则不仅中间的缺省 struct 要用 <code>{}</code> 占位，后续缺省的 struct 也得占位——这需要默认值的数量是确定的；</li>
<li>map 刚好反过来，没有指定的 key 也不会被删除，但是指定了的 key 对应的 value 是直接覆盖，不能合并。</li>
</ul>
</li>
</ul>
<h3 id="流行的第三方库：jsoniter"><a href="#流行的第三方库：jsoniter" class="headerlink" title="流行的第三方库：jsoniter"></a>流行的第三方库：jsoniter</h3><p>再看当下比较流行的第三方库 jsoniter 。同样的代码，只是单纯的把 <code>&quot;encoding/json&quot;</code> 换成 <code>json &quot;github.com/json-iterator/go&quot;</code> ，再看结果，是完全一样的，说明在覆盖性的兼容上，jsoniter 是兼容官方库的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">baseline: &#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:333,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:444&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:666,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:99.9,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:1010,<span class="string">"B"</span>:11.11,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div><div class="line">overlay: &#123;<span class="string">"A"</span>:123,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:234,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:777,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:0&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:456,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:765,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;json 作为一种可读性高、跨平台的序列化手段，常用在持久化和网络间传输。一般情况下，只需考虑是否按照作者的意图序列化和反序列化；反序列化的目标一般是一个 &lt;strong&gt;空白的对象&lt;/strong&gt;，供写入得到的值。&lt;/p&gt;
&lt;p&gt;但有一些特殊情况，还要考虑反序列化过程中，值的覆盖性：用到的字段非常多，给每个都赋值很麻烦，所以提供一套默认值（注意默认值不一定是 0 值），只要 json 中没有指定，就转而使用默认值。这在 jQuery 中只需要使用 &lt;code&gt;$.extend(default, opts1, opts2...)&lt;/code&gt;；而如果想递归合并，则只需要把 &lt;code&gt;true&lt;/code&gt; 作为第一个参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="json" scheme="https://jaycechant.info/tags/json/"/>
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang-string 和 bytes 之间的 unsafe 转换</title>
    <link href="https://jaycechant.info/2019/golang-unsafe-cast-between-string-and-bytes/"/>
    <id>https://jaycechant.info/2019/golang-unsafe-cast-between-string-and-bytes/</id>
    <published>2019-04-30T09:52:12.000Z</published>
    <updated>2019-05-01T08:28:00.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近写一个 golang 的工具包时，涉及到反复在 string 和 []byte 之间来回转换。这给了我一个机会了解转换时底层发生的事情。</p>
<h3 id="结论先行"><a href="#结论先行" class="headerlink" title="结论先行"></a>结论先行</h3><ul>
<li>string 和 []byte 互转都涉及底层数据复制；可以通过 unsafe 强制转换绕过复制提高性能。</li>
<li>string 类型的底层数组可能放在常量区（字面量初始化）也可能动态分配；无论哪一种，当以 string 类型出现时底层数据都是不可修改的（避免影响其他引用），string 的修改实际上是指向重新生成的底层数组。</li>
<li>当以 []byte 类型出现时，可以修改具体某一个 byte 的值；不过如果是从指向常量区的 string 通过 unsafe 转换而来，尝试修改时会产生不可恢复的 runtime error。</li>
<li>这也是为什么这个包叫 unsafe：绕过类型检查强行转换，绕过了底层数据复制，提高性能同时也失去了检查和复制的保护，需要调用方自行确认不会出错。</li>
<li><code>+</code> 连接会复制内存，<code>strings.Split()</code> 直接在原串做切片…具体不同实现要以源码为准。</li>
<li>即使 string 是动态分配的内容，也不建议修改对应的 []byte，可能会引起引用同一块内容的其他 string 的异常—— 除非你能确保没有别的地方引用它。</li>
<li>实际调用中碰到了 对 A 串做 unsafe 转换，结果完全无关的 B 串出现切片时数组越界；A 串改为普通转换就好了。暂时没能找到原因，保险起见放弃使用 unsafe，改为用 <code>json.RawMessage</code> 多封装一层。本次研究权当学习了。</li>
</ul>
<a id="more"></a>
<h3 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h3><p>具体来说，是一个缓存相关的封装包：把对象 <code>json.Marshal()</code> 之后得到的 []byte 放到缓存；或者反过来，取出 []byte 交给 <code>json.Unmarshal()</code> 。无论正反方向的调用，输入输出都是 []byte，本没有 string 的事。</p>
<p>偏偏这中间为了实现某些功能，需要往 marshal 之后的 json 字符串上追加（存的时候）或提取（读的时候）某些信息。追加还好办，可以把追加的内容一起变成 []byte 之后 <code>append()</code> ；但提取需要基于字符串的语义，不得不先转成 string，解析完再转回来。</p>
<p>我对这中间的开销产生了兴趣。</p>
<h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><p>写 demo 对比地址之后，可以确定每次转换，string 和 []byte 的地址都有变化。</p>
<p>但是这只能确定 string 和 slice ([]byte 的 slice) 的结构体发生了复制，结构体指向的底层 byte array 是否有发生复制无从得知。</p>
<p>通过查阅网上的讨论以及源码，进一步确认，底层的 array 也发生的复制。既然发生了深复制，那么一定是有额外开销的，只是多和少的差别。</p>
<p>通过 <code>unsafe</code> 包，可以强制直接转换来绕过复制的开销。实际上 <code>strings.Builder</code> 就是这样做的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> myunsafe</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToString</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToBytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;s))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>那究竟两种转换方式差别有多大呢？</p>
<p>跑一个 Benchmark：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> myunsafe_test</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	. <span class="string">"myunsafe"</span></div><div class="line">	<span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	strs = []<span class="keyword">string</span>&#123;</div><div class="line">		<span class="string">"a"</span>,</div><div class="line">		<span class="string">"abc"</span>,</div><div class="line">		<span class="string">"some words"</span>,</div><div class="line">		<span class="string">"loooooooooooooonger"</span>,</div><div class="line">		<span class="string">"Characters with 1234567890 +-*/ and !@#$%^&amp;()="</span>,</div><div class="line">		<span class="string">`a multi-line long text, here is line one.</span></div><div class="line">line two.</div><div class="line">line three.</div><div class="line">some other texts:</div><div class="line">1234567890-=!@#$%^&amp;*()_+</div><div class="line">abcdefghijklmnopqrstuvwxyz</div><div class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ    `,</div><div class="line">	&#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCast</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	n := <span class="built_in">len</span>(strs)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</div><div class="line">			b := []<span class="keyword">byte</span>(strs[j])</div><div class="line">			_ = <span class="keyword">string</span>(b)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnsafeCast</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	n := <span class="built_in">len</span>(strs)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</div><div class="line">			b := StringToBytes(strs[j])</div><div class="line">			_ = BytesToString(b)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果对比如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">go <span class="built_in">test</span> -test.bench=.* -benchmem -run=none </div><div class="line">goos: windows</div><div class="line">goarch: amd64</div><div class="line">pkg: myunsafe</div><div class="line">BenchmarkCast-8         	 5000000	       281 ns/op	     448 B/op	       4 allocs/op</div><div class="line">BenchmarkUnsafeCast-8   	200000000	         8.81 ns/op	       0 B/op	       0 allocs/op</div><div class="line">PASS</div><div class="line">ok  	myunsafe	4.996s</div></pre></td></tr></table></figure>
<p>我用不同数据测过几次，上面只是其中一次。用较短的字符串测试时，大概是 20 倍的差距；当字符串越来越长，差距越来越明显。所以当反复转换较长的字符创时，可以考虑用 unsafe。</p>
<h3 id="字面量常量"><a href="#字面量常量" class="headerlink" title="字面量常量"></a>字面量常量</h3><p>网友提到这个转换只能对动态生成的字符串用，但是我上面的测试用了字面量常量，却没有报错呢？</p>
<p>有什么办法可以让它报错呢？我想差别是在于读和写。上面虽然对字面量常量做了 unsafe 转换，但是转换之后得到的结果并没有尝试写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	. <span class="string">"myunsafe"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	s := <span class="string">"a"</span></div><div class="line">	b := StringToBytes(s)</div><div class="line">	fmt.Println(b, <span class="keyword">string</span>(b))</div><div class="line">	b[<span class="number">0</span>] = <span class="number">0x42</span> <span class="comment">// ascii for B</span></div><div class="line">	fmt.Println(b, <span class="keyword">string</span>(b))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然报错了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[97] a</div><div class="line">unexpected fault address 0x4bb9ac</div><div class="line">fatal error: fault</div><div class="line">[signal 0xc0000005 code=0x1 addr=0x4bb9ac pc=0x48b615]</div></pre></td></tr></table></figure>
<p>改为动态生成的字符串看看。怎么生成？可以用 <code>strings.Builder</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	. <span class="string">"myunsafe"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	sb := strings.Builder&#123;&#125;</div><div class="line">    sb.WriteString(<span class="string">"a"</span>)</div><div class="line">	s := sb.String()</div><div class="line">	b := StringToBytes(s)</div><div class="line">	fmt.Println(b, <span class="keyword">string</span>(b))</div><div class="line">	b[<span class="number">0</span>] = <span class="number">0x42</span> <span class="comment">// ascii for B</span></div><div class="line">	fmt.Println(b, <span class="keyword">string</span>(b))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这回就不报错了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[97] a</div><div class="line">[66] B</div></pre></td></tr></table></figure>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><h4 id="concat-运算符"><a href="#concat-运算符" class="headerlink" title="concat 运算符 +"></a>concat 运算符 +</h4><p>如果一个字符串是通过连接符 <code>+</code> 得到的呢？</p>
<p>它的实现在 <code>src/runtime/string.go</code> 里，可以看到做了内存复制。所以无论连接前的字符串是动态分配的还是字符串常量，连接之后得到的结果都是动态分配的。</p>
<h4 id="strings-Split"><a href="#strings-Split" class="headerlink" title="strings.Split()"></a>strings.Split()</h4><p>类似的，如果字符串是分解得到的子串呢？</p>
<p>同样可以看源码，Split 实际上并没有生成字符串，而是在原串的基础上做了切片。所以修改是否会报错，视乎原串是常量还是动态分配的内存。</p>
<p>其他情况就不一一尝试了。总的来说，各种情况都有，需要看源码核实。不过确认是动态分配的串也只是避免 runtime error 造成程序中断而已；但即使不报错，也应该避免修改 unsafe 转换得到的 []byte，这会导致其他指向同一地址的 string 有意外的结果—— <strong>除非你确定这是对底层 array 唯一的引用</strong> 。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="https://sheepbao.github.io/post/golang_byte_slice_and_string/" target="_blank" rel="external">golang string和[]byte的对比</a></p>
</li>
<li><p><a href="https://ninokop.github.io/2017/10/25/Go-Slice%E4%B8%8EString%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9E%E7%8E%B0" target="_blank" rel="external">Go Slice与String内存布局和实现</a></p>
</li>
<li><p><a href="https://liudanking.com/performance/golang-strings-builder-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Golang strings.Builder 原理解析</a></p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写一个 golang 的工具包时，涉及到反复在 string 和 []byte 之间来回转换。这给了我一个机会了解转换时底层发生的事情。&lt;/p&gt;
&lt;h3 id=&quot;结论先行&quot;&gt;&lt;a href=&quot;#结论先行&quot; class=&quot;headerlink&quot; title=&quot;结论先行&quot;&gt;&lt;/a&gt;结论先行&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;string 和 []byte 互转都涉及底层数据复制；可以通过 unsafe 强制转换绕过复制提高性能。&lt;/li&gt;
&lt;li&gt;string 类型的底层数组可能放在常量区（字面量初始化）也可能动态分配；无论哪一种，当以 string 类型出现时底层数据都是不可修改的（避免影响其他引用），string 的修改实际上是指向重新生成的底层数组。&lt;/li&gt;
&lt;li&gt;当以 []byte 类型出现时，可以修改具体某一个 byte 的值；不过如果是从指向常量区的 string 通过 unsafe 转换而来，尝试修改时会产生不可恢复的 runtime error。&lt;/li&gt;
&lt;li&gt;这也是为什么这个包叫 unsafe：绕过类型检查强行转换，绕过了底层数据复制，提高性能同时也失去了检查和复制的保护，需要调用方自行确认不会出错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 连接会复制内存，&lt;code&gt;strings.Split()&lt;/code&gt; 直接在原串做切片…具体不同实现要以源码为准。&lt;/li&gt;
&lt;li&gt;即使 string 是动态分配的内容，也不建议修改对应的 []byte，可能会引起引用同一块内容的其他 string 的异常—— 除非你能确保没有别的地方引用它。&lt;/li&gt;
&lt;li&gt;实际调用中碰到了 对 A 串做 unsafe 转换，结果完全无关的 B 串出现切片时数组越界；A 串改为普通转换就好了。暂时没能找到原因，保险起见放弃使用 unsafe，改为用 &lt;code&gt;json.RawMessage&lt;/code&gt; 多封装一层。本次研究权当学习了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>为什么不要用 pip 安装 conda</title>
    <link href="https://jaycechant.info/2019/why-not-install-conda-with-pip/"/>
    <id>https://jaycechant.info/2019/why-not-install-conda-with-pip/</id>
    <published>2019-01-15T14:37:08.000Z</published>
    <updated>2019-01-23T06:47:37.346Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有人都直接安装 Anaconda。但它不过是 conda 包管理器 + 预置一系列常用 sci&amp;math 包。</p>
<p>如果我有环境洁癖，只允许存在一个 Python 环境，我可以 <code>pip install conda</code> ，再逐个 <code>conda install xyz</code> 安装那些 conda 下的包吗？</p>
<a id="more"></a>
<hr>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>接触 Python 有好些年了，用得不算多，主要做辅助的脚本工具，更像瑞士军刀，不是主力武器。而我的工作偏开发，所以 Anaconda 有所耳闻，并未直接使用。直到有数据分析的需求。</p>
<p>快速浏览相关的介绍和对比，大概得出这么一些信息：</p>
<ul>
<li>conda 是个包管理器</li>
<li>Python + conda = Miniconda</li>
<li>Minconda + 一系列预置的 sci&amp;math 的包 = Anaconda</li>
</ul>
<p>大概讨论这个的都是偏 Science 和 Data Analysis 的社区，大家都觉得直接安装 Anaconda 是标准操作，哪怕你已经安装了 Python。至于为什么不能在 Python 上安装 conda，几乎没有提及。</p>
<p>所以我想试一下。虽然我明知道直接安装会省事很多，但我要知道为什么。</p>
<h2 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h2><p>直接上手试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">pip install conda <span class="comment"># 前面试过一次，所以有 cache</span></div><div class="line">Collecting conda</div><div class="line">  Using cached https://files.pythonhosted.org/packages/74/4e/c533c3136427be62c38cc0e038cabf167bb54489c2ced2f6df903c456861/conda-4.3.16.tar.gz</div><div class="line">Collecting pycosat&gt;=0.6.1 (from conda)</div><div class="line">  Using cached https://files.pythonhosted.org/packages/c0/fd/e38d68774c0a345b0090d608a90f1fbf423970d812f7ec7aef9ac024e648/pycosat-0.6.3.zip</div><div class="line">Collecting requests&gt;=2.12.4 (from conda)</div><div class="line">  Using cached https://files.pythonhosted.org/packages/7d/e3/20f3d364d6c8e5d2353c72a67778eb189176f08e873c9900e10c0287b84b/requests-2.21.0-py2.py3-none-any.whl</div><div class="line">Collecting ruamel.yaml&gt;=0.11.14 (from conda)</div><div class="line">  Using cached https://files.pythonhosted.org/packages/d3/6b/7d085479a131c16fd910f22172ca7cecf5e5c8ec0b508abf543a54a3b4b0/ruamel.yaml-0.15.85-cp36-cp36m-win_amd64.whl</div><div class="line">Collecting menuinst (from conda)</div><div class="line">  Could not find a version that satisfies the requirement menuinst (from conda) (from versions: )No matching distribution found <span class="keyword">for</span> menuinst (from conda)</div></pre></td></tr></table></figure>
<p>找不到 conda 依赖的 menuinst。</p>
<p>Google 之，得到 <a href="https://stackoverflow.com/questions/43397018/could-not-find-a-version-that-satisfies-conda-for-python-3" target="_blank" rel="external">https://stackoverflow.com/questions/43397018/could-not-find-a-version-that-satisfies-conda-for-python-3</a> 的方案：安装 4.2.7 版本的 conda ，再用 conda 升级它自己：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pip install auxlib</div><div class="line"><span class="comment"># 省略输出</span></div><div class="line">pip install conda==4.2.7</div><div class="line"><span class="comment"># 这次提醒缺少 VSC++ 套件......</span></div></pre></td></tr></table></figure>
<p>咦，有点不对劲。我明明是想用 conda 管理二进制依赖，好不用自己安装各种非 Python 的编译环境来着。</p>
<p>没事，我在答案里还发现了 conda 的安装包：<a href="https://www.continuum.io/downloads#windows" target="_blank" rel="external">https://www.continuum.io/downloads#windows</a></p>
<p>结果点进去……Error522。嗯，也许最新版的下载地址变了，我直接在 <a href="https://continuum.io" target="_blank" rel="external">https://continuum.io</a> 找。</p>
<p>一点，地址变成 <a href="https://www.anaconda.com/" target="_blank" rel="external">https://www.anaconda.com/</a> 了。</p>
<h2 id="OK-Anaconda"><a href="#OK-Anaconda" class="headerlink" title="OK, Anaconda"></a>OK, Anaconda</h2><p>根据网上资料，这 continuum 就是开发 conda 的公司。可能由于 Anaconda 成为了最知名的产品，公司直接改名 Anaconda Inc. 了……</p>
<p>我找了半天，没有直接提供 conda 的安装包。最多安装 Miniconda，但是还是不可避免多出一个 Python 环境。</p>
<p>既然我并非真的闲得想手动安装一个一个常用依赖，只是想知道 Why，我最终安装了 Anaconda，并且多了一个 Anaconda 专用的 Python 3.7 （未加入 PATH）。以后一般 Python 的应用开发，使用 原来的 Python 3.6，Anaconda 相关的在 Anaconda Prompt 下操作。以上。</p>
<h2 id="some-tips"><a href="#some-tips" class="headerlink" title="some tips"></a>some tips</h2><p>pip 与 conda 并非竞争对手——他们的工作有部分重叠，但更多面向不同的需求：</p>
<ul>
<li>pip 面向纯 Python 环境，从源码安装，是 Python 官方包管理器</li>
<li>conda 来自 Python 不止于 Python，是为 PyData 社区解决各种非 Python 的二进制依赖</li>
</ul>
<p>本质上，这是一个二难质问：如果你愿意折腾用 pip 安装 conda ，你就没有必要安装 conda；既然你需要 conda 为你解决二进制依赖，你就不能用 pip 安装——因为 conda 本身也有一系列二进制依赖。</p>
<p>后续操作：（如果有必要，我考虑另起一篇展开说）</p>
<ul>
<li>安装 Anaconda （官方已经不提供二进制的 conda 安装包），既然这样，不再折腾</li>
<li>当前版本（2018.12）已带 Jupyter</li>
<li>添加清华 channels</li>
<li>conda 安装 nbextensions</li>
<li>修改 notebook 默认位置<ul>
<li>快捷方式改参数</li>
<li>配置文件改 <code>jupyter notebook --generate-config</code></li>
</ul>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有人都直接安装 Anaconda。但它不过是 conda 包管理器 + 预置一系列常用 sci&amp;amp;math 包。&lt;/p&gt;
&lt;p&gt;如果我有环境洁癖，只允许存在一个 Python 环境，我可以 &lt;code&gt;pip install conda&lt;/code&gt; ，再逐个 &lt;code&gt;conda install xyz&lt;/code&gt; 安装那些 conda 下的包吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="pip" scheme="https://jaycechant.info/tags/pip/"/>
    
      <category term="Anaconda" scheme="https://jaycechant.info/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>配置 Golang 开发环境</title>
    <link href="https://jaycechant.info/2018/setup-golang-env/"/>
    <id>https://jaycechant.info/2018/setup-golang-env/</id>
    <published>2018-11-06T16:53:09.000Z</published>
    <updated>2020-01-12T13:06:31.432Z</updated>
    
    <content type="html"><![CDATA[<p>为想尝试 Go 的朋友开个头，介绍环境的配置。语言的优缺点不在此展开。</p>
<p>因身边多数使用 Win64 环境，以下无特殊说明均以 Win64 为例，日后有需要再补充其他平台部分。</p>
<a id="more"></a>
<h2 id="1-Go"><a href="#1-Go" class="headerlink" title="1. Go"></a>1. Go</h2><ul>
<li>下载：<a href="https://golang.org/dl/" target="_blank" rel="external">https://golang.org/dl/</a> （out of wall）</li>
<li>版本：1.9+，一般下载最新版本即可</li>
</ul>
<h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>访问官网下载页面，获取对应版本。不过如果你不懂得翻-墙，会发现访问不了官网，因为它在 Google 的服务器上。这点请自行解决。不过经过 PuTTY 和 iOS SDK 第三方下载被植入木马的事件，劝各位还是努力到官网下载。</p>
<p>Win64 的安装文件一般为 <code>go1.xx.y.windows-amd64.msi</code> ，下载好后安装，路径默认或自定义，没有强制要求，不要出现中文和空格，尽量短一些即可。个人路径供参考： <code>D:\Dev\Go</code> 。</p>
<h3 id="1-2-环境变量"><a href="#1-2-环境变量" class="headerlink" title="1.2 环境变量"></a>1.2 环境变量</h3><p>安装后设置环境变量，指定 官方工具包（及内置库） 和 工作目录。</p>
<p>以下设置均在：<code>我的电脑（Win10 此电脑） &gt; 右键菜单 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量</code> ， 如果变量存在就确认内容，不存在就新建。</p>
<h4 id="1-2-1-GOROOT"><a href="#1-2-1-GOROOT" class="headerlink" title="1.2.1 GOROOT"></a>1.2.1 GOROOT</h4><p>指定 Go 的安装目录，并以此确定工具包和内置库的位置。确保 <code>GOROOT</code> 指向 Go 的安装目录 （例： <code>D:\Dev\Go</code>）。</p>
<h4 id="1-2-2-GOPATH"><a href="#1-2-2-GOPATH" class="headerlink" title="1.2.2 GOPATH"></a>1.2.2 GOPATH</h4><p>指定 Go 的 workspace（工作目录）。<code>GOPATH</code> 允许指定多个 workspace，中间以 <code>;</code> 隔开（跟 <code>PATH</code> 类似，其他平台下的分隔符是 <code>:</code>）。可以在任意一个 workspace 下开发，但是 <code>go get</code> 和 <code>go install</code> 的包只会放在第一个目录。当引用包的时候，会先查找 <code>%GOROOT%\pkg</code> 的语言内置包，再顺序查找每个 workspace 的 <code>src</code> 目录，找到就结束。</p>
<p>一般情况下，推荐设置两个 workspace ： 第一个存放下载的第三方依赖包，第二个存放本地开发的代码，分开避免混淆。例：<code>C:\Users\Jayce\go;E:\workspace\go</code> 。</p>
<h4 id="1-2-3-PATH"><a href="#1-2-3-PATH" class="headerlink" title="1.2.3 PATH"></a>1.2.3 PATH</h4><p><code>PATH</code> 是系统自带的执行路径，所以我们不能覆盖它，只能在后面追加。需要将<strong>GOROOT 的 bin 目录</strong> 和 <strong>第一个 workspace 的 bin 目录加入 PATH</strong> ，以调用 官方工具包 和 安装的第三方工具。其中如果你检查 GOROOT 的时候发现 GOROOT 已经配置好了，有可能 <code>%GOROOT%\bin</code> 也已经添加了，你可以复制到记事本里检查一下。</p>
<p>假定两个都没有添加，那么以上述 <code>GOPATH</code> 的配置为例，则是 <code>原来的PATH内容;%GOROOT%\bin;C:\Users\Jayce\go\bin</code></p>
<p><strong>注：Win10 对 PATH 的管理进行了优化，不再是一长串用 <code>;</code> 分隔的路径，而是一个路径的列表，追加时只需新建子项即可。</strong></p>
<h3 id="1-3-验证"><a href="#1-3-验证" class="headerlink" title="1.3 验证"></a>1.3 验证</h3><p>打开 cmd，然后按如下操作</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看安装版本</span></div><div class="line">go version</div><div class="line"><span class="comment"># 正常应该显示你安装的版本</span></div><div class="line"><span class="comment"># 找不到指令请检查安装  GOROOT 的安装目录是否正确 / PATH 里是否包含了 %GOROOT%\bin</span></div><div class="line">go version go1.<span class="number">10.1</span> windows/amd64</div></pre></td></tr></table></figure>
<h2 id="2-gcc-和-make"><a href="#2-gcc-和-make" class="headerlink" title="2. gcc 和 make"></a>2. gcc 和 make</h2><p>有时部分依赖包以 C 开发，需要用到 gcc 编译；另外，为简化编译流程，项目规模增大后会逐渐交由 make 管理编译。两个工具在 Linux 下一般自带，或通过系统的包管理很轻易地安装，Windows 下则要安装 MinGW-w64 。注意必须是 <strong>MinGW-w64</strong> 。MinGW 不兼容 64 位系统，同时长期不更新；而 w64 可以同时兼容 32 和 64 位。</p>
<ul>
<li>下载：<a href="https://sourceforge.net/projects/mingw-w64/" target="_blank" rel="external">https://sourceforge.net/projects/mingw-w64/</a></li>
</ul>
<h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>下载得到的是安装器，在选择版本后，会自动下载对应版本并安装。建议不要改动任何选项，只需要确保 Architecture 对应你的计算机即可（Win64 选 x86_64）。</p>
<p>安装路径依然没有强制要求，无中文和空格，尽量短即可。参考：<code>D:\Dev\mingw-w64</code> 。</p>
<h3 id="2-2-创建-make-的软链接"><a href="#2-2-创建-make-的软链接" class="headerlink" title="2.2 创建 make 的软链接"></a>2.2 创建 make 的软链接</h3><p>安装完后进入 安装目录的 bin 目录，可以看到大量的工具，其中有 <code>gcc.exe</code>  和 <code>mingw32-make.exe</code> ，没有 <code>make.exe</code> 。其实 <code>mingw32-make.exe</code> 就是，但是用这个名字调用太长，也不利于其他工具用默认的名字调用，所以我们要创建一个名字叫 <code>make.exe</code> 的软链。</p>
<p>首先用管理员权限打开 cmd （右键菜单 &gt; 用管理员权限打开），然后按如下操作：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 请修改路径对应你的安装目录</span></div><div class="line">C:\Windows\system32&gt;cd /d D:\Dev\mingw-w64\bin</div><div class="line"></div><div class="line">D:\Dev\mingw-w64\bin&gt;mklink make.exe mingw32-make.exe</div><div class="line">为 make.exe &lt;&lt;===&gt;&gt; mingw32-make.exe 创建的符号链接</div></pre></td></tr></table></figure>
<p><strong>建议创建软链之后就关掉管理员权限的 cmd，避免因权限过高造成不可恢复的误操作。后续操作在普通权限下执行即可。</strong></p>
<p>完成后你会看到 bin 目录下多了一个 <code>make.exe</code> 文件，然后执行 <code>dir make.exe</code> ，会看到</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\Dev\mingw-w64\bin&gt;dir make.exe</div><div class="line"><span class="number">2018</span>/<span class="number">10</span>/<span class="number">04</span>  <span class="number">18</span>:<span class="number">17</span>    &lt;SYMLINK&gt;      make.exe [mingw32-make.exe]</div></pre></td></tr></table></figure>
<h3 id="2-3-PATH-环境变量"><a href="#2-3-PATH-环境变量" class="headerlink" title="2.3 PATH 环境变量"></a>2.3 PATH 环境变量</h3><p>跟 Go 安装类似的， bin 目录也要追加到 PATH 目录的最后，详细可以参考 1.2.3 Go 的 PATH 环境变量部分。</p>
<p><strong>特别强调：mingw-w64 下面还有一套 mingw32，添加到 PATH 的是根目录的 bin，不是 mingw32 下面的！！</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mingw-w64</div><div class="line">├── bin <span class="comment"># 64位系统认准这个！！</span></div><div class="line">├── mingw32</div><div class="line">│   ├── bin <span class="comment"># 不是这个</span></div><div class="line">......</div></pre></td></tr></table></figure>
<h3 id="2-4-验证"><a href="#2-4-验证" class="headerlink" title="2.4 验证"></a>2.4 验证</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gcc --version</div><div class="line"><span class="comment"># 正常会输出 gcc 的版本，64位：x86_64, 32位：i686; 注意区分</span></div><div class="line">make -v</div><div class="line"><span class="comment"># 能调用就行，不需要留意位数</span></div></pre></td></tr></table></figure>
<h2 id="3-项目包管理及编译"><a href="#3-项目包管理及编译" class="headerlink" title="3. 项目包管理及编译"></a>3. 项目包管理及编译</h2><h3 id="3-0-预备知识：Go-的目录结构与包管理"><a href="#3-0-预备知识：Go-的目录结构与包管理" class="headerlink" title="3.0 预备知识：Go 的目录结构与包管理"></a>3.0 预备知识：Go 的目录结构与包管理</h3><p>每个 workspace 下都有三个指定用途的目录，用到的时候如果不存在，会自动创建：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">├── bin <span class="comment"># 存放 install 之后的可执行文件</span></div><div class="line">├── pkg <span class="comment"># 存放编译之后链接之前的中间文件</span></div><div class="line">└── src <span class="comment"># 存放 包 的源文件</span></div></pre></td></tr></table></figure>
<p>其中 <code>go get</code> 获得的 src 和 <code>go install</code> 获得的 bin ，会放在第一个 workspace 中，所以建议至少添加两个 workspace，并在第二个进行本地开发，避免混淆。</p>
<p>Go 语言引用包时，需要在代码开头 import 对应包的路径（非包名，虽然路径的最后一层目录往往跟包名一样，但也可以不一样）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"../local/relative/path"</span> <span class="comment">// 相对路径。不纳入 workspace 的小项目允许。正规项目需要纳入，会报错！！</span></div><div class="line">    <span class="string">"github.com/urface/cli"</span> <span class="comment">// 全局路径。</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>全局路径的 import </p>
<ol>
<li>先在 <code>%GOROOT%\pkg</code> 查找内置的包（已编译，所以引用 pkg）</li>
<li>再在每个 workspace 的 src 目录查找</li>
<li>在 1.6 版本后新增了项目根目录下的 vendor 目录，可以通过依赖管理工具拷贝特定版本的依赖，方便锁定依赖的版本，并随项目源码一起提交。</li>
</ol>
<p>使用了 local import 的包，不能被别的包 import，所以在正式项目中基本是禁止使用的。那么需要被引用的包只能存放在 src 或者 vendor 中。</p>
<p>跟 Java 相比最大的差别就是， <strong>项目的根目录不在 import 的搜索范围内</strong> 。Java 项目内的包，包名（跟路径对应）不包括项目名，从根目录下开始算；Go 没有项目本地包的概念，都是全局 import，包路径从 src 下开始算，所以项目<strong>根目录名</strong>也是包路径的一部分。由此得出结论：</p>
<ul>
<li>Go 项目必须在 workspace 的 src 目录下开发</li>
<li>根目录 <strong>名字确定后就不能随意更改</strong> ，否则项目内的互相 import 都得改</li>
</ul>
<h3 id="3-1-包管理"><a href="#3-1-包管理" class="headerlink" title="3.1 包管理"></a>3.1 包管理</h3><p>有了上述知识准备，接下来的内容就容易理解了。</p>
<ul>
<li>git clone 必须在 （第二个） workspace 的 src 目录进行 （后续要新建项目同理）。</li>
<li>项目名（例：myproj） 需要跟 import 路径 （<code>import myproj/xxx/yyy</code>） 保持一致，新建项目时就要考虑，clone 之后不能修改目录名。</li>
<li>推荐使用官方的依赖管理工具 dep，所有第三方依赖都会拷贝到 vendor 跟源码一起管理，clone 后不需 <code>go get</code> 对应的依赖。</li>
</ul>
<h3 id="3-2-编译"><a href="#3-2-编译" class="headerlink" title="3.2 编译"></a>3.2 编译</h3><p>在确保做好包管理的基础上，编译就很简单了，在根目录打开 cmd：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build</div></pre></td></tr></table></figure>
<p>即可。 </p>
<p>（后续项目复杂度增加后，编译建议交给 make 管理。）</p>
<h2 id="4-IDE"><a href="#4-IDE" class="headerlink" title="4. IDE"></a>4. IDE</h2><ul>
<li><p><a href="https://github.com/visualfc/liteide" target="_blank" rel="external">LiteIDE</a>：LiteIDE is a simple, open source, cross-platform Go IDE</p>
<p>国人开发的开源跨平台 IDE，简单，免费，够用。</p>
</li>
<li><p><a href="https://www.jetbrains.com/go/" target="_blank" rel="external">GoLand</a>：A Clever IDE to Go by JetBrains</p>
<p>IDE 名门 JetBrains 出品，口碑很好，就是要付费。</p>
</li>
<li><p><a href="https://code.visualstudio.com/" target="_blank" rel="external">Visual Studio Code</a>：Code Editing. Redefined</p>
<p>传统软件巨头微软拥抱开源之后的 开源 IDE ，热度很高；并非专门为 Go 设计，但提供相关插件。</p>
</li>
</ul>
<p>视乎你更习惯哪个 IDE，看你自己喜欢。</p>
<h2 id="5-其他工具"><a href="#5-其他工具" class="headerlink" title="5. 其他工具"></a>5. 其他工具</h2><ul>
<li>bindata：将资源文件编译成 go 源码，参与编译。（类似 Android 下的 R.java）</li>
<li>dep：Go 官方依赖管理工具，将指定版本的第三方依赖拷贝到 vendor 目录，跟源码一起管理。</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为想尝试 Go 的朋友开个头，介绍环境的配置。语言的优缺点不在此展开。&lt;/p&gt;
&lt;p&gt;因身边多数使用 Win64 环境，以下无特殊说明均以 Win64 为例，日后有需要再补充其他平台部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
      <category term="dep" scheme="https://jaycechant.info/tags/dep/"/>
    
  </entry>
  
  <entry>
    <title>golang 依赖管理：glide 从入门到放弃（转投 dep）</title>
    <link href="https://jaycechant.info/2018/glide-from-start-up-to-give-up/"/>
    <id>https://jaycechant.info/2018/glide-from-start-up-to-give-up/</id>
    <published>2018-10-24T10:01:17.000Z</published>
    <updated>2020-01-07T09:06:14.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-结论"><a href="#0x0-结论" class="headerlink" title="0x0 结论"></a>0x0 结论</h2><p>先丢结论，两个推荐选项：</p>
<ul>
<li>forked glide + 配置 mirror ：<a href="https://github.com/xkeyideal/glide" target="_blank" rel="external">https://github.com/xkeyideal/glide</a> ，具体修复哪些 bug ，以及它特有的 mirror 配置，请看 <a href="https://github.com/xkeyideal/glide/blob/master/README_CN.md" target="_blank" rel="external">https://github.com/xkeyideal/glide/blob/master/README_CN.md</a></li>
<li>dep + proxy ：<a href="https://github.com/golang/dep" target="_blank" rel="external">https://github.com/golang/dep</a> ，proxy 不过是设置 <code>http_proxy</code> 和 <code>https_proxy</code> 两个环境变量。</li>
</ul>
<a id="more"></a>
<p>glide 声名在外，但太子 dep 出生以来不再活跃，bug 不少且修复不活跃，要改用网友 fork 的版本。<strong>如果不会搞 proxy，推荐这个</strong> 。</p>
<p>而 <strong>长远考虑，官方支持的 dep 更好</strong> ，别的不说，光 prune 一个特性就值了。</p>
<p>折腾过程请看下文：</p>
<hr>
<p>go 最近几年热了起来，我一个长期靠 Java 吃饭的人，也从 Python 吹，变成了 go 吹。</p>
<h2 id="0x1-依赖管起来-glide-init"><a href="#0x1-依赖管起来-glide-init" class="headerlink" title="0x1 依赖管起来 glide init"></a>0x1 依赖管起来 glide init</h2><p>一开始就知道 go 官方的依赖管理不给力。如果第三方依赖有 breaking changes，或者干脆删库走人，好好一个项目，换个没有依赖包缓存的机器，就编译不能了。1.5 开始引入了 vendor 目录，但毕竟没有默认启用，工具支持也不够（当时 dep 不知道是没发布，还是还在 alpha）。</p>
<p>当时看了网上的讨论，好像一致推崇 glide 。安装，玩一下就算了。当时写小工具，依赖很少，没把 glide 用起来。（多数是用 go 重写 Python 工具。把工具共享出去时别人没装 Python，懒得折腾打包。）</p>
<h3 id="breaking-changes"><a href="#breaking-changes" class="headerlink" title="breaking changes"></a>breaking changes</h3><p>直到写稍大一点的项目，依赖多起来。但还是拖着，心想具体用哪个包可能还会变，不会刚写两天就来一个 breaking change。</p>
<p>写到稍有模样，碰到个 bug，最后发现是依赖包引起的，去主页一看，作者已经 fix 了，是个 breaking change，发了个大版本。我升级了，还好 breaking 的地方对我没有影响。但这样一来，就下决心把依赖管理起来。</p>
<h3 id="碰『壁』"><a href="#碰『壁』" class="headerlink" title="碰『壁』"></a>碰『壁』</h3><p>（这不是教学帖，不教安装使用。反正教程一搜一大把。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">glide init</div><div class="line">...... // 省略 glide 问我的一堆问题</div><div class="line">glide install</div><div class="line">[INFO]  Lock file (glide.lock) does not exist. Performing update.</div><div class="line">[INFO]  Downloading dependencies. Please wait...</div><div class="line">...... // 省略那些成功的包</div><div class="line">[INFO]  --&gt; Fetching golang.org/x/crypto/acme/autocert</div><div class="line">[WARN]  Unable to checkout golang.org/x/crypto/acme/autocert</div><div class="line">[ERROR] Error looking <span class="keyword">for</span> golang.org/x/crypto/acme/autocert: Cannot detect VCS</div><div class="line">...... // 这种报错一个 4 个，都是 golang.org 上的包</div></pre></td></tr></table></figure>
<p>出问题问谷歌，然后找到这么一个文章： <a href="https://studygolang.com/articles/10453" target="_blank" rel="external">https://studygolang.com/articles/10453</a> ， 里面说是 golang.org 被墙了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">curl golang.org</div><div class="line">curl: (7) Failed to connect to golang.org port 80: Timed out</div><div class="line"></div><div class="line">curl https://golang.org</div><div class="line">curl: (7) Failed to connect to golang.org port 443: Timed out</div><div class="line"></div><div class="line">curl -x socks5://127.0.0.1:1080 https://golang.org/x/crypto/acme/autocert</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>/&gt;</div><div class="line">&lt;meta name=<span class="string">"go-import"</span> content=<span class="string">"golang.org/x/crypto git https://go.googlesource.com/crypto"</span>&gt;</div><div class="line">&lt;meta name=<span class="string">"go-source"</span> content=<span class="string">"golang.org/x/crypto https://github.com/golang/crypto/ https://github.com/golang/crypto/tree/master&#123;/dir&#125; https://github.com/golang/crypto/blob/master&#123;/dir&#125;/&#123;file&#125;#L&#123;line&#125;"</span>&gt;</div><div class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0; url=https://godoc.org/golang.org/x/crypto/acme/autocert"</span>&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">Nothing to see here; &lt;a href=<span class="string">"https://godoc.org/golang.org/x/crypto/acme/autocert"</span>&gt;move along&lt;/a&gt;.</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>确实被墙了。那平时上为什么毫无障碍的？这时才想起翻 pac 配置，发现 golang.org 赫然在列，说明被屏蔽不是一天两天，早早被加入了 gfwlist。（后来得知网站托管在 google 服务器上）</p>
<p>而且结合 <code>golang.org/x/crypto</code> 的重定向 和 meta 信息，可以看出来 golang.org 只是提供重定向信息，<code>go get</code> 和 <code>glide</code> 应该是解析这些信息之后，再去 googlesource 或者 github 取代码。而目前第一步就 Time out 了，所以即使给 git 加 proxy 也没用。</p>
<h2 id="0x2-配置镜像-glide-mirror"><a href="#0x2-配置镜像-glide-mirror" class="headerlink" title="0x2 配置镜像 glide mirror"></a>0x2 配置镜像 glide mirror</h2><h3 id="mirror-的-N-种配置方法"><a href="#mirror-的-N-种配置方法" class="headerlink" title="mirror 的 N 种配置方法"></a>mirror 的 N 种配置方法</h3><p>那配置镜像吧。咦，不对，别人的例子都是 import 依赖包的根目录，例如 <code>golang.org/x/crypto</code> ，可以直接映射 <code>github.com/golang/crypto</code> ，但是子包 <code>golang.org/x/crypto/acme/autocert</code> 怎么办？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glide mirror <span class="built_in">set</span> golang.org/x/crypto github.com/golang/crypto</div></pre></td></tr></table></figure>
<p>照样 <code>Cannot detect VCS</code> 。 这个命令实际上写入了 <code>~/.glide/mirrors.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">repos:</span> <span class="comment"># 以这个包为例子，省略同理的其他包，下同</span></div><div class="line"><span class="attr">- original:</span> golang.org/x/crypto</div><div class="line"><span class="attr">  repo:</span> github.com/golang/crypto</div></pre></td></tr></table></figure>
<p>所以为了避免反复 <code>glide mirror remove</code>  再 set，我直接在 <code>mirrors.yaml</code> 上修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">repos:</span> <span class="comment"># 考虑 import 的路径是 golang.org/x/crypto/acme/autocert，可能不会命中 golang.org/x/crypto</span></div><div class="line"><span class="attr">- original:</span> golang.org/x/crypto/acme/autocert</div><div class="line"><span class="attr">  repo:</span> github.com/golang/crypto/acme/autocert</div></pre></td></tr></table></figure>
<p>继续一样的错误，再改</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">repos:</span> <span class="comment"># github 上实际的地址是 github.com/golang/crypto/tree/master&#123;/dir&#125;， github.com/golang/crypto/acme/autocert 根本不存在，也许映射到根目录，余下的会根据规则匹配？</span></div><div class="line"><span class="attr">- original:</span> golang.org/x/crypto/acme/autocert</div><div class="line"><span class="attr">  repo:</span> github.com/golang/crypto</div></pre></td></tr></table></figure>
<p>照旧，再改</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">repos:</span> <span class="comment"># 看到有些人加了 https，死马当活马医，加上试试</span></div><div class="line"><span class="attr">- original:</span> https://golang.org/x/crypto/acme/autocert</div><div class="line"><span class="attr">  repo:</span> https://github.com/golang/crypto</div></pre></td></tr></table></figure>
<p>好了，终于不报该死的 <code>Cannot detect VCS</code> 了。</p>
<h3 id="看不见的折腾"><a href="#看不见的折腾" class="headerlink" title="看不见的折腾"></a>看不见的折腾</h3><p>这数次不断尝试和失败的过程非常痛苦。因为没有一次跑到最后，没有生成 gllide.lock 文件，所以每次执行 <code>glide install</code> ，实际触发的都是 <code>glide update</code> ；而 github 虽然可以访问，速度并不快，在知道关键的 4 个包是否成功 fetch 前，先要忍受一堆包的 fetch updates，偶尔还会因为超时出现 <code>exit status 128</code>。</p>
<p>而除了上面列出的，还尝试过加 <code>--vcs git</code> ，加 <code>--base</code> ，给 git 加 proxy …… 尝试次数比看到的要多，只是最后证明无关就没有列出；每次失败之后都要思考背后的原因，看哪里还能调整一下。在这上面耗了大半天。</p>
<h2 id="0x3-还有-ERROR？-另一个-glide"><a href="#0x3-还有-ERROR？-另一个-glide" class="headerlink" title="0x3 还有 ERROR？ 另一个 glide"></a>0x3 还有 ERROR？ 另一个 glide</h2><h3 id="endless-errors"><a href="#endless-errors" class="headerlink" title="endless errors"></a>endless errors</h3><p>你以为这就完了？并没有！</p>
<p>在终于消灭了所有 <code>Cannot detect VCS</code> 之后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ERROR] Unable to <span class="built_in">export</span> dependencies to vendor directory: Error moving files: <span class="built_in">exit</span> status 1. output</div><div class="line">: ***********</div><div class="line">************** // 乱码会打乱这篇文章的编码，所以用 * 代替</div></pre></td></tr></table></figure>
<p>还有 ERROR，而且还乱码，什么鬼啊！？？ 然后我就找到了这个：</p>
<p><a href="https://github.com/xkeyideal/glide/blob/master/README_CN.md" target="_blank" rel="external">https://github.com/xkeyideal/glide/blob/master/README_CN.md</a></p>
<p>简单说，glide 有两个 bug，一个是子包的目录映射错误（还没成功 export 过，无缘见识），一个是 Windows 下 export dependencies 时的权限问题，乱码是由于编码（Windows 默认 GB2312，但 glide 输出 UTF-8）。因为原作者迟迟没有合 PR <a href="https://github.com/Masterminds/glide/pull/889/commits/cc37dc711a3191c2b91b01b9593c685660eeb9af" target="_blank" rel="external">#889</a> ，作者就 fork 之后修复了。（我去看了，17 年 7 月的 PR，到现在 18 年 10 月，仍然没有合并……）</p>
<h3 id="forked-glide"><a href="#forked-glide" class="headerlink" title="forked glide"></a>forked glide</h3><p>先把原来的 glide 重命名为 <code>glide.Materminds.bk</code> （在 <code>~/go/bin</code> 下），然后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/xkeyideal/glide</div></pre></td></tr></table></figure>
<p>另外，记得加上 base 参数，实测过不加 export 的目录结构确实是错的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">repos:</span></div><div class="line"><span class="attr">- original:</span> https://golang.org/x/crypto</div><div class="line"><span class="attr">  repo:</span> https://github.com/golang/crypto</div><div class="line"><span class="attr">  base:</span> github.com/golang/crypto</div></pre></td></tr></table></figure>
<p>已经忘了是第几次执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># glide init 只需执行一次，只要 glide.yaml 存在就不必再次执行</span></div><div class="line">glide install</div></pre></td></tr></table></figure>
<p>终于执行到了最后。</p>
<h2 id="0x4-转投-dep"><a href="#0x4-转投-dep" class="headerlink" title="0x4 转投 dep"></a>0x4 转投 dep</h2><p>完事了吗？还没有。</p>
<p>从上面的尝试可以看出，glide 虽在一众依赖管理工具中收获了人气， 但存在不少 bug；而 364 个 open issue / 34 个 oepn pr ，多数有一年没有处理，最早的居然是 15 年的 （截止 2018/10/24），可以看出来作者 <strong>不再活跃</strong> ，对一个开源项目来说， <strong>比有 bug 更糟糕</strong> 。</p>
<p>像 Windows 下的权限问题，上面 #889 一年多前提了 PR 没人管，9月又有人提了重复的PR <a href="https://github.com/Masterminds/glide/pull/1020" target="_blank" rel="external">#1020: Update winbug.go</a> ，作者依旧没有处理。</p>
<p>fork 项目虽解决了几个明显问题，毕竟不是活跃的原项目，更多是先修复继续用的权益之计，以后也很难代替原作者继续推进开发。</p>
<h3 id="重新评估"><a href="#重新评估" class="headerlink" title="重新评估"></a>重新评估</h3><p>我要考虑对于 go 依赖管理工具的认知是不是已经过时了。重新查这方面的对比，尽量留意时间近的帖子，翻到这么两篇：</p>
<ul>
<li><p><a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="external">PackageManagementTools</a></p>
</li>
<li><p><a href="https://github.com/blindpirate/report-of-build-tools-for-java-and-golang" target="_blank" rel="external">A Survey on Build Tools of Golang and Java</a></p>
</li>
</ul>
<p>挑重点说：go 有了官方的依赖管理工具 dep，关注度很高，而这还是 17 年 11 月的比较，当时 dep 刚出不久。</p>
<p>关键我还在原版 glide 的 release history 发现这么个东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Release 0.13.0</div><div class="line">@mattfarina mattfarina released this on 29 Sep 2017 · 16 commits to master since this release</div><div class="line"></div><div class="line">The latest release of Glide brings continued support.</div><div class="line"></div><div class="line">Consider switching to dep</div><div class="line">Glide is used by a great number of projects and will continue to get support for some time. But, the near future is likely in dep. dep can handle importing Glide config files. Please consider trying dep on your project or converting to dep. If you encounter an issue please check if there is an existing bug report and file one if there is not.</div><div class="line"></div><div class="line">Glide will continue to be supported for some time as there are many users who rely on it and some are not able or ready to move to dep.</div></pre></td></tr></table></figure>
<p>重点就是：这是 Glide 最后一个持续支持的版本了（我的理解是，往后只 patch，不大改），你们考虑切换到 dep 吧。dep 都能导入 Glide 的配置了，未来是官方亲儿子的。</p>
<h3 id="亲儿子-dep"><a href="#亲儿子-dep" class="headerlink" title="亲儿子 dep"></a>亲儿子 dep</h3><p>说得那么好，试试。地址在这 <a href="https://github.com/golang/dep" target="_blank" rel="external">https://github.com/golang/dep</a></p>
<p>安装略过，请按官方指引来，以后也许会变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 加 -gopath 优先检查本地 gopath，加 -v 看详细输出否则啥进度没有干着急</span></div><div class="line">dep init -gopath -v</div><div class="line">...... // 省略正常内容</div><div class="line">init failed: unable to solve the dependency graph: Solving failure: No versions of github.com/kataras/pio met constraints:</div><div class="line">        master: unable to deduce repository and <span class="built_in">source</span> <span class="built_in">type</span> <span class="keyword">for</span> <span class="string">"golang.org/x/sys/unix"</span>: unable to <span class="built_in">read</span> metadata: unable to fetch raw metadata: failed HTTP request to URL <span class="string">"http://golang.org/x/sys/unix?go-get=1"</span>: Get http://golang.org/x/sys/unix?go-get=1: dial tcp 216.239.37.1:80: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.</div></pre></td></tr></table></figure>
<p>又是 golang.org 无法访问。是不是同样的配方，熟悉的味道？</p>
<p>这还没到下载，而是分析依赖图时获取 metadata 就出错了，所以 gopath 里已有了 cache 并不改变结果。难道 glide 上的困难又得重来一遍？继续问谷歌，又找到一篇：<a href="https://my.oschina.net/u/553243/blog/1504715" target="_blank" rel="external">https://my.oschina.net/u/553243/blog/1504715</a></p>
<p>具体说，就是设置 <code>http_proxy</code> 和 <code>https_proxy</code> 两个环境变量，dep 自然会读取并使用。环境变量根据系统有差异，为了不影响其他地方，每次打开 cmd / shell 设一下也不算麻烦；当然 alias 也是一种解决办法。</p>
<h3 id="意外惊喜"><a href="#意外惊喜" class="headerlink" title="意外惊喜"></a>意外惊喜</h3><p>这回终于好了。依赖图分析需要网络，稍有点久，后面直接读 gopath，速度很快。之后就是把 vendor 提交掉。</p>
<p>不过，提交过程太流畅了，隐约有一丝不对劲。毕竟用 glide 的时候，提交卡顿了一会儿，70+M 的一堆小文件，很正常。去看一眼 vendor 文件夹，这次居然才 25+M！？太小了吧，难道漏文件了？</p>
<p>可是点进去看我就懂了，dep 把引用不到的子包删掉了。换言之，glide 的最小粒度是 项目，哪怕只引用了大项目里的一个子包，也会把整个项目 export 到 vendor； 而 dep 应该是基于 subpackage 或者 文件的，先分析依赖图，没有引用到的文件都不要。<code>Gopkg.toml</code> 里的这段可以作为佐证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[prune]</div><div class="line">  go-tests = true</div><div class="line">  unused-packages = true</div></pre></td></tr></table></figure>
<p>用过之后，感觉 dep 相当简洁，<code>-gopath</code> 选项 和 prune 特性则是意外之喜。</p>
<h2 id="0x5-写在最后"><a href="#0x5-写在最后" class="headerlink" title="0x5 写在最后"></a>0x5 写在最后</h2><ul>
<li>在程序员的节日折腾这些，感受 GFW 带来的不便，相当不友好，感叹国内开发的不易，总有额外成本</li>
<li>今天这『群雄并起，太子一统』的故事套路，怎么感觉跟当年 pip 那么像</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x0-结论&quot;&gt;&lt;a href=&quot;#0x0-结论&quot; class=&quot;headerlink&quot; title=&quot;0x0 结论&quot;&gt;&lt;/a&gt;0x0 结论&lt;/h2&gt;&lt;p&gt;先丢结论，两个推荐选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;forked glide + 配置 mirror ：&lt;a href=&quot;https://github.com/xkeyideal/glide&quot;&gt;https://github.com/xkeyideal/glide&lt;/a&gt; ，具体修复哪些 bug ，以及它特有的 mirror 配置，请看 &lt;a href=&quot;https://github.com/xkeyideal/glide/blob/master/README_CN.md&quot;&gt;https://github.com/xkeyideal/glide/blob/master/README_CN.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;dep + proxy ：&lt;a href=&quot;https://github.com/golang/dep&quot;&gt;https://github.com/golang/dep&lt;/a&gt; ，proxy 不过是设置 &lt;code&gt;http_proxy&lt;/code&gt; 和 &lt;code&gt;https_proxy&lt;/code&gt; 两个环境变量。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
      <category term="glide" scheme="https://jaycechant.info/tags/glide/"/>
    
      <category term="dep" scheme="https://jaycechant.info/tags/dep/"/>
    
  </entry>
  
  <entry>
    <title>为什么你应该学 Python</title>
    <link href="https://jaycechant.info/2017/why-you-should-learn-python/"/>
    <id>https://jaycechant.info/2017/why-you-should-learn-python/</id>
    <published>2017-10-18T15:37:29.000Z</published>
    <updated>2017-10-18T16:45:35.565Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用Python</p>
<a id="more"></a>
<h2 id="1-What-amp-Why"><a href="#1-What-amp-Why" class="headerlink" title="1 What &amp; Why"></a>1 What &amp; Why</h2><h3 id="1-1-What’s-Python"><a href="#1-1-What’s-Python" class="headerlink" title="1.1 What’s Python?"></a>1.1 What’s Python?</h3><p><strong>Python</strong>（英语发音：/ˈpaɪθən/，类似 『派森』）, 是一种 <strong>面向对象</strong>、<strong>解释型</strong>、<strong>动态 强类型</strong> 程序设计语言。</p>
<p>由 Guido van Rossum 于 <strong>1989年底</strong> 发明，第一个公开发行版发行于 1991 年。</p>
<p>Python 语法 <strong>简洁而清晰</strong>，具有 <strong>丰富和强大的类库</strong>。常被称为 <strong>胶水语言</strong>，能够把用其他语言制作的各种模块（尤其是 C/C++）很轻松地联结在一起。</p>
<p>常见一种应用情形是，使用 Python 快速生成程序原型（有时是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写，比如 3D 游戏中的图形渲染模块，性能要求特别高，就可以用 C++ 重写。</p>
<h3 id="1-2-Why-Python"><a href="#1-2-Why-Python" class="headerlink" title="1.2 Why Python?"></a>1.2 Why Python?</h3><blockquote>
<p>生产工具决定生产效率</p>
</blockquote>
<p>理由很多，我列举一些普遍公认的好处，以及优秀特性。</p>
<h4 id="1-2-1-明确、简单、优雅"><a href="#1-2-1-明确、简单、优雅" class="headerlink" title="1.2.1 明确、简单、优雅"></a>1.2.1 明确、简单、优雅</h4><p>这必须放在最前面，而且有可能是最重要的。</p>
<p>Python 在设计上坚持了 <strong>清晰划一</strong> 的风格，这使 Python 非常易读、易写、易维护。</p>
<p>Python 哲学里有这样一句话</p>
<blockquote>
<p>In the face of ambiguity, refuse the temptation to guess.<br>当存在多种可能时，不要尝试去猜测<br>There should be one– and preferably only one –obvious way to do it.<br>应该有一个——而且最好只有一个——最明显的方法去完成</p>
</blockquote>
<p>（Python 在语法上接近C语言，后面的例子会C/C++或者Java的人应该很快可以理解。）</p>
<hr>
<p>以下问题应该多少遇过：</p>
<ul>
<li>C语言 <code>b = a+++++a;</code> 的优先级问题</li>
<li>纠结 <code>while(){}</code> 和 <code>do{}while();</code> 的差别。</li>
<li>凌乱的括号和缩进，团队内难以统一</li>
<li>……</li>
</ul>
<p>于 Python，这些问题都不存在：</p>
<ul>
<li>没有 <code>++</code></li>
<li>只有 <code>while</code> 没有 <code>do</code> </li>
<li>推荐一行一句，不推荐分号</li>
<li>没有花括号</li>
<li>唯一缩进风格，缩进决定代码层级（换言之，缩进不仅仅是排版，而是语义的一部分）</li>
</ul>
<p>一般语言缩进不对，是风格问题，影响可读性，不影响运行；Python 哪怕多一个空格，<strong>报错，罢工。</strong></p>
<p>你可能会不习惯，甚至觉得蛮不讲理。可一旦你习惯并使用一段时间，需要阅读自己以前的代码，或者别人的代码：你会发现，可读性真好！</p>
<p>Python 有意设计 <strong>限制性很强的语法</strong>，使得不好的编程习惯直接不能通过编译（注：需要编译为字节码）。你只有两个选择：清晰易读的代码，和不能运行的代码，没有中间选项。同时也避免了初学者在多种写法中选择困难，在歧义中玩猜谜游戏。</p>
<hr>
<p>去掉令人费解的特性同时，Python 加入了很多符合直觉的语法</p>
<h5 id="同时赋值"><a href="#同时赋值" class="headerlink" title="同时赋值"></a>同时赋值</h5><p>（注：背后的机制是自动打包与解包）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C code</span></div><div class="line">temp = a;</div><div class="line">a = b;</div><div class="line">b = temp;</div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line">a, b = b, a</div></pre></td></tr></table></figure>
<p>五个变量按以下顺序交换，如果用 C 怎么写？多少个临时变量？按什么顺序赋值？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python</span></div><div class="line">a, b, c, d, e = b, d, a, e, c</div></pre></td></tr></table></figure>
<p>不仅是少了两行代码 和 一个临时变量，而是大大提升可读性！</p>
<h5 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C Code</span></div><div class="line"><span class="keyword">int</span> <span class="built_in">list</span>[SIZE];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SIZE; i++)&#123;</div><div class="line">    <span class="built_in">list</span>[i] = i * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line"></div><div class="line">list = [i * <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(SIZE)]</div></pre></td></tr></table></figure>
<h5 id="默认参数-和-命名参数"><a href="#默认参数-和-命名参数" class="headerlink" title="默认参数 和 命名参数"></a>默认参数 和 命名参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java code</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</div><div class="line">        bar(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> arg1)</span> </span>&#123;</div><div class="line">        bar(arg1, <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</div><div class="line">        System.out.println(arg1 + <span class="string">", "</span> + arg2)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main() here</span></div><div class="line">Foo f = <span class="keyword">new</span> Foo();</div><div class="line">f.bar(); <span class="comment">// 1, 2</span></div><div class="line">f.bar(<span class="number">11</span>); <span class="comment">// 11, 2</span></div><div class="line">f.bar(<span class="number">11</span>, <span class="number">55</span>); <span class="comment">// 11, 55</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>严格来说，由于 Python 的参数表没有指定类型，无法基于参数表做重载。<br>不过由于 <strong>默认参数</strong> 和 <strong>命名参数</strong> 的存在，Python 不需要重载，还更易用。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, arg1=<span class="number">1</span>, arg2=<span class="number">2</span>, arg3=<span class="number">3</span>, arg4=<span class="number">4</span>)</span>:</span></div><div class="line">        print(<span class="string">', '</span>.join(arg1, arg2, arg3, arg4))</div><div class="line">    </div><div class="line"><span class="comment"># main() here</span></div><div class="line">f = Foo()</div><div class="line">f.bar() <span class="comment"># 1, 2, 3, 4</span></div><div class="line">f.bar(<span class="number">56</span>) <span class="comment"># 56, 2, 3, 4</span></div><div class="line">f.bar(<span class="number">56</span>, <span class="number">78</span>) <span class="comment"># 56, 78, 3, 4</span></div><div class="line">f.bar(<span class="number">56</span>, arg3=<span class="number">99</span>) <span class="comment"># 56, 2, 99, 4 # 如果跳过了中间的参数，后面的参数都要用命名参数</span></div></pre></td></tr></table></figure>
<h5 id="map-与-匿名函数（λ-计算）"><a href="#map-与-匿名函数（λ-计算）" class="headerlink" title="map() 与 匿名函数（λ 计算）"></a>map() 与 匿名函数（λ 计算）</h5><p>以下代码试图将一个列表的每个数变成自己的平方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C code</span></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SIZE; i++)&#123;</div><div class="line">    <span class="built_in">list</span>[i] = <span class="built_in">list</span>[i] * <span class="built_in">list</span>[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line">list = map(<span class="keyword">lambda</span> n : n**<span class="number">2</span>, list)</div></pre></td></tr></table></figure>
<p><code>map()</code> 的两个参数分别是 <strong>函数</strong> 和 <strong>列表</strong>。（Python一切皆对象，包括函数本身也可以赋值和作为参数传递）作用是将 列表 中的每一个元素，都放进函数运行，将结果重新构成一个 新的列表 返回。</p>
<p>其中，这个匿名函数等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n**<span class="number">2</span></div></pre></td></tr></table></figure>
<h5 id="in-关键字"><a href="#in-关键字" class="headerlink" title="in 关键字"></a>in 关键字</h5><p>多条件判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C code</span></div><div class="line"><span class="keyword">if</span>((a == <span class="number">1</span> || a == <span class="number">2</span> || a == <span class="number">4</span> || a == <span class="number">9</span>) &amp;&amp; (b != <span class="number">3</span> &amp;&amp; b != <span class="number">8</span>))&#123;</div><div class="line">    <span class="comment">// so something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line"><span class="keyword">if</span> a <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>) <span class="keyword">and</span> b <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">3</span>, <span class="number">8</span>):</div><div class="line">    <span class="comment"># do something</span></div></pre></td></tr></table></figure>
<p>容器遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C code</span></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ROW_SIZE; i++)&#123;</div><div class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; COL_SIZE; j++)&#123;</div><div class="line">        <span class="comment">// do something with list[i][j]</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> list:</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> row:</div><div class="line">        <span class="comment"># do something with x</span></div></pre></td></tr></table></figure>
<h5 id="容器特性"><a href="#容器特性" class="headerlink" title="容器特性"></a>容器特性</h5><p>按照一定间隔取元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C code</span></div><div class="line"><span class="keyword">for</span>(i = <span class="number">3</span>; i &lt; <span class="number">100</span>; i += <span class="number">4</span>)&#123;</div><div class="line">    <span class="comment">// do something with list[i]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list[<span class="number">3</span>:<span class="number">100</span>:<span class="number">4</span>]:</div><div class="line">    <span class="comment"># do something with x</span></div></pre></td></tr></table></figure>
<p>访问尾部元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java code</span></div><div class="line">list[list.length - <span class="number">1</span>];</div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python code</span></div><div class="line">list[<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<p>一不小心就介绍了太多特性</p>
<p>好用的特性不止这些，像 自动打包与解包，装饰器，闭包这些特性，以后有机会再讨论。</p>
<hr>
<p>大家可以发现，Python 代码非常接近自然语言，基本可以当作英语去阅读理解。所以 Python 又有 『可以运行的伪代码』 之称。</p>
<p>它的简单，让大脑从细节中解放，集中精力放在业务流程和算法上。</p>
<h4 id="1-2-2-跨平台、胶水语言、丰富和强大的类库"><a href="#1-2-2-跨平台、胶水语言、丰富和强大的类库" class="headerlink" title="1.2.2 跨平台、胶水语言、丰富和强大的类库"></a>1.2.2 跨平台、胶水语言、丰富和强大的类库</h4><h5 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h5><p>Python 是开源的语言，只要目标平台实现一个解析环境就能支持。</p>
<p>实际上 Mac 和 大多数 Linux 发行版 内置支持Python。只有 Windows 和 手机 需要安装一下。</p>
<h5 id="胶水语言"><a href="#胶水语言" class="headerlink" title="胶水语言"></a>胶水语言</h5><p>Python 可以跟很多语言互相调用。首先是 C。</p>
<p>这意味着如果某些地方用 Python 实现不好（譬如太慢），你可以换成更适合的语言实现。</p>
<h5 id="强大的类库"><a href="#强大的类库" class="headerlink" title="强大的类库"></a>强大的类库</h5><p>自带的库就包含大量高级数据类型，如 列表、元组、字典、集合、队列… 非常强大。<br>甚至于你要启动一个简单的 Server，一般的语言都要费点劲，Python 自带 HTTPServer ，跑起来就一两行代码。</p>
<p>至于各种第三方库，就强大到令人发指了。除了本身 Python 编写的库，由于 Python 对 C/C++ 友好，众多强大的开源软件包即使不是用 Python 写的，也往往提供 Python API。</p>
<ul>
<li>GUI 库 Qt</li>
<li>计算机视觉库 OpenCV</li>
<li>三维可视化库 VTK</li>
<li>医学图像处理库 ITK</li>
<li>3个著名的科学计算库 NumPy / SciPy / matplotlib </li>
<li>…</li>
</ul>
<p>良好的类库支持，聚集了一大批活跃的开发者，将开发成果继续开源发布出来……</p>
<p>强大的类库支持，让我们从重复造轮子的劳动中解放出来。</p>
<h4 id="1-2-3-快！"><a href="#1-2-3-快！" class="headerlink" title="1.2.3 快！"></a>1.2.3 快！</h4><p>这一点是前面两点的结果。</p>
<p>有网友实践，一个ASF XML 序列化工具，C++ 需要 1580 行，而Python只用 130 行。Python 作为一个高级语言的代码生产力高于多数语言的。（这里高级是指抽象层级更高，无好坏之分）</p>
<p>只要敲非常少的代码，引用强大的类库，就实现了需求；每次修改之后，不需要等待编译，马上可以运行。</p>
<p>这对于 <strong>快速原型</strong> 和 <strong>流程自动化</strong> 很重要。</p>
<h4 id="1-2-4-需求巨大"><a href="#1-2-4-需求巨大" class="headerlink" title="1.2.4 需求巨大"></a>1.2.4 需求巨大</h4><p>最新的 Github 语言排行，Python 已代替 Java 上升到第二的位置。</p>
<p>科学计算、数据挖掘、人工智能、自动化运维/测试 … 未来对于 Python 的需求非常大。</p>
<h4 id="1-2-5-缺点"><a href="#1-2-5-缺点" class="headerlink" title="1.2.5 缺点"></a>1.2.5 缺点</h4><p>Python 没有缺点吗？有：</p>
<ul>
<li><p>慢： 相对于 C/C++ ,  Java 而言，抽象层级高的代价，是执行效率不高。<br>但随着运算力越来越廉价 和 人的时间越来越宝贵，很多时候这变得不那么重要。<br>何况：</p>
<ol>
<li>自己写的 C/C++ 代码，算法效率未必比得上 Python 库里的实现</li>
<li>Python 已经优化得越来越快了，某些特定领域甚至超过了 C（通过 PyPy 的 JIT 技术）</li>
<li>根据 20/80 定律，可以把性能瓶颈用 C/C++ 重写。为什么不一开始就用 C/C++ ？Python 可以快速实现原型。<br>一般的自动化工具，根本感觉不到速度问题。</li>
</ol>
</li>
<li><p>动态语言难以维护大型项目：对于编程习惯不好的人，是的。  </p>
<p>但是同样的人，在静态语言也会面临问题。Java 之所以存在大量复杂的 Design Pattern ，很大一部分是为了绕过语言设置的限制，为此逻辑弄得晦涩难明。<br>Python 语法上做了大量限制，逻辑上却给予了很大的自由，可以很简单就实现原本复杂的设计模式才有的功能。<br>至于大型项目的可维护性，要依赖良好的设计 和 编码规范。另外也可以通过装饰器限制参数类型。不过从公司的角度，要找到合格的开发者，确实比 Java 要难。</p>
</li>
</ul>
<h2 id="2-How-to-Python"><a href="#2-How-to-Python" class="headerlink" title="2 How to Python"></a>2 How to Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 3.x</span></div><div class="line">print(<span class="string">"Hello world!"</span>)</div></pre></td></tr></table></figure>
<p>That’s all!</p>
<hr>
<p>是的，我没有打算展开讲。</p>
<p>语法接近C，而且非常直观。我到现在为止没有买过任何一本 Python 的书，大多数早期的问题， API 文档就够了。（注1：Windows 版 Python 安装时，会附带一份 API 文档。注2：这段话写于 2015年，后来我买了一本 《Python cookbook》）</p>
<p>文档还看不懂，请打开浏览器。（谷哥还是度娘，自己选择）</p>
<p>到不得不买书的时候，往往已经比较深入了。</p>
<h3 id="Python-2-x-VS-Python-3-x"><a href="#Python-2-x-VS-Python-3-x" class="headerlink" title="Python 2.x VS Python 3.x"></a>Python 2.x VS Python 3.x</h3><p>作为将 <strong>简洁清晰</strong> 视作生命的语言，为了减轻历史包袱，Python 3.0 以后的版本，并 <strong>不兼容</strong> 之前的版本。于是，关于用哪一个版本就分成了两派。</p>
<p>其实很简单</p>
<ul>
<li>如果有什么理由不得不用 Python 2.x，例如有个库只有 2.x 的版本，那就用 2.x （注：随着时间推移这种情况已经越来越少）</li>
<li>否则，推荐从 3.x 开始。它代表未来 Python 的方向。到了今天，多数的库都已移植到 3.x ，官方宣布 2020 停止维护 2.x 。</li>
<li>或者不得已，都用。差别没那么大。</li>
</ul>
<hr>
<blockquote>
<p>Life is short, you need Python!<br><cite>– Bruce Eckel, ANSI C++ Comitee member</cite></p>
</blockquote>
<p><br></p>
<p>文章的最后，一起来看一下 <strong>Python 之禅</strong></p>
<blockquote>
<p><strong>The Zen of Python </strong><br><cite>——Tim Peters</cite><br>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one– and preferably only one –obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea – let’s do more of those!  </p>
</blockquote>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用Python&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://jaycechant.info/tags/Python/"/>
    
      <category term="why" scheme="https://jaycechant.info/tags/why/"/>
    
  </entry>
  
  <entry>
    <title>改用 screen 作为 byobu 的后端</title>
    <link href="https://jaycechant.info/2017/use-screen-as-byobu-backend/"/>
    <id>https://jaycechant.info/2017/use-screen-as-byobu-backend/</id>
    <published>2017-09-19T08:57:40.000Z</published>
    <updated>2017-10-12T14:41:16.668Z</updated>
    
    <content type="html"><![CDATA[<p>如题，一分钟Mark文。</p>
<a id="more"></a>
<p><strong>byobu</strong> 是很方便的 Unix 窗口管理器 和 Terminal Multiplexer，它是一套 profiles 或者说 wrapper ，降低使用 tmux 或 screen 的 配置 和 操作 成本。（如果不知道我说什么，看这里<a href="../special-for-tools/">《小工具专题》</a> ，还有 <a href="http://www.byobu.co/" target="_blank" rel="external">byobu主页</a>）</p>
<p>不过我只能算轻度用户，多数时间只使用两个功能：</p>
<ul>
<li>通过 detach 让我下线之后 Session 还能继续干活，以及下次上线不用重新找目录</li>
<li>方便的多窗口管理（F2，F3，F4 完事）</li>
</ul>
<p>从没关心过后面是 tmux 还是 screen。直到公司服务器的 byobu 由我一个人用，到大家都用。大家直接敲 <code>byobu</code> 完事，于是都挤在一个 Session 里，互相干扰。</p>
<hr>
<p>用 byobu 之前我是一个 screen 用户，自然想到大家各自连自己的 Session 。试着给 byobu 加 screen 的参数，发现不行。这时才想到去确认，发现当前版本（5.74）byobu 默认 backend 是 tmux。（印象中是不是早期 byobu 试过以 screen 为默认？忘了）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ byobu --version</div><div class="line">byobu version 5.74</div><div class="line">tmux 1.8</div><div class="line">$ cat ~/.byobu/backend</div><div class="line">BYOBU_BACKEND=tmux</div></pre></td></tr></table></figure>
<p>我知道 tmux 也很强大，加上一些指令和参数，也可以分别创建和管理 Session。可是，我已经习惯 screen ，所以决定把后端换掉。（各位看到这里不必跟我争论哪个好用）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 首先你要确定装了 screen，我一直有装就跳过</span></div><div class="line">$ vim ~/.byobu/backend <span class="comment"># 把里面的值改为 screen，然后保存</span></div><div class="line">$ cat ~/.byobu/backend</div><div class="line">BYOBU_BACKEND=screen</div></pre></td></tr></table></figure>
<p>这时候开始，执行 <code>byobu</code> 背后已经是 screen 在干活。最初目的是为了方便分别创建 Session，对应 <code>screen -S SessionName</code>，相应的 byobu 指令是否可行呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ byobu -S jayce</div><div class="line"><span class="comment"># 执行完跳到了一个新的窗口，但是不是真的成功了呢？</span></div><div class="line">~ byobu -ls</div><div class="line">There is a screen on:</div><div class="line">        151664.jayce    (Tuesday, September 19, 2017 05:30:12 CST)      (Attached)</div><div class="line">1 Socket <span class="keyword">in</span> /var/run/screen/jayce.</div></pre></td></tr></table></figure>
<p>注意最后的那个 Attached，表明现在就在这个 Session 里。</p>
<p>如果按 <code>F6</code> 或者 <code>Ctrl-A,Ctrl-D</code> detach ，之后再看：（注意，如果第一次在 screen 按 <code>Ctrl-A</code> ，它会询问 Escape Sequence，建议选 <code>1 screen mode</code> 就好）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ byobu -ls</div><div class="line">There is a screen on:</div><div class="line">        151664.jayce    (Tuesday, September 19, 2017 05:30:12 CST)      (Detached)</div><div class="line">1 Socket <span class="keyword">in</span> /var/run/screen/jayce.</div></pre></td></tr></table></figure>
<hr>
<p>基本能用了，只是还有一个小问题：如果不记得/不确定之前的 Session 还在不在，那么操作流程是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ byobu -ls <span class="comment"># 列出当前所有 Session</span></div><div class="line">$ byobu -r mysession <span class="comment"># 如果 Session 还在就重连</span></div><div class="line">$ byobu -S mysession <span class="comment"># 如果因为重启的原因不在，新建一个</span></div></pre></td></tr></table></figure>
<p>比较麻烦。screen 自带 <code>-R SessionName</code> 参数实现『有则重连，无则新建』 的动作。可尝试把 <code>-R</code>加载 byobu 后面，不支持。byobu 是怎样接受参数并传递给 screen 的呢？试一下在没有 Session 的情况下，执行没有参数的 byobu：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ byobu</div><div class="line"><span class="comment"># Ctrl-A,D detach</span></div><div class="line">$ screen -ls <span class="comment"># 跟 byobu -ls 等价</span></div><div class="line">There is a screen on:</div><div class="line">        152910.byobu    (Tuesday, September 19, 2017 05:48:24 CST)      (Detached)</div><div class="line">1 Socket <span class="keyword">in</span> /var/run/screen/jayce.</div></pre></td></tr></table></figure>
<p><code>byobu</code> 背后执行的是 <code>screen -S byobu</code> ，也就是说，如果不指定任何参数，byobu 默认会创建一个名字叫 『byobu』 的 Session。而如果指定了（某些）参数，默认名字就不会起效。但 <code>-R</code> 不算在某些参数里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ sudo vim `<span class="built_in">which</span> byobu`</div><div class="line"><span class="comment"># 省略....</span></div><div class="line">148                 BYOBU_SESSION_NAME=<span class="string">"-S <span class="variable">$PKG</span>"</span> <span class="comment"># 这里的 $PKG 的值就是 byobu</span></div><div class="line">149                 <span class="comment"># Zero out $BYOBU_SESSION_NAME if user has specified a session name</span></div><div class="line">150                 <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></div><div class="line">151                         <span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span></div><div class="line">152                                 -*r*|-*d*|-*D*|-*S*|-ls|-list)</div><div class="line">153                                         BYOBU_SESSION_NAME=</div><div class="line">154                                 ;;</div><div class="line">155                         <span class="keyword">esac</span></div><div class="line">156                 <span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>看完上面的内容，应该就知道了『某些参数』是哪些。当指定这几个参数时，默认 Session 名就会被清空。</p>
<p>那容易，把『某些参数』改成下面的样子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">152                                 -*r*|-*R*|-*d*|-*D*|-*S*|-ls|-list)</div></pre></td></tr></table></figure>
<p>保存。好了，<code>-R</code> 可以用了。</p>
<p>就酱。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题，一分钟Mark文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="screen" scheme="https://jaycechant.info/tags/screen/"/>
    
      <category term="byobu" scheme="https://jaycechant.info/tags/byobu/"/>
    
  </entry>
  
  <entry>
    <title>OpenGrok + Universal ctags</title>
    <link href="https://jaycechant.info/2017/OpenGrok-Universal-ctags/"/>
    <id>https://jaycechant.info/2017/OpenGrok-Universal-ctags/</id>
    <published>2017-03-06T02:30:56.000Z</published>
    <updated>2017-09-24T09:04:30.354Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGrok 环境搭建踩坑。</p>
<a id="more"></a>
<p>不知道 OpenGrok 自己放 Google ，为何选它不选 Source Insight 或者 Source Navigator 也请自己查。</p>
<p>安装时，服务器上已有 JDK 和 Tomcat，这部分直接跳过。</p>
<h2 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h2><h3 id="Exuberant-V-S-Universal"><a href="#Exuberant-V-S-Universal" class="headerlink" title="Exuberant V.S. Universal"></a>Exuberant V.S. Universal</h3><p>OpenGrok 官方 Requirements</p>
<blockquote>
<ul>
<li>Latest <a href="http://www.oracle.com/technetwork/java//" target="_blank" rel="external">Java</a> 1.8</li>
<li>A servlet container like <a href="https://glassfish.dev.java.net/" target="_blank" rel="external">GlassFish</a> or <a href="http://tomcat.apache.org/" target="_blank" rel="external">Tomcat</a> (8.x or later) also running with Java at least 1.8</li>
<li><a href="http://ctags.sourceforge.net/" target="_blank" rel="external">Exuberant Ctags</a></li>
</ul>
</blockquote>
<p>前两个就不说。原打算装 Exuberant Ctags（以下简称EC） ，结果看到知乎上大家讨论，说Universal Ctags （以下简称UC）更好。</p>
<p>官网在此 <a href="http://ctags.io/" target="_blank" rel="external">http://ctags.io/</a></p>
<p>简单说，就是 EC 托管在 SourceForge 不再活跃了，UC 作为 Fork 接过接力棒，继续开发。</p>
<hr>
<blockquote>
<p> autogen.sh runs autoreconf internally. If you use a (binary oriented) GNU/Linux distribution, autoreconf may be part of the autoconf package. In addition you may have to install automake and/or pkg-config, too.</p>
</blockquote>
<h3 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h3><p>官方提醒 autogen.sh 脚本里面调用了 <code>autoreconf</code> ，先安装 automake</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install automake <span class="comment"># ubuntu, centos 用 yum</span></div></pre></td></tr></table></figure>
<p>然后跟着官方走：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/universal-ctags/ctags.git</div><div class="line">$ <span class="built_in">cd</span> ctags</div><div class="line">$ ./autogen.sh</div><div class="line">$ ./configure --prefix=/<span class="built_in">where</span>/you/want <span class="comment"># defaults to /usr/local</span></div><div class="line">configure.ac:120: error: possibly undefined macro: AC_DEFINE</div><div class="line">      If this token and others are legitimate, please use m4_pattern_allow.</div><div class="line">      See the Autoconf documentation.</div><div class="line">configure.ac:342: error: possibly undefined macro: AC_MSG_ERROR</div><div class="line">configure.ac:596: error: possibly undefined macro: AS_IF</div><div class="line">autoreconf: /usr/bin/autoreconf failed with <span class="built_in">exit</span> status: 1</div></pre></td></tr></table></figure>
<p>报错，几个宏找不到。用这几个错误搜索，有人说这个包那个包，最后发现是 <code>pkg-config</code> 解决掉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install pkg-config</div></pre></td></tr></table></figure>
<p>是不是很眼熟？是的，一开始那段提醒里就已经提到，因为 写着 or ，没当回事。安装完就不再报错了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ ./autogen.sh</div><div class="line">$ ./configure --prefix=/<span class="built_in">where</span>/you/want <span class="comment"># defaults to /usr/local</span></div><div class="line">$ make</div><div class="line">$ make install <span class="comment"># may require extra privileges depending on where to install</span></div><div class="line">$ ctags --version</div><div class="line">Universal Ctags 0.0.0(d2efd07), Copyright (C) 2015 Universal Ctags Team</div><div class="line">Universal Ctags is derived from Exuberant Ctags.</div><div class="line">Exuberant Ctags 5.8, Copyright (C) 1996-2009 Darren Hiebert</div><div class="line">  Compiled: Feb 15 2017, 15:19:35</div><div class="line">  URL: https://ctags.io/</div><div class="line">  Optional compiled features: +wildcards, +regex, +option-directory, +coproc</div></pre></td></tr></table></figure>
<p>UC 安装完毕。</p>
<h2 id="OpenGrok"><a href="#OpenGrok" class="headerlink" title="OpenGrok"></a>OpenGrok</h2><h3 id="初次索引"><a href="#初次索引" class="headerlink" title="初次索引"></a>初次索引</h3><p><a href="http://opengrok.github.io/OpenGrok/" target="_blank" rel="external">OpenGrok</a> 分两个主要部分：</p>
<ol>
<li>index 生成工具</li>
<li>搜索查询的 webapp</li>
</ol>
<p>下载之后，解压目录主要都是 1) ，llib/ 目录下的 <code>source.war</code> 则是 2)。</p>
<p>war 包直接放到 Tomcat 的 webapp 目录即可 通过 <code>http://path/to/tomcat/source/</code> 访问，只不过现在没有项目。</p>
<p>index 工具部分，主要是 lib/ 下的 <code>opengrok.jar</code> 和 bin/ 下的 <code>OpenGrok</code> 脚本。</p>
<p>网上大家讨论，往往要配置很多环境变量，调用 opengrok.jar 时还要给一堆参数。</p>
<p>我懒，直接来最简单的版本：</p>
<ol>
<li>环境变量只配置 <code>OPENGROK_INSTANCE_BASE</code> ，设为 OpenGrok 根目录，其他相关目录，你没有配置会自动在根目录下生成。然后把 <code>OPENGROK_INSTANCE_BASE/bin/</code> 加入 PATH （为了全局执行 OpenGrok ）。</li>
<li>上述配置生效后（source 或者 重新登录 ssh），将项目源码放到 <code>OPENGROK_INSTANCE_BASE/src/</code> 下 （我是直接<code>ln</code> 过去，当然你真放也行），然后 <code>sudo -E OpenGrok index</code> 。</li>
</ol>
<p>尽可能使用默认配置，除了上面半开玩笑的懒，另一方面原因是怕以后会忘掉自己怎么配置。默认配置有它的道理，刚接触拍脑袋决定很难比默认好，集中放在根目录下也方便管理。以后有新需要，再改不晚。</p>
<h3 id="关闭历史"><a href="#关闭历史" class="headerlink" title="关闭历史"></a>关闭历史</h3><p>第一次生成索引，非常顺利。</p>
<p>一段时间之后，代码有更新，重新生成索引，结果一堆报错，几乎每条都是相同内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">14:43:02 WARNING: Non-zero <span class="built_in">exit</span> code status 1 from <span class="built_in">command</span> [/usr/bin/svn, <span class="built_in">log</span>, --trust-server-cert, --non-interactive, --xml, -v] <span class="keyword">in</span> directory /path/to/the/<span class="built_in">source</span>: svn E170001: Unable to connect to a repository at URL <span class="string">'svn://path/to/SVN/repo'</span></div><div class="line">svn: E170001: Can<span class="string">'t get username or password</span></div></pre></td></tr></table></figure>
<p>原因清楚明白：OG 试图生成文件历史，对每个文件都执行 <code>svn log</code>。可是没有账号密码。</p>
<p>当然没有，我都没给它。</p>
<p>我后来查到，只要定义两个宏的值，就可以告诉它账号密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">OPENGROK_SUBVERSION_USERNAME=<span class="string">"xxx"</span></div><div class="line">OPENGROK_SUBVERSION_PASSWORD=<span class="string">"yyy"</span></div></pre></td></tr></table></figure>
<p>其实你去看 OpenGrok 托管在 github 的 <a href="https://github.com/OpenGrok/OpenGrok" target="_blank" rel="external">源码</a> ，看<a href="https://github.com/OpenGrok/OpenGrok/blob/d2db363d135fe9eb6498bf458bbc49e30a494480/src/org/opensolaris/opengrok/history/SubversionRepository.java" target="_blank" rel="external">src/org/opensolaris/opengrok/history/SubversionRepository.java</a> ，源码里写得很清楚。</p>
<p>不过因为某些原因，我暂时不想生成历史，怎么关闭历史索引功能呢？我找到了一个讨论：<a href="https://github.com/OpenGrok/OpenGrok/issues/32" target="_blank" rel="external">https://github.com/OpenGrok/OpenGrok/issues/32</a></p>
<p>简单说，只有加了 <code>-S</code> 和 <code>-H</code> 参数，才会生成历史；这点去看 <a href="https://github.com/OpenGrok/OpenGrok/blob/75f1fc793f0b203cc97c1a75dc82522f171aa431/src/org/opensolaris/opengrok/index/Indexer.java" target="_blank" rel="external">src/org/opensolaris/opengrok/index/Indexer.java</a> 能得到证实。</p>
<hr>
<p>然而，我并没有加任何参数 ？！</p>
<p>一研究，是这样，参数是传给 oepngrok.jar 的。OpenGrok 脚本默认有添加一系列参数。</p>
<p>那就简单了，直接在 /path/to/OpenGrok/bin/OpenGrok 脚本里搜索，将 <code>-S</code> 和 <code>-H</code> 去掉。很简单，就不贴出来了。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenGrok 环境搭建踩坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenGrok" scheme="https://jaycechant.info/tags/OpenGrok/"/>
    
      <category term="ctags" scheme="https://jaycechant.info/tags/ctags/"/>
    
  </entry>
  
</feed>
