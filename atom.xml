<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>存档Save&amp;Load</title>
  <subtitle>存档意味着放下包袱，搞砸了不过回来读档</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jaycechant.info/"/>
  <updated>2020-05-24T11:49:36.371Z</updated>
  <id>https://jaycechant.info/</id>
  
  <author>
    <name>Jayce Sigit Chant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在静态页中使用必应搜索</title>
    <link href="https://jaycechant.info/2020/use-bing-search-in-your-static-pages/"/>
    <id>https://jaycechant.info/2020/use-bing-search-in-your-static-pages/</id>
    <published>2020-05-24T01:20:03.000Z</published>
    <updated>2020-05-24T11:49:36.371Z</updated>
    
    <content type="html"><![CDATA[<p>博客搜索框跳转搜索结果，搜索引擎从 BD 改 必应。很琐碎，且没有什么技术含量。纯粹因为平时不写前端，记一下，避免以后忘了还得查这些琐碎的内容。</p>
<a id="more"></a>
<h2 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h2><p>博客是 github pages，生成器是 hexo，模板 landscape-plus。自带的搜索框如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.baidu.com/baidu"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"word"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">tn</span> <span class="attr">type</span>=<span class="string">hidden</span> <span class="attr">value</span>=<span class="string">"bds"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">cl</span> <span class="attr">type</span>=<span class="string">hidden</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">ct</span> <span class="attr">type</span>=<span class="string">hidden</span> <span class="attr">value</span>=<span class="string">"2097152"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"si"</span> <span class="attr">value</span>=<span class="string">"&lt;%- config.url.replace(/^https?:\/\//, '') %&gt;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;%- config.url.replace(/^https?:\/\//, &#39;&#39;) %&gt;</code> 是 hexo 的模板代码，实际页面会替换成 <code>jaycechant.info</code> 。这样写是为了把域名变成变量，避免以后如果改域名还得一个一个地方修改。</p>
</blockquote>
<p>就一个 form，action 设置为 get baidu 搜索页，下面的 input 都会按 name 追加在 query string。通过这种方式，在提交时跳转到一个搜索结果。</p>
<p>例如，搜索博客的关于 Golang 的内容：<code>http://www.baidu.com/baidu?word=Golang&amp;tn=bds&amp;cl=3&amp;ct=2097152&amp;si=jaycechant.info</code></p>
<p>显示：<strong>很抱歉，没有找到与“Golang”相关的网页。</strong></p>
<p>很长一段时间，都没有注意到它。早期文章少，也用不上搜索。</p>
<p>直到有一天，发现博客还有引用 http 资源，排查的时候，才留意到这个搜索框。因为众所周知的原因，不想用 BD。何况它也没收录我的博客。</p>
<h2 id="更换"><a href="#更换" class="headerlink" title="更换"></a>更换</h2><h3 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h3><p>首选 Google。不过这不光是给我用的，读者也可能用，只能选方便访问的 Bing。</p>
<p>同样在 Bing 搜上面的内容，拿到对应的 URL ：<code>https://bing.com/search?q=site%3ajaycechant.info+Golang</code></p>
<p>这回有结果了。</p>
<p>不过 <code>site</code> 参数跟搜索关键词混在一起，需要想办法自动添加。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://global.bing.com/search"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"si"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"&lt;%- config.url.replace(/^https?:\/\//, '') %&gt;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"ensearch"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样是不行的。Bing 不识别 <code>si</code> 。类似的， <code>site</code> 也不识别。搜索，查文档，测试，Bing 貌似没有给来源站点提供独立的 query 参数。</p>
<p>也试过放两个 <code>q</code> 参数，后面那个 <code>&lt;input name=&quot;q&quot; type=&quot;hidden&quot; value=&quot;site:jaycechant.info&quot;&gt;</code> ，也不行，同名的两个 query 参数，只有最后一个会起效，相当于覆盖效果。</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>然后发现自己陷入思维定势。被从原来的搜索框改限定了思路。</p>
<p>用 js 拼接一下 q 的 value 就可以了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://global.bing.com/search"</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span> <span class="attr">onsubmit</span>=<span class="string">"document.getElementById('searchtext').value+=' &lt;%- config.url.replace(/^https?:\/\//, '') %&gt;';return true;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"searchtext"</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"ensearch"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样已经足够简单了，不过表单一提交就会跳转到搜索页，能不能留住读者，不要跳出博客？这个简单，可以用 <code>target=&quot;_blank&quot;</code> 解决。</p>
<p>不过还有一个问题：关键词被修改了，如果连续搜索，关键词会不断添加 site。要么难看，干扰真正的关键词；要么要读者手动删掉。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>还是思维定势：这个 form 一定要提交吗？</p>
<p>直接 <code>onclick=&quot;window.open(&#39;&#39;)&quot;</code> 不行吗？</p>
<p>回车不起效？拦截 keycode 就好了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"searchtext"</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span> <span class="attr">onkeypress</span>=<span class="string">"if(event.keyCode==13)&#123;document.getElementById('searchsub').click();return false;&#125;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"searchsub"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span> <span class="attr">onclick</span>=<span class="string">"window.open('https://global.bing.com/search?q=site:&lt;%- config.url.replace(/^https?:\/\//, '') %&gt; '+document.getElementById('searchtext').value, '_blank')"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"ensearch"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>效果还满意，不多折腾，收工。</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>除此以外，还有一些备选方案，因为时间关系，没有折腾，先 Mark。</p>
<h3 id="第三方站内搜索"><a href="#第三方站内搜索" class="headerlink" title="第三方站内搜索"></a>第三方站内搜索</h3><p>调用第三方的服务，如 <a href="http://www.swiftype.com/" target="_blank" rel="external">Swiftype</a> ，<a href="https://www.algolia.com" target="_blank" rel="external">algolia</a>，<a href="https://www.bonsai.io/" target="_blank" rel="external">Bonsai</a>，<a href="https://www.expertrec.com/" target="_blank" rel="external">ExpertRec</a>，<a href="https://www.aliyun.com/product/opensearch" target="_blank" rel="external">阿里云开放搜索</a> 等。</p>
<p>简单说，注册帐号，提供站点地址，配置各种选项，他们就帮忙索引。然后通过 API 也好，嵌入 js 也好，提供搜索服务。</p>
<p>本质上跟传统搜索引擎没有太大区别，只是既然你注册了，就一定会收录你的站点，以及可以配置。</p>
<p>相应的，多数收费，最多提供有条件的免费（限时、限额）。</p>
<h3 id="基于-js-的站内搜索"><a href="#基于-js-的站内搜索" class="headerlink" title="基于 js 的站内搜索"></a>基于 js 的站内搜索</h3><p>静态博客如果不想依赖其它服务，那么唯一可以提供动态能力的，就只有 js 了。仍然是静态页，没有 hosted server，就把跑脚本的负担，转移到浏览器。</p>
<p>选项有 <a href="https://lunrjs.com/" target="_blank" rel="external">lunr.js</a>，基于 lunr.js 的 <a href="https://github.com/weixsong/elasticlunr.js" target="_blank" rel="external">elasticlunr.js</a> ， <a href="https://fusejs.io/" target="_blank" rel="external">Fuse.js</a> 等。</p>
<p>简单说，静态站点生成时，就把索引一起生成。搜索时，脚本在用户端运行，读取索引进行搜索。</p>
<p>看着很美好，但是有一些因素制约了使用：</p>
<ul>
<li>所有索引数据加载到用户端，并在浏览器运行，对于网速和性能有一定要求，否则影响用户体验。</li>
<li>同样的，索引数据不能太大，因此不适合大站点使用；小站点也不方便做全文索引，大多只索引 title 和 tag。</li>
<li>需要索引，也就需要分词，很多 lib 对中文支持不好，需要额外增加插件或者踩坑。</li>
</ul>
<p>纯记录，暂时没有动力折腾这两种方案。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客搜索框跳转搜索结果，搜索引擎从 BD 改 必应。很琐碎，且没有什么技术含量。纯粹因为平时不写前端，记一下，避免以后忘了还得查这些琐碎的内容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写作之难（二）：认知隧道 与 两步笔记法</title>
    <link href="https://jaycechant.info/2020/cognitive-tunnel-and-2-step-note-taking/"/>
    <id>https://jaycechant.info/2020/cognitive-tunnel-and-2-step-note-taking/</id>
    <published>2020-05-18T14:52:00.000Z</published>
    <updated>2020-05-20T18:00:47.233Z</updated>
    
    <content type="html"><![CDATA[<p>接着聊上次写作的话题，顺便记一个最近学到的，写作和资料整理方面的技巧。</p>
<a id="more"></a>
<h2 id="写作之难"><a href="#写作之难" class="headerlink" title="写作之难"></a>写作之难</h2><p>我之前写过《<a href="https://jaycechant.info/2020/difficulties-of-writing/">写作困难：你是否有类似的烦恼？</a>》，提到写文章时遇到的困难和思考。这是一个大题目，落笔时正处在困惑当中。我希望通过写的过程来让自己想清楚，结果写得很痛苦，最后删删改改，眼看成为时间黑洞，就把当时想到的先写下来结束掉。</p>
<p>那篇里面初步写了两个事情：</p>
<ul>
<li><p>结构</p>
<p>  思维 和 文本 的结构差异极大，而且想法稍纵即逝。所以我花了很长篇幅，试图通过工具和技巧，去减低难度。仿佛有了神器和窍门，文章就出来了。</p>
</li>
<li><p>内容</p>
<p>  可改进了技术，才发现，内容才是最大的困境。不会储存、运输、加工、包装，固然是浪费原材料；但空有一条生产线，没有原料也白搭。对于持续获得有价值的内容，我尚未形成自己的见解。</p>
</li>
</ul>
<h2 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h2><p>后来看到王树义老师的文章（公众号：玉树芝兰）。他在《如何高效写长文？》中，引用 史蒂芬·平克 在《风格感觉》里的话，来解释什么是写作的『非线性』：</p>
<blockquote>
<p>写作之难，在于把 <strong>网状的思考</strong>，用 <strong>树状的语法结构</strong>，转换成 <strong>线性字符串</strong>。（“The Web, the Tree, and the String”）。</p>
<footer>—史蒂芬·平克, <cite>风格感觉</cite></footer>

</blockquote>
<p>简单一句话，比我痛苦思考之后的长篇大论要清晰得多。</p>
<p>这个非线性，就是上面说到的，思维 和 文本 的鸿沟。</p>
<p>在认知上，要意识到差异的存在，并且训练自己适应这种转换；同时懂得使用工具去辅助。</p>
<h2 id="内容匮乏"><a href="#内容匮乏" class="headerlink" title="内容匮乏"></a>内容匮乏</h2><p>再看到王老师另一篇文章《如何高效实践卡片式写作？》。里面他强调，不要 <strong>自顶向下去</strong> 填写内容；要让材料 <strong>自底向上</strong> 地 <strong>生长</strong> 。</p>
<blockquote>
<p>如果此时你手头，已经有了一堆卡片。这些卡片拼在一起，已经可以勾勒出整个文章的版图。那么这篇文章，就基本上可以当做是“生长”出来，而非“生产”出来。</p>
<footer>—王树义, <cite>如何高效实践卡片式写作？</cite></footer>

</blockquote>
<p>（王老师用卡片积累素材。我从阳志平老师的文章了解过卡片写作法，之前写文章也有提过。目前还在寻找适合自己的工具，时机成熟了再给大家介绍我的实践。）</p>
<h3 id="向下分解？"><a href="#向下分解？" class="headerlink" title="向下分解？"></a>向下分解？</h3><p>得益于写代码的经验，我很轻易地意识到写作有 自顶向下 和 自底向上 这两种方式，并在之前的文章中指出。可我的理解是具体写作场景决定方向：</p>
<ul>
<li>平日对一件事积累了各种材料和想法，有一天所有思考在一个点上汇合了，整理成文，就是自底向上。</li>
<li>要是命题作文，包括作文、演讲、辩论稿，给定了题目，就只能自顶向下了。</li>
</ul>
<p>记忆里 自顶向下 的情况占多数。写文章没那么多『恍然大悟』，一方面各种命题作文，另一方面有时为了学一个技能、理解一个知识点，要通过输出特定主题内容，促进学习。</p>
<p>也就是说，多数情况下我们就是 <strong>主题 -&gt; 大纲 -&gt; 填写内容</strong> 这样的顺序在写东西。 <strong>主题 总是先于 素材</strong> 进入我们的意识。我们对一个主题有概念之前，接收不到相关的信息，也无法进行有效的思考。</p>
<p>如果从没开过车，在路上你会留意车道导向吗？调头是最左车道还是最右车道？</p>
<p>也许你是老司机，很熟。那你留意过路边的通信基站吗？自行车绿道呢？</p>
<p>这些信息你一定见过，可脑海里没有概念，相关内容只是被忽略的噪音。都能答得上的，大概是一位开车上下班、闲暇喜欢骑行的通信工程师。（不是我，不要对号入座）</p>
<p>外行人要写，只能是拿到命题之后开始留意。自顶向下很自然啊，有什么问题？</p>
<h3 id="认知隧道"><a href="#认知隧道" class="headerlink" title="认知隧道"></a>认知隧道</h3><p>《如何高效实践卡片式写作？》点出了关键：先有网再被动填充节点，会造成心理压力，继而造成 认知隧道（cognitive tunnel）。这里王老师说他是引用 采铜老师的笔记（公众号：采铜的创想世界，我没找到出处）：</p>
<blockquote>
<p>全部的注意力都聚焦在当下那件紧急的事情上，变得特别狭窄和受限，此时容易忽略全局的信息，看不到整体。</p>
</blockquote>
<p>所谓一叶障目，不见森林。这让我想起被 命题作文 支配的恐惧。眼看交卷时间一秒一秒接近，构思的内容就是写不出来；眼看明天就要上台比赛，大半夜讲稿还是挤不出来；眼看马上要出门办事了，文件就是不记得放哪了。</p>
<p>更气人的是，卷子一交，比赛一结束，手续一办完，原本想不通理不顺记不得的东西，突然一下子通了、顺了、记得了。</p>
<p>我知道 认知隧道 是怎么一回事了。</p>
<h3 id="功夫在平日"><a href="#功夫在平日" class="headerlink" title="功夫在平日"></a>功夫在平日</h3><p>可前面也说了，自顶向下分解 是情景所迫，并非主动选择。我是这样考虑的：</p>
<blockquote>
<p>先有概念，然后才能有意识地 积累素材 和 思考。</p>
<p>可你未必要等拿到命题，才能接触这个主题。</p>
</blockquote>
<p>成功的观点输出，很少是事前毫无概念、毫无准备的，更不是单凭拿到命题之后的准备时间，就能完成整张思维网络的构建。哪怕是即兴演讲，成功的输出者，也一定有自己的知识积累。</p>
<p>准备不足，以致作文命题没听过，现场辩题看不懂，来不及查资料和细想，那就只剩下瞎掰一个选项。同样的情况，哪怕准备时间换成一晚，一周，一个月，只要 准备不足 + deadline 的压力把思维逼进墙角，也不过是卡壳和拖延来回切换。（你写过毕业论文吗？）</p>
<p>就好像内存不够的电脑卡顿了，如果因为慌张一顿瞎操作，结果只会更卡。（见过太多人喜欢按刷新。）</p>
<p>你本该对命题范围早有准备，也在之前了解过相关信息，有过思考。临场不过提取之前的积累，进行二次加工。换句话说，我们是把这个现场 <strong>向下建立</strong> 的 <strong>金字塔尖</strong> ，嫁接在之前 <strong>早已准备好</strong> 的 <strong>底座</strong> 上，最后导向塔尖上的结论。</p>
<p>只是很多时候，之前的了解和积累、甚至临场的记忆调取都是下意识进行，所以才会觉得成功的命题作文是完全自顶向下写出来的。事实上，根本 <strong>不会有人纯粹地向上构建（build up）或向下分解（break down）</strong> 。思考是 <strong>网状</strong> 的，只是 <strong>下笔时为了简化</strong> ，才 <strong>裁剪成树状逻辑</strong>。向上『生长』成文，也需要向下组织内容，和主动检索补充细节；那么向下分解，当然也要用之前『培育』的材料。</p>
<p><img src="../../images/cognitive-tunnel-and-2-step-note-taking.png" alt=""></p>
<blockquote>
<p>本文的结构树</p>
</blockquote>
<p>命题作文不可避免，就要在平时准备更多用得上的材料，把『底座』准备得更坚实，这样才能把临场构造的工作量最小化，尽量限定在 <strong>结构调整</strong> 和 <strong>语言润色</strong> 的范围内。</p>
<p>试想『小学生应不应该使用智能手机』的讨论，对 小学生 和 智能手机 有概念的普通人，都能简单发表一些看法。而关注教育相关信息、少年儿童的心智特点 还有 智能手机相关知识的人，显然观点质量会更高。与之相反，一个从未用过智能手机的人，哪怕题目背景给介绍智能手机，他的观点也只能基于臆测，结论很难靠谱。</p>
<p>所以，最后还是回到平日里 做事、读书、思考。</p>
<h3 id="出坑"><a href="#出坑" class="headerlink" title="出坑"></a>出坑</h3><p>我想，如果做菜时，锅热下油后，才发现缺了主要食材，我们会杵在原地，给自己施加压力说『赶紧把食材变出来』吗？不会吧。</p>
<p>那为什么我们会认为对着 纸笔 和 键盘，就能憋出点什么？</p>
<p>有了这个认识，我想还是无法避免再次因为紧迫的任务掉进『认知隧道』里。但那时大概能意识到自己在坑里， <strong>赶紧先关火</strong> ，改出去下馆子，或者改做冰箱里有材料的菜。就算领导点名要吃这道菜，能不能商量下顿做，或者赶紧再去一趟菜市场。</p>
<p>跳出来，别在原地耗着。</p>
<h2 id="笔记做两次"><a href="#笔记做两次" class="headerlink" title="笔记做两次"></a>笔记做两次</h2><p>关于用笔记积累素材，王老师强调了一些原则，我总结如下：</p>
<blockquote>
<ul>
<li><p>集中保存、内容完整、含上下文。</p>
<p>  他举了爱在书边空白写『这个问题我已经会证明了』的费马作为反例。  </p>
<p>  不好好集中记，容易忘记含义、上下文，甚至直接把笔记弄丢。</p>
</li>
<li><p>记笔记不能干扰本来在做的事。</p>
<p>  我们先是在做事、听课、讨论。因为内容很重要，或者当时受到了启发，决定记笔记。  </p>
<p>  不赶紧记，会忘；优先级太高，容易分心扰了正事。</p>
</li>
<li><p>要用自己的话，不能光是摘录。</p>
<p>  这里面包含至少两个原因：</p>
<ul>
<li><p>只有理解清楚了，才能用自己的话讲清楚。</p>
<p>  这是用输出倒逼输入，是 <strong>费曼技巧</strong> 的核心。</p>
</li>
<li><p>版权保护表达不保护思想。</p>
<p>  笔记将来要用在自己的输出里，思想可以借鉴，表达必须是自己的话，这样才能减少侵权的风险。（题外话：相对直接的借鉴，哪怕用自己的话复述，也要署名和列出处，否则就成了洗稿了。）</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>好难。</p>
<p>做到 第一点 和 第三点 就已经非常难了。然后第二点还跟这两点冲突。</p>
<p>王老师说，那就记两次。</p>
<p>第一次，以不干扰为优先，先随便记录，确保靠这个记录短时间内能想起来详情。</p>
<p>然后，24 小时之内——我想最好可能是当天睡前——好好实施 第一点 和 第三点：集中、完整、以平时一贯的方式，用自己的话复述。</p>
<h3 id="关键词-钩子"><a href="#关键词-钩子" class="headerlink" title="关键词 + 钩子"></a>关键词 + 钩子</h3><p>这时，我突然想起 李照楠老师（公众号：L先生说）在《这套法则，治好你的信息焦虑》里讲过的『关键词 + 钩子』整理资料的办法。这是 18 年的文章，我去翻了当时的笔记。</p>
<p>面对海量的信息，他按 <strong>兴趣高低</strong> 和 <strong>是否系统</strong> ，分成了四类：</p>
<blockquote>
<ul>
<li><p>兴趣低 + 零碎 = 噪音</p>
<p>  舍弃。多数热点属于这类。对我来说短视频也算。</p>
</li>
<li><p>兴趣高 + 系统 = 方法</p>
<p>  直接操作、实践。因为系统，实践意愿又高，所以最好直接动手做。这篇文章里我学到的几个方法就是这种。</p>
</li>
</ul>
</blockquote>
<p>这两个都很明确。我认为重点在剩下两类</p>
<blockquote>
<ul>
<li><p>兴趣高 + 零碎 = 想法</p>
<p>  记笔记，思考，找材料，让它变系统。自己平时冒出来的想法属于这种。</p>
</li>
<li><p>兴趣低 + 系统 = 资料</p>
<p>  记笔记，关键词描述是什么有什么用，钩子描述用到时去哪找。现成成体系的内容，暂时用不上，弃之可惜，又没必要投入太多精力，就留下『关键词 + 钩子』，等以后感兴趣、有需要。</p>
</li>
</ul>
</blockquote>
<p>我当初看到文章时，就把这篇文章归入了 资料。有理有据有实操，算系统的内容。但当时我还没有太深的体会，也不愿意投入太多精力尝试。所以就按里面的方法，建立了一篇钩子笔记。体会浅，没坚持下来，这就成了唯一一篇钩子笔记，后面就忘了 [捂脸]。两年后，试图用关键词搜索找回文章而不得，还是凭笔记找回来的。确实有用。</p>
<h3 id="我的版本"><a href="#我的版本" class="headerlink" title="我的版本"></a>我的版本</h3><p>具体到每个人的做法，就要跟自己的工作和生活习惯，使用的工具相关。如果之前有积累，还要考虑迁移成本。</p>
<p>我笔记系统的出发点，首先是剪贴。</p>
<p>我在高中摘抄和剪贴了好几本笔记。大学后期开始用 <strong>为知笔记</strong>，到现在第十个年头，笔记 6K +，是最早一批 VIP，并打算一直续费下去。在有了 Evernote、OneNote、有道云笔记 等竞争者的今天，为知算不上多优秀。但前身是『网文快捕』的为知，剪贴线上内容一招鲜，对样式的兼容程度暂时没有看到竞争者。</p>
<p>十年里见过太多网站和服务下线，也有作者自己删文。当时只留链接的，现在很多成了死链。所以我不能真的只留『关键词 + 钩子』，而是要一份资料的 <strong>完整拷贝</strong> 。我也很早意识到，记笔记负担一定要小，不能干扰正事，要容易坚持。所以操作麻烦的，拷贝资料之后格式识别会崩的，不能跨平台同步的，都被淘汰出局。</p>
<p>就因为这点，为知的小缺点都无伤大雅。何况为知还跨平台，PC 本地全量备份（可离线），手机部分缓存（省空间）。何况它还开源，有自建私服的选项。它对 Markdown 的支持是真的弱，所以我用 Typora 当外部编辑器。</p>
<p>一旦确定原始材料的归宿，剩下的工作除非完全不兼容，都会围绕着它进行。之前资料太多，试过分目录，成效不好，改为标签 + 搜索。现在学会了 二次整理笔记，还有在拷贝基础上 关键词概括 + 钩子，就会在整理笔记时，<strong>增加一种笔记类型，专门概括和索引其他笔记</strong> 。为知支持笔记内链，虽然功能很弱。</p>
<p>大纲 和 思维导图 是没有的，需要整理思路时，只能引入 幕布。还好幕布也是跨平台同步，所以也买了 VIP。</p>
<p><img src="../../images/note-taking-workflow.svg" alt=""></p>
<blockquote>
<p>文档工作流的一部分，原始素材以及基于原始素材的链接，在为知笔记上进行。</p>
</blockquote>
<p>这是我的版本，不一定适合你的情况。</p>
<p>就好像我通过上面提到的几位在 认知 和 写作 方面的老师（他们好像都学心理学和会编程），知道了卡片式写作，知道了 Scrivener、Gingko、Devonthink、Roam research 这些工具，看着很高大上，是否适合我，如何从当前的工作流迁移，还需要尝试和磨合。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不知道这篇算不算自底向上生长的成果。我是带着问题，看了很多文章之后，加上自己的思考，在相对成熟的时机，写了这些文字。果然，比之前那篇写起来要顺利很多。</p>
<p>最终成文要组织调整这些材料时，仍然是一个向下分解的过程，但是分解到具体观点，素材已经等着我了。</p>
<p>果然人不能闭门造车，要多学习。不过没有痛苦思考的过程，可能也体会不到这句话背后的分量。子曰：『学而不思则罔，思而不学则殆』。</p>
<p>先聊到这，回头要把《风格感觉》看完，把 6 千多条历史笔记整理一下。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着聊上次写作的话题，顺便记一个最近学到的，写作和资料整理方面的技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://jaycechant.info/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>评论：为什么你应该学 Go ？</title>
    <link href="https://jaycechant.info/2020/review-why-should-you-learn-go/"/>
    <id>https://jaycechant.info/2020/review-why-should-you-learn-go/</id>
    <published>2020-05-17T04:48:48.000Z</published>
    <updated>2020-05-18T05:00:18.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇评论是我 ARTS 打卡中 Review 的部分，也就是阅读一篇英语（技术）文章，然后评论。</p>
<p>第一次做，也不知道做得对不对。不管，先实践，慢慢就会好的了。</p>
</blockquote>
<a id="more"></a>
<p>平时太过于依赖翻译，只有极少数觉得翻译质量不好，乃至内容存疑，才会主动去翻英语资料。</p>
<p>所以当第一次为了打卡 <strong>无目标地主动</strong> 找英文材料看，突然不知道从哪里找起。翻了半天，大多是社交网络的碎片内容。眼看时间浪费了不少，先随便找了一篇，正好我最近也想写一下学 Go 的原因。</p>
<p>《Why should you learn go?》，文章地址：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="external">https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65</a> （17 年 1 月的文章，有点旧。特别提醒，Medium 为 推家 旗下网站，访问需工具。）</p>
<p>如题，作者罗列了推荐 Go 的理由。我先简单总结作者观点（只是用引用格式区分，并非原文），再提出我的看法。</p>
<h2 id="硬件限制"><a href="#硬件限制" class="headerlink" title="硬件限制"></a>硬件限制</h2><blockquote>
<p>摩尔定律正在失效</p>
<p>过去十几年，计算机（单核）算力没有明显的变化。</p>
<p>随着在微观尺度上量子效应越发明显，堆砌晶体管数量也变得越来越难，越来越不经济。现在厂商只能增加内核数量和增大缓存。但这些办法也有其限制，很快就无法继续。</p>
</blockquote>
<p>同意。我们认为开发者的时间比较宝贵，以及我们渴望更酷炫的效果，结果就是硬件进步获得的性能，都在软件层面被挥霍掉。我们愿意花费大量的算力，只是为了提升一点点人工的效率。过去这么多年，摩尔定律虽然不精确，也基本预言了性能提升的趋势。软件的最终运行速度，不仅没有怎么提升，甚至有些还变慢了。</p>
<p>这种『挥霍』多数情况下，<strong>其实是合理</strong> 的。假定 10 年里算力提升了 50 倍，面对一个要 80 工时开发的，10 年前运行时间要 1 秒的程序，有两个选择：</p>
<ul>
<li>维持 10 年前的开发方式，开发工时和运行效率都不变。这意味着算力提升后，程序运行时间变成 1/50，也就是 20 ms。获得了 980 ms 的提升。</li>
<li>为了减轻开发负担，引入更多中间层，屏蔽更多细节。一般来说，我们不能忍受变得更慢，理想情况下，运行效率的降低大致上更好跟算力的提升打平，也就是运行时间在 10 年后还是 1s，以此换得开发时间减半。开发者省下了 40 工时。</li>
</ul>
<p>例子非常粗糙，现实世界比这个复杂得多，但勉强能说明问题：50 倍 和 2 倍，看似前者更重要。可现实中我们比较的是差值。980 ms 运行速度提升，没有人在意；而 40 工时的提速，实际上重要的多。至于这 40 工时再被不确定的需求浪费掉，就是另一个故事了。</p>
<p>摩尔定律有效时，『挥霍』是理性的选择。不过，随着大规模分布式系统的普及，以及摩尔定律逐渐失效，在处理器有基础突破之前（超导？量子？），运行效率应该被重新重视起来。</p>
<h2 id="Go-有协程"><a href="#Go-有协程" class="headerlink" title="Go 有协程"></a>Go 有协程</h2><blockquote>
<ul>
<li>轻量用户级协程，2KB 低开销，动态增长栈，MPG 调度模型 …… 轻易开到百万协程。对比之下，Java 线程开销 1MB 起。</li>
<li>CSP （Communicating Sequential Process，通信顺序进程）并发模型，可以大幅降低正确并发代码的心智负担。</li>
</ul>
<p>总的来说，就是 09 年诞生的 Go，比这些上个世纪诞生的老前辈，更原生地支持 并发 和 并行。</p>
<p>用作者话说，强大如 Java，C/C++；代码直白优雅如 Erlang。</p>
</blockquote>
<p>作者指出在摩尔定律失效的年代，靠增加 CPU 核心来提高算力。相应地，程序需要良好的并发，乃至部署分布式的系统（原文用的微服务）来更好地利用这些算力。</p>
<p>但随着了解深入，作为 Go 吹的我也必须指出两点：</p>
<ul>
<li>Java 通过第三方库也引入了协程 和 CSP。虽然使用不如原生的直接，但是结合 Java 已有的生态，还是增强了 Java 在并发方面的能力，使得 协程 + CSP 不再是 Go 的专属。</li>
<li>CSP 的底层依然是靠 锁 实现的，只是通过封装向开发者屏蔽了复杂性。在大多数场景，性能不差，同时大大降低了心智负担。但是极端情况下，还是自己控制锁的粒度才能最大限度发挥性能，这时 Go 并没有明显的优势。</li>
</ul>
<h2 id="Go-直接运行在硬件上"><a href="#Go-直接运行在硬件上" class="headerlink" title="Go 直接运行在硬件上"></a>Go 直接运行在硬件上</h2><blockquote>
<p>其实就两点</p>
<ul>
<li>Go 是编译语言</li>
<li>Go 没有虚拟机</li>
</ul>
<p>作者就是想说，Go 没有虚拟机，运行接近 C/C++ 的速度，但又不用像 C/C++ 那样自己管理内存。</p>
</blockquote>
<p>这里要提点反对意见了。早些年我也想当然地认为，Go 接近 C/C++ ，Go 肯定比 Java 快。</p>
<p>现在我要说，这是 <strong>分场合的</strong> 。Java 凭借多年深厚的积累，特别是在不同场景下的 JIT 或 AOT 优化，有些情况就是比年纪尚轻的 Go 快。当然，发生在特定场景，在 Java 可以优化，而 Go 还没有或者基于某些设计不能进行优化的时候。更多情况下，Go 比 Java 快一点，或者差不多。懒得研究和稀泥说法是，它们都在比 C/C++ 略慢的第二梯队，比多数高级语言要快。但有一点是确定的，<strong>不能闭着眼睛说 Go 没有虚拟机就一定比有虚拟机的 Java 快</strong> ！</p>
<p>编译语言、没有虚拟机真正的优势在于，无依赖地跨平台发布。实际上，通过一些技巧，还能达到单文件发布。做过运维搞过批量部署的同学，会知道这是多么宝贵的特性。</p>
<h2 id="Go-容易维护"><a href="#Go-容易维护" class="headerlink" title="Go 容易维护"></a>Go 容易维护</h2><blockquote>
<p>Go 非常克制地保持了一个简洁和清晰的语法。</p>
<p>它拒绝了很多现代高级语言会有的特性，来避免副作用：</p>
<ul>
<li>类</li>
<li>继承</li>
<li>构造函数</li>
<li>注解</li>
<li>泛型</li>
<li>异常处理</li>
</ul>
<p>它宁可让你多写两三行代码，也要保持代码的简洁明了和运行高效。</p>
<p>另外，Go 语法非常稳定，保持了很好的向后兼容。（向后指 backward，跟中文的语义理解上相反，其实指新版本兼容老版本，新环境能跑老代码）</p>
</blockquote>
<p>这确实是值得称道的点。Go 核心团队以他们多年的经验，精心挑选了核心的特性，然后努力避免不必要的特性让语言变得臃肿。</p>
<p>但是，这往往也是一个被吹捧过度的点。例如缺乏泛型 是 Go 一直被诟病的。</p>
<p>缺乏泛型，让开发者不得不在 数据结构部分 <strong>充斥复制粘贴</strong> 和 <strong>大量依赖代码生成器</strong> 之间做选择。</p>
<p>这就是语言表达力的问题。冗余代码就是会带来管理负担，代码生成器就是会引入额外依赖。</p>
<p>官方也没说过不需要泛型。只是说泛型相对不急，还没找到更好的实现方案，团队先把时间花在优化性能上。</p>
<blockquote>
<p>一旦说了 Yes，之后就必须一直 Yes。现在说 No，以后还有机会说 Yes。（大意复述）</p>
</blockquote>
<p>这才是核心团队的意思。泛型的草案已经讨论有年头了，社区的呼声也非常高。期待 Go 泛型的到来。</p>
<p>无论如何，足够精简的特性，对于 编译速度、运行速度 还有 开发者的心智负担，都很重要。也正是凭借这些方面的优势，让 Go 在各个方面都能做到接近第一梯队，然后整体下来一看，综合很强。</p>
<h2 id="背靠-Google"><a href="#背靠-Google" class="headerlink" title="背靠 Google"></a>背靠 Google</h2><p>以及很多大公司在用。</p>
<p>严格来说，这是生态角度。生态的几个指标：大厂支持，杀手案例，活跃社区，企业框架。</p>
<p>但是文章作者角度刁钻地说出了一个算技术方面的理由：</p>
<blockquote>
<p>Google 见过大场面，Google 有世界最大规模的云设施之一，由它设计的语言一定会把它遇到的问题考虑进去，做到可扩展和高效。</p>
</blockquote>
<p>呃，G 厂厉害也不是这样吹的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最后的结论还是『虽然我考试每科都是老二，但是总分高啊』。</p>
<p>运行速度不如 C/C++ ，但是开发效率和心智负担妥妥碾压。C/C++ 历史包袱重，对新手意味着学习曲线更陡、坑更多，对团队意味着管理难度高。对于离得硬件和性能稍微远一些的开发，这些代价可能不值得。</p>
<p>表达力、开发自由度不如 JavaScript 和 Python，但是静态安全性和速度又是遥遥领先。</p>
<p>所以 Go 就是很适合作为 CLI 工具、web 服务（特别是云原生的微服务）的开发语言。</p>
<p>因为优秀的类库还需要积累，又缺乏企业级的开发框架，距离 Java 还是有距离。但是发展到今天：</p>
<ul>
<li>大厂支持一开始就有，含着金钥匙诞生。</li>
<li>杀手级案例，最早是 Docker 和 K8s，后面越来越多云生态的组件加入。</li>
<li>社区人气是够的，其中中国开发者又是最捧场的。第三方库勉强够用，但是不足够好。特别是包管理转向 module 后很多包遗留了兼容问题。</li>
<li>最后只是缺足够强大全面的，可以对标 spring 的开发框架。</li>
</ul>
<p>学 Go 肯定是值得的。老手可能花一个小时就能大概上手。当前 Go 已经可以用于生产环境，用来搭建运维工具箱，或者实现一个服务。它就好像是专门为 分布式 和 云 准备的。但如果整个技术栈完全用 Go，生态还不如 Java 完善，可能还要自己踩一些坑。</p>
<p>必须承认，在强大全面的 Java 面前，Go 还是个弟弟。但奔 3 的 Java 已经开始有点油腻，才 10 岁的 Go 正年轻。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇评论是我 ARTS 打卡中 Review 的部分，也就是阅读一篇英语（技术）文章，然后评论。&lt;/p&gt;
&lt;p&gt;第一次做，也不知道做得对不对。不管，先实践，慢慢就会好的了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="review" scheme="https://jaycechant.info/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 25: Reverse Nodes in k-Group</title>
    <link href="https://jaycechant.info/2020/leetcode-25-reverse-nodes-in-k-group/"/>
    <id>https://jaycechant.info/2020/leetcode-25-reverse-nodes-in-k-group/</id>
    <published>2020-05-16T10:25:33.000Z</published>
    <updated>2020-05-16T17:05:43.369Z</updated>
    
    <content type="html"><![CDATA[<p>好久不刷题，还得捡起来。</p>
<a id="more"></a>
<p>太久不刷，不好一来就选太难。好奇 LeetCode 中国有啥区别，逛了一下，刚好发现置顶推荐 25 号题，选择困难症表示就它了。（不过考虑到翻译和讨论质量，还是刷 LeetCode 原版，最多两边都提交一下。）</p>
<p>题目在此：<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="external">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一句话题意：给定链表 和数字 k，把链表按照每 k 个节点一组，组内原地倒序；最后不满 k 个的剩余元素保留原样。</p>
<p>例子：</p>
<p><code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>k = 2 时，返回 <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>k = 3 时，返回 <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p>约束：</p>
<ul>
<li>只能使用常数规模的额外内存</li>
<li>不能修改节点的值，而要动链表的结构</li>
</ul>
<p>题目只需要实现给定签名的 <code>reverseKGroup(head *ListNode, k int)</code> 函数，不需要写完整的程序。</p>
<hr>
<p>就是考察链表基本操作的题目，这样的题目居然也标 Hard？</p>
<p>水题一道，为了避免浪费读者时间，<strong>刷题老手可以关闭了</strong> 。新手可以参考一下我的解题流程和切入思路，毕竟没有难点可说。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="测试驱动"><a href="#测试驱动" class="headerlink" title="测试驱动"></a>测试驱动</h3><p>题目虽然简单，但链表操作还是比较违反直觉的。</p>
<p>『七加减二』法则说，人只能在短时记忆里同时处理 5 到 9 个内容。而最新的研究表明，实际上人类的平均值更低，大约只有 4。（你知道为什么一般记数字都是 4 个一组记了吧）</p>
<p>如果光凭想象，多数没有经过特殊训练的人，很快就不记得哪个节点指向哪个了。所以开始前对于新手有两个建议：</p>
<ul>
<li>拿好纸和笔，没有把握的内容，写下来推算</li>
<li>写实现之前，先写测试</li>
</ul>
<p>事实上，这两个建议对实际的软件开发也是适用的。很多时候，大家信心满满，觉得这么点事情，拿纸笔和写测试的时间是浪费。可很快就会发现，节省的时间跟陷入莫名错误时调试耗的心力和时间比，根本不算什么。正所谓『磨刀不误砍柴工』。</p>
<p>第二个建议，如果按规范执行，就是所谓的 TDD （测试驱动开发）。这里不展开，不知道的自己查一下。最近一直在用 Go，刷题也是。借助 Go 自带的测试框架，很快就可以写出这样的单元测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 静态类型检查</span></div><div class="line"><span class="keyword">var</span> _ fmt.Stringer = (*ListNode)(<span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">// String 方法方便调试输出</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *ListNode)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	b := strings.Builder&#123;&#125;</div><div class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</div><div class="line">		<span class="comment">// 为了省事，不特殊处理最后的逗号</span></div><div class="line">		b.WriteString(fmt.Sprintf(<span class="string">"%d%s"</span>, head.Val, <span class="string">","</span>))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> b.String()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从切片（Go 的动态数组）生成链表，避免声明链表的麻烦</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceToList</span><span class="params">(s []<span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	<span class="comment">// 为了不用特殊处理，头节点留空</span></div><div class="line">	head := <span class="built_in">new</span>(ListNode)</div><div class="line">	last := head</div><div class="line">	<span class="keyword">var</span> cur *ListNode</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</div><div class="line">		cur = <span class="built_in">new</span>(ListNode)</div><div class="line">		cur.Val = v</div><div class="line">		last.Next = cur</div><div class="line">		last = cur</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 跳过头节点</span></div><div class="line">	<span class="keyword">return</span> head.Next</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试用例，需要增加用例只需要添加，不需要动逻辑</span></div><div class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	k    <span class="keyword">int</span></div><div class="line">	s    []<span class="keyword">int</span></div><div class="line">	want <span class="keyword">string</span></div><div class="line">&#125;&#123;</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"1"</span>, <span class="comment">// name 是为了并发测试时用来区分用例的，随便给，能区分就行</span></div><div class="line">		k:    <span class="number">1</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</div><div class="line">		want: <span class="string">"1,2,3,4,5,6,7,"</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"2"</span>,</div><div class="line">		k:    <span class="number">2</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</div><div class="line">		want: <span class="string">"2,1,4,3,6,5,7,"</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"3"</span>,</div><div class="line">		k:    <span class="number">3</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</div><div class="line">		want: <span class="string">"3,2,1,6,5,4,7,8,"</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"39"</span>,</div><div class="line">		k:    <span class="number">3</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</div><div class="line">		want: <span class="string">"3,2,1,6,5,4,9,8,7,"</span>,</div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverseKGroup</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		<span class="comment">// 并发测试</span></div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			head := sliceToList(tt.s)</div><div class="line">			got := reverseKGroup(head, tt.k).String()</div><div class="line">			<span class="keyword">if</span> got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"reverseKGroup() = %v; want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要看着这些代码很长，写多了都是套路，部分代码还能工具生成（这里用的 VS Code + 插件），耗费的注意力是很少的。而一旦测试用例写完，我们就有了一个清晰的目标：通过修改实现，让测试通过。每次验证的成本为 0。</p>
<h3 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h3><p>解决任何问题，首先要懂得分解问题。如果问题看起来有点复杂，尝试分解成几个子问题去解决。如果还是棘手，就继续分解，直到比较容易解决为止。怎样的问题算复杂，因人而异。有些问题很难，解决多了有了固定解法，也可以直接写答案；新手生疏，就多分解细一些。</p>
<p>这里先忽略 k，先考虑整个链表原地倒序。</p>
<p>所谓倒序，对于单向链表而言，就是 前一个节点 和 后继 节点反过来。</p>
<p><code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> ==&gt; <code>1&lt;-2&lt;-3&lt;-4&lt;-5</code> （为了强调修改结构而不是节点，特意不动节点位置，而修改指针指向。）</p>
<p>很容易想到，可以新建一个链表，将原链表的节点，从尾部逐个放到新链表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	<span class="comment">// 倒序后的链表，创建一个空节点避免特殊处理</span></div><div class="line">	reversed := <span class="built_in">new</span>(ListNode)</div><div class="line">	<span class="comment">// 倒序链表尾节点</span></div><div class="line">	rTail := reversed</div><div class="line">	<span class="keyword">for</span> head.Next != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// 原链表尾节点</span></div><div class="line">		<span class="keyword">var</span> tail *ListNode</div><div class="line">		cur := head</div><div class="line">		<span class="comment">// 将 cur 移向原链表最后一个节点，tail 指向倒数第二个节点</span></div><div class="line">		<span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &#123;</div><div class="line">			tail = cur</div><div class="line">			cur = cur.Next</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 将最后一个节点挂到倒序链</span></div><div class="line">		rTail.Next = cur</div><div class="line">		rTail = cur</div><div class="line">		<span class="comment">// 并从原链移除</span></div><div class="line">		tail.Next = <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	rTail.Next = head</div><div class="line">	<span class="comment">// 跳过空节点</span></div><div class="line">	<span class="keyword">return</span> reversed.Next</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用了四个指针，分别指向两条链表的头和尾。跑一下单元测试，当然是失败的，但可以看到，输出整体倒序了。</p>
<p>不过，这个实现，效率太差。链表是无法随机访问的，光访问尾节点，就得耗费 $ O(N) $ 复杂度，每次访问尾节点都从头开始查找，整体的复杂度就变成 $ O(N^2) $ 了。其实，倒序链没有必要非要从头部开始构建。原链只能从头开始读，那么倒序链就从尾部开始构建，就可以遍历一遍完成倒序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	rNext := head</div><div class="line">	reversed := rNext.Next</div><div class="line">	head = reversed.Next</div><div class="line">	rNext.Next = <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		reversed.Next = rNext</div><div class="line">		<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> reversed</div><div class="line">		&#125;</div><div class="line">		rNext = reversed</div><div class="line">		reversed = head</div><div class="line">		head = head.Next</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种实现不仅只需要遍历一次，连指针都少用了一个。解释起来比较麻烦，直接画图反而直观：</p>
<p><img src="../../images/leetcode25-reverse.svg" alt=""></p>
<p>每次从原链表取头节点，放到倒序链表做头节点，三个额外的指针一路向后移动。遍历完成，转换也完成了。对链表稍熟练一点，应该直接想到这种做法。前面第一版实际上是写文章时临时写出来做对比的。</p>
<h3 id="分组断开与重组"><a href="#分组断开与重组" class="headerlink" title="分组断开与重组"></a>分组断开与重组</h3><p>最基本的倒序解决了。不过实际上要解决的，是把原链表分成多个 k 大小的子链表，每条子链表内部倒序。把上面实现的函数，重命名为 <code>func reverseSubGroup(head *ListNode) *ListNode</code> ，用来给每个子链表倒序时调用。参数 k 去掉，用不上。原来函数，变成解决两个问题：把原链表分割后交给倒序函数；把倒序后的链表重新拼成完整的链表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> k == <span class="number">1</span> &#123;</div><div class="line">		<span class="comment">// 及早剪枝</span></div><div class="line">		<span class="keyword">return</span> head</div><div class="line">	&#125;</div><div class="line">	cur := head</div><div class="line">	<span class="comment">// head, tail: 原链表 头节点，尾节点</span></div><div class="line">	<span class="comment">// gHead, gTail: 当前 Group 头节点 和 尾节点</span></div><div class="line">	<span class="keyword">var</span> gHead, gTail, tail *ListNode</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		gHead = cur</div><div class="line">		<span class="keyword">if</span> gHead == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// 新 Group 为空，表明节点数刚好是 k 的倍数，返回</span></div><div class="line">			<span class="keyword">return</span> head</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 跳过 k 个节点，找到 Group 尾部</span></div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</div><div class="line">			<span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</div><div class="line">				<span class="comment">// 当前 Group 不够 k 个节点</span></div><div class="line">				<span class="comment">// 不需倒序，接上剩余节点后返回</span></div><div class="line">				tail.Next = gHead</div><div class="line">				<span class="keyword">return</span> head</div><div class="line">			&#125;</div><div class="line">			gTail = cur</div><div class="line">			cur = cur.Next</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 倒序之前，将当前 Group 和后面断开</span></div><div class="line">		gTail.Next = <span class="literal">nil</span></div><div class="line">		<span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</div><div class="line">			head = reverseSubGroup(gHead)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			tail.Next = reverseSubGroup(gHead)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 倒序之后 gHead 实际上变成了 Group 尾</span></div><div class="line">		tail = gHead</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历逻辑跟前面很接近，差别是这里不需要倒序，只是 Group 的断开和重连。重点都用注释标注了。</p>
<p>再跑一次单元测试，OK 了。提交一下，AC，时间 4ms（打败 97.84%），内存 3.6 MB（打败 50%）。</p>
<p>外层函数也是只遍历了一遍，时间复杂度 $ O(N) $ （机械地从有多少层循环得出 $ O(N^2) $ 乃至 $ O(N^3) $ 的醒醒），空间复杂度也满足常数阶。如果不追求极限优化，特别是考虑到代码的可读性，我觉得可以接受了。</p>
<h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul>
<li><p>理解链表不能随机访问，只能从头节点开始遍历的特点，尽量用几个指针，在一次遍历里尽量多地获取稍后需要用到的节点。</p>
</li>
<li><p>多个指针一起移动时，需要小心处理赋值顺序，避免拿到错误的值。一般马上要断开的指针（修改成指向别的节点），需要先用另一个指针备份避免『失联』。</p>
</li>
<li><p>我看到讨论区里有人用栈来实现，还通过了。需要指出，这是 <strong>不符合题目要求</strong>的。</p>
<p>  题目要求额外的内存是常数。而一旦使用了栈来储存节点，栈的大小就是与 k 相关的了。k 作为一个输入，是无法控制其大小的。在实际生产环境，这会成为性能隐患。而刷题的角度说，题目既然给定了约束，这种做法直接是不符合题意。居然能通过，说明这道题的测试用例太弱了。</p>
</li>
</ul>
<p>总的来说，这道题作为新手熟悉 链表操作 的题目，值得一做。但也就这样了，我故意多写一种倒序的『初级思路』，把过程掰碎了说，也只能写到这么点内容。</p>
<p>你觉得我讲得怎样？关键点说明白了吗？有讲到你疑惑的点，还是废话连篇？欢迎留言告诉我。</p>
<h2 id="题外话：什么是-ARTS"><a href="#题外话：什么是-ARTS" class="headerlink" title="题外话：什么是 ARTS"></a>题外话：什么是 ARTS</h2><p><strong>ARTS</strong> 是由陈皓（左耳朵耗子）发起的一个活动，每周坚持做四件事，具体内容如下</p>
<ul>
<li>Algorithm：至少做一道 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ul>
<p>耗子叔说『只要坚持每天学习 1 小时，就超过了 99% 的人』（大意）。</p>
<p>我印象中很早就见过。当时不知道是忙还是别的原因，居然没有想到一起打卡。</p>
<p>儿子出生后，压力更大更忙了。可我反而意识到，需要做的事，迟早都得做，一个都逃不掉。年轻的时候会说『等 xxx 的时候』，现在越来越明白，那个时候可能永远等不到，如果现在不做，等到什么时候？</p>
<p>早年也零星刷过题，不过一般在 POJ，然后是 URAL，再后来为了方便，就泡在 Virtual Judge。在三星当算法讲师时最爽，能够带薪刷题，还自己出题构造测试用例；但是投入太多，开发业务却又落下。离开三星那个氛围，专注技术转型之后，刷题又落下了。现在重新捡起，选择了业界一致选择的 LeetCode，然后顺便开启 ARTS 的打卡。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不刷题，还得捡起来。&lt;/p&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://jaycechant.info/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://jaycechant.info/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="https://jaycechant.info/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>跟黄执中学观念传递：简单、意外、具体</title>
    <link href="https://jaycechant.info/2020/the-key-to-conveying/"/>
    <id>https://jaycechant.info/2020/the-key-to-conveying/</id>
    <published>2020-05-12T09:16:34.000Z</published>
    <updated>2020-05-12T10:54:48.608Z</updated>
    
    <content type="html"><![CDATA[<p>把话说清楚，本质上是要传达的内容，让受众听（看）进去。重要的首先是 <strong>内容</strong> ，然后是传达的 <strong>形式</strong> 。</p>
<a id="more"></a>
<p>明确要传达的内容，想清楚。然后考虑场景和受众，<strong>调整内容的形式</strong> 。三分钟内口头传达一个观念，跟官方声明、法律文件，不是一回事。</p>
<p>日常更多是前者。有限时间和注意力，先求触及。听进去了，感兴趣了，才有机会深入，把细节交给 面谈、合同、规范 …… 写文章也在传达观念，多数人不是写论文 和 公文。匆匆路过的读者，注意力有限。</p>
<p>至于市面常见的技巧训练，在特定的、强调仪式感的场合有用；不分场合强调，是舍本逐末。</p>
<p>有价值的内容，来自积累与洞见。具体跟所在领域相关。读书与实践，增加输入，似乎是唯一的通用法门。<br>至于传达形式，见过太多说法，头绪纷乱。直到看了少爷一个视频，豁然开朗。后来写文卡住，翻出来看。再遇到瓶颈，再看。 一看就懂，一做肌肉记忆打回原形 。知易行难。那就用自己的话复述一下，顺便推荐给大家。</p>
<blockquote>
<p>打（过）辩论的，没有不知道少爷（黄执中）的。通过《奇葩说》，现在更多人知道了他。</p>
</blockquote>
<p><br></p>
<hr>
<p><br></p>
<p>少爷说了啥？ <strong>周全和精准，妨碍我们传达。</strong> </p>
<p>此话一出，命中强迫症要害。太想把话说圆满，反而引入更多漏洞，话说成了缠脚布，打满补丁。<br>有限时间、内容里，让观念牢牢黏在听众脑海，就三个词：</p>
<ul>
<li>简单：给受众减负，让他在忘掉别的所有之后，只要记得一个。</li>
<li>意外：松动已有认知，调整观念，印象深刻。</li>
<li>具体：给细节，有画面感的细节。有温度的体验，强过冷冰冰的数据。</li>
</ul>
<p><img src="../../images/conveying-in-3-min.png" alt=""></p>
<p>推荐你完整看下来，<strong>用自己的话复述</strong> 。B 站地址在这里：《黄执中：你如何听懂我说的话？》<a href="https://www.bilibili.com/video/BV1Y7411V7wW" target="_blank" rel="external">https://www.bilibili.com/video/BV1Y7411V7wW</a></p>
<blockquote>
<p>视频记得是 16 年的，很早就看过，不知道为什么 B 站上日期变成最近的了。</p>
</blockquote>
<p><br></p>
<hr>
<p><br></p>
<p>是不是觉得道理『平平无奇』。不要围观，只有下场体验过求圆满时 <strong>加无可加</strong> 的无奈，才能理解 <strong>减无可减</strong> 的『简单』不简单。</p>
<p>而且他说的，有严格的上下文限定。不看上下文就质疑『怎么可能只缩减到一条』，属于抬杠。</p>
<p>我当年通过人人网（那时好像还叫校内），看剑气之争，还有价值之辩知道他。当时太年轻，还试图在师弟师妹面前挑他理论的毛病。</p>
<p>他的话当然不是权威，认真挑也可以挑出毛病。但是他在 辩论——或者说对受众进行观念传达上，投入精力之多、程度之深，多数人比不上。这种深入，让他比一般人多考虑了几层；我看到的问题，有时考虑浅了，更高层面就不存在了；有时问题确实存在，但对核心来说无关紧要。</p>
<blockquote>
<p>这一节属于 『想要周全』 ，是 <strong>简单</strong> 的反面案例。</p>
<p>这些话跟主线相关性很弱，可有可无。抬杠的人那么多，堵得了多少个人的口。</p>
<p>不删了，留在这里当 <strong>具体</strong> 的例子，意不 <strong>意外</strong>？</p>
</blockquote>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把话说清楚，本质上是要传达的内容，让受众听（看）进去。重要的首先是 &lt;strong&gt;内容&lt;/strong&gt; ，然后是传达的 &lt;strong&gt;形式&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://jaycechant.info/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="语言表达" scheme="https://jaycechant.info/tags/%E8%AF%AD%E8%A8%80%E8%A1%A8%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>听说 B 站 500+ 万粉丝 up 主被病毒勒索</title>
    <link href="https://jaycechant.info/2020/buran-virus-what-happens/"/>
    <id>https://jaycechant.info/2020/buran-virus-what-happens/</id>
    <published>2020-05-03T09:16:18.000Z</published>
    <updated>2020-05-04T01:01:32.429Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷 B 站，在首页刷到一个视频：百大 up 主，B 站全站排名第 13，拥有 500+ 万粉丝的『机智的党妹』，被“黑客”攻击并勒索了。</p>
<a id="more"></a>
<p>这个视频是 up 主自己讲述事情的经过，在 B 站日排行最高达到第五名。</p>
<h2 id="这篇文章想说什么"><a href="#这篇文章想说什么" class="headerlink" title="这篇文章想说什么"></a>这篇文章想说什么</h2><blockquote>
<p>我写文章容易跑题，想到啥说啥。现在尝试开头一问，收束一下思维方向。</p>
</blockquote>
<ul>
<li>有这么个事</li>
<li>简单解释发生了什么</li>
<li>一点点原理（我尽量不写那么长）</li>
<li>对此普通人能做什么防备</li>
</ul>
<blockquote>
<p>注：</p>
<p>Hacker 是指对设计、编程和计算机科学方面具高度理解的人，一开始是中性词，只有技术高超的意思。中文大部分地区译作 黑客，台湾地区译作 骇客。</p>
<p>Cracker 是指恶意（一般是非法地）试图破解某个程序、系统或网络，进而窃盗、毁损或使其瘫痪的人。正确译法应该是 破坏者，或者 溃客。</p>
<p>Cracker没有道德标准，也没有“黑客精神”。Hacker 建设，而 Cracker 破坏。</p>
<p>但是由于翻译混乱，Cracker 也经常被翻译成 黑客 和 Cracker，现在提起 黑客，往往指的是 骇客，这个污名已经很难洗清了。</p>
</blockquote>
<h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>我们根据党妹视频的自述，还原一下事件经过</p>
<h3 id="自建-NAS"><a href="#自建-NAS" class="headerlink" title="自建 NAS"></a>自建 NAS</h3><p>简单说，党妹作为头部 up 主，视频制作精益求精。视频素材开始用 4K 高清，视频里出现各种高端的换场景、换装混剪，好像还有异地外景，这就导致素材量噌噌噌从几百 M 慢慢变成了 <strong>几百 G</strong>。（变成了 几百 G 是党妹视频中的自述，变大的原因像 4K 这些是我大致浏览之前的视频后猜的。之前没看过她的视频，也不懂剪辑，有可能说错。）</p>
<p>而且专业化之后肯定是团队作战，素材拷来拷去很不方便，所以他们团队自建了一个 NAS （Network Attached Storage，网络附加储存）。可以理解为一个自建的网盘，或者说在内网的公共硬盘。</p>
<p>这个 NAS，投入了十几万，长时间测试维护，觉得可以了，启用。</p>
<h3 id="被黑"><a href="#被黑" class="headerlink" title="被黑"></a>被黑</h3><p>然后第一天就被黑了。所有文件被加密，留下一封勒索信，只有交了赎金才能拿回密码，重新解密。等于 NAS 上的视频素材被当做了人质（感觉人质哪里不对？文（件）质？素（材）质？）。</p>
<p>第一天 ……</p>
<p><br></p>
<p>因为视频制作精良，素材要求很高，成本涉及场地、设备、服化道、人工，甚至还有外景的差旅费。收入方面，500+ 万粉丝，按最近的视频平均 300 万左右的播放量，无论是创作激励还是潜在的一些商业合作，也是非常可观。无论从成本还是收入看，损失都很大。</p>
<p>但这个领域太新了，要立案，证据认定都成了个问题。几百 G 加密的乱码，怎么证明花了多少成本？还没发出来的视频，怎么证明能有多少收入？</p>
<h3 id="buran-病毒"><a href="#buran-病毒" class="headerlink" title="buran 病毒"></a>buran 病毒</h3><p>中的病毒叫 buran 勒索病毒。</p>
<p>上网搜了一下，国内网络安全机构在 19 年下半年就发出过安全预警，像这篇：<a href="https://s.tencent.com/research/report/817.html" target="_blank" rel="external">《腾讯安全预警：Buran勒索病毒传入我国，用户宜小心处理不明邮件》</a> ，</p>
<p>还有这篇： <a href="https://www.secpulse.com/archives/118852.html" target="_blank" rel="external">《利用IQY（Excel Web Query）文件分发，Buran勒索病毒又出新变种》</a> 。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>可惜我不是吃安全这口饭的，上来就讲加壳、特征码、漏洞、注册表 这些也不是我擅长的。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>『通过加密保护信息安全』，倒是可以聊聊。</p>
<p>假定你有一些隐私信息，不想被人看到。可是不巧，手机（或硬盘）要拿去修。想想当年 GX 哥的遭遇。</p>
<p>资料还有用，不能删。不仅不能删，随时用到，随身携带。唯一的办法，就是加密。</p>
<blockquote>
<p> <code>私房钱藏在鞋柜里的New Balance</code> </p>
<p>&lt;=&gt; <code>\u79c1\u623f\u94b1\u85cf\u5728\u978b\u67dc\u91cc\u7684\u004e\u0065\u0077\u0020\u0042\u0061\u006c\u0061\u006e\u0063\u0065</code></p>
<p>这种叫编码（Encode），不叫加密。字跟编码的对应关系是唯一的，像 <code>\u79c1</code> 唯一对应 <code>私</code> ，你不认识，计算机可熟悉，解码（Decode）就能恢复。例子里用的是 Unicode 编码。</p>
</blockquote>
<p>加密本质上是一系列特别复杂的 <strong>数学运算</strong> 。有意义的明文（原文）经加密运算之后得到无意义的密文。想重新得到明文，则要执行相反的解密运算。当然，如果大家都用一样的加密算法，解密没什么难的，所以加密过程还要引入一个变量：密钥（key，为了避免跟密码混淆，下面直接称 key）。加密算法一样，但每次 key 不同，不知道 key 就无法解密。（俗称的密码，实际上是口令（password），能通过运算转换成 key。）</p>
<p><img src="../../images/encryption.svg" alt=""></p>
<p>如果使用经过理论和实践证明过的强加密算法，例如 AES 和 RSA，加密后 <strong>只有知道 key</strong> 才能读取有效信息，否则只能读到一堆加密后无意义的乱码。</p>
<p>如果不知道 key，只能暴力穷举。2 bit 的 key （实际上不允许），只有 00, 01, 10, 11 四种，一下子就全部试完。可如果是常见的 256 bit 长的 key，总共有 $ 2^{256} \approx 1.1579209\times10^{77} $ 种。这是一个非常大的数，科学家推断整个宇宙中的原子数也不过在 $ 10^{78} \sim 10^{82}$ 之间。</p>
<p>假定计算机运算特别快，一秒能试 $ 10^{8} $ 个 key，也得 $ 3.6717431\times10^{61} $ 年才能试完，仍然是个天文数字。即使调动整个比特币网络 18 年时的算力（$ 3.5\times10^{19}  $ FLOPS），依然没有进入可以接受的范围。目前破解只有通过对硬件缺陷和人的疏漏（社会工程学）下手。</p>
<p>RSA 还要特殊一些，属于 <strong>非对称加密</strong> ，简单说，它加密解密不同同一个 key，而是使用成对的 公钥 和 私钥。密钥对虽然关联，但是拿着其中一个算不出另一个。所以 公钥 可以公开，这也是它为什么叫公钥。作为代价，生成密钥对很慢，不像 AES 随机一串就可以了。另外，RSA 加密运算也比 AES 慢。非对称加密还有更多用途，感兴趣可以自己了解一下。</p>
<p><img src="../../images/asym-encryption.svg" alt=""></p>
<h3 id="商业机密"><a href="#商业机密" class="headerlink" title="商业机密"></a>商业机密</h3><p>其实你手里的是一系列非常值钱的商业机密，是谈判的重要筹码。竞争对手偷走了电脑，一边尝试解密，一边跟你谈判。你早就预料到这么一天，文件很多，有可能在电脑还在执行加密时，对方就出现把电脑带走，停掉加密。该怎么设计加密方案呢？</p>
<ol>
<li><p>加密、解密 <strong>尽量快</strong> 。文件太多，别还没加密完就被发现了；要用的时候，也能尽快拿回来。</p>
</li>
<li><p>没有 key 时，<strong>暴力破解难度高</strong> 。</p>
</li>
<li><p>每个文件 <strong>独立 key</strong> 。就算暴力破解了一个，还有好多个。而且谈判时能解密一个作为筹码：不骗你，我真有密钥。</p>
</li>
<li><p><strong>只保管一个 key</strong> ，多了不好管。</p>
</li>
<li>就算 <strong>中途打断</strong> ，已经完成加密的文件也不会受影响。</li>
</ol>
<p>这里面 1 和 2，3 和 4 其实是矛盾的。但通过巧妙的设计，是可以鱼与熊掌兼得的。</p>
<ul>
<li>一开始，生成一对 512 bit 的 RSA 密钥对，把私钥送到安全的地方。RSA 生成密钥对很慢，但只生成一次。</li>
<li>文件用 AES 256 bit 的 key 加密，key 每次都重新生成。</li>
<li>每个 AES key 都用 RSA 公钥加密一下，跟对应的文件放在一起。RSA 加密相对较慢，但是 AES key 只有 256 bit，只能放下 32 个字母或者约 16 个汉字，还没这句话长，快慢几乎没有差别。</li>
</ul>
<p>看看效果：</p>
<ul>
<li>AES 生成 key 和 加密都很快，满足 1。慢操作只有生成 RSA 密钥对，只执行一次，影响不大，干脆设长一点。</li>
<li>每个文件独立的 AES key，满足 3。</li>
<li>AES key 加密之后跟文件放一起，不用记，只需要保管 RSA 私钥。满足 4。</li>
<li>无论是文件数那么多个 256 bit AES key，还是一个 512 bit RSA 私钥，破解难度都是天文数字。满足 2。</li>
<li>正在加密时被打断，拿到了 RSA 公钥，完全不影响前面完成加密的文件，满足 5。</li>
</ul>
<h3 id="Cracker-帮你加密"><a href="#Cracker-帮你加密" class="headerlink" title="Cracker 帮你加密"></a>Cracker 帮你加密</h3><p>以上加密方案真是兼顾了不同情况，考虑周到。可要不是你自己主动加密呢？</p>
<p>要是 Cracker 侵入你的电脑，帮你加密，密码在他手里呢？</p>
<p>外边有坏人寻仇，你把家人藏起来，防盗门锁起来，这叫『保护』；如果坏人把你家人藏起来锁起来，就变成什么了？</p>
<p>变成了绑架。</p>
<p><br></p>
<p>可是 Cracker 是怎么『帮你加密』的呢？</p>
<p>两种可能：远程控制你的电脑后运行病毒，或者诱导你运行病毒。</p>
<p>前者往往扫描 <strong>远程控制端口</strong> ，发现端口开着就开始暴力枚举密码。如果密码不长，没有混进特殊字符，或者干脆就是网上常见的弱口令，很快就被猜中了。也有可能系统有某些提权漏洞，没打对应的补丁。总之，现在 Cracker 就像用自己电脑一样，远程控制了你的电脑。</p>
<p>后者就是把病毒混在邮件、视频、文档、软件里，诱导你打开。你在打开 <strong>来路不明</strong> 的 邮件附件、小电影、文档、破解软件 时，病毒也悄悄运行起来了。</p>
<p>然后这个 buran 病毒就开始执行上面的加密操作。除此之外，它还做了一些额外工作（不一定全）：</p>
<ul>
<li>它加密所有文件，除了一些重要的系统目录、系统文件，避免系统崩溃。加密完把原来的文件彻底删除。</li>
<li>禁用系统自动修复功能、删除系统备份、删除RDP连接历史记录、删除系统日志，并且关闭系统日志开机启动。</li>
<li>生成勒索信。</li>
<li>事情完成之后，把各种痕迹删掉，把病毒程序删掉。</li>
</ul>
<h2 id="两难境地"><a href="#两难境地" class="headerlink" title="两难境地"></a>两难境地</h2><p>前面花了较长篇幅讲加密。看到那些天文数字，我想你能大致理解，不乖乖交赎金，文件可能回不来。除非安全研究员发现 Cracker 留下了什么漏洞，可以推算出 key。我觉得这希望不大。</p>
<p>但是另一方面，也没有办法确定，Cracker 收了钱一定会办事。如果对方得寸进尺怎么办？</p>
<p>所以，明明都是现成的技术，并没有很高深的地方，但是顶尖的网络安全机构，都束手无策。</p>
<p>最好的方法，其实是事前防备。由于最近打算限制文章字数，多写短文，这篇先写到这里。防备部分后续再发一篇接着聊。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刷 B 站，在首页刷到一个视频：百大 up 主，B 站全站排名第 13，拥有 500+ 万粉丝的『机智的党妹』，被“黑客”攻击并勒索了。&lt;/p&gt;
    
    </summary>
    
      <category term="科普" scheme="https://jaycechant.info/categories/%E7%A7%91%E6%99%AE/"/>
    
    
      <category term="安全" scheme="https://jaycechant.info/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>写作困难：你是否有类似的烦恼？</title>
    <link href="https://jaycechant.info/2020/difficulties-of-writing/"/>
    <id>https://jaycechant.info/2020/difficulties-of-writing/</id>
    <published>2020-04-29T09:03:15.000Z</published>
    <updated>2020-05-01T16:39:04.060Z</updated>
    
    <content type="html"><![CDATA[<p>从小到大，我在身边人眼里，大概算 能说会写。作文偶有评优，被当做范文；初中到大学一直当学生干部，大学打辩论；工作后每次培训都拿优秀，再到当企业内训讲师，和后面带技术团队。同学和同事，对我的表达能力评价不低。</p>
<a id="more"></a>
<p>可这样的我，经常憋不出文章。</p>
<h2 id="忠实记录"><a href="#忠实记录" class="headerlink" title="忠实记录"></a>忠实记录</h2><p>我知道自己在书面表达上不得要领。不擅修辞，行文口癖频现，不够准确精炼；内容组织上，也全凭运气。</p>
<p>我所一直依仗的，仅仅是忠实记录而已。刚好对一个主题有自己观点，落笔顺理成章，还显真诚——那本来就是真实想法；可如果没想法，或者命题方向不是真实观点，就很痛苦，拧巴地挤牙膏。实际上，上高中以后我作文发挥就非常不稳定，对命题议论文尤其抵触。</p>
<p>还好选的理工科，好赖把书念完，找了个工程师的工作，平时除了代码，再写写文档，写作的问题好像也没那么重要。</p>
<p>偶尔做培训准备材料，做技术介绍，写学习笔记，内容专业性强，有明确对错和优劣，带入的个人观点依据也非常清晰。这些课纲和文章，成文有一些口癖，大致上是通顺易懂的。这走的还是忠实记录路线，没了高考作文的压力，觉得这样也没什么不对。</p>
<h2 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h2><p>可我不光写技术，也不能光写技术。</p>
<p>『宝藏男孩』、『行走的百科全书』….. 恭维话听多了，心里清楚大家过誉了，还是会窃喜，觉得可以总结一些经验想法和大家分享。另一方面，希望以输出带动思考和学习，让自己进步。就有了博客和公众号的记录，当下姑且叫做『存档计划』，开始增加非技术的内容。</p>
<p>写着写着，老问题还在，不能说彻底写不出，但输出效率显然太低，之前绕开的石头，再次挡在路上。</p>
<p>以前只是没想法或者观点冲突时卡壳，现在哪怕写亲身的体会，明明洗澡、躺床上、排队时想得好好的，等坐下面对键盘或纸笔，就写不出来了。同样的内容，有人来问，不管是面对面、语音、还是 打字，能很流畅讲给对方听；换做写成文章分享给更多人，又卡了。感觉自己是 <strong>装饺子的茶壶</strong> ，非常难受。</p>
<p>继续写技术科普，很顺畅，不缺技术主题，可以一直写下去。但这样写技术类的成就感，会掩盖掉非技术类存在的问题。最近要求自己每写几篇技术文章，中间来一篇非技术内容，如果写不出，技术内容也跟着暂停。要直面这个问题。</p>
<h2 id="技术原因"><a href="#技术原因" class="headerlink" title="技术原因"></a>技术原因</h2><blockquote>
<p>这个技术不是 Technology 的意思，而是 Cause in Technique，也就是战术操作上的原因。</p>
</blockquote>
<p>这些年断断续续在思考，和尝试不同的工具。但一天不整理输出，思考始终还处于混沌的状态。现在逼着自己整理这个话题，变成了一个 <strong>元叙述</strong>。亦即，整理的内容本身，就是关于整理的过程；整理过程本身，恰恰就是对整理成果的 尝试 和 验证。这是一个痛苦并有趣的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%% 下面这个图，不是画出来的，而是用键盘直接敲出来的。如果你感兴趣，留言告诉我。如果大家都感兴趣，我就找机会介绍一下。</div><div class="line">graph TD</div><div class="line">  st(开始)--&gt;thk[/之前的思考/]--&gt;idea[(想法的集合)]--&gt;arr[整理成文]--&gt;diff&#123;&quot;有困难吗？&quot;&#125;</div><div class="line">  diff--&gt;|&quot;很顺利&quot;|ed(输出)</div><div class="line">  diff--&gt;|&quot;又卡了&quot;|whyhow[&quot;思考为什么/怎么办？&quot;]--&gt;add[加入想法集合]--&gt;idea</div></pre></td></tr></table></figure>
<p><img src="../../images/difficulties-of-writing.svg" alt=""></p>
<h3 id="1-口头和文本的差异"><a href="#1-口头和文本的差异" class="headerlink" title="1. 口头和文本的差异"></a>1. 口头和文本的差异</h3><p>能聊不能写，是因为口头交流和文本，是两套体系。即时通讯虽然打字，内容节奏仍然是口头交流。</p>
<ol>
<li><p>交流有明确 <strong>上下文</strong> ，参与者都知晓，无需赘述。</p>
<p> 一旦面向更多读者，背景突然需要解释，三言两语未必解释得清。</p>
</li>
<li><p>交流有 <strong>时效性</strong> 。</p>
<p> 随着对话的推进，你不会也不可能太在意发言的严谨性；不会每说一句话都斟词酌句，大家在等着；也不会动不动挑别人话里的刺，除非影响理解了。随着对话推进，错误要么被忽略，要么被补充。</p>
<p> 一旦落实成公开文本，到处是漏洞，（我怕）在缺乏上下文的语境里，会被读者误解和放大。</p>
</li>
<li><p>交流有 <strong>实时反馈</strong> 。</p>
<p> 参与者的理解程度和评价，都是实时响应。不解和负面评价，可以马上做出反应；正面反馈，则给了继续交流的信心。单向文本输出失去了这些，作者只能想象读者的接受度。强迫症如我，陷入说不清和太罗嗦的两难。</p>
</li>
</ol>
<p>把一个还算满意的交流过程录音，原样转成文本，尝试直接发表，就会发现两者之间的鸿沟。</p>
<h3 id="2-想法稍纵即逝"><a href="#2-想法稍纵即逝" class="headerlink" title="2. 想法稍纵即逝"></a>2. 想法稍纵即逝</h3><p>一个想法的诞生，除了对问题持续的实践与思考，还需要松弛的精神状态，和特定情景触发。那么这个短时记忆，产生时的状态、触发的情景没有了，离开最初的时间地点越远，面容越模糊。</p>
<p>记录不方便，或者自信『这么印象深刻的想法一定不会忘』，那么大概率到有空整理时，已经丢失了大量的细节。偏偏某些细节才是关键，一旦忘记，余下部分就重归混沌与平庸。</p>
<p>更糟糕的是一下子冒出多个想法，互相干扰，大大缩短遗忘时间。</p>
<h3 id="3-思维与文本的差异"><a href="#3-思维与文本的差异" class="headerlink" title="3. 思维与文本的差异"></a>3. 思维与文本的差异</h3><p>思维的特点，和文本记录，差别很大。</p>
<p>大脑思考和记忆，是通过一系列离散信息的关联来完成的。对某个复杂的主题，大脑不像硬盘，并没有一个地方储存着这个主题的文本，一字一字线性地读或者写。而是大量零散信息，储存在不同神经元的关联里；这些信息的进一步兴奋关联，构成了更复杂的主题，以此类推。它是金字塔或者说树的结构——考虑到存在跨子树和叶子的关联，有环，其实是网状结构。</p>
<p>大脑思考时，会尝试调取已有的记忆，去解释、解决当前问题。就好像在 <strong>拼拼图或者立体模型</strong> ，去翻找用得上的零件（想象大量的、好多套零件混在一起，不是每个都用得上，需要的也不一定都有）。思维的跳跃因人而异，不同人的知识结构差异很大（怎么找，依赖零件怎么放，平时有没有整理）。</p>
<p>如果严格按照拼图从左上到右下的刻板顺序，只能盯着当前拼接位置，一块块试，接得上留下，接不上丢回去。海量候选零件，等于在蒙，全凭运气。这就是文本线性记录的特点：<strong>在没想好的地方卡住，先想到的却暂时找不到安置之处</strong> 。碰到『易碎』零件，没用上丢回去，碎了，下次要用也找不到了。</p>
<p>思维本身不受顺序限制，要有一个框架，把思维丢过来的有用零件，都先接住。</p>
<h2 id="改善办法"><a href="#改善办法" class="headerlink" title="改善办法"></a>改善办法</h2><p>能清楚界定问题，对症下药改善，反而简单。</p>
<h3 id="1-找一个倾诉对象"><a href="#1-找一个倾诉对象" class="headerlink" title="1. 找一个倾诉对象"></a>1. 找一个倾诉对象</h3><p>找一个听众。能懂相关话题，积极反馈，很好。</p>
<p>对方不懂，愿意听，也很好（参考费曼技巧）。</p>
<p>一时找不到人，一个玩偶，或任意拟人的东西，对着它说，提供的心理暗示也很有用（参考小黄鸭调试法）。</p>
<p>重要的，是有人倾听的交流感。一个人时，可以想象一个目标听众，（当作）录音给 TA 听，来增强感觉。</p>
<h3 id="2-实时记录"><a href="#2-实时记录" class="headerlink" title="2. 实时记录"></a>2. 实时记录</h3><p>实时捕获想法，不要相信当时『茅塞顿开』或『印象深刻』的感觉。</p>
<p>这句话的意思是，不要相信以后会记得，要马上记录；也不要高估这个想法起的作用，需要长时间坚持记录，才有可能从大量想法里，筛选出一些有用的。记录时尽量不要前置甄别，幼稚的念头也有启发意义，而且删除很容易；等发现那个想法确实很关键，可能就想不起来了。</p>
<p>随时记录包括两个方面： </p>
<h4 id="a-用工具降低记录成本"><a href="#a-用工具降低记录成本" class="headerlink" title="a) 用工具降低记录成本"></a>a) 用工具降低记录成本</h4><p>纸笔党可以随身携带小型记事本和笔，参考类似 Moleskine 的绑带记事本，绑一支笔。要不要 Moleskine<br>这个意大利牌子，见仁见智。个人觉得不必要，洇墨的无酸纸对不起招牌和价格。</p>
<p>再学习一些视觉笔记的符号，了解一点思维导图，尽量做到快速勾勒想法，而不是一字一句抠字眼。</p>
<p>不拘泥于纸笔，或者像我这样写字画画手残的，要感谢智能手机，提供了很多方便的工具：</p>
<ul>
<li><p>录音</p>
<p>  适合特别复杂又稍纵即逝的想法，快速而忠实地记录。</p>
<p>  缺点是，录得多了整理麻烦，一般的内容没有动力整理就堆积了。能找到带识别的录音就更好了，可以作为整理时的参考。</p>
</li>
<li><p>记事本 + 语音输入法</p>
<p>  如果不录音，以输入法识别结果作为唯一记录，语音识别的正确率一定要高。谁都不想说了一堆话之后，还要对着识别结果一个一个修改错误。适合篇幅长的内容，避免后续人工转换成文本的负担。</p>
<p>  缺点是，如果记录时识别错误没有发现，有一定概率事后会想不起原本的意图。</p>
<p>  免费的中文语音识别这块，暂时没有发现比讯飞做得好的。（如果有更新更好的选择，欢迎留言告诉我。讯飞打钱！）</p>
<p>  输入法只是转换，内容还需要一个载体，你需要一个能秒开的记事本。这里记事本是泛指，跟每个人用的手机、使用软件的习惯有关，需要亲自试用体验。</p>
</li>
</ul>
<h4 id="b-培养随时记录习惯"><a href="#b-培养随时记录习惯" class="headerlink" title="b) 培养随时记录习惯"></a>b) 培养随时记录习惯</h4><p>将记录内化成一个下意识动作。尽量地有想法就记录，不假思索，不经筛选，肌肉记忆，快速完成。</p>
<p>然后每隔一段时间，找一个集中的时间段，整理记录。</p>
<p><br></p>
<p>一定是 a) 先做出改善，再尝试做 b)，顺序不能颠倒。在觉得一个事情执行起来非常不便时，就强迫自己养成习惯，会浪费注意力，难以坚持，还损害自我评价。这是长期跟『劣根性』斗争后的体会，一定要顺应人性。</p>
<h3 id="3-结构化记录"><a href="#3-结构化记录" class="headerlink" title="3. 结构化记录"></a>3. 结构化记录</h3><p>既然大脑不习惯像打字机那样线性思考，就让记录过程迁就大脑，像思考过程那样 跳跃、发散、立体。这种记录的方式需要：</p>
<ul>
<li>能快速建立『框架』</li>
<li>能快速定位框架上的『节点』</li>
<li>方便修改，无论是节点内容，还是框架结构</li>
</ul>
<p>有些笔记达人理解原理之后，靠自己定义的符号就清晰记录。但手残党及纠结怪如我，频繁改结构，笔记很快会变得面目全非无法维护，需要引入工具协助。</p>
<h4 id="卡片笔记法"><a href="#卡片笔记法" class="headerlink" title="卡片笔记法"></a>卡片笔记法</h4><p>纸笔党可以考虑这个方法。本质上，就是拆散的、原子化的、方便索引和重新组织的笔记本。</p>
<p>很多大师都用这个方法，能马上想到的，就有 钱钟书 和 博纳科夫。钱钟书一生积累的卡片，据说近十万张。</p>
<p>做法非常简单，准备索引卡 + 铅笔，开头的一到两张卡片写下概括性的内容和大纲，然后索引到每张卡片写具体内容。内容较多条目，可以再嵌套一层，先写概括和大纲，索引到一张新卡片展开，写不完索引到下一张。互联网时代这种形式很好理解，就是一个纸质的网站，每页大约一条微博大小，带着指向其他页面的『链接』。</p>
<p>上面是 『自顶向下分解』(top break down) 的写法，有了大纲再丰富细节。有时是先想到某些具体的点，再逐渐拼凑出全貌，叫『自底向上构建』(bottom build up)，就是先写内容卡片，再概括和索引。</p>
<p><img src="../../images/card-note.svg" alt=""></p>
<p>每张卡片不大，很容易写满，给到 <strong>阶段性完成的反馈</strong> 。微博时代相比博客时代，创作量突然大增，就是因为字数越少，创作门槛越低。随手写 20 条 140 字的微博，远远比 2800 字文章容易的多 —— 前者只需 140 字内的自洽，后者需要 2800 字的思路。</p>
<p>但一个内容也不至于分很多张写，频繁换卡片 <strong>提醒我们</strong> 考虑再分一节。通过恰到好处的容量设置，同时达到这两个目的。</p>
<p>需要强调的是，不要心疼卡片，你的思考比卡片宝贵。铅笔 和 橡皮，是为了不浪费只需要小改的内容，而不是省卡片。</p>
<p>（类似 <code>$0IWc1NrJyw3$</code> 这种索引卡片，十块左右 210 张，哑光耐擦写，大小至少写得下 50 字，但又不会太大，推荐横线款而不是格子或者纯色款；铅笔是为了可修改。）</p>
<p><br></p>
<p>索引卡接近纸笔的终极解决方案。相关的卡片放一个盒子，或者打个孔穿起来，除了量大时 保存 和 人工索引 费点劲，找不到更多缺点。</p>
<p>但手残 + 习惯了软件解决方案的我，还是会寻求软件工具。当然，索引卡方案如此优秀，软件方案不同程度上是它的信息化版本。</p>
<h4 id="a-wiki-工具"><a href="#a-wiki-工具" class="headerlink" title="a) wiki 工具"></a>a) wiki 工具</h4><p>可以理解为个人版的维基百科。wiki 是项目管理中标配的知识管理工具。</p>
<p>一页相当于一张卡片，里面可以写正文，也可以添加到其他页的链接。除了单页字数不限，所有特性跟卡片笔记一一对应。</p>
<p>用过两款 wiki 软件，monowiki 和 zim wiki，其中zim wiki 使用了很长时间。基于以下原因，最近已经很少使用：</p>
<ol>
<li><p>页面的概念太重</p>
<p> 我的意思是，wiki 的使用，总是倾向于写详细的页面内容，而不是写大量小片段然后链接。</p>
<p> 一方面是由于 wiki 页面最初的设计，就是主题的详细介绍（参考维基百科，以及各种软件的 wiki 页）；另一方面是由于第 2 点，频繁的链接实际上不方便查看。</p>
</li>
<li><p>难以获得全局视角</p>
<p> 卡片获得全局视角，只需要在桌子上摊开摆放。wiki 聚焦于一页，同时查看很多页非常麻烦（受限于同时打开网页的操作和屏幕大小），甚至不可能。</p>
</li>
<li><p>移动体验</p>
<p> 这是放弃 wiki 的最后一根稻草。智能手机时代，没有找到比较合适的多段同步的 wiki 工具。将个人 wiki 服务搭建在公网，维护成本太高。最后，小屏幕让跨页面浏览编辑变得更难。</p>
</li>
</ol>
<h4 id="b-思维导图"><a href="#b-思维导图" class="headerlink" title="b) 思维导图"></a>b) 思维导图</h4><p>思维导图很好地解决了 单节点过大 和 全局视角 的问题。在 PC 上，我长时间地交替使用 XMind 和 FreeMind 两款软件。只要稍微熟悉快捷键，就能获得非常流畅的编辑体验。但同样因为一些原因，思维导图也变成了后备方案：</p>
<ol>
<li><p>重图轻文</p>
<p> 导图强调图的概念，编辑然后导出图片倒是方便。可整理思路最终是要成文的。</p>
<p> FreeMind 好一点，可以全选，复制粘贴到文本后，还保留层次结构，导出选项里也有 odt，可以用别的工具（pandoc）再转到目标格式。XMind 复制粘贴后只有缩进，丢失了层次结构，稍特殊的导出格式都要收费。</p>
</li>
<li><p>移动体验</p>
<p> 移动体验同样是让我放弃的最后一根稻草。手机上思维导图软件并不少，也有个别趁手，但跟 PC 不是同一个软件，使用体验割裂，增加同步和转换成本。稍好一点的全平台同步方案，并不便宜。而且无论哪一个，小屏幕让强调图属性的编辑更为不便。</p>
</li>
</ol>
<h4 id="c-大纲工具"><a href="#c-大纲工具" class="headerlink" title="c) 大纲工具"></a>c) 大纲工具</h4><p>新的选择是大纲编辑工具 Workflowy。考虑到速度，本地化等问题，推荐国内的模仿者 <strong>幕布</strong> 。</p>
<p>幕布在宣传时，有强调 随时转思维导图。这确实是一个杀手级特性，让轻度用户又少一个打开思维导图软件的理由。但并不是我选择幕布的主要原因，幕布也 <strong>不是一个思维导图软件</strong> 。</p>
<p>幕布编辑的是大纲。所谓大纲，是类似目录的东西，是『显示层级关系和树状结构型态的一种清单』。它的逻辑含义跟最基本的思维导图一样，是一棵树。</p>
<p><img src="../../images/outline.png" alt=""></p>
<p>幕布称大纲上的节点为『主题』，主题下可以挂正文。主题之间并列或从属，构成整个大纲。我们很容易联想到，主题=卡片。</p>
<p>把幕布当作首选解决方案的理由有：</p>
<ul>
<li>Enter=新增主题，Tab=缩进主题，Shift+Tab=提升主题，<strong>三个操作</strong> ，轻易构建大纲。</li>
<li>拖动主题前的小圆点可以把主题 <strong>拖到任意位置</strong> ，从属的子主题会跟着移动！这个操作，把主题真正变成了任意调整关系的卡片。也可以选中多个主题剪切粘贴，层次结构同样保持不变。</li>
<li>点击小圆点可以『 <strong>下钻</strong> 』，就是把选中主题变成根主题，专注于局部的内容。也可以 <strong>折叠</strong> 任意主题，隐去细节，只关注上层的结构。这是比图片缩放更精确的层次缩放功能。</li>
<li>跨平台使用体验一致，打开和同步速度尚可。基本功能免费版够用，如果需要无限主题（免费限 200 每篇）和 高级导出，9 元 / 月 或 90 / 年 的会员可以接受。</li>
</ul>
<p>还有 多条件搜索，标签分类 等功能，试用一下就知道了。多数功能思维导图也有，但在文本大纲上实现，并且随时可以转换成思维导图，比较少见（也有人说 Workflowy 模仿的 Emacs 的 org-mode）。</p>
<p><img src="../../images/export-mind-map.png" alt=""></p>
<p>更极致的用法，是只建一个文档，在文档中为所有冒出的想法找到位置，把幕布变成大脑知识的映射。幕布的 Slogan 正是『管理你的大脑』。</p>
<p>如果说还有什么不满意，编辑和导出不支持 Markdown，正文不支持和子主题混排。但这些实现起来跟底层的 OPML 格式有冲突，所以不抱期望。我只用幕布写大纲，想法成型后导出到 Typora 完成细节编辑，格式自己通过 pandoc 解决。</p>
<p>如果你也想试一下，微信扫邀请码注册，可以在原有关注官方公众号送 15 天会员的基础上，多送 15 天。 4 月 26 之前注册本来有一个周年庆抽奖，最差也得 3 个月。但那时没空写文章，只在朋友圈和知识星球提醒了一下。</p>
<p><img src="../../images/mubu-invite.png" alt=""></p>
<p><br></p>
<p>这节本质上还是引入工具，降低认知负担。但不是简单的加快速度，重点在顺应思考的习惯，帮助梳理思维。</p>
<h2 id="问题的根本"><a href="#问题的根本" class="headerlink" title="问题的根本"></a>问题的根本</h2><p>上述问题都解决掉，是不是就写出文章了？</p>
<p>很遗憾，不是。</p>
<p>战术的勤奋，不能解决战略的无力；技巧的熟练，不能填充思想的空白。</p>
<p>散乱的拼图固然可能隐藏了精美的思想蓝图，也可能美化了一团乱麻。把思路理清楚了，可能会揭露一个残酷的事实：想不明白，苦苦思索整理的成果 <strong>没有价值</strong> ——用力越猛越意味着，<strong>我没有这方面才能</strong>。</p>
<p>技巧可以把 50 分变成 60，不及格变及格；从 70 到 80，一般变优秀；但不可能把 10 变成 60，50 变成 100。</p>
<p><br></p>
<p>结论很伤人，却恐怕道出了大部分的真相。</p>
<p>这些技巧仍然是有用的，这个结论也是有启发性的。</p>
<p>过去很长的时间里，我根本不知道问题出在哪里。写作技巧 很容易成为替罪羊，毕竟比起承认自己的无知，缺乏技巧更好接受。可一旦下决心解决技巧问题，去掉干扰因素，结论很容易就水落石出：</p>
<ul>
<li><p>如果是整理和表达问题，梳理之后文章就出来了。</p>
</li>
<li><p>如果整理的成果显得浅薄，高估了自己的见解，承认就好。才能除了天赋，还有大量的投入时间。技术类的文章顺利的根本原因，是因为在提笔之前，我就投入了大量的实践时间。</p>
<p>  问自己要达到期望的水平，还要继续投入多少时间？值不值？</p>
<ul>
<li>其实不那么感兴趣，没那么重要，投入太高，完全可以放弃掉不写，回归擅长的内容。再遇到同类问题，求助专业人士。</li>
<li>很感兴趣，很重要，绕不过去。只能多花时间，多实践，多读书， <strong>求教</strong> 专业人士。</li>
</ul>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Last but not least.</p>
<ul>
<li><p>警惕宏大-叙述的冲动，多做小而局部（local）的叙述。</p>
<p>  宏大指的是，构建严密的、无所不包的自洽观点的尝试。有时输出显得浅薄，除了水平问题，还有可能是选择了过于宏大的框架（俗称 hold 不住）。一些见解，放在特定的上下文，是可以新颖且自洽的；可一旦放到更大的框架里，突然就会显得自相矛盾。就像编程多用 局部作用域（local scope），少用不用 全局作用域。</p>
<p>  本文就因为 <strong>自我指涉</strong> ，而构成了艰难的元叙述。在发现这是一个无底洞之后，赶紧收尾。</p>
</li>
<li><p>本文写得很混乱，删改的字数比能看到的多得多。我愿意把它看做认真看待 『如何思考、整理、写作』的开始，而不是想清楚之后的总结。</p>
</li>
<li><p>有独特见解，善于整理表达，只是第一步。借用严复的译事三难，仅仅是信（准确）。还要锤炼遣词造句，让表达更简练精准，是为达（流畅）。更进一步，考虑文章节奏、音韵 乃至 意象 的美感，是为雅（优雅）。后面境界，感觉离我有点远，感叹一句，读书太少。</p>
</li>
<li><p>文中提及脑神经科学和心理学的内容尚无很确切的结论，以后有可能被更新的理论代替。</p>
</li>
<li><p>文中不多的推荐，没有收钱。</p>
</li>
</ul>
<p>篇幅所限，未尽话题，以后接着聊。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从小到大，我在身边人眼里，大概算 能说会写。作文偶有评优，被当做范文；初中到大学一直当学生干部，大学打辩论；工作后每次培训都拿优秀，再到当企业内训讲师，和后面带技术团队。同学和同事，对我的表达能力评价不低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://jaycechant.info/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>域名解析从 DNSPod 到 Cloudflare</title>
    <link href="https://jaycechant.info/2020/name-server-from-dnspod-to-cloudflare/"/>
    <id>https://jaycechant.info/2020/name-server-from-dnspod-to-cloudflare/</id>
    <published>2020-04-10T15:11:52.000Z</published>
    <updated>2020-04-12T05:22:10.791Z</updated>
    
    <content type="html"><![CDATA[<p>个人博客托管在 Github pages，居然也快 8 年了。省事，不花钱。<br>前几年我又给它配了域名，解析用的免费 DNSPod 。（被腾讯收购是后来的事）</p>
<p>近期折腾技术上的事，了解到 Cloudflare 也有免费域名解析，而且居然带免费 CDN 和 DDOS 保护，有点动心。</p>
<a id="more"></a>
<h2 id="换-Cloudflare-的念头"><a href="#换-Cloudflare-的念头" class="headerlink" title="换 Cloudflare 的念头"></a>换 Cloudflare 的念头</h2><p>必须说，CDN 可有可无。虽然 github.io 服务器在国外，有时访问确实有点卡，CDN 可能改善一下，但也没到非缓存不可。而且 CDN 的缓存，会让修改和发布时，生效有延迟，不能马上看到。</p>
<p>至于 DDOS，谁有空攻击我呢。</p>
<p>这多出来的功能，属于 <strong>鸡肋</strong>。为什么我还是动心，折腾了呢？</p>
<ol>
<li><p>Cloudflare （以下简称 CF）作为盛名在外的服务商，它的解析服务不至于太烂。</p>
<p> 我只用过 DNSPod （以下简称 DP）的服务，如果以后需要用别家的，容易抓瞎。花点时间换个差不多的免费服务，可以了解一下各家的差别。</p>
</li>
<li><p>CDN 和 DDOS 保护，暂时鸡肋，但是开了也不至于有害（搞不好真香）。那么体验一下，日后需要这些功能时，值不值得弄、要怎么操作心里也有底。</p>
</li>
</ol>
<p>说白了，这是我做事的习惯：在不紧迫时，多折腾不同方案，建立起判断的基线。最坏也不过得出一个『CF 真烂，DP 真香』的结论，然后迁回去。</p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><p>注册 CF 帐号，选择免费方案，输入域名，很快就导入了当前的 DNS 记录（但是不全）。</p>
<p>然后会提醒 Name-server 不是他们家，给出他们的两个 Name-server 地址。每个人拿到的地址可能不一样，以 CF 给的为准。据说不用他们家的解析，也能用 CDN，我没研究。</p>
<p>去到域名注册商，把 Name-server 改过来。等了一下，刷新，注册商那边显示生效了。</p>
<p>回到 CF ，因为注册时刚检测过 DNS，下一次自动检测还要好久，可以手动点一下检测，然后就开始排队。过了不久，检测之后发现 Name-server 记录已经指过来了，就显示域名已经在 CF 的保护下。</p>
<p>上面一排功能按钮，起码看起来是比 DP 厉害的样子（当然不排除 DP 也有类似功能，只是它没摆出来，我也没探索过）。</p>
<p>首先把 DNS 记录缺的照抄过来（已经忘了缺哪几条了），DP 那边的记录有这些</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>域名</th>
<th>目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNAME</td>
<td>@</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>*</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>www</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>qqmailxxxxx （这串码每个人不同）</td>
<td>mail.qq.com</td>
</tr>
<tr>
<td>MX</td>
<td>@</td>
<td>mxdomain.qq.com (priority:5)</td>
</tr>
<tr>
<td>MX</td>
<td>@</td>
<td>mxdomain.qq.com (priority:10)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>@</code> 代表根域名。同时注册 <code>@</code> , <code>*</code> , <code>www</code> ，是因为这个地址暂时只有博客，当时希望访客就算自动补上 www，或者输了随便哪个子域名，也能访问到（当然这个配置也是当年不求甚解抄网上的）。</li>
<li>也注册了域名邮箱。不要问我为什么一样的内容，要添加不同优先级的两条记录，QQ 邮箱教程这样写，照做而已。（现在 QQ 域名邮箱已经停止注册和新增邮箱了，已经注册的还能用，但新注册或者新增只能注册一个企业微信用企业邮箱。）</li>
</ul>
<p>把记录都抄过来之后，看起来差别只有两个地方：</p>
<ul>
<li>CF 有一项功能叫 CNAME flatterning，会自动把 <code>@</code> 替换成实际的根域名（<code>jaycechant.info</code> ，记录 Name 栏显示的就是完整域名），然后把指向的域名解析成实际的地址（但记录 target 栏显示的还是域名）。声称加快 30% 解析速度。只有根域名会这样做，相当于帮你生成了 根域名的 A 记录。</li>
<li>右边多了一列图标，点击在两种状态切换：箭头穿过黄色的云（Proxied）表示开启了 CDN 缓存，箭头绕过灰色的云（DNS only）表示关闭。MX 记录不能打开缓存。想体验一下，就把 CDN 打开了。</li>
</ul>
<p>配置完等了一会，博客还能访问。不确定是缓存还在起效，还是新的设置已经生效（其实也没差别）。于是去 DP 把原来的域名解析删掉。</p>
<h2 id="redirect-loop-和-1016"><a href="#redirect-loop-和-1016" class="headerlink" title="redirect loop 和 1016"></a>redirect loop 和 1016</h2><p>再等了一会，终于能看到差别：博客访问不了。错误是 ERR_TOO_MANY_REDIRECTS。</p>
<p>（参考 <a href="https://kinsta.com/blog/err_too_many_redirects/）" target="_blank" rel="external">https://kinsta.com/blog/err_too_many_redirects/）</a></p>
<p>按照 Chrome 提示和找到的建议，清浏览器缓存，清 CF 缓存，都没有用。可能是有 redirect loop。</p>
<p>于是我先关掉了 CDN，删了根记录（我也不知道当时为什么想到删根记录，可能当时还没理解好），好了，报新的错误了 Error 1016 ……</p>
<p>在好好学习，终于理解 1016 是什么意思之后，终于也知道根记录的重要性，加回去，继续 ERR_TOO_MANY_REDIRECTS……</p>
<p>问题似乎出在 通配符（wildcard）记录。根据查到的说法，每个服务商对 wildcard 的支持会不一样。我想，好像也没必要支持除了 www 以外的二级域名，就把这条记录删了（鬼知道当年跟哪里抄的做法），好了。</p>
<blockquote>
<p>注：敲下这些文字已经是第二天，我尝试找到背后的原因。重新按照之前的配置，加上 wildcard record，关掉 CDN ，清掉各种缓存，甚至尝试换个浏览器，用 curl 跟踪，都没能重现 ERR_TOO_MANY_REDIRECTS。</p>
<p>有可能这是两个 DNS 服务部分失效部分生效时产生的 edge case。可惜当时没想到跟踪 redirect ，了解具体是哪几个地址形成了 loop。</p>
<p>不过即使 wildcard record 不会引起错误，随便输一个子域名跳转到 <code>jaycechant.github.io</code> 还是 404，这条记录没有实际意义，最后还是删掉了。</p>
</blockquote>
<h2 id="Page-Rules"><a href="#Page-Rules" class="headerlink" title="Page Rules"></a>Page Rules</h2><p>然后测试 <code>www</code> 记录。（由于是默认主机名，有些人会习惯加，这条记录还是有用的）</p>
<p>结果是能访问，但会报安全提醒。这是因为证书是颁发给 <code>jaycechant.info</code> 而不是通配符域名 <code>*.jaycechant.info</code> ，<code>www.jaycechant.info</code> 不在范围内。</p>
<p>为什么不直接签一个通配符证书呢？因为证书不是自己申请的，而是在 Github pages 配置时，输入域名，Github 代为申请的。Github 官方的文档看这里：<a href="https://help.github.com/en/github/working-with-github-pages/about-custom-domains-and-github-pages。" target="_blank" rel="external">https://help.github.com/en/github/working-with-github-pages/about-custom-domains-and-github-pages。</a></p>
<p>这时发现了 CF 提供的 <strong>Page Rules</strong> 功能，可以编写规则，对满足特定条件的地址，应用某些功能，包括 Always Online （通过缓存实现）、Always use HTTPS （估计通过 301 实现）、Auto Minify 等等 20+ 个功能。</p>
<p>这里用到 Forwarding URL，可选 301（Permanent）和 302（Temporary）：</p>
<p><code>www.jaycechant.info/*</code>  -&gt;  <code>https://jaycechant.info/$1</code>，支持通配符，而且可以通过 <code>$1</code> , <code>$2</code> 这样的变量按顺序引用。</p>
<p>免费版仅提供 3 条规则，目前来看，不搞复杂的规则，够了。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>说回 CDN。</p>
<p>从我有限的尝试看，结果基本如我所料，开启 CDN 会让页面加载变快，同时修改应用有延迟。但必须说，这两个效果起码在这两天，差距都不算很大。</p>
<p>据官方说，国内他们是和百度 CDN 合作的，确实也是秒加载，不明显只能说原来直连 Github 还不够卡。</p>
<p>延迟方面，从上传完毕开始计时，一直刷新，到刷出更新的内容停止，大约 45 s。这个数字看着很大。但是要知道，上传完到 Github 发现变更，然后部署生效，也是有延迟的。而且 CF 还提供 Development Mode 开关，临时绕过缓存。（这个开关是 3小时自动关闭的，不用自己手动关。非要说麻烦的地方，就是还得登录 CF。）</p>
<p>总结下来，开没开 CDN 最明显的差异就是……证书不一样：没有 CDN 时，证书是颁发给 <code>jaycechant.info</code> 本身的，开了之后证书是颁发给 <code>sni.cloudflaressl.com</code> 。（那为什么证书地址和博客地址不一样居然能通过名称验证呢？这就要提到 SNI 了 ：<a href="https://zh.wikipedia.org/wiki/服务器名称指示" target="_blank" rel="external">服务器名称指示</a>）</p>
<p>综合下来最后还是没开 CDN。如果有一天直连 Github 卡得不行了，我再回来。</p>
<h2 id="Cloudflare-workers"><a href="#Cloudflare-workers" class="headerlink" title="Cloudflare workers"></a>Cloudflare workers</h2><p>最后提一个意外发现，Cloudflare 支持 edge computing workers，从一开始只有 js，到现在支持 js, Rust, C, C++，相当于一个 FaaS。提供了两种方案。</p>
<p>免费方案：</p>
<ul>
<li>Includes <strong>100,000 requests per day</strong> (UTC+0)</li>
<li>Up to 10ms CPU time per request</li>
<li>Lowest latency after the first request</li>
<li>Up to 30 Workers</li>
</ul>
<p>每个月花 5刀：</p>
<ul>
<li>Includes <strong>10 million requests per month</strong></li>
<li>Up to 50ms CPU time per request</li>
<li>Always lowest latency</li>
<li>Up to 30 Workers</li>
<li><strong>Key-value storage:</strong><ul>
<li>Up to 100 namespaces</li>
<li>1 GB of storage</li>
<li>10 million read operations, 1 million write, 1 million delete, and 1 million list operations</li>
</ul>
</li>
</ul>
<p>这能用来干嘛呢？要知道 Github pages 是静态托管，有限动态部分只能是浏览器端的 js，像评论这种功能就要引入额外的服务器和储存。所以第一反应就是可以运行一个评论服务，然后作为插件加入博客中。</p>
<p>它不限流量，限请求次数和每次请求的 CPU 时间。免费版每天 10 W requests ，完全够用了。</p>
<p>等等，带储存的吧，好像有 workers KV 服务。哦，KV 只有收费版才有啊，那打扰了，等我想到新的应用场景再回来……</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>最后列一下用到的工具和命令，备忘（如无备注，均是 Windows 下）</p>
<ul>
<li>清除 DNS 缓存 <code>ipconfig /flushdns</code></li>
<li>查找当前 dns 指向 <code>nslookup &lt;domain&gt;</code></li>
<li>输出详细解析和重定向过程 <code>curl -v -L &lt;domain&gt;</code> （Windows 不带，需要额外安装）</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人博客托管在 Github pages，居然也快 8 年了。省事，不花钱。&lt;br&gt;前几年我又给它配了域名，解析用的免费 DNSPod 。（被腾讯收购是后来的事）&lt;/p&gt;
&lt;p&gt;近期折腾技术上的事，了解到 Cloudflare 也有免费域名解析，而且居然带免费 CDN 和 DDOS 保护，有点动心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DNS" scheme="https://jaycechant.info/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>海恩法则 和 海因里希法则：李鬼的诞生</title>
    <link href="https://jaycechant.info/2020/ohain-and-heinrich/"/>
    <id>https://jaycechant.info/2020/ohain-and-heinrich/</id>
    <published>2020-04-07T17:33:39.000Z</published>
    <updated>2020-04-13T04:32:01.876Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前，就对所谓的『海恩法则』有印象。具体怎么接触到的已经忘了，可能是公司组织的培训，也可能是纯粹在网上无意中浏览到。</p>
<p>它对生产安全的重视，还有强调在小问题中发现重大事故的隐患，给我留下了深刻印象。</p>
<p>不过这不是我真正想聊的。</p>
<a id="more"></a>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>概念给我留下深刻印象，但因为没有实际应用，并没有特意记忆。我并不能复述出它的细节，特别是 300-29-1 的这个比例，有时候甚至连名称都回忆不起来。</p>
<p>『我记得有个什么法则，说的大概是在重大事故发生之前，其实已经有多少个小事故发生过，以及更多的无伤害事故被忽视。』这个表述，连名字都不记得，到处是好像、大概的语气，说服力大打折扣。</p>
<p>所以有一天想记录下来，好好学习，好让下次引用可以准确说出这个 Ohain’s Law。</p>
<p>印象里模糊记得 海恩法则 和 Ohain’s Law （O is silent 让人印象深刻），用中文一搜，果然有大量结果，各个百科、文库、门户网站的文章。</p>
<p>（在写这篇文章时，重新搜了一下，有  BD 百科、MBA 智库、360 百科、互动百科、搜狗百科、搜狐新闻（引用的 JieFangJun 报）、TX 网、安全管理网 …… 现在认真再看一下，百科都是互相引用，文章也都没有查证。）</p>
<p>这些结果无不指向这样一些信息：帕布斯·海恩，德国人，涡轮喷射发动机发明者，航空界关于安全飞行的法则。</p>
<h2 id="不存在的-Ohain’s-Law"><a href="#不存在的-Ohain’s-Law" class="headerlink" title="不存在的 Ohain’s Law"></a>不存在的 Ohain’s Law</h2><p>但这就是关于 <strong>提出者</strong> 和 <strong>出处</strong> 的全部信息了。以 BD 百科为例，整个词条约 4 千字，其中关于安全管理、企业经营、职场、启示，再延伸到『墨菲定律』用了 3300 多字。而关于 提出者 和 提出的背景 只有一句：</p>
<blockquote>
<p>海恩法则(Ohain’s law)，是德国飞机涡轮机的发明者帕布斯·海恩提出的一个在航空界关于飞行安全的法则，多被用于企业的生产管理，特别是安全管理中。</p>
</blockquote>
<p>其它来源在后续话题扩展上有所增减，可在 提出者、背景这块，非常地一致。尝试求助于维基，并无此词条。</p>
<p>我是擅长推导而不擅记忆的人。无法背诵那些洋洋洒洒的理论，而是希望理解 提出者 当初的情景，然后跟他一样顺理成章地得出相似的结论。</p>
<p>可单凭这些信息，并不足以了解 提出者 是什么人，在怎么样的背景下，因为什么契机，提出这样的理论。</p>
<p>我改为用 <strong>英文关键词</strong>  <code>Ohain&#39;s Law</code> 搜索。</p>
<p>这样我得以了解 Hans Joachim Pabst von Ohain (1911 – 1998) 这位德国物理学家，喷气发动机的发明者。可是英文维基长达 2600+ 个单词的词条里——不可谓不详细——仍然毫无 <code>Ohain&#39;s Law</code>的踪影。其他搜索结果也都是关于 海恩 先生的信息。</p>
<p>如果说中文互联网关于『海恩法则』的介绍，是只有内容而忽略了出处；那么 “Ohain’s Law” 在英文互联网直接不存在。</p>
<h2 id="海因里希"><a href="#海因里希" class="headerlink" title="海因里希"></a>海因里希</h2><p>我一筹莫展，疑惑重重，不断改变关键词的组合，尝试找到一丝蛛丝马迹时，直到 <code>Heinrich&#39;s Law</code> 进入了视线。（在哪突然看到我已经忘了）</p>
<p>改为用它做关键词搜索，得到以下信息：Herbert William Heinrich(1986-1962)，30 年代 美国工业安全先驱，保险公司主管，75000 多份事故报告，Accident Triangle …… 故事终于被串起来，一切都 make sense。就是它（事故三角），就是他（海因里希）。</p>
<h2 id="知名的李鬼"><a href="#知名的李鬼" class="headerlink" title="知名的李鬼"></a>知名的李鬼</h2><p>这时 “Heinrich’s Law” 讲了什么，反而不是重点了。重点是，”Ohain’s Law” 是怎么来的。</p>
<p>我现在已经非常肯定，它是李鬼。（注意，说的是这个 Law 是李鬼。Ohain 先生是货真价实的科学家，跟 Heinrich 先生八竿子打不着。）</p>
<p>我们来对比一下 李逵 和 李鬼。</p>
<p>我尝试用 『海因里希法则』搜索，发现是有结果的。但是排面小得多。</p>
<p>例如说它同样有 BD 百科词条，这个词条还是经过『科普中国』审核的。但只有 1800 多字，而且里面有 近 700 字是讲出处的，跟 『海恩法则』长篇大论的扩展，形成了强烈的对比。</p>
<p>还有，『海因里希法则』的 BD 搜索结果里，有名的网站只有 BD 百科一个，剩下的网站，学习啦、酷知 等等，都名不见经传。</p>
<p>看数字就更直接了，『海因里希法则』只有 593,000 条，即使考虑到 Heinrich 还有 海恩里希的译法，把『海恩里希法则』的 84,100 个结果加上，一共也只有 <strong>六十七万七千一百</strong> 条。『海恩法则』的结果有 1,220,000 （<strong>一百二十二万</strong>）条。</p>
<p>李鬼 远比 李逵 传播范围广。</p>
<h2 id="一些猜测"><a href="#一些猜测" class="headerlink" title="一些猜测"></a>一些猜测</h2><p>前面说，这些信息看起来高度一致，现在想想，根本就是互相照抄的。</p>
<h3 id="巧合？"><a href="#巧合？" class="headerlink" title="巧合？"></a>巧合？</h3><p>你会说，有没有可能两位先生都提出了类似的理论？我也不敢说完全不可能，大家自己感受一下：</p>
<blockquote>
<p>海因里希法则</p>
<p>当一个企业有300起隐患或违章，非常可能要发生29起轻伤或故障，另外还有一起重伤、死亡事故。</p>
<p>海恩法则</p>
<p>每一起严重事故的背后，必然有29次轻微事故和300起未遂先兆以及1000起事故隐患。</p>
</blockquote>
<p>它们都有 300:29:1 的数字，都有一个金字塔图，都用于安全管理和企业管理，提出者的名字（中文译名）非常相似。与此同时，后者还完全没有任何英文资料。这个没有资料是指，以 <code>Ohain&#39;s Law</code> 搜不到任何结果之余，Ohain 先生的资料也完全没提及他提出类似的理论。</p>
<h3 id="英文资料缺失？"><a href="#英文资料缺失？" class="headerlink" title="英文资料缺失？"></a>英文资料缺失？</h3><p>你可能又会说，凭啥以英文资料为准啊，中文资料就不权威吗？可能是他们美国的资料缺失了。</p>
<p>是这样的，两位先生都不是中国人，也没有在中国生活、工作过。海因里希 是美国人，发表理论用的自然是英语；海恩 是德国人，后面移民美国，并且拿了美国工程学最高奖，他的知名理论应该 德语 和 英语都有发表。</p>
<p>所以关于他们的理论，必然以英语发表（海恩 也可能早年先以德语发表，但在美国知名以后应该也有英文译介），然后通过翻译介绍到中文知识界。英文 资料不仅应该有，而且考虑到传播距离 和 译介有选择性，理应比中文资料更丰富。</p>
<p>一手资料因为来源 作者、作者身边的人 以及 记者、传记作者 等多个渠道，内容 和 行文 上会表现出更大的多样性。中文知识界因为不是所有人都有接触国外一手资料的机会 和 翻译的能力，更多是引用翻译，相对就会比较单一。（当然这种数量关系有一个例外，就是一个外国人，他在中国的影响力比在他本国还要大，以至于使用中文的研究者 比 使用他母语的研究者还多。）</p>
<h3 id="误译？"><a href="#误译？" class="headerlink" title="误译？"></a>误译？</h3><p>这样看来，应该是 Heinrich 在翻译介绍的过程中，被误简略为 海恩，闹的误会。</p>
<p>但是 误译、误会，都只能解释这个故事的开头，而没办法解释这样的内容：『德国飞机涡轮机的发明者帕布斯·海恩提出的一个 <strong>在航空界关于飞行安全</strong> 的法则』。</p>
<p>试想一下，在 <code>Accident Triangle</code>  的某个翻译版本里，只提到了 海恩里希，没提到是哪个 海恩里希，然后传播过程中，把 里希 弄丢了。可能原本的版本就提到了 “XX’s Law” ， 也有可能中文先给加上法则。</p>
<p>这时有人拿到这版翻译，完全没提 海恩 是谁。他很受启发，也想知道 理论作者，于是他（中文的 海恩 为关键词）找到了德国物理学家 帕布斯·冯·海恩。</p>
<p>不知哪来的信心，他猜测就是这位 海恩了（正如我现在猜测事情经过的做法），试图拼凑一个带 作者背景 的 『海恩法则』。</p>
<p>可即便这样，跳过了身份认证，得到的也只是『德国飞机涡轮机的发明者帕布斯·海恩提出的一个法则』，还得有人接着脑补，海恩 先生是如何收到启发的呢？根据他的身份，必然是 在航空界，从飞行安全中得到的启发。至于一个飞机发动机专家是否有做过飞行安全的研究，无人查证。我甚至怀疑，这里面混入了 幸存者偏差 的提出者 Wald Ábrahám 的故事。</p>
<p>以上当然都只是个人猜测，当不得真。但真实的传播情况可能已经无从考究，我认为这算一个相对合理的猜测。</p>
<h3 id="先后？"><a href="#先后？" class="headerlink" title="先后？"></a>先后？</h3><p>更好笑的是，看到有些网友注意到了同时存在『海恩法则』和『海因里希法则』。</p>
<p>如 <a href="https://wenku.baidu.com/view/09533c05b52acfc789ebc99f.html" target="_blank" rel="external"> BD 文库</a> 就有人把两者并列在一个文档中。然后呢，他注意到什么，说什么了吗？并没有。他只是一个复读机，一个复制黏贴的机器，把它们放在了一起。</p>
<p>如 <a href="https://zhidao.baidu.com/question/328323536.html" target="_blank" rel="external"> BD 知道</a> 就有人问，两者有啥区别，谁先谁后。居然有人一本正经地回答两者的不同（在我看来这些不同简直是睁眼说瞎话），并且说：</p>
<blockquote>
<p>海恩法则在前，海因里希法则在后。</p>
</blockquote>
<p>先不说对两者高度雷同视而不见，看看这个先后问题，海因里希 比 海恩 <strong>年长 25 岁</strong>。1931 年 保险公司助理主管 海因里希提出 事故三角 理论（即 海因里希法则）时，哥廷根大学二年级的大学生 海恩 <strong>才 20 岁</strong>，尚未毕业（1930 年高中毕业，1935 年攻读博士学位），要到 1936 才完善理论开始申请专利，到 1937 年才完成发动机模型开始测试 并在同年获得专利。大学生 海恩 如何能在 1931 年之前就从飞行事故中比 海因里希 更早得出相似的理论？</p>
<p><br></p>
<p>我能理解『海恩法则』比 『海因里希法则』更容易传播，因为前者更短。也许有更深层的、我们不知道的原因，但是短足以解释很多。更好记忆，更符合国人对人名的习惯。试想你在书上或网上匆匆一瞥，很长一段时间后回忆，完全有可能只记得『海因』或 『海恩』开头。然后你一搜 ……</p>
<p>我理解一些网友纯粹不巧拿错了关键词，从此被关键词困在了 <strong>信息茧房</strong> 里，需要碰见另一个关键词才得以释放。（之前的我就是这样）大家都很忙，拿来的论据直接用了，没有时间（或缺乏相应的『科学』素养）进一步检索。</p>
<p>那这些已经发现了 李鬼 或者 六耳猕猴 的人，居然丝毫不觉得违和，甚至还自圆其说，就已经不知道如何形容了。（__ 是个好东西）</p>
<p>更难以理解的，是那些对着可能是误译的、内容不全『海恩法则』，能不查证就把 Ohain 的信息往里添加，脑补这是『关于飞行安全的法则』。</p>
<h2 id="感触"><a href="#感触" class="headerlink" title="感触"></a>感触</h2><p>因为上述内容，很多是基于查到的资料的（合理）猜测，并不敢说是结论。我也是有等打脸的觉悟的。所以只能说一下查资料中间的感触。</p>
<h3 id="互联网信息质量不高"><a href="#互联网信息质量不高" class="headerlink" title="互联网信息质量不高"></a>互联网信息质量不高</h3><p>首先，感慨中文互联网的 <strong>信息质量</strong> 不高。</p>
<p>我们现代化起步比较晚，很多领域包括信息化都是追赶者；现在有了很大进步，甚至个别领域反超，但不得不承认大量历史积累 和 某些领域的最新成果，仍然是 <strong>以英文资料</strong> 存在。然后你懂的原因，引介学习这些信息，还有各种阻碍。（理解这些阻碍的出发点，但对做到现在这种程度持保留态度）</p>
<p>你可能说，这次刚好查国外的信息，如果查国内信息呢？老实说，如果不是大热的理论，外文未必能查得到。但由于一些原因，国内的信息即使在中文互联网上，检索结果的质量依然不高。这些原因包括，缺乏一个足够好的中文搜索引擎，和大量 <strong>劣质信息稀释了有效信息的密度</strong> 。前者不必解释，后者是指因为一些短期 KPI 的驱动，很多平台网站 <strong>容忍乃至鼓励粗制滥造</strong> 的内容。</p>
<p>忍不住提一嘴的是，无论是不够好的搜索，还是求量不求质内容，BD 都与有荣焉（看看上面的 BD 搜索、 BD 百科、 BD 文库）。不过好像悲观早了， BD 还要做信息流，所谓 BJ 号，营销号横行，一个骇人听闻的标题，东拼西凑连句子都不通顺的内容，连李鬼都不如——人家起码句子是通顺的。</p>
<p>很多千篇一律，洗稿抄袭，乃至胡言乱语拼凑的内容，就是在这样的背景下诞生的。</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>已经很克制了，还是说多了。说说对普通人的建议吧。</p>
<ul>
<li><p>不要道听途说，要有 <strong>求证精神</strong>。当然不建议像我这样啥都好奇。最起码，涉及 工作、金钱、健康、法律 这几方面的内容，上点心。</p>
</li>
<li><p>培养 <strong>逻辑思维</strong>，认识常见的逻辑谬误。</p>
</li>
<li><p>生活中留心观察，建立判断的 <strong>常识基线</strong> 。</p>
<p>  举例说，一个人从没买过鳕鱼，从没了解理财，自然无法判断说 18 块一斤的鳕鱼，和 18% 的月收益 是个什么情况。但只要稍有留意，知道常态的基准线在什么范围，你就能马上知道两个都是骗子：前者大概是 油鱼冒充，后者只能是骗局。</p>
</li>
<li><p><strong>学好英语</strong>，最低限度能阅读。有些人未必是英语水平问题，纯粹思维惰性。（因为哪怕英语还行，不是母语脑细胞用得多一些。我英语烂我理解。）</p>
<p>  那就推荐 AI 翻译，比 GG 翻译还好，非关键的信息可以用来偷懒：<a href="https://www.deepl.com/translator" target="_blank" rel="external">https://www.deepl.com/translator</a> </p>
</li>
<li><p><strong>善用工具</strong>，培养 <strong>信息检索、处理</strong> 的能力。</p>
<p>  像是懂得高级搜索，能理解正则表达式，知道互联网的一些高级玩法，乃至懂一点编程入门。</p>
<p>  如果觉得有点难，那么最基本的，不用 BD 搜索，有条件用 GG，没条件用 bing，也是一个开始。</p>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>海因里希法则 对 20 世纪的 健康与安全文化 造成重大影响，引起人们对工作场所安全的重视。但也受到了一些批评，批评主要集中在</p>
<ol>
<li>直接给出确切的数字具有误导性，因为在不同领域这个数字差距很大。</li>
<li>过分强调个人行为，而忽视了对制度的关注。油气行业的研究表明，通过预防减少了轻微事故，事故 SW 人数并未相应下降。</li>
</ol>
<p>这个理论提出已经过去了 90 年，有发展，有研究，也有质疑和批评。觉得这个 Law 很有启发，不代表要拿长篇大论来当金科玉律。恰恰相反，真正了解它的背景和发展，才能化为己用。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前，就对所谓的『海恩法则』有印象。具体怎么接触到的已经忘了，可能是公司组织的培训，也可能是纯粹在网上无意中浏览到。&lt;/p&gt;
&lt;p&gt;它对生产安全的重视，还有强调在小问题中发现重大事故的隐患，给我留下了深刻印象。&lt;/p&gt;
&lt;p&gt;不过这不是我真正想聊的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="thought" scheme="https://jaycechant.info/tags/thought/"/>
    
  </entry>
  
  <entry>
    <title>go-bindata：go 语言的静态资源嵌入</title>
    <link href="https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/"/>
    <id>https://jaycechant.info/2020/go-bindata-golang-static-resources-embedding/</id>
    <published>2020-04-02T06:28:09.000Z</published>
    <updated>2020-04-03T16:48:54.728Z</updated>
    
    <content type="html"><![CDATA[<p>单文件无依赖发布，是 go 语言一项杀手级特性。看着不怎么起眼，但被应用发布和运维折磨过的朋友，会明白这意味着什么。</p>
<p>可没高兴多久，发现应用还是要引入各种静态资源。这时就要拿出 go-bindata 了。</p>
<a id="more"></a>
<blockquote>
<p>本文没有一开始给出最佳实践，而是从最简单的做法开始，展示一点一点改进的过程。长度尽量精简，希望你看到最后。</p>
</blockquote>
<h2 id="壹、是什么"><a href="#壹、是什么" class="headerlink" title="壹、是什么"></a>壹、是什么</h2><p>项目主页：<a href="https://github.com/go-bindata/go-bindata" target="_blank" rel="external">https://github.com/go-bindata/go-bindata</a></p>
<p>官方自述：</p>
<blockquote>
<p>This package converts any file into managable Go source code. Useful for embedding binary data into a go program. The file data is optionally gzip compressed before being converted to a raw byte slice.</p>
</blockquote>
<p>简单说，将 <strong>任意</strong> 文件转成 go 源码。它还可以帮你把数据 <strong>压缩一下</strong> 。常用于将数据嵌入程序。</p>
<p>这些资源文件变成源码之后，数据储存在字节切片中 (raw byte slice)，只需要导入生成的源码，调用几个简单的函数就可访问，反正比 文件IO 来得 <strong>简单和快</strong> 。因为是源码，也会加入编译，最后 <strong>包含在可执行文件中</strong> ，发布时也就不再需要带着资源文件。</p>
<p>原文写的是二进制数据，大概作者认为纯文本和字面量本身就可以在程序中声明。但下面你会看到，即使是这些数据，也有使用 go-bindata 的必要。</p>
<h2 id="贰、安装"><a href="#贰、安装" class="headerlink" title="贰、安装"></a>贰、安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get -u github.com/go-bindata/go-bindata/...</div></pre></td></tr></table></figure>
<p>一行命令，没什么好说的。三个点是指检查并安装所有子目录（如果有可以编译的 main 函数）。实际上提供的 CLI 工具在 go-bindata 子目录里，也就是 <code>github.com/go-bindata/go-bindata/go-bindata/</code> ，三个 go-bindata 从前到后分别是 organ 名、项目名、目录名。</p>
<p>你可能会发现，这里提供的地址，跟其他一些文章给的不一样。为了不把前面拖长，背后的故事放到了 <strong>最后</strong> 。</p>
<h2 id="叁、使用"><a href="#叁、使用" class="headerlink" title="叁、使用"></a>叁、使用</h2><p>先看帮助信息（当前版本 v3.1.2 。篇幅关系，省略了详细内容，你还是安装之后自己执行一遍吧。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">go-bindata --help <span class="comment"># 虽然参数列表里没有 --help, 但是确实起效了，-h 也有效</span></div><div class="line">Usage: go-bindata [options] &lt;input directories&gt;</div><div class="line"></div><div class="line">  -debug</div><div class="line">  -dev</div><div class="line">  -fs</div><div class="line">  -ignore value</div><div class="line">  -mode uint</div><div class="line">  -modtime int</div><div class="line">  -nocompress</div><div class="line">  -nomemcopy</div><div class="line">  -nometadata</div><div class="line">  -o string (default <span class="string">"./bindata.go"</span>)</div><div class="line">  -pkg string (default <span class="string">"main"</span>)</div><div class="line">  -prefix string</div><div class="line">  -tags string</div><div class="line">  -version</div></pre></td></tr></table></figure>
<p>最 <strong>基本的用法</strong> 是直接命令 + 目录，参数全部走默认（生成 <code>./bindata.go</code> ，包名 <code>main</code>），只包含目标目录，不包括子目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-bindata data/</div></pre></td></tr></table></figure>
<p>但这样用过于粗糙，特别是生成的源码直接放在根目录的 main 包下，不方便管理。</p>
<p>网上比较 <strong>常见的用法</strong> 是这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-bindata -o=asset/asset.go -ignore=<span class="string">"\\.DS_Store|desktop.ini|README.md"</span> -pkg=asset template/... theme/... doc/...</div></pre></td></tr></table></figure>
<p>做出的改进有：</p>
<ul>
<li>为了更好地管理生成的源码，（<code>-o</code>）指定输出的目录和文件名，（<code>-pkg</code>）给一个独立的包名（为了减少 import 时的认知负担，建议三者直接保持一致）。</li>
<li>目标目录可以有多个，三句点省略号表示 <strong>递归包含子目录</strong> 。</li>
<li>为了避免一些常见的文件被当作资源文件编译进去，（<code>-ignore</code>）添加一个 ignore pattern，注意用的是 <strong>正则表达式</strong> 。</li>
</ul>
<p>而我更 <strong>推荐的用法</strong> 是尽量把资源文件集中放在一个目录下面，避免这里放一点那里放一点，最后生成时遗漏。例如统一放 <code>assets</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-bindata -o=bindata/bindata.go -ignore=<span class="string">"\\.DS_Store|desktop.ini|README.md"</span> -pkg=bindata -prefix=assets assets/...</div></pre></td></tr></table></figure>
<ul>
<li><code>assets</code> 目录放了资源文件之后，为了避免混淆，也为了一眼能看出来是 go-bindata 生成的代码，源码路径、文件名 和 包名，都统一改为了 <code>bindata</code>。</li>
<li>资源既然统一放在 <code>assets</code> 目录下，增加 <code>-prefix</code> 参数，在生成的代码中去掉公共前缀。这样就可以直接用 <code>abc.png</code> 来引用 <code>assets/abc.png</code> 。</li>
</ul>
<p>执行这行命令得到的 <code>./bindata/bindata.go</code> 大概是这样子的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Code generated by go-bindata. DO NOT EDIT. @generated</span></div><div class="line"><span class="comment">// sources:</span></div><div class="line"><span class="comment">// assets/web.toml</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 被转换的文件清单...</span></div><div class="line"><span class="keyword">package</span> bindata</div><div class="line"></div><div class="line"><span class="keyword">import</span> (<span class="comment">/*...*/</span>)</div><div class="line"></div><div class="line"><span class="comment">// 私有结构体、函数定义</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 数据以私有 []byte 的方式保存</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 篇幅关系，只展示公共 API</span></div><div class="line"></div><div class="line"><span class="comment">// Asset 根据文件名读取文件内容的 []byte，出错返回 error</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Asset</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// MustAsset 跟 Asset 的区别只在于出错不返回 error ，直接 panic</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustAsset</span><span class="params">(name <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// AssetInfo 根据文件名返回文件信息</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssetInfo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(os.FileInfo, error)</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// AssetNames 返回所有文件名</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssetNames</span><span class="params">()</span> []<span class="title">string</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// AssetDir 返回指定目录下的所有文件，可以近似看作 ls / dir 命令</span></div><div class="line"><span class="comment">// 参数从根目录算起，空串 "" 当作根目录</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssetDir</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// RestoreAsset 将 name 指定的文件，恢复到 dir 指定的位置上</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">RestoreAsset</span><span class="params">(dir, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// RestoreAssets 是递归版的 RestoreAsset，如果 name 是目录，会递归执行下去</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">RestoreAssets</span><span class="params">(dir, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div></pre></td></tr></table></figure>
<p>除此以外，再了解一下 <code>-debug</code>  和 <code>-dev</code> 参数，就基本够用了，更多参数完全可以看着帮助信息自己试。</p>
<p>加了这两个参数（的其中一个），转换时不会真的把资源放进生成的源码，还是去原来的文件读，只是做了一层 API 封装。这样有利于开发和资源设计并行。</p>
<ul>
<li>代码已经生成，开发可以基于生成的 API 进行，背后究竟读硬盘上的文件还是内存里的切片，不影响调用。</li>
<li>各种资源文件还可以继续修改，只要在原有的文件上修改，没有新增文件或者重命名，就不需要重新执行 go-bindata 重新生成。频繁修改资源文件，调试时很容易忘掉是否有重新执行 go-bindata 。这个特性就特别有用。</li>
</ul>
<p><code>-debug</code> 和 <code>-dev</code> 之间的差别，仅仅是背后加载文件时，使用 绝对路径 还是 相对路径。这个看调试方便，差别不是特别大，正式的构建时时一定要关掉的。</p>
<h2 id="肆、自动生成"><a href="#肆、自动生成" class="headerlink" title="肆、自动生成"></a>肆、自动生成</h2><p>已经有固定的命令 + 参数搭配了，但是每次执行，不要说手敲麻烦又易错，就连复制粘贴都是体力活。</p>
<p>更不要说修改完资源容易忘掉重新执行转换。这时候就需要 go generate 和 make 出场了。</p>
<blockquote>
<p>关于 go generate 的详细介绍和用法，请自行搜索，或者等我后续介绍。</p>
<p>在 Windows 下配置 make 的方法，已经在前面几篇介绍 go 开发环境配置中写了。后续也考虑介绍 Makefile 的写法。</p>
<p>anyway，两个都只讲用到的，这里不详细展开。</p>
</blockquote>
<h3 id="go-generate"><a href="#go-generate" class="headerlink" title="go generate"></a>go generate</h3><p><code>go generate</code> 是 go 工具链自带的命令，自 go 1.4 之后提供。（写文章时最新是 1.14，我还在用 1.13）</p>
<p>只要在某个 go 源文件开头写（注意 <code>//go:generate</code> 前面和中间没有任何空格，冒号是半角冒号）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:generate go-bindata -o=bindata/bindata.go -ignore="\\.DS_Store|desktop.ini|README.md" -pkg=bindata assets/...</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> xyz</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"abc"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>这之后只要执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go generate</div></pre></td></tr></table></figure>
<p>工具链就会自行扫描项目所有源码里的 <code>//go:generate &lt;cmd&gt; [args]...</code> ，执行里面的 <code>cmd args</code> ，包括但不限于 go-bindata，任何在当前工作目录可以执行的命令，都行。</p>
<p>建议哪里的代码引用了资源文件，这行指令就放那个源码的开头。如果多处引用，则建议统一放程序入口。</p>
<h3 id="go-generate-make"><a href="#go-generate-make" class="headerlink" title="go generate + make"></a>go generate + make</h3><p>但 generate 只是解放了一长串命令 + 参数 的记忆负担，对强迫症来说，每次修改资源都要记得 <code>go generate</code> 仍然很难受。这时可以用 make 减轻负担。因为重点不是介绍 make，直接上结论：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: bindata build</span></div><div class="line"></div><div class="line">all: build</div><div class="line"></div><div class="line"><span class="comment"># build 依赖 bindata.go，这样构建时就不会忘掉生成</span></div><div class="line">build: bindata/bindata.go</div><div class="line">	go build # 真实项目中 go build 应该加上更多编译参数，这里不是重点，省略</div><div class="line"></div><div class="line"><span class="section">bindata:</span></div><div class="line">	go generate</div><div class="line"></div><div class="line">bindata/bindata.go: assets/*</div><div class="line">	go generate</div></pre></td></tr></table></figure>
<p>稍微解释一下 <code>bindata</code> 和 <code>bindata/bindata.go</code> 两个 target ：它们都是要执行 <code>go generate</code>  命令，生成转换后的源码，区别在于，前者是 <strong>伪目标</strong> ， 后者是真实文件。</p>
<ul>
<li><code>bindata</code> ：不存在这么一个文件，而且前面显式声明了它是一个伪目标 (phony target) ，意味着构建这个目标时，不需要判断文件是否存在和新旧，必定执行。可以用来在特殊情况下强制执行（如资源文件通过 <code>cp -p</code> 从别的地方拷贝过来覆盖过）。</li>
<li><code>bindata/bindata.go</code> ：是真实的文件。make 会比较 target 和 prerequisites 是否存在和修改时间先后判断是否执行。<code>bindata/bindata.go</code> 存在且最新时，是不会执行命令的。</li>
</ul>
<p>这个实际试一下就明白了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 前面已经生成了最新的 bindata/bindata.go</span></div><div class="line">make bindata/bindata.go</div><div class="line">make: <span class="string">'bindata/bindata.go'</span> is up to date.</div><div class="line"></div><div class="line"><span class="comment"># make bindata 仍然有效</span></div><div class="line">make bindata</div><div class="line">go generate <span class="comment"># 这行是 make 的 echo，说明 go generate 执行了</span></div><div class="line"></div><div class="line"><span class="comment"># 这时更新一下其中一个资源的时间</span></div><div class="line">touch assets/web.toml</div><div class="line">make bindata/bindata.go</div><div class="line">go generate <span class="comment"># 同上，这行是 make 的 echo</span></div></pre></td></tr></table></figure>
<h3 id="make-就够了"><a href="#make-就够了" class="headerlink" title="make 就够了"></a>make 就够了</h3><p>不过这样也还是有问题。</p>
<p>随着加入更多的代码生成工具，像 stringer （自动生成 String 方法），wire（自动生成依赖注入），protobufs（从 .proto 生成 .pb.go）等等，都要靠 <code>go generate</code> 触发。这时 <strong>粒度</strong> 就有点粗了，明明只是其中一种修改了要重新生成，偏偏一个 <code>go generate</code> 全部都触发。文件少的时候还好，多的时候就会平白增加生成和磁盘读写的时间。</p>
<p>而且分散在各个 go 文件注释中的 go generate 指令也增加了管理难度。</p>
<p>其实就大多数生成命令而言，make 就够用了。go generate 能做到的事情，make 基本都可以完成，还能定义宏和依赖关系，更加灵活。全局的生成指令建议 <strong>都放到 Makefile</strong>。只有个别生成指令跟某个 go 源文件高度相关、参数各处不一样，可以继续放在注释里，靠 go generate 调用。</p>
<p>修改之后的 Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里只是为了演示，实际中不改动的部分没有必要定义宏</span></div><div class="line"><span class="comment"># 或者定义一个 BINDATA_NAME 统一用它就好</span></div><div class="line">BINDATA_PATH = bindata</div><div class="line">BINDATA_NAME = bindata</div><div class="line">BINDATA_PACKAGE = bindata</div><div class="line">BINDATA_DIR = assets</div><div class="line"><span class="comment"># ignore list 还是建议定义一个宏，方便随时添加</span></div><div class="line">BINDATA_IGNORE = "\\.DS_Store|desktop.ini|README.md"</div><div class="line"></div><div class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: bindata build</span></div><div class="line"></div><div class="line">all: build</div><div class="line"></div><div class="line">build: bindata/bindata.go</div><div class="line">	go build</div><div class="line"></div><div class="line"><span class="comment"># 这两个 target 执行的命令一样，合并成一条规则</span></div><div class="line">bindata bindata/bindata.go: $(BINDATA_DIR)/*</div><div class="line">	go-bindata -o=<span class="variable">$(BINDATA_PATH)</span>/<span class="variable">$(BINDATA_NAME)</span>.go -ignore=<span class="variable">$(BINDATA_IGNORE)</span> -pkg=<span class="variable">$(BINDATA_PACKAGE)</span> -prefix=<span class="variable">$(BINDATA_DIR)</span> <span class="variable">$(BINDATA_DIR)</span>/...</div></pre></td></tr></table></figure>
<h2 id="伍、配置文件嵌入"><a href="#伍、配置文件嵌入" class="headerlink" title="伍、配置文件嵌入"></a>伍、配置文件嵌入</h2><p>回到文章开头提出的场景。</p>
<p>嵌入资源文件，是为了保持单文件发布的优势。各种资源嵌入源码后，不仅应用变成了单个可执行文件，数据还做了（Gzip）压缩。直接从代码区读取数据，也比磁盘 IO 要来的快捷可控。基本上只要文件不是非常巨大，资源嵌入都是利大于弊的。</p>
<p>而对于配置文件而言，要考虑得多一些。要允许用户修改配置，代码中的配置是无法修改的。这面临几个选择：</p>
<ol>
<li><p>应用单文件发布，配置文件让用户自行创建。</p>
<p> 开发角度看很方便。但对用户不友好，特别是开源项目。用户面对的只有可执行文件，只能尝试执行、启动，或者看一下 help 信息。对于如何、在哪创建配置文件，该怎么写，新用户 <strong>毫无头绪</strong> 。这样做需要项目文档相对完善，文档中有配置的章节，并且文档入口放在项目主页显眼的地方，最好在 help 信息里也有。</p>
</li>
<li><p>可执行文件带着默认的配置文件，打包发布。</p>
<p> 这种做法对用户友好一些。但首先享受不到单文件发布的便利。而且用户一旦不小心错误覆盖、或者删除了配置文件，仍然陷入了第一种情况，需要从头手敲配置。</p>
<p> 一种改进是将默认配置加上 <code>.sample</code> 后缀，用户启用了配置文件需要拷贝一份后去掉多余的后缀。这看起来是个好办法，把上述问题除了单文件发布都解决了。我用过这个方案。实际中发现哪怕仅仅拷贝重命名，对于小白用户而言还是 <strong>过于复杂</strong>，能产生各种开发者想象不到的问题。（Windows 上隐藏了后缀名，怎么改都不对；直接把 sample 文件覆盖了，出错了不知道拿什么做参考…）</p>
</li>
</ol>
<p>经过不同的尝试，我认为比较好的办法是：</p>
<ul>
<li>把默认配置嵌入代码，单文件发布；</li>
<li>在某个时机，将默认配置重新写回磁盘，用户在这个文件基础上修改配置；（这个时机可以是一个显式的 install 操作，也可以是启动时发现还没有配置文件，等等，根据需要实现）</li>
<li>如果因为某些原因丢失了配置，重新生成默认配置即可。</li>
</ul>
<p>代码实现（假定默认配置为 <code>assets/web.toml</code>，已经按上面最后的配置转换成 <code>bindata/bindata.go</code>）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> config</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"path/filepath"</span></div><div class="line"></div><div class="line">	<span class="string">"playground/bindata"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	customDir  = <span class="string">"custom"</span></div><div class="line">	configFile = <span class="string">"web.toml"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">()</span> *<span class="title">Config</span></span> &#123;</div><div class="line">	maybeRestoreConfigFile()</div><div class="line">	<span class="keyword">return</span> loadConfigFromFile()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">maybeRestoreConfigFile</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !isFile(filepath.Join(customDir, configFile)) &#123;</div><div class="line">        <span class="comment">// 如果配置文件不存在，先将默认配置恢复到目标位置</span></div><div class="line">		bindata.RestoreAsset(customDir, configFile)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfigFromFile</span><span class="params">()</span> *<span class="title">Config</span></span> &#123;<span class="comment">/*...*/</span>&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;<span class="comment">/* 判断一个路径是不是一个文件 */</span>&#125;</div></pre></td></tr></table></figure>
<p>篇幅关系，这是一个非常精简的例子，省略了很多错误判断，不重要的函数也把实现删掉了。最后外部直接调用 <code>config.Load()</code> ，无论原本是否有配置文件，都能加载到配置。</p>
<p>如果配置比较复杂，不想静默地生成一个默认配置，可以显式地加入一个 <code>install</code> 之类的命令，引导用户填写一些配置，再结合默认配置生成。但总体上是这么个思路。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>提一下 go-bindata 项目之前的一些周折。</p>
<p>如果你搜索 go-bindata 的文章，会发现早期的文章指向的项目地址往往是：<a href="https://github.com/jteeuwen/go-bindata" target="_blank" rel="external">https://github.com/jteeuwen/go-bindata</a> 。那是最早的项目地址，<code>jteeuwen</code> 是原作者 Jim Teeuwen 的账号。</p>
<p>但不知道什么时候，因为什么原因，原作者把项目关闭了，连 <code>jteeuwen</code> 这个账号都删除了。（从现存线索推断，大约是 2018 年的事）</p>
<p>现在原地址也有一个项目，但已经 <strong>不是原项目</strong> ，也 <strong>不再维护</strong> 了。那是有人发现 go-bindata 删除后，为了让依赖它的项目不会报错，重新注册了 <code>jteeuwen</code> 这个账号，重新 fork 了这个项目 (真正原项目已删，是从一个 fork 那里 fork 的) 。因为初衷是让某个项目能够继续工作（据说是已经没法修改的私人项目，所以也不能指向新的地址），并没有打算继续维护，也不想冒充原项目，所以这个项目设为了 archived (read only)。详情可以参考以下讨论：</p>
<ul>
<li><p><a href="https://github.com/jteeuwen/go-bindata/issues/5" target="_blank" rel="external">https://github.com/jteeuwen/go-bindata/issues/5</a></p>
</li>
<li><p><a href="https://github.com/jteeuwen/discussions/issues" target="_blank" rel="external">https://github.com/jteeuwen/discussions/issues</a></p>
</li>
</ul>
<p>现在给出的项目地址，不确定跟原作者有没有关系——估计是没有的。那它不过是众多 fork 的其中一个。选它仅仅因为它最活跃、关注人数最多。这可能跟它挂在了同名 organization 下有一定关系，也可能里面有某个大牛。</p>
<p>理由并不重要，只需要知道它最活跃是一个共识，就够了。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单文件无依赖发布，是 go 语言一项杀手级特性。看着不怎么起眼，但被应用发布和运维折磨过的朋友，会明白这意味着什么。&lt;/p&gt;
&lt;p&gt;可没高兴多久，发现应用还是要引入各种静态资源。这时就要拿出 go-bindata 了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>渐进式图像加载</title>
    <link href="https://jaycechant.info/2020/progressive-image-loading/"/>
    <id>https://jaycechant.info/2020/progressive-image-loading/</id>
    <published>2020-03-20T11:30:39.000Z</published>
    <updated>2020-03-22T03:42:28.323Z</updated>
    
    <content type="html"><![CDATA[<p>网页上的图片，先加载一个模糊预览，然后逐渐变清晰，怎么实现的？</p>
<a id="more"></a>
<h2 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h2><p>之前文章多是折腾记录，宁可长篇大论，也懒得截 / 画图。前几天，发演示文档截图，一篇的配图是之前所有配图总量的 7 倍。博客托管在 Github pages，因不~明原因，访问速度越来越慢。图多 + 访问慢，居然偶尔能看到图片加载的过程 —— 就是那种等待投影幕放下来的效果，偏偏放得很慢，还卡顿。</p>
<p><img src="../../images/basiline-jpeg-load.png" alt=""></p>
<p>通过压缩图片大小算是初步解决。</p>
<p>可如果访问速度进一步恶化呢？这时想起之前见过另一种加载效果，不是下放幕布，而是类似对焦，先显示一幅非常模糊的图片，然后逐渐变清晰。于是有了开头一问。</p>
<p><img src="../../images/progressive-jpeg-load.png" alt=""></p>
<p>直觉技术上应该不难，之前居然没想过去了解。</p>
<h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><p>经过尝试不同的关键词组合，大概知道关键词应该是 ‘progressive image loading’ / 渐进式图像加载。看完网上讨论，发现可以分成两大类方案：</p>
<ul>
<li><p>代码方案</p>
<p>  具体实现方式很多，web 的 app 的，自己写代码，或者调用第三方库。但基本原理是相通的：</p>
<ol>
<li>先加载一个很小很模糊的预览图，拉伸到目标图像大小。这样会锯齿，没关系，加个高斯模糊（或者别的模糊算法）。</li>
<li>利用预览安抚用户的时间，把原图下载下来。</li>
<li>两图叠加前图透明也好，图片替换也好，换的同时，将模糊渐变到 0，看到原图。</li>
</ol>
</li>
<li><p>文件编码方案</p>
<p>  查到的有 interlace gif，progressive jpeg，interlace png 三种。实际上只是格式规范选用的术语不同，效果上都是 progressive 渐进显示。</p>
<p>  本质上是改变文件的数据块组织顺序，从原本的线性从左上到右下，变成按照某些特定的方式组织，让用户端在只下载了少量数据时，就能显示图片轮廓。然后随着下载的数据越来越多，逐渐清晰，直至显示原图。</p>
</li>
</ul>
<p>代码方案显然更灵活，可以根据需要实现不同的效果。而且因为加了模糊，不会出现难看的锯齿效果。</p>
<p>不过相对应地，代码方案开发和维护的负担也增加。如果平台支持图片格式的 progressive 特性（主要是 浏览器，暂时不考虑 app），直接改动文件显然是更省事的方案。</p>
<p>显然我不愿意为这么小的事情在博客模版加代码，格式自带的编码方案是当前首选。代码方案留待以后有需要再试。</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>据说常见的制图工具，导出选项里都有对应的选项。png 和 gif 格式的选项是 interlace（一般翻译成交错），jpeg(jpg) 的选项则是 progressive （翻译成 渐进）。</p>
<p>网上大家的截图证明 Photoshop 是可以的。我尝试 GIMP 2.8 是可以的。惊喜的是，常用的其中一个图片浏览器 XnView 也可以。用 XnView 打开图片，另存为 &gt; 选项 &gt; 选好格式和选项后保存。非常快捷，与之相比，特意打开一个大型的 编辑 / 设计 软件只修改文件的编码方式简直杀鸡牛刀。</p>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>问题又来了：怎么判断一个图片是否打开了 progressive 选项呢？</p>
<p>答案是：<strong>不知道</strong> 。试了不同的软件打开，然后查看图片详情和元信息，没有一个地方显示是否打开了 interlace / progressive 特性。</p>
<blockquote>
<p>注：在文章快写完时，才发现用 XnView 打开，显示『图像信息』，在格式一栏有显示，非常地不起眼（本以为会有一个独立字段显示）。</p>
<ul>
<li>png 会显示 <code>Portable Network Graphics (Interlaced)</code> ，多出括号里的 Interlaced。</li>
<li>gif 会显示 <code>Compuserve GIF (Version 89a - Interlaced)</code>，同样多了 Interlaced.</li>
<li>jpg 文件仍然没有看到区别。</li>
</ul>
</blockquote>
<p>看不出差别，意味着没法判断图片是否 progressive。正常网速下，肉眼根本无法看到加载过程。你也很难模拟一个特别卡的网络环境，去测试加载过程。</p>
<p>后来找到一个在线测试，可以测试网页引用的图片是否 progressive：<a href="https://webpagetest.org/。输入要测试页面的地址，点击开始测试即可。有很多测试项，其中" target="_blank" rel="external">https://webpagetest.org/。输入要测试页面的地址，点击开始测试即可。有很多测试项，其中</a> Performance Review 页可以看资源的加载情况。其他测试项对优化网页也有一定的参考意义。</p>
<p>不过，</p>
<ol>
<li>只支持 progressive jpg 检测。</li>
<li>需要先把网页发布到外网访问，测试后发现不对再优化。</li>
<li>这个测试使用了谷歌的 recaptcha 验证，很多朋友会用不了。</li>
</ol>
<p>就本文的目的而言，意义不大。</p>
<h2 id="格式规范-Specifications"><a href="#格式规范-Specifications" class="headerlink" title="格式规范 Specifications"></a>格式规范 Specifications</h2><p>考虑到博客配图以图表为主，多数是有清晰边缘的色块，很少实景照片，而且 png 支持 alpha 通道，显然选择 png 格式会得到更好的显示效果，压缩率也（大概率）不会比 jpg 差。所以下面主要研究 png 的格式。</p>
<h3 id="RFC2083"><a href="#RFC2083" class="headerlink" title="RFC2083"></a>RFC2083</h3><p>查维基可知，png 是 Portable Network Graphics 或 PNG is Not GIF 的缩写。1996 年由 IETF（Internet Engineering Task Force，互联网工程任务组）起草，并成为 W3C 建议，后成为 RFC2083。现行版本是 2003 年的国际标准 ISO 15948。</p>
<blockquote>
<ul>
<li>查询 RFC ：<a href="https://www.rfc-editor.org/search/rfc_search.php，可以用关键词或者编号查询" target="_blank" rel="external">https://www.rfc-editor.org/search/rfc_search.php，可以用关键词或者编号查询</a></li>
<li>RFC2083：<a href="https://www.rfc-editor.org/rfc/rfc2083.html" target="_blank" rel="external">https://www.rfc-editor.org/rfc/rfc2083.html</a></li>
<li>png 官网：<a href="http://www.libpng.org/pub/png/" target="_blank" rel="external">http://www.libpng.org/pub/png/</a></li>
<li>最新版规范：<a href="http://www.libpng.org/pub/png/spec/iso/index-object.html" target="_blank" rel="external">http://www.libpng.org/pub/png/spec/iso/index-object.html</a></li>
</ul>
</blockquote>
<p>规范很长，规定了格式的定义的方方面面。没打算实现一个 encoder 或者 decoder，直接搜 interlace 部分。</p>
<p>对比两版规范可以发现，interlace 在第一版就已经有了，而且基本没有改动。我们看最新的规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">8.2 Interlace methods</div><div class="line">Two interlace methods are defined in this International Standard, methods 0 and 1. Other values of interlace method are reserved for future (see 4.9: Extension and registration).</div></pre></td></tr></table></figure>
<p>大意：定义了 0 和 1 两种交错方式（分别是关闭和打开），剩下的值为未来保留。那这个值保存在哪里呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">11 Chunk specifications</div><div class="line">11.1 Introduction</div><div class="line">The PNG datastream consists of a PNG signature (see 5.2: PNG signature) followed by a sequence of chunks. Each chunk has a chunk type which specifies its function. ......</div><div class="line">......</div><div class="line">11.2 Critical chunks</div><div class="line">......</div><div class="line">11.2.2 IHDR Image header</div><div class="line">The four-byte chunk type field contains the decimal values</div><div class="line"></div><div class="line">73 72 68 82 // 注：49 48 44 52，其实就是 IHDR 的 ASCII 码。为了方便后续比较，列出十六进制值，下同。</div><div class="line">The IHDR chunk shall be the first chunk in the PNG datastream. It contains:</div><div class="line"></div><div class="line">Width	4 bytes</div><div class="line">Height	4 bytes</div><div class="line">Bit depth	1 byte</div><div class="line">Colour type	1 byte</div><div class="line">Compression method	1 byte</div><div class="line">Filter method	1 byte</div><div class="line">Interlace method	1 byte</div></pre></td></tr></table></figure>
<p>大意：一个 png 文件以 PNG 签名开头，然后是一系列数据块。第一号数据块是 IHDR（Image Header） 块，以 4 字节的 <strong>块类型</strong> 字段开头，然后是一系列字段，interlace method 是第 13 个字节。</p>
<p>再去看这里提到的 PNG 签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">5.2 PNG signature</div><div class="line">The first eight bytes of a PNG datastream always contain the following (decimal) values:</div><div class="line"></div><div class="line">137 80 78 71 13 10 26 10 // 注：89 50 4E 47 0D 0A 1A 0A，其中 50 4E 47 是 PNG 的 ASCII 码。</div><div class="line"></div><div class="line">This signature indicates that the remainder of the datastream contains a single PNG image, consisting of a series of chunks beginning with an IHDR chunk and ending with an IEND chunk.</div><div class="line">5.3 Chunk layout</div><div class="line">Each chunk consists of three or four fields (see figure 5.1). The meaning of the fields is described in Table 5.1. The chunk data field may be empty.</div><div class="line">LENGTH, CHUNK TYPE, CHUNK DATA, CRC</div><div class="line">OR</div><div class="line">LENGTH(=0), CHUNK TYPE, CRC</div></pre></td></tr></table></figure>
<p>略长挑重点：PNG 签名占据开头的 8 个字节。一个数据块则是 4 字节标数据块大小 LENGTH， 4 字节块类型，LENGTH 字节大小的数据，CRC 校验码。</p>
<p>这些信息足够做一个小学算术：8（PNG 签名）+ 4 （块长度）+ 4（块类型字段）+ 13（块数据内字节顺序） = 29。Interlace method 字段在 第 29 个字节。而且由于前面的数据都是固定不可省略的，所以这个顺序也是固定的。</p>
<h3 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h3><p>随便找了一张 png，用 XnView 生成一张 interlace 版本，分别用 十六进制编辑器打开：</p>
<p>标准版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52</div><div class="line">00 00 02 00 00 00 01 72 08 03 00 00 00 B4 A4 92</div></pre></td></tr></table></figure>
<p>交错版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52</div><div class="line">00 00 02 00 00 00 01 72 08 03 00 00 01 C3 A3 A2</div></pre></td></tr></table></figure>
<ul>
<li>开头 8 个字节：都是 <code>89 50 4E 47 0D 0A 1A 0A</code>，符合文档说明。</li>
<li>第二部分 4 个字节：都是 <code>00 00 00 0D</code> （13），符合 IHDR 数据长度是 13。</li>
<li>第三部分 4 个字节：<code>49 48 44 52</code>（IHDR），是块类型。</li>
<li>第四部分 13 个字节，直接看 第 13个：符合 标准版是 <code>00</code>，交错版是 <code>01</code>。</li>
</ul>
<p>再试了几个文件，都符合以上规律。说明对规范的理解是正确的。那么在没有找到工具支持查看 interlace 特性时，可以直接用 十六进制编辑器打开 判断：第 29 个字节，或者像这样每行 16 个字节排版的第 2 行倒数第 4 个字节。</p>
<h3 id="交错实现原理"><a href="#交错实现原理" class="headerlink" title="交错实现原理"></a>交错实现原理</h3><p>在文档 <code>4.5 Encoding the PNG image</code> 和 <code>8 Interlacing and pass extraction</code> 解释了 interlace 的原理。篇幅所限，就不贴原文了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1 6 4 6 2 6 4 6</div><div class="line">7 7 7 7 7 7 7 7</div><div class="line">5 6 5 6 5 6 5 6</div><div class="line">7 7 7 7 7 7 7 7</div><div class="line">3 6 4 6 3 6 4 6</div><div class="line">7 7 7 7 7 7 7 7</div><div class="line">5 6 5 6 5 6 5 6</div><div class="line">7 7 7 7 7 7 7 7</div></pre></td></tr></table></figure>
<p>核心其实就是这个 8x8 的顺序表。interlace 会把整个图像分割成 N 个 8x8 像素的小方块，每块上的像素按照这样的顺序编号。编码传输时，并非从左上到右下顺序进行，而是先把所有的 1 放前面，然后是所有的 2…… 以此类推。</p>
<p>假定现在有一张 16x16 的图，也就是会按上面分成 4 块进行编号。那么传输仅仅 4 个像素（1 / 64）之后，我们就能看到一个模糊的轮廓（这个只有 4 个像素的图会拉伸到原图大小，所以锯齿会非常明显）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 1</div><div class="line">1 1</div></pre></td></tr></table></figure>
<p>再传 4 个像素，变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 2 1 2</div><div class="line">1 2 1 2</div></pre></td></tr></table></figure>
<p>再传 8 个像素，变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1 2 1 2</div><div class="line">3 3 3 3</div><div class="line">1 2 1 2</div><div class="line">3 3 3 3</div></pre></td></tr></table></figure>
<p>以此类推。从 N 个像素开始构建一个最粗糙的缩略图（reduced image），然后每当传输的像素数量翻一番，清晰度就提高一倍，直到显示出原图。</p>
<h3 id="其他格式"><a href="#其他格式" class="headerlink" title="其他格式"></a>其他格式</h3><p>查找文档，理解文档，试验核实，花了一些时间，和占据了颇长的篇幅。考虑到主要用 png，就懒得折腾剩下两种格式了。把文档地址贴出来，有兴趣的朋友可以自己看看。</p>
<p>GIF Version 89a：<a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt" target="_blank" rel="external">https://www.w3.org/Graphics/GIF/spec-gif89a.txt</a></p>
<p>JPEG 官网：<a href="https://jpeg.org/" target="_blank" rel="external">https://jpeg.org/</a></p>
<p>大概扫了一眼，这两种格式要麻烦很多。</p>
<p>GIF 的 interlace flag 比较靠后，前面有好几个数据块，计算偏移会麻烦些。</p>
<p>更麻烦的是 JPEG。JPEG 实际上是一个组织名，<strong>联合图像专家组</strong>（Joint Photographic Experts Group），用作后缀时实际上是指 JFIF（JPEG File Interchange Format，JPEG 文件交换格式）。但除此之外，还有 JPEG-XT, JPEG Lossless, JPEG 2000, JPEG-XR……等等格式。虽然我知道这里面很多格式并不共享 <code>.jpeg</code> 这个后缀名，而是各自有专属的后缀。但是在全部看完他们的规范之前，还是无法确定他们跟 JPEG 的关系，以及 JPEG 从哪个版本开始支持 progressive 特性 —— 据了解第一版是不支持的，而 JFIF3 的规范文档里，也完全搜不到 interlace 或者 progressive 这些关键词。</p>
<p>好吧，这次就先到这里吧。以后有空，或者用到 JPEG 时再回来继续。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>其实目前对于 渐进式加载 的需要并没有那么急切。我只是惊讶于自己老早看过这种效果，居然没有想过去探究。感觉应该不复杂，想着了解一下就完了，没想到工具支持不算完善，中文互联网上的资料质量也很参差（基本是互相参考，抄来抄去连排版都不改）。</p>
<p>后面直接去读官方的规范文档，只看某一部分的话，加一点耐心查找和理解，并不难。</p>
<p>最后，前面用到了十六进制编辑器，选择不少；甚至一些文本编辑器，通过插件或者开关也可以支持。我使用的是以下这个，免费不开源，还挺好用，供参考：</p>
<p><a href="https://mh-nexus.de/en/downloads.php?product=HxD20" target="_blank" rel="external">https://mh-nexus.de/en/downloads.php?product=HxD20</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://jmperezperez.com/more-progressive-image-loading/" target="_blank" rel="external">https://jmperezperez.com/more-progressive-image-loading/</a></p>
<p><a href="https://www.hostinger.com/tutorials/website/improving-website-performance-using-progressive-jpeg-images" target="_blank" rel="external">https://www.hostinger.com/tutorials/website/improving-website-performance-using-progressive-jpeg-images</a></p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网页上的图片，先加载一个模糊预览，然后逐渐变清晰，怎么实现的？&lt;/p&gt;
    
    </summary>
    
    
      <category term="png" scheme="https://jaycechant.info/tags/png/"/>
    
      <category term="jpg" scheme="https://jaycechant.info/tags/jpg/"/>
    
  </entry>
  
  <entry>
    <title>我该学编程吗？</title>
    <link href="https://jaycechant.info/2020/should-i-learn-programming/"/>
    <id>https://jaycechant.info/2020/should-i-learn-programming/</id>
    <published>2020-03-17T17:29:21.000Z</published>
    <updated>2020-03-18T10:39:04.061Z</updated>
    
    <content type="html"><![CDATA[<p>有部分朋友面临这个困惑。</p>
<ul>
<li>一种是互联网行业的非技术岗，能接触到 IT 技术人员，对编程有一定认识，知道这个对工作有帮助，想学。但怕学不来，不知道怎么学。</li>
<li>另一种是完全没有接触，只是大概听说 IT 行业前（钱）景好。听说哪哪地方编程进课堂。然后碰见广告，或者大街上宣传学编程，产生了疑问：我（我的孩子）该学编程吗？</li>
</ul>
<a id="more"></a>
<blockquote>
<p>还有一种情况，已经是 IT 研发，可能非科班出身，基础薄弱，感觉补课补得有点吃力，萌生了退意。严格来说，不是目标读者，但也可以看一下一些观点，可能有一些启发。</p>
</blockquote>
<p>他们会咨询我，自己 / 孩子要不要学；也有我建议亲友了解一下之后，对方表示对此毫无概念。</p>
<p>与此同时，网络上充斥着各种对这个行业、这个群体的误解：</p>
<ul>
<li>程序员会自黑（压力大秃头、无情趣理工直男、工作时间长单身…），渲染得行业和岗位非常可怕。</li>
<li>各种少儿编程、成人培训班，会把编程渲染得无所不能，同时又非常容易学。（学会了这个，工作自动完成，学费只要9.9，一杯奶茶的钱…）</li>
</ul>
<p>作为一个从业者，也许可以说说我的看法，给大家做个参考。（做成文章 / 演示稿，也可以避免我面对不同的提问者反复说同样的内容。）</p>
<blockquote>
<p>这个演示稿为了通俗易懂，写的是口述稿，相对口语化，对于一些专业性强的内容作了简化，<strong>很多地方并不严谨</strong> 。请知悉。</p>
<p>部分内容借鉴了熊节 《<a href="https://gigix.github.io/2018/9/3/why-study-it/" target="_blank" rel="external">穷学IT</a>》中的观点。</p>
</blockquote>
<h2 id="一、学编程有用吗？"><a href="#一、学编程有用吗？" class="headerlink" title="一、学编程有用吗？"></a>一、学编程有用吗？</h2><p>毫无疑问地说，有。接下来我们看看都在哪些方面有用。</p>
<p><img src="../../images/should-i-learn-programming/sshot-003.png" alt=""></p>
<p>最直接的，就是收入。</p>
<p>这是国家统计局 2018 年的数据，2019 年的数据要 2020 年 5 月 才公布，所以在当前时间点（2020 年 3 月），这是最新的公开数据。</p>
<p>我印象中，应该是金融业第一，信息和软件产业第二。不知道从那一年开始，反超了。翻过 17 年的数据也是信息产业第一。篇幅所限，只取了最新数据。</p>
<p>国家统计局是分开 非私营 和 私营 统计的，分别都做了图表。</p>
<p><img src="../../images/should-i-learn-programming/sshot-004.png" alt=""></p>
<p>可以看到，前三和后四在 两边都一样。其中排第一的信息软件服务业，平均工资是最后的农业的 3 倍多接近 4 倍（非私营），私营也有两倍。也是所有行业平均值的两倍左右。比金融业还明显高出一截，差距有 1W4（私营） ~ 快2W（非私营）。</p>
<p>而且需要注意的是，这是按行业分的，不是按岗位。</p>
<p>在互联网和软件行业，这个高薪会编程的人可以享受到。负责编程的技术研发，属于比较核心的岗位，即使不是最高薪的岗位，起码也是高于平均值的。</p>
<p>与此同时，其他行业里，仍然有不少会编程的人在里面享受高薪。IT 的专业人才在各行各业都有需求。换句话说，金融业的高薪、科研行业的高薪，也有会编程的人能分到一杯羹。</p>
<p>网上有种说法，叫『富学金融，穷学IT』。金融 和 IT 是目前中国薪资最高的两个行业。但多数行业——包括金融——都一定程度需要依靠人脉。可能只有 IT 行业，至少目前为止，还是相对公平、开放、透明的行业，是一个穷人家的小孩不靠关系、不靠家底、不靠父母帮忙、甚至自己不用溜须拍马，也可以得到较高薪资，甚至实现阶级跃迁的地方。</p>
<p><img src="../../images/should-i-learn-programming/sshot-005.png" alt=""></p>
<p>然后，是跨行业和长时间的高需求。</p>
<p>现在各行各业，生活方方面面，哪个可以脱离开计算机（或手机）和软件。</p>
<p>页面大小限制，上面列这些是收入前几的行业。我们再看看人均工资靠后的行业。</p>
<p>住宿餐饮，现在多少店只收现金（不用移动支付），手动（按计算器）算账报税？还有外卖平台，多少是只靠接电话做外卖的？是不是都要接入收款、报税、外卖的软件系统。这里关键，是要理解计算机软件在处理数据的数量和速度上，都碾压人工。</p>
<p>什么叫碾压？就是完全不是一个数量级，不是两倍三倍，不是十几倍，而是千倍、万倍，乃至一般人无法想像的倍数。</p>
<p>听众 / 读者里可能有完全外行的，我们给个具体一点的概念。一个汉字，在计算机占两到三个字节（字节的缩写是 B）；一本两百万字的书，就是六到七百万字节，最多不超过 7 MB（大约一到两首歌的大小）；一个图书馆按一万种藏书算，也就不到 100 GB（大约几部高清电影的大小）。而今天，一个规模较大的企业一天产生的数据，一个前沿实验室一天产生的数据，就是 多少 GB，甚至到了 TB（1024 GB）或者 PB（100 多万 GB）。</p>
<p>少量的数据，靠纸笔手算。先进一点，用电脑表格（Excel），人工操作。几倍的数据，人勤快一点，找找技巧，累死累活通个宵，还是可能完成的。<strong>但当数据量跨了几个数量级，就不是慢而已了，而是人力忙活一辈子都不可能完成。</strong> 何况人工还容易出错。靠计算机软件是唯一的出路。</p>
<p>当一个行业里，多数企业开始用上计算机处理核心的数据，剩下的要么跟上，要么淘汰。</p>
<p>未来很多行业很多职业会严重过剩，会有大量的人失业。原因恰恰跟 IT 有关：软件的自动化、人工智能，这些技术会取代人的工作。比如司机会被无人驾驶取代掉，大多数常见的场景，无人驾驶可以胜任，只有少量特殊情况由司机来开。那么司机的人数和待遇，都会降低很多。甚至传统看起来很光鲜的职业，律师、医生、教师，都会受到 IT 技术的挤压。技术先取代各个职业 <strong>大量且单调重复</strong> 的部分；然后人工智能从大量过往数据里找到规律，把 <strong>需要经验</strong> 的部分也取代了。最后剩下的，是各个职业里，最需要创造力的部分。</p>
<p>整个社会趋势会变成，少数富有创造力的精英收益很高，大多数一般人压力越来越大、待遇越来越差。IT行业、特别是搞技术的职业，可能是唯一一个不太受技术挤压、反而因为技术发展对人才需求越来越旺盛的行业。（当然，IT 行业自身 那些 单调重复 和 没有创造力的岗位，也会逐渐受到挤压，但是这个行业里创造出的新岗位会更多。）</p>
<p><img src="../../images/should-i-learn-programming/sshot-006.png" alt=""></p>
<p>为什么编程这么厉害，编程究竟是什么？不用术语，口语化的解释就是上面这个。</p>
<p>（使用计算机）这一点，只要不是专业性很强的软件，相信从小接触计算机 / 智能手机 的年轻一代，都能对各种软件很快上手。而这对老一辈很晚接触的人来说，却难上了很多。差别是有没有在某个年龄，形成思维定势之前，在脑海里建立起 <strong>一个事物的概念模型</strong> 。</p>
<p>（编程）这一步，同样地，越早接触，就会理解得越好，越能建立先发优势。</p>
<p><img src="../../images/should-i-learn-programming/sshot-007.png" alt=""></p>
<p>将来这个标准会继续提高。</p>
<p>也许有一天，编程也变成了整个社会的基本素养之一。</p>
<p>只是那时候，编程的门槛可能变低，甚至不再叫编程。就像现在的电脑和手机，也比十几二十年前的更先进易用。<br>如果你不是坐着等那天到来，等着它变容易，而是现在就学会，那就建立了先发优势。</p>
<p>像上面说到的，学了编程，并不代表就去软件行业当程序员。很多其他行业和岗位，都对编程能力有需求。</p>
<p>甚至退一万步讲，以后未必从事编程工作，光学习的过程对于锻炼逻辑思维，发现问题、解决问题的能力，都有很大的帮助。</p>
<p><img src="../../images/should-i-learn-programming/sshot-008.png" alt=""></p>
<p>看到这里，看到我对编程评价如此之高。</p>
<p>是不是说，那些课程销售说的都是真的，我（我的孩子）应该赶紧去报一个班？</p>
<p>别急，继续看下去。</p>
<h2 id="二、不同人说的编程，可能不是一回事"><a href="#二、不同人说的编程，可能不是一回事" class="headerlink" title="二、不同人说的编程，可能不是一回事"></a>二、不同人说的编程，可能不是一回事</h2><p>课程销售说的、业内人士说的。</p>
<p>中小学老师说的、大学老师说的、培训班老师说的。</p>
<p>不同岗位说的。都不是一回事！</p>
<p><img src="../../images/should-i-learn-programming/sshot-010.png" alt=""></p>
<p>少儿编程班，绝大多数，说的是这种。</p>
<p>像积木一样，拖动，拼接，调一下数字。实现的效果多数受组件限制，创造性有限。小学低年级，感兴趣的前提下，还是推荐接触一下。培养兴趣，锻炼思维。但也就仅此而已。</p>
<p>从小用乐高积木拼汽车，也只是培养了兴趣，离长大了真的去做汽车非常遥远。积木学会的东西，能用来造真车的非常有限。</p>
<p>成年人、高年级的孩子、或者低年级但天赋超前的孩子，这个玩具就没有必要学了。</p>
<p>少儿编程这个市场，最鱼龙混杂。孩子太小，家长不懂。很多老师本质上就是临时培训了一下的销售。</p>
<p>这点少儿编程培训班说得大概和我不一样。他们鼓吹编程多重要之后，直接把学这个，等同于学编程，直接等于各种美好的未来。</p>
<p>当然这也算编程，但更多是玩具，离实际应用，有点远，更不会有人用来干活。</p>
<p><img src="../../images/should-i-learn-programming/sshot-011.png" alt=""></p>
<p>logo 是个很古老的编程语言 / 工具了。</p>
<blockquote>
<p>什么是语言？</p>
<p>可不是英语法语这些外语，而是跟计算机打交道的『编程语言』。</p>
<p>编程语言也有好多种，不同语言难度不一样，能完成的任务也有差别。 </p>
</blockquote>
<p>这是二十几年前我小学时候的启蒙。现在基本很少有人用了。</p>
<p>之所以提一下，是因为：</p>
<ul>
<li>跟前面的积木玩具比，它起码是个正经的编程语言，需要自己写，能实现各种复杂功能。</li>
<li>跟后面更新的工具比，它有一个画图的功能，对孩子来说，能看到自己写的效果，前期不那么枯燥，更容易坚持下来。（实际上，如果学的不是前端技术，学编程的初期要跟黑窗打很长时间的交道，完全看不到漂亮的软件界面。这种落差容易让一些朋友坚持不下去。）</li>
</ul>
<p>因为它太老了，现在很少人用了，学会了用处也不大，一般是不会推荐的。</p>
<p>但是有一些人，下一页的内容可能都觉得难，需要一些马上看得见的效果，来培养兴趣。那么我会推荐先试一下 logo 的画图部分，只学画图。等培养出感觉了，还是赶紧学新的。</p>
<p><img src="../../images/should-i-learn-programming/sshot-012.png" alt=""></p>
<p>从这一页开始，往后提到的语言，都是真家伙了。实际干活的人也用这些，学会了理论上也能干活了。</p>
<p>但是一上来就干活太难了，光学理论看不到效果又太枯燥。于是就有人把学习过程写成了游戏。</p>
<p>Swift playground 是苹果公司开发的，学的是苹果特有的 Swift 语言。软件本身是免费的，适合家里有 iPad 的朋友。不过用途比较受限，学会了只能在苹果的设备开发，开发出来的软件也只能在苹果的设备跑。</p>
<p><img src="../../images/should-i-learn-programming/codecombat_big.png" alt=""></p>
<p>CodeCombat 则可以学 Python、JavaScript 等多种语言，都是应用范围很广的语言。</p>
<p>这个软件是免费的，但是关卡不免费。现在国内是网易在代理，收费是 599/年（不带教学提示）和 899/年（带教学提示）。如果不买关卡，只有这个软件，那么你得找老师给你设计关卡。</p>
<p>编程这种技能，需要在实践中循序渐进地增加难度，通过不断练习学会，不是光说理论就能掌握的。而根据学习进度设计恰到好处难度的训练作业，恰恰是最麻烦的地方，一个老师可能需要教过大量的学生，在教学中逐渐调整作业难度，打磨出一套合适的习题（这里的游戏关卡，本质上就是习题）。这也是请一个好的老师贵的地方。如果还要他专门给你设计关卡，又耗时又贵，还不如直接买设计好的。599 还是 899，就要因人而异了。</p>
<p>自学能力特别强的，或者找了老师带的，599 就可以了。899 只是多了提示和新手关，不是真人教。当然不差钱加上提示，也挺好。</p>
<p><img src="../../images/should-i-learn-programming/sshot-014.png" alt=""></p>
<p>来到这页，又更接近实际工作中的应用了。</p>
<p>因为这些高强度的竞赛，本来就是为了筛选人才、培养人才，最后往各个工作岗位输送人才的。</p>
<p>在初中高中大学的语境里，学校老师讲的编程，就很可能是这些。</p>
<p>如果感兴趣，学习进度又跟得上，高年级的学生直接想办法学竞赛，或者参加学校的竞赛队伍，是最实际含金量最高的。出了成绩，或者仅仅有过竞赛经历，都会对后续成为职业开发者有帮助。</p>
<p>如果一下子达不到，可以先降低要求，报班或自学，逐渐提高到符合要求。水平够不着参加竞赛，也不要有压力，因为竞赛经历只是加分，对职业开发者都不是硬性要求，其他岗位要求就更低一些。</p>
<p><img src="../../images/should-i-learn-programming/sshot-015.png" alt=""></p>
<p>这些是互联网行业常见的需要用到编程技能的岗位。大概过目，不详细介绍了。</p>
<p>换句话说，差别特别大的岗位，虽然都是编程，但是互相未必能听懂对方说什么。</p>
<p>所以上面那么多页，都是编程。但是不同说话的场境，不同人说出来，差异是很大的。</p>
<h2 id="三、编程难吗？"><a href="#三、编程难吗？" class="headerlink" title="三、编程难吗？"></a>三、编程难吗？</h2><p><img src="../../images/should-i-learn-programming/sshot-017.png" alt=""></p>
<p><img src="../../images/should-i-learn-programming/sshot-018.png" alt=""></p>
<p>说编程没什么门槛，有一定道理。</p>
<p>2017年的苹果开发者大会的参加者，从最小 10 岁澳大利亚的 Yuma 小朋友（从 6 岁开始编程）到最大的 82 岁若宫雅子老奶奶（60 岁开始学计算机，81 岁开始学编程）。</p>
<p>业内比较有名的技术专家郝培强（网名 tinyfool），也讲过他前妻的故事，一个初中毕业的发廊小妹，到现在 IT 公司的高管。谷歌也有一个工程师，原本只是富士康流水线上的普通工人。</p>
<p>可以看到，没有硬性的门槛，跟贫富、人脉、学历、年龄，都没有硬性绑定。（完全不相关是不可能的，富裕的家庭、高学历、年轻必然有更多机会。但是在其他领域，穷人、低学历、老人，这些普通人可能连入场券都没有。）</p>
<p>但是，没有硬门槛，相对应一定会变成软实力的竞赛。如果一个技能一个岗位收入很高又毫无门槛，那么一定会有人大量涌入，最后变得不值钱。如果这种事情没有发生，说明一定有什么东西，阻拦了大多数想进入的人。</p>
<p>越晚起步，特别是过了大学之后，非科班起步，越往后，软性限制会越明显，你越是需要付出比别人<strong>数倍的时间和努力去弥补</strong> 。实际上大多数速成培训班里面出来的，基础都很差，在市场上竞争力不强，只有少数可以靠自己的毅力坚持学习，熬到好一点的岗位。</p>
<p>这是多数 <strong>培训班不会跟你说的</strong> 。他们为了招生，除了说编程重要，还会夸大学习的效果。他们会给你一个模板，把东西都做得差不多，你只要往里填点东西，或者照着做一遍，就能跑起来，让你产生学会了的错觉。但是等你离开培训班，自己从头做的时候，才发现要求稍变化一点点，你就不知所措了。这是没有打基础，没有学内功的原因，做不到举一反三。<strong>编程没有那么容易</strong>。</p>
<p>如果你条件不适合。如果你很容易就放弃。<strong>学编程技术这条路比想象中枯燥和艰苦，你有可能投入了时间精力最后一事无成。</strong></p>
<p>可是即使这样，我仍然强烈建议你尝试。</p>
<p>前面说了 IT 行业和相关岗位，有可能是未来唯一人才需求还会增长的地方。只有人才需求旺盛的行业，才会有公平的竞争、对员工的重视，才会有普通人不靠背景不靠关系靠自己努力一步步上升的可能性。</p>
<p>在阶层固化严重的行业、在人力过剩的行业，论资排辈苦熬日子已经算好的，你会看到更多的关系户、更多的拼爹、更多的溜须拍马、更多的人情世故。你可能说我不太擅长数学、我逻辑思维不好、我英语不行。但是这些跟社会上更多更艰难的事情比，不算什么，坚持一下智商正常都是可以学会的。</p>
<h2 id="四、怎么开始？"><a href="#四、怎么开始？" class="headerlink" title="四、怎么开始？"></a>四、怎么开始？</h2><p><img src="../../images/should-i-learn-programming/sshot-020.png" alt=""></p>
<p>计算机配置不算太过于老旧，能随时上网下载工具，和查阅资料。如果报了班，可能在线上课。</p>
<p>每周拨出固定的时间学习，坚持不断地练习，以及可能需要中途补一点 数学、逻辑、英语。</p>
<p><img src="../../images/should-i-learn-programming/sshot-019.png" alt=""></p>
<p>我的建议是，如果你确实感兴趣，也大致符合条件，尽早开始，并且做好长期投入的准备。</p>
<p>以我个人的经历来说，中间会经历一些瓶颈期，让你对自己产生怀疑。这个时候，不要轻易放弃，试着跟老师前辈交流一下，找靠谱的技术社区问问题，甚至换换教材，或者多尝试多练习。突然有一天你理解之后，回头看发现不过如此。</p>
<p>还好现在的资料多了很多，编程工具更易用，互联网也更发达。学习的曲线会平滑很多。</p>
<p>可能你今天会觉得，学计算机、编程，这些事情听起来太高深了，太难了，太不适合你。其实是陌生形成的印象，都是纸老虎。成为合格的 IT 技术人员，凭技术挣到一份不错的生活，需要的知识水平并不比其他行业更高，甚至还要低得多，因为这个行业太缺人了。你只要有好奇心、勤学苦练、英文稍加强到能看懂文档，就能做到。</p>
<p><img src="../../images/should-i-learn-programming/sshot-021.png" alt=""></p>
<p>这个话题每个人的情况不一样。上面列的，也不是唯一的选择。需要根据每个人的情况具体地讨论。</p>
<p>之所以提一下这个，是因为初学者一开始就面临学什么的困惑。然后你会发现这方面的讨论很多，网上甚至争论起来，各说各有理，互不相让。作为初学者，可能会感到无所适从。</p>
<p>早些年我也关注甚至参与这些口水仗。而现在我会说，你要做什么更重要。我们不会争论锤子好用还是扳手好用。你决定做什么了，自然有合适的工具。</p>
<p>当然，你可能会说，具体到某个方向大家还是在吵，没有答案。我的答案是，<strong>随便选一个多人提到的</strong> ，大概率不会错。多人用的，会有更多资料，讨论更充分，遇到问题容易找到解决方案。语言没那么重要，只要不是选中了一个已经被淘汰没人维护的语言，随便学好了哪门都能有所作为。等到你碰到语言的瓶颈时，大概已经有了自己选择的判断力，到那时再学一门新的，并不难。编程最后拼的，是 算法、数据结构、系统设计…… 这些内功，先练少林长拳，还是武当剑法，都是一个入口，反正最后熟练了，都很容易触类旁通。</p>
<blockquote>
<p>补充一个对业内人士来说是常识，但一般人可能不知道的事实：这些平台 / 语言，基本都是免费的。至于为什么免费，展开说太长，简单说就是 它们都是由专业人士的社区（可以近似认为是公益组织）在维护，有些是技术大牛一时兴起，做了个开头之后交给社区，有些是公司开发好之后，捐献给社区。</p>
<p>他们这样做，不是因为要做慈善，而是一个平台 / 一个语言，不是一个公司可以维护好的，维护好也没什么人会用，造成不了影响力。所以业界通行的模式，是开辟好一块荒地，让大家都能免费来玩，来的很多人本身也是大牛，看到它不够好，都会自发地添砖加瓦。这个地方更好之后，更多人来，更多人贡献，变成良性循环。大家都从这个地方获益，然后有能力的会主动地贡献力量。环境好了之后，来得人非常得多，就是每个人买瓶矿泉水，都能赚很多。如果收门票，荒地就一开始就不会有人来。</p>
</blockquote>
<p>所以一个人如果 <strong>自学能力够强、够自律</strong> ，实际上学习编程的成本可以非常非常地低。一台计算机、再买点打基础的书，几乎就是全部的支出。一旦熬过了最初啥也不懂的新手期，网络发达的时代，网上有大量免费的教程，有文字的，也有视频的，就是要花点时间去找。像我们哪怕科班出身的，工作几年之后也有大量的技能是过时需要更新的，多数是自学，没有花额外的钱。</p>
<p>但我并不鼓吹非要免费学。看具体的人，具体学什么，具体的培训班 /  老师靠不靠谱。</p>
<p>对于小朋友，或者 0 基础的人，完全靠自律自学，比较难。难点在于：一是找到合适难度的教材和作业，循序渐进地学。太容易就没有效果，太难就会有挫败感，产生畏难心理。可初学者自己没办法判断难度。二是越是初学者，越是需要引导、反馈、监督。一个知识点的学习，像一场马拉松，已经辛辛苦苦跑到终点附近，结果迷路了，看不到终点，特别容易产生『我是不是不适合学这个』的自我怀疑，很容易就放弃了。这时一点点点拨效果就会马上不一样。</p>
<p>所以初学者，一是需要跟自己水平差不多的人作为同伴，可以交流和参照；二是需要一个老师的点拨。这个阶段，花点钱报一个靠谱的班，我认为是值得的。等有了一定基础，再逐渐选择一部分知识点完全看书自学，只有自己搞不定的再报班。</p>
<hr>
<p>因为是口语化地聊，篇幅比较长，听（看）完后面，前面该忘了。我简单总结一下：</p>
<ul>
<li><p>学编程有用吗？  </p>
<p>  有，锻炼思维、工作高薪、岗位需求大。</p>
</li>
<li><p>Ta 跟我说学编程，是什么意思？  </p>
<p>  看什么语境，Ta 是谁，你又是谁，想用编程干什么。</p>
</li>
<li><p>学编程难吗？</p>
<p>  要正经做出水平，也难。起码没有某些培训班宣传的那么容易。  </p>
<p>  可世上任何事想做好，都是不容易的。编程不比学别的技能难，甚至相对性价比高，容易看到回报。  </p>
<p>  建议你试一下，再坚持一下。</p>
</li>
<li><p>怎么开始？  </p>
<p>  一台电脑、一根网线、一些教材、一点兴趣、一点坚持。  </p>
<p>  是否花钱找老师，因人而异。初学者找靠谱的老师更容易开始。</p>
</li>
</ul>
<p><img src="../../images/should-i-learn-programming/sshot-022.png" alt=""></p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有部分朋友面临这个困惑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是互联网行业的非技术岗，能接触到 IT 技术人员，对编程有一定认识，知道这个对工作有帮助，想学。但怕学不来，不知道怎么学。&lt;/li&gt;
&lt;li&gt;另一种是完全没有接触，只是大概听说 IT 行业前（钱）景好。听说哪哪地方编程进课堂。然后碰见广告，或者大街上宣传学编程，产生了疑问：我（我的孩子）该学编程吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="presentation" scheme="https://jaycechant.info/tags/presentation/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 踩坑流水账</title>
    <link href="https://jaycechant.info/2020/flutter-kickoff/"/>
    <id>https://jaycechant.info/2020/flutter-kickoff/</id>
    <published>2020-03-13T14:10:05.000Z</published>
    <updated>2020-03-13T17:04:52.428Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 作为前端一个发展方向大热，有必要了解一下。</p>
<p>踩坑流水账，遇到啥记啥，不求全；遇到的 <strong>弯弯绕绕，错误示范</strong> 也 <strong>如实记载</strong> 。当前 Flutter 还不太稳定，可能过一段时间操作细节就变了（希望是改进），这种记录可以跟将来做对比。</p>
<a id="more"></a>
<blockquote>
<p>我的水平远远够不上厉害，但在一些朋友看来可能有可取之处，当他们自学遇到困难时，偶尔会问我是怎么学的。记录这样的流水账，你可以看到，我遇到新事物，一样是一点点试错。相信真正的大牛，（至少曾经）也是这样过来。  只不过大牛可能悟性好，试错时间和次数少一些。自己试错多了，也会掌握试错的套路。</p>
<p>某个程序员朋友，连 help 和 man 都不知道，让人着急。可我高中时，明明已经学过简单的编程，对 Linux 居然连听都没听过，听同学讨论一头问号。我的反应是什么？放假第一时间让我的电脑变成 Windows / Ubuntu 双系统。他之前不知道 help，现在知道了。<strong>互联网时代，知道了关键词，就不能说你一无所知。起码要把公开资料看完吧？</strong></p>
<p>你看到的『最佳实践』的文章，其实已经是作者熟练之后提炼的结果。好处是读者不必再走一次弯路，坏处是读者可能会产生心理落差。</p>
<p>—— 这段文字跟本文内容关系不大，发散一下，算是呼应之前《<a href="../save-load-a-solution-for-ordinary-people/">S/L 大法——平凡人的做事方法</a>》的观点吧。</p>
</blockquote>
<p>后面如果觉得 Flutter 开发（在当前、对我而言）可以入坑，再来写经过整理总结的经验帖，否则就此一篇。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="获取-Flutter-stable"><a href="#获取-Flutter-stable" class="headerlink" title="获取 Flutter stable"></a>获取 Flutter stable</h3><p>考虑 flutter 还在快速开发中，为了方便更新，直接拉仓库的 stable 分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> -b stable https://github.com/flutter/flutter.git</div></pre></td></tr></table></figure>
<p>得到的版本是 <code>1.12.13+Hotfix.8</code> 。</p>
<p>然后运行 flutter_console.bat ，按提示，先执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutter doctor</div></pre></td></tr></table></figure>
<p>提示 powershell 版本太低，这时才想起，去看看依赖（这台老电脑买的时候预装 Win8，因为 Win8 只是个过渡产物很快升了 Win10。结果某个硬件驱动不兼容 Win10，干脆退回 Win7。）</p>
<blockquote>
<ul>
<li><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-windows-powershell" target="_blank" rel="external">Windows PowerShell 5.0</a> 或者更高的版本（Windows 10 中已经预装了）</p>
</li>
<li><p><a href="https://git-scm.com/download/win" target="_blank" rel="external">Git for Windows</a> 2.x，并且勾选<strong>从 Windows 命令提示符使用 Git</strong> 选项。</p>
<p>  如果 Windows 版的 Git 已经安装过了，那么请确保能从命令提示符或者 PowerShell 中直接执行 git 命令。</p>
</li>
</ul>
</blockquote>
<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p>git 作为最高频的工具，几乎是最新的。而平时不用的 Powershell，什么版本真的没概念，赶紧打开一个 Powershell，输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$PSVersionTable</span></div></pre></td></tr></table></figure>
<p>才 2.0，装个最新的吧。</p>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell" target="_blank" rel="external">installing-powershell</a></p>
<p>发现 6.0 以上不能直接安装，还得安装 Powershell Core （因为从 Win 专用变成跨平台了）。要不要装最新的呢？先不管，反正 .NET 4.5 以上是一定需要的，先看 .NET 的版本</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$DotNetVersions</span> = <span class="built_in">Get-ChildItem</span> HKLM:\SOFTWARE\WOW6432Node\Microsoft\Updates | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.name <span class="nomarkup">-like</span></div><div class="line"> <span class="string">"*.NET Framework*"</span>&#125;</div><div class="line"></div><div class="line"><span class="keyword">ForEach</span>(<span class="variable">$Version</span> <span class="keyword">in</span> <span class="variable">$DotNetVersions</span>)&#123;</div><div class="line">    </div><div class="line">   <span class="variable">$Updates</span> = <span class="built_in">Get-ChildItem</span> <span class="variable">$Version</span>.PSPath</div><div class="line">    <span class="variable">$Version</span>.PSChildName</div><div class="line">    <span class="keyword">ForEach</span> (<span class="variable">$Update</span> <span class="keyword">in</span> <span class="variable">$Updates</span>)&#123;</div><div class="line">       <span class="variable">$Update</span>.PSChildName</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是 4.7 ，够新了。</p>
<h3 id="WMF"><a href="#WMF" class="headerlink" title="WMF"></a>WMF</h3><p>然后是 WMF(Windows Management Framework)。</p>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/wmf/setup/install-configure" target="_blank" rel="external">wmf-install-configure</a></p>
<p>不同版本的 Powershell 和 WMF 的依赖关系如下：</p>
<table>
<thead>
<tr>
<th>Powershell 版本</th>
<th>PS 5.0</th>
<th>PS 5.1</th>
<th>PS 6.0+</th>
</tr>
</thead>
<tbody>
<tr>
<td>依赖的 WMF 版本</td>
<td>WMF 5.0 （已包含 PS 5.0）</td>
<td>WMF 5.1 （已包含 PS 5.1）</td>
<td>WMF 4.0+</td>
</tr>
</tbody>
</table>
<p>结论，不管我装不装 6.0+，安装一个 WMF 5.1 总是没错的。</p>
<p>下载，解压，按说明在 Powershell 里运行安装的 ps1 脚本。提示没有签名。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">get-executionpolicy</span> -list</div><div class="line"><span class="built_in">set-executionpolicy</span> remotesigned -scope <span class="keyword">process</span></div></pre></td></tr></table></figure>
<p>再运行一次，可以了。</p>
<p>这时再看 Powershell 的版本。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$PSVersionTable</span>.PSVersion</div><div class="line"></div><div class="line">Major  Minor  Build  Revision</div><div class="line">-----  -----  -----  --------</div><div class="line"><span class="number">5</span>      <span class="number">1</span>      <span class="number">14409</span>  <span class="number">1005</span></div></pre></td></tr></table></figure>
<p>Powershell 5.1 已经包含在 WMF 5.1 了，已经满足要求，就没啥动力继续折腾 6.0+ 了。</p>
<h3 id="Flutter-镜像"><a href="#Flutter-镜像" class="headerlink" title="Flutter 镜像"></a>Flutter 镜像</h3><p>回到 flutter_console ，继续 <code>flutter doctor</code> ，这回 Powershell 不报错，开始自动下载 Dart SDK 了（难怪没有要求先安装 Dart）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Checking Dart SDK version...</div><div class="line">Downloading Dart SDK from Flutter engine e1e6ced81d029258d449bdec2ba3cddca9c2ca0c...</div></pre></td></tr></table></figure>
<p>貌似因为网络不好，下载过程重试了几遍，还好最终成功了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Checking Dart SDK version...</div><div class="line">Downloading Dart SDK from Flutter engine e1e6ced81d029258d449bdec2ba3cddca9c2ca0c...</div><div class="line">Unzipping Dart SDK...</div><div class="line">Building flutter tool...</div><div class="line">Running pub upgrade...</div><div class="line">Error (<span class="number">69</span>): Unable to <span class="string">'pub upgrade'</span> flutter tool. Retrying <span class="keyword">in</span> five seconds... (<span class="number">9</span> tries left)</div></pre></td></tr></table></figure>
<p>同样的，<code>pub upgrade</code> 也重试了很多遍，不过次数太多，引起注意，先停掉。翻到</p>
<p><a href="https://flutter.cn/community/china" target="_blank" rel="external">在中国网络环境下使用 Flutter</a></p>
<p>扫了一眼，直接用 Flutter 社区的镜像。因为是 Windows，打开环境变量，加上这两个值：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PUB_HOSTED_URL=https://pub.flutter-io.cn</div><div class="line">FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</div></pre></td></tr></table></figure>
<h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p>重新打开 flutter_console.bat，再次 <code>flutter doctor</code> </p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">Doctor summary (to see all details, run flutter doctor -v):</div><div class="line">[√] Flutter (Channel stable, v1.<span class="number">12.13</span>+hotfix.<span class="number">8</span>, on Microsoft Windows [Version <span class="number">6.1</span>.<span class="number">7601</span>], locale</div><div class="line">    zh-CN)</div><div class="line">[X] Android toolchain - develop <span class="keyword">for</span> Android devices</div><div class="line">    X Unable to locate Android SDK.</div><div class="line">      Install Android Studio from: https://developer.android.com/studio/index.html</div><div class="line">      On first launch it will assist you <span class="keyword">in</span> installing the Android SDK components.</div><div class="line">      (or visit https://flutter.dev/setup/<span class="comment">#android-setup for detailed instructions).</span></div><div class="line">      <span class="keyword">If</span> the Android SDK has been installed to a custom location, set ANDROID_HOME to that location.</div><div class="line"></div><div class="line">      You may also want to add it to your PATH environment variable.</div><div class="line"></div><div class="line">[!] Android Studio (version <span class="number">3.6</span>)</div><div class="line">    X Flutter plugin not installed; this adds Flutter specific functionality.</div><div class="line">    X Dart plugin not installed; this adds Dart specific functionality.</div><div class="line">[!] Connected device</div><div class="line">    ! No devices available</div></pre></td></tr></table></figure>
<blockquote>
<p>作为一个前 Android 开发者，电脑上其实一直有 Android Studio 和 Android SDK。</p>
<p>开始这篇流水账之前，我已经把 Android Studio 升级到当下最新的 3.6，SDK tools 也升级到最新的 26.1.1。只是 Android Studio 能定位 SDK 的位置，所以没有设置 ANDROID_HOME。</p>
<p>因为 Android Studio 已经很稳定，下载很快，安装很傻瓜，就不提了。</p>
</blockquote>
<h4 id="SDK-version"><a href="#SDK-version" class="headerlink" title="SDK version"></a>SDK version</h4><p>新添加 <code>ANDROID_HOME</code> ，重开 console（以重新加载环境变量），再次 <code>flutter doctor</code> ，SDK 居然不是最新，而且也不是 Android Studio 里显示的 26.1.1，可能升级时漏了什么：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[!] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">27.0</span>.<span class="number">3</span>)</div><div class="line">    X Flutter requires Android SDK <span class="number">28</span> and the Android BuildTools <span class="number">28.0</span>.<span class="number">3</span></div><div class="line">      To update using sdkmanager, run:</div><div class="line">        <span class="string">"%ANDROID_HOME%\tools\bin\sdkmanager"</span> <span class="string">"platforms;android-28"</span> <span class="string">"build-tools;28.0.3"</span></div><div class="line">      or visit https://flutter.dev/setup/<span class="comment">#android-setup for detailed instructions.</span></div><div class="line">    X Android license status unknown.</div><div class="line">      <span class="keyword">Try</span> re-installing or updating your Android SDK Manager.</div><div class="line">      See https://developer.android.com/studio/<span class="comment">#downloads or visit</span></div><div class="line">      https://flutter.dev/setup/<span class="comment">#android-setup for detailed instructions.</span></div></pre></td></tr></table></figure>
<p>那就去跑一下 sdkmanager 吧</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">sdkmanager.bat</div><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.NoClassDefFoundError: javax/xml/bind/annotation/XmlSchema</div><div class="line">        at com.android.repository.api.SchemaModule<span class="variable">$SchemaModuleVersion</span>.&lt;init&gt;(SchemaModule.java:<span class="number">156</span>)</div><div class="line"></div><div class="line">        at com.android.repository.api.SchemaModule.&lt;init&gt;(SchemaModule.java:<span class="number">75</span>)</div><div class="line">        at com.android.sdklib.repository.AndroidSdkHandler.&lt;clinit&gt;(AndroidSdkHandler.java:<span class="number">81</span>)</div><div class="line">        at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:<span class="number">73</span>)</div><div class="line">        at com.android.sdklib.tool.sdkmanager.SdkManagerCli.main(SdkManagerCli.java:<span class="number">48</span>)</div><div class="line">Caused by: java.lang.ClassNotFoundException: javax.xml.bind.annotation.XmlSchema</div><div class="line">        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:<span class="number">582</span>)</div><div class="line">        at java.base/jdk.internal.loader.ClassLoaders<span class="variable">$AppClassLoader</span>.loadClass(ClassLoaders.java:<span class="number">190</span></div><div class="line">)</div><div class="line">        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">499</span>)</div><div class="line">        ... <span class="number">5</span> more</div><div class="line"><span class="comment"># 改为写 go 之后好久没写 Java，难道是版本太旧？</span></div><div class="line">java --version</div><div class="line">java <span class="number">10.0</span>.<span class="number">1</span> <span class="number">2018</span>-<span class="number">04</span>-<span class="number">17</span></div><div class="line">Java(TM) SE Runtime Environment <span class="number">18.3</span> (build <span class="number">10.0</span>.<span class="number">1</span>+<span class="number">10</span>)</div><div class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM <span class="number">18.3</span> (build <span class="number">10.0</span>.<span class="number">1</span>+<span class="number">10</span>, mixed mode)</div></pre></td></tr></table></figure>
<p>虽然因为有一段时间没写 Java，并非最新的 LTS 版本（当前是 Java8 u241 或者 Java 11.0.6），但 Java 10 也不旧。我还特意看了 Java 10 的文档，确定有 <code>javax/xml/bind/annotation/XmlSchema</code> 。而且 sdkmanager 的版本也很迷。</p>
<p>（后来发现，Java 很可能是太新，而不是太旧，所以需要指定 JavaEE 包。据说 Java 11 已经移除了 JavaEE (变成了雅加达独立出去了)，更加运行不了。）</p>
<p>暂时没有兴趣深入了解哪里出了问题，直接卸载 Android SDK tools，然后下载最新的 SDK tools 压缩包。</p>
<p><a href="https://www.androiddevtools.cn/" target="_blank" rel="external">https://www.androiddevtools.cn/</a> 有收集。注意只是收集各个版本的地址而已，来源还是官方的，下完可以校验一下。这回的 SDK tools 在 Android Studio 显示 26.0.1，终于可以调用了。有一个可用更新 26.1.1，感觉这里就是问题所在，又给升了级，果然又出现上面的 <code>NoClassDefFoundError</code>。</p>
<p>先不管这个问题，退回到可用的 26.0.1。这是重新认真看 Doctor summaries，发现 <code>&quot;platforms;android-28&quot; &quot;build-tools;28.0.3&quot;</code> ，也就是它要求的所谓 SDK Version，并非我理解的 SDK tools 的 version，而是分别指 platform 和 build-tools 的版本，对应 Android 9(Pie)。为什么迟迟没有发现这点？因为在<a href="https://flutter.dev/docs/get-started/install/windows#set-up-your-android-device" target="_blank" rel="external">flutter 官方的引导</a>上面有这么一句话</p>
<blockquote>
<p>To prepare to run and test your Flutter app on an Android device, you’ll need an Android device running Android 4.1 (API level 16) or higher.</p>
</blockquote>
<p>被我理解为了开发的 API level 是 16+。</p>
<h4 id="license-status-unknown"><a href="#license-status-unknown" class="headerlink" title="license status unknown"></a>license status unknown</h4><p>再次 <code>flutter doctor</code>，这回 SDK 版本不报错了，只剩下 <code>Android license status unknown.</code> 。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flutter doctor --android-licenses</div><div class="line">A newer version of the Android SDK is required. To update, run:</div><div class="line">%ANDROID_HOME%\tools\bin\sdkmanager --update</div></pre></td></tr></table></figure>
<p>跟上面说的 <code>Try re-installing or updating your Android SDK Manager.</code> 一致。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdkmanager --update</div></pre></td></tr></table></figure>
<p><code>NoClassDefFoundError</code> 又出现了…… 本来不想在这上面耗时间，看来是躲不过了。</p>
<p>最后找到StackOverflow 的两个问题的回答： <a href="https://stackoverflow.com/questions/47150410/failed-to-run-sdkmanager-list-with-java-9" target="_blank" rel="external">StackOverflow 问题1</a> ，<a href="https://stackoverflow.com/questions/43574426/how-to-resolve-java-lang-noclassdeffounderror-javax-xml-bind-jaxbexception-in-j/43574427#43574427" target="_blank" rel="external">StackOverflow 问题2</a></p>
<p>编辑器打开 sdkmanager.bat，找到 DEFAULT_JVM_OPTS，在后面追加 <code>-XX:+IgnoreUnrecognizedVMOptions --add-modules java.se.ee</code> ，注意 Windows 环境不需要额外在外面加单引号，加了会导致变量扩充 <code>%~dp0\..</code> 出错，加完之后那一行变成了：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set DEFAULT_JVM_OPTS=<span class="string">"-Dcom.android.sdklib.toolsdir=%~dp0\.."</span> -XX:+IgnoreUnrecognizedVMOptions --add-modules java.se.ee</div></pre></td></tr></table></figure>
<p>然后再次执行</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sdkmanager --update</div><div class="line">done</div></pre></td></tr></table></figure>
<p>没有任何变化，版本没变，文件修改时间没变，然后 <code>flutter doctor --android-licenses</code> 依然说需要新版本。</p>
<p>然后尝试执行</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdkmanager --licenses</div></pre></td></tr></table></figure>
<p>提示有 licenses 还没 accept，赶紧一路 yes。</p>
<p>这时我试着再 <code>flutter doctor</code> 一次，居然通过了。说明版本旧不是根本问题。<strong>关键是 accept 掉 licenses</strong> 。</p>
<h4 id="升级-SDK-tools"><a href="#升级-SDK-tools" class="headerlink" title="升级 SDK tools"></a>升级 SDK tools</h4><p>本来这样就完事了，但还是有点好奇。记不记得 Android Studio 可以直接升级 SDK tools 到 26.1.1 ，那就升级看看。</p>
<p>Android Studio 确实可以升级 SDK tools，但是执行到最后，升级失败。因为升级靠的是打补丁，升级程序检查到 sdkmanage.bat <strong>有过修改，补丁失败</strong>。然后升级程序自动改为全量安装，不知道是不是因为打开了某些目录或者文件没管，继续失败。我猜 <code>sdkmanage --update</code> 也是因为类似的原因所以失败了，只是没有报错信息。</p>
<p>这时我想到两个选择：</p>
<ol>
<li>把 sdkmanager.bat 改回去，然后用 Android Studio 升级。</li>
<li>把修改之后的 sdkmanager.bat 改个名字，然后复制一份原名的改回去。然后执行修改过的 bat。</li>
</ol>
<p>（因为没有备份）这需要一字不差改回去，还好改动不多。我尝试了 1 ，成功了。2 就没有验证。</p>
<p>升级完 <strong>还得把参数加回去</strong> ，不然又会出现 <code>NoClassDefFoundError</code>。</p>
<p>继续 <code>flutter doctor</code> ，这回</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[!] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">28.0</span>.<span class="number">3</span>)</div><div class="line">    ! Some Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</div></pre></td></tr></table></figure>
<p>这次有了经验，我没有按它的来，而是 <code>sdkmanager --licenses</code> 。应该是升级过的 tools 还要再确认一遍 licenses。</p>
<h3 id="Android-Studio-Plugins"><a href="#Android-Studio-Plugins" class="headerlink" title="Android Studio Plugins"></a>Android Studio Plugins</h3><p>Settings &gt; Plugins 或者直接在打开项目的界面 Configure &gt; Plugins， 直接搜索 Flutter 安装，安装过程中会提示依赖 Dart 一起安装。</p>
<p>如果中间出现网络不好导致超时，就不要同时装，先装 Dart，再装 Flutter。</p>
<p>据说用 VSCode 开发也可以，我也有在用 VSCode。但是既然 flutter doctor 要求 Android Studio，就先按它的套路走通。</p>
<h3 id="真机-or-AVD"><a href="#真机-or-AVD" class="headerlink" title="真机 or AVD"></a>真机 or AVD</h3><p>最后一步就比较简单了，要么插个真机，要么创建一个 AVD。因为没有多余手机，随便选了一个 Pixel 3 + 奥利奥8.0 x86_64 的AVD。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Doctor summary (to see all details, run flutter doctor -v):</div><div class="line">[√] Flutter (Channel stable, v1.<span class="number">12.13</span>+hotfix.<span class="number">8</span>, on Microsoft Windows [Version <span class="number">6.1</span>.<span class="number">7601</span>], locale</div><div class="line">    zh-CN)</div><div class="line">[√] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">28.0</span>.<span class="number">3</span>)</div><div class="line">[√] Android Studio (version <span class="number">3.6</span>)</div><div class="line">[√] Connected device (<span class="number">1</span> available)</div><div class="line"></div><div class="line">• No issues found!</div></pre></td></tr></table></figure>
<p>这四个 ✔ 得来不易。</p>
<h2 id="第一个项目"><a href="#第一个项目" class="headerlink" title="第一个项目"></a>第一个项目</h2><p>安装 flutter 插件之后的 Android Studio ，New 菜单会多出一个 New Flutter Project，有引导，没啥值得说的，一路 Next。结果创建完之后，在生成项目的界面转了半天。第一次生成，对需要多长时间没有概念，以为是老机器卡，就先丢下去干别的。等我离开电脑半天，回来还在转，事情就不太正常了。</p>
<h3 id="flutter-lockfile"><a href="#flutter-lockfile" class="headerlink" title="flutter lockfile"></a>flutter lockfile</h3><p>试图强关 AS 无效之后，只好直接杀掉进程。这时去看 AS 的 workspace，项目看起来已经生成好了。试着重新打开 AS，可能是因为杀进程丢失了一些配置，需要重新指定 Android SDK 的位置。打开 AS 没看到新建的项目，就去打开前面生成的项目。</p>
<p>打开成功，没有提示缺这少那，说明项目生成是没什么问题的。但是初始化之后（自动生成的）代码一片红色，明显是缺少依赖引起的，同时 AS 也弹出提醒，还没有<code>run flutter packages get</code> ，旁边给了几个选项，分别是 Get dependencies 和 Update dependencies（第三个忘了）。</p>
<p>一次都还没获取依赖，自然点第一个，底下的 log 显示：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> myapp...</div><div class="line">Waiting <span class="keyword">for</span> another flutter command to release the startup lock...</div></pre></td></tr></table></figure>
<p>查了一下，flutter 有一个全局的 lockfile，在 <code>flutter/bin/cache/lockfile</code> ，每次只允许一个进程打开，作为全局锁。这种套路经常跟 Linux 打交道的应该很熟悉。按网上的说法，把它删掉（因为有进程占用，使用了 unlocker 释放句柄），然后再来。</p>
<h3 id="flutter-pub-get"><a href="#flutter-pub-get" class="headerlink" title="flutter pub get"></a>flutter pub get</h3><p>这回只是输出少了一行，然后又陷入了无尽的等待。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> myapp...</div></pre></td></tr></table></figure>
<p>没办法，退出 AS 再来（这次没有生成的对话框，可以正常退出），然后又提示锁的问题。死循环了。</p>
<p>锁的问题前面已经说了，是因为 dart 执行命令异常退出，没有释放锁，强制释放就行（后来发现 lockfile 不用删，释放掉就行。当然如果没有 unlocker 之类的工具，强删也行，反正就一个大小为 0 的文件，没有会自动新建）。问题在于为什么第一次会卡死。</p>
<p>pub 是 dart 的包管理器，如同 pip 于 Python，go mod 于 go，Maven 于 Java，npm 于 nodejs… 试了一下，pub 不能直接调用，大概因为没有独立安装 dart，而 flutter pub 是针对 flutter 的封装。</p>
<p>既然是获取依赖包这步卡了，那么大概率就是 GFW 的问题。还记得上面设置的镜像吗？这回释放完 lockfile，改在 flutter_console 里执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flutter packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">5.9</span>s</div></pre></td></tr></table></figure>
<p>不到 6 秒完事，还真就好了。代码里的各种错误也没了。</p>
<h3 id="Android-Studio-的环境变量"><a href="#Android-Studio-的环境变量" class="headerlink" title="Android Studio 的环境变量"></a>Android Studio 的环境变量</h3><p>可是每次都要手动执行命令也很烦。而且就算我愿意，AS 也不会每次执行命令停下来，告诉我对应的命令让执行；它一旦卡死，还得费劲去释放 lockfile。所以，是 AS 读不到设置的环境变量吗？</p>
<p>首先，<code>flutter help</code> 输出的指令里没有 <code>packages</code> ，然后 <code>flutter help packages</code> 告诉我们，<code>packages</code> 只是 <code>pub</code> 的别名。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">flutter help packages</div><div class="line">Commands <span class="keyword">for</span> managing Flutter packages.</div><div class="line"></div><div class="line">Usage: flutter pub &lt;subcommand&gt; [arguments]</div><div class="line">-h, --help    Print this usage information.</div><div class="line"></div><div class="line">Available subcommands:</div><div class="line">  cache       Work with the Pub system cache.</div><div class="line">  deps        Print package dependencies.</div><div class="line">  downgrade   Downgrade packages <span class="keyword">in</span> a Flutter project.</div><div class="line">  get         Get packages <span class="keyword">in</span> a Flutter project.</div><div class="line">  global      Work with Pub global packages.</div><div class="line">  pub         Pass the remaining arguments to Dart<span class="string">'s "pub" tool.</span></div><div class="line">  publish     Publish the current package to pub.dev</div><div class="line">  run         Run an executable from a package.</div><div class="line">  test        Run the "test" package.</div><div class="line">  upgrade     Upgrade packages in a Flutter project.</div><div class="line">  uploader    Manage uploaders for a package on pub.dev.</div><div class="line">  version     Print Pub version.</div><div class="line"></div><div class="line">Run "flutter help" to see global options.</div></pre></td></tr></table></figure>
<p>再 <code>flutter help packages get</code> 一下。三层命令 help 进来，都没有看到 <code>--no-color</code> 参数干嘛用，先不管它。</p>
<p>这次模仿 AS 的调用方式，不直接在 flutter_console 操作，而是直接调用 <code>flutter/bin/flutter.bat</code> ：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">flutter\bin\flutter.bat packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">0.6</span>s</div><div class="line"></div><div class="line">flutter\bin\flutter.bat packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">0.5</span>s</div><div class="line"></div><div class="line">flutter\bin\flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">0.5</span>s</div></pre></td></tr></table></figure>
<p>完全没问题。其实没问题是应该的，因为打开 flutter_console.bat 看就知道，里面只做了两件事，把 <code>flutter/bin/</code> 临时加入 PATH，然后打开一个 cmd，没了。</p>
<p>（好吧，其实是三件，前面还显示了 flutter 的 ascii-art 和 简单的说明。）</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">REM <span class="string">"%~dp0"</span> is the directory of this file including trailing backslash</div><div class="line">SET PATH=%~dp0bin;%PATH%</div><div class="line"></div><div class="line">CALL cmd /K <span class="string">"@echo off &amp; cd %USERPROFILE% &amp; echo on"</span></div></pre></td></tr></table></figure>
<p>会不会是因为依赖已经下载好了，根本没有触发网络访问？在 AS 再试一次，又卡了……（又要找 unlocker）</p>
<p>在 AS 里打开Terminal，从输出看其实就是一个 cmd，在这里再执行一次，又卡死了……</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里是 AS 里面的 Terminal</span></div><div class="line">echo %PUB_HOSTED_URL%</div><div class="line">%PUB_HOSTED_URL%</div></pre></td></tr></table></figure>
<p>环境变量实锤了。</p>
<p>在对着 AS 的 Terminal 一顿 echo 之后，发现绝大多数环境变量都能读到，无论是系统变量，还是用户变量。什么 <code>PATH</code>，<code>GOROOT</code>，<code>GOPATH</code>….. 都有值，唯独 <code>ANDROID_HOME</code> 和 两个镜像地址。然后想了想，这几个值好像都是这次新建的，并且中间没有重启过。呃，人家 cmd 都是关掉重开就可以加载到，难道就你 AS 非要重启计算机？（AS 都重启好多遍了）</p>
<p>试试吧。重启，第一时间打开 AS。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">echo %PUB_HOSTED_URL%</div><div class="line">https://pub.flutter-io.cn</div><div class="line">flutter\bin\flutter.bat --no-color packages get</div><div class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> three_five_two...                      <span class="number">2.9</span>s</div><div class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>我x [口吐芬芳]，还真是！浪费时间。估计新建项目时也是卡在这里。有空研究一下 AS 的环境变量究竟是怎么加载的。这老电脑开关机慢，一堆文件也懒得关了重新打开，平时都是休眠的，改点啥都要重启真是为难人。</p>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p>接下来还剩一步，就是验证自带的模板程序能不能跑起来。</p>
<p>打开 AVD，启动前面创建的虚拟设备，然后选这个设备为 run target，然后 run。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Launching lib\main.dart on Android SDK built <span class="keyword">for</span> x86 <span class="number">64</span> <span class="keyword">in</span> debug mode...</div><div class="line">Running Gradle task <span class="string">'assembleDebug'</span>...</div><div class="line"><span class="comment"># 再等一下就能结束战斗了</span></div><div class="line"><span class="comment"># 啪，打脸</span></div><div class="line">FAILURE: Build failed with an exception.</div><div class="line"></div><div class="line">* What went wrong:</div><div class="line">A problem occurred configuring root project <span class="string">'android'</span>.</div><div class="line">&gt; Could not resolve all artifacts <span class="keyword">for</span> configuration <span class="string">':classpath'</span>.</div><div class="line">   &gt; Could not download kotlin-gradle-plugin.jar (org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="number">1.3</span>.<span class="number">50</span>)</div><div class="line">      &gt; Could not get resource <span class="string">'https://jcenter.bintray.com/org/jetbrains/kotlin/kotlin-gradle-plugin/1.3.50/kotlin-gradle-plugin-1.3.50.jar'</span>.</div><div class="line">         &gt; Connection reset</div><div class="line"></div><div class="line">* <span class="keyword">Try</span>:</div><div class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</div><div class="line"></div><div class="line">* Get more help at https://help.gradle.org</div><div class="line"></div><div class="line">BUILD FAILED <span class="keyword">in</span> <span class="number">8</span>m <span class="number">41</span>s</div><div class="line">Finished with error: Gradle task assembleDebug failed with <span class="keyword">exit</span> code <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这明显是 jcenter 的网络问题。侥幸认为应该只是慢，重试一遍，居然真的跑起来了。</p>
<p>下次还是换个 aliyun 的仓库镜像吧。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">maven&#123; url<span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span> &#125;</div><div class="line">maven&#123; url<span class="string">'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span>&#125;</div></pre></td></tr></table></figure>
<p>第一次的编译时间特别久，老机器可能加重了这个情况。后续的修改用 hot reload 应该会快很多。</p>
<p><br></p>
<p>到这，一行代码都没写，但写代码前的准备工作，算是告一段落。不知不觉居然记了这么长流水账，前后断断续续折腾了两天多。时间大部分是被地理位置下访问技术资源的可达性及网速（简称 Qiang）拖累的，少部分是因为 flutter 有些小坑且文档有误导性。</p>
<p>在等网络和命令执行的间隙，快速扫了一眼 dart 的语法，从不同的地方看到了 Java、Python 还有 Go 的影子，当然也有一些比较原创的语法糖（如级联调用）。刚好这三门语言都还算熟，希望写起来不费劲。</p>
<p>这篇太长了，就此打住。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter 作为前端一个发展方向大热，有必要了解一下。&lt;/p&gt;
&lt;p&gt;踩坑流水账，遇到啥记啥，不求全；遇到的 &lt;strong&gt;弯弯绕绕，错误示范&lt;/strong&gt; 也 &lt;strong&gt;如实记载&lt;/strong&gt; 。当前 Flutter 还不太稳定，可能过一段时间操作细节就变了（希望是改进），这种记录可以跟将来做对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="https://jaycechant.info/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>配置 1.13+ 的 golang 环境（Windows 篇）</title>
    <link href="https://jaycechant.info/2020/golang-1-13-env-for-win/"/>
    <id>https://jaycechant.info/2020/golang-1-13-env-for-win/</id>
    <published>2020-03-10T15:07:44.000Z</published>
    <updated>2020-03-11T07:53:39.897Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间为 go 1.13 写了 <a href="../setup-golang-env-for-1-13-and-above/">《配置 1.13+ 的 golang 环境》</a> （注：现在go 1.14 都发布了），以区别于 1.9 还在用 GOPATH 时写的  <a href="../../setup-golang-env/">《配置 Golang 开发环境》</a> 。考虑到后者写了 Win 环境下的配置，于是前者就写一下 Linux 环境。</p>
<p>当下这个时间点，当然参考 1.13+ 那篇。可是在 Windows 配置怎么办？那就把文中系统相关的操作（主要是环境变量）换成 Win 的对应操作。两篇文章，分别涉及到了 “&lt; 1.13 &amp; Win” 和 “1.13+ &amp; Linux”，看完举一反三，应该新旧版本两个系统平台，都会配置了。</p>
<p>结果今晚让朋友看着新教程（1.13+）配置 Win 下 go 1.13+ 环境，证明我还是太天真：这些配置教程的目标读者很可能根本没有跨平台的经验，一个 Linux 的操作在 Windows 下对应着什么，他们完全没有概念 [摊手]。</p>
<p>一气之下，只好再发一篇。注意，这篇 <strong>没有任何新内容</strong>，纯粹是旧文的重新组合！（Windows &amp; go 1.13+）</p>
<a id="more"></a>
<p>不是我想水好吧，我也是被某些人气的。[摊手]</p>
<p>反正入门教程就不能对读者有期待，不然达不到 <strong>扔给 朋友 / 学生 之后不用管</strong> 的效果。本文遇到大段引用我其他文章的，不再只给链接，直接把内容贴过来，方便你们不用跳转，也方便我不用解释 [白眼]。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>重申，这篇讲 Windows 环境下，go 1.13 以上版本的配置。当下最新的是 1.14，但是配置方法没有变化。</p>
<h3 id="0x00-下载安装"><a href="#0x00-下载安装" class="headerlink" title="0x00 下载安装"></a>0x00 下载安装</h3><p><del>找下载链接请到官网 golang.org/dl ，如果国内不能访问</del>，请直接到国内的官方镜像站 golang.google.cn/dl 。</p>
<p>找到 Windows 的安装包，名字大概是 <code>go1.14.windows-amd64.msi</code> 。后续新版本出来，版本号会变大。如果你的操作系统是 32 位，就把 <code>amd64</code> 换成 <code>386</code> 。找到符合的链接，下载。</p>
<p>下载完了之后安装，安装路径随你的习惯。建议尽量短，不带空格和中文。个人习惯放到 <code>D:\Dev\go</code> 下。</p>
<h3 id="0x01-系统环境变量"><a href="#0x01-系统环境变量" class="headerlink" title="0x01 系统环境变量"></a>0x01 系统环境变量</h3><p>然后将可执行文件加入系统路径。</p>
<p>如果你对 Windows 下添加系统环境变量毫无概念，建议你先搜索一下 <strong>带图的教程</strong>，毕竟 Win7 和 Win10 还有点不同。已经耐着性子水这篇，不想把这种东西展开讲。</p>
<ul>
<li><p>先添加 <code>GOROOT</code>。检查环境变量里是否已经存在 <code>GOROOT</code>，没有就新建，值填上一步的安装路径。以我的为例，就是 <code>D:\Dev\go</code>。先设置 <code>GOROOT</code> ，后面引用，方便以后改安装位置时只改这里，不用到处修改。</p>
</li>
<li><p>再添加 <code>Path</code> 。<code>Path</code> 变量是原本就存在的。</p>
<ul>
<li>Win10 下 <code>Path</code> 是个列表，新建两项，分别填 <code>%GOROOT%\bin</code> 和 <code>%USERPROFILE%\go\bin</code>。</li>
<li>Win7 等只有一个 Path 值的，修改，在最后面追加 <code>;%GOROOT%\bin;%USERPROFILE%\go\bin</code> </li>
</ul>
</li>
</ul>
<p>注意涉及的标点都是英文半角符号。设置完一步步确认就好。</p>
<h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>惯例地检查一下是否配置正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go version</div><div class="line">go version go1.14 windows/amd64</div></pre></td></tr></table></figure>
<p>如果不能正确执行 <code>go version</code> ，把当前版本输出，请回头检查哪里出错。</p>
<p>跟老版本不同的是，只要把 go 本身的可执行路径 和 go bin 的安装路径加入 Path 就可以了，剩下的 go env 自行管理了。</p>
<h3 id="0x02-go-env"><a href="#0x02-go-env" class="headerlink" title="0x02 go env"></a>0x02 go env</h3><p>执行 <code>go env</code>，就会看到 go 内置的环境变量，以及部分默认值。</p>
<p>大家看自己的输出，我的已经改过，不是默认值，就不贴了。</p>
<p><code>go env -w key=value</code>  这样的形式，是将 key 变量修改成 value 这个值。</p>
<h4 id="必改"><a href="#必改" class="headerlink" title="必改"></a>必改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go env -w GO111MODULE=on</div><div class="line">go env -w GOPROXY=https://goproxy.cn,direct</div></pre></td></tr></table></figure>
<p><strong>GO111MODULE</strong> : </p>
<ul>
<li>auto : 自 1.11 实验性加入之后就是默认值。auto 意味着由工具链自动判断是否启用 go modules。在 1.13 以前的启用条件是『项目根目录有 go.mod 且项目不在 GOPATH 内』，1.13+ 去掉了 『不在 GOPATH 内的限制』，也就是只要有 go.mod 就会启用。</li>
<li>on : 如果你觉得上面这段话太长懒得看，或者害怕以后启用条件还会变，那么 1.13 已经准备好全面启用 go modules，直接设为 on 就好了。设为 on 之后无条件启用 go modules。</li>
<li>off :  关闭 go modules，回到 GOPATH 时代。</li>
</ul>
<p><strong>GOPROXY</strong> :</p>
<p>国内环境必备，原因你懂的。甚至可以说这是新版本为中国开发者做出的最大改进之一也不为过。在 dep 的时代是靠自建的代理熬过来的，那么不会代理的朋友就很麻烦了。改用镜像就友好太多了。</p>
<p>目前国内最早最好的代理是 七牛云提供的 <code>https://goproxy.cn</code> 。如果团队内部还有搭建私有代理，可以用 <code>,</code> 隔开，go 会依次尝试。最后记得加上 <code>direct</code> ，让镜像上找不到的依赖回源查找。（包括但不限于 镜像还没同步，私有仓库 等情况）</p>
<p>目前自建代理的开源方案貌似有以下几个。由于我暂时没有自建代理的需要，没有实测，请自行对比选择。</p>
<ul>
<li><a href="https://github.com/goproxyio/goproxy" target="_blank" rel="external">https://github.com/goproxyio/goproxy</a></li>
<li><a href="https://github.com/gomods/athens" target="_blank" rel="external">https://github.com/gomods/athens</a></li>
<li><a href="https://github.com/goproxy/goproxy" target="_blank" rel="external">https://github.com/goproxy/goproxy</a></li>
</ul>
<h4 id="推荐改"><a href="#推荐改" class="headerlink" title="推荐改"></a>推荐改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go env -w GOBIN=%USERPROFILE%/go/bin</div></pre></td></tr></table></figure>
<p><strong>GOBIN</strong> 如果没有设置，默认值为 <code>%GOPATH%/bin</code> ，是通过 <code>go get</code> 或 <code>go install</code> 安装的可执行文件的存放目录。不设并不影响使用，但考虑到 GOPATH 正在被边缘化，未来不知道哪个版本就取消了，所以建议还是单独设置一下比较好。我为了保持使用习惯，设置了跟默认相同的目录（因为 GOPATH 默认值是 <code>%USERPROFILE%/go</code>），区别只是这个值不依赖 GOPATH 的值。</p>
<p>值得 <strong>提醒</strong> 的是，这个目录也需要加入系统 PATH ，并且我已经在 系统环境变量 里加入（最后一个），如果你根据自己的习惯修改了 GOBIN 的位置，那么 0x01 里的配置也得相应修改。</p>
<p>更多的变量，推荐参考 《<a href="https://mp.weixin.qq.com/s/AsdCDodxZFxs2SkhSwOvpg" target="_blank" rel="external">干货满满的 Go Modules 和 goproxy.cn</a>》。</p>
<h4 id="确认-1"><a href="#确认-1" class="headerlink" title="确认"></a>确认</h4><p>到这里之后，建议安装任意一个 go 开发的工具测试 GOBIN 是否正确配置。这很重要，后续需要安装各种 go 编写的工具，并且需要在命令行调用。VSCode 的 go 插件，就依赖大量这样的工具。</p>
<p>如果在这里配置好了，VSCode 会自动安装到正确的地方，自动后台调用，你是几乎无感知的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">go get -u github.com/go-bindata/go-bindata/...</div><div class="line"><span class="comment"># 留意安装过程是否有报错</span></div><div class="line">go-bindata --help</div><div class="line"><span class="comment"># 如果安装好了，执行目录也加入了 Path，这里应该输出帮助信息</span></div><div class="line">Usage: go-bindata [options] &lt;input directories&gt;</div><div class="line">...</div><div class="line"><span class="comment"># 或者看版本信息</span></div><div class="line">go-bindata -version</div></pre></td></tr></table></figure>
<h3 id="0x03-cgo-和-build-tool"><a href="#0x03-cgo-和-build-tool" class="headerlink" title="0x03 cgo 和 build tool"></a>0x03 cgo 和 build tool</h3><p>go 语言的 cgo 特性允许 C 语言 和 go 语言互调，达到 <strong>复用已有的 C/C++ 庞大代码资源</strong> 的目的；又或者用 C 编写程序的一部分以达到某些 底层语言才能达到的目标。而要使用 cgo 特性，就需要有 C/C++ 的构建工具链 <strong>gcc</strong> 。</p>
<p>另一方面，随着项目规模变大，你会逐渐需要一个 <strong>构建工具</strong> （build tools）帮你管理构建细节，就像 ant / maven / gradle 之于 Java。由于 go 本身的构建比较简单（或者说 go 的构建规则比较清晰，自带的 build 命令够用），又有了现成的依赖管理（之前的 vgo / glide / dep，现在官方的 go modules），官方并没有一个专用的构建工具。这部分，因为依赖管理已有，管理额外的构建细节， <strong>Makefile (make) 足矣</strong> 。</p>
<p>gcc 和 make 在多数 Linux 发行版是自带的，你可以通过  <code>gcc -v</code> 和 <code>make -v</code> 来确认安装的版本。即使没有，视乎不同的包管理器，也就是一两句命令的事。Windows 下稍微麻烦一些，要安装 MinGW-w64 。注意必须是 <strong>MinGW-w64</strong> 。MinGW 不兼容 64 位系统，同时长期不更新；而 w64 可以同时兼容 32 和 64 位。</p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>下载：<a href="https://sourceforge.net/projects/mingw-w64/" target="_blank" rel="external">https://sourceforge.net/projects/mingw-w64/</a></p>
<p>下载得到的是安装器，在选择版本后，会自动下载对应版本并安装。建议不要改动任何选项，只需要确保 Architecture 对应你的计算机即可（Win64 选 x86_64）。</p>
<p>安装路径依然没有强制要求，无中文和空格，尽量短即可。参考：<code>D:\Dev\mingw-w64</code> 。</p>
<h4 id="创建-make-的软链接"><a href="#创建-make-的软链接" class="headerlink" title="创建 make 的软链接"></a>创建 make 的软链接</h4><p>安装完后进入 安装目录的 bin 目录，可以看到大量的工具，其中有 <code>gcc.exe</code>  和 <code>mingw32-make.exe</code> ，没有 <code>make.exe</code> 。其实 <code>mingw32-make.exe</code> 就是，但是用这个名字调用太长，也不利于其他工具用默认的名字调用，所以我们要创建一个名字叫 <code>make.exe</code> 的软链。</p>
<p>首先用管理员权限打开 cmd （右键菜单 &gt; 用管理员权限打开），然后按如下操作：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 请修改路径对应你的安装目录</span></div><div class="line">C:\Windows\system32&gt;cd /d D:\Dev\mingw-w64\bin</div><div class="line"></div><div class="line">D:\Dev\mingw-w64\bin&gt;mklink make.exe mingw32-make.exe</div><div class="line">为 make.exe &lt;&lt;===&gt;&gt; mingw32-make.exe 创建的符号链接</div></pre></td></tr></table></figure>
<p><strong>建议创建软链之后就关掉管理员权限的 cmd，避免因权限过高造成不可恢复的误操作。后续操作在普通权限下执行即可。</strong></p>
<p>完成后你会看到 bin 目录下多了一个 <code>make.exe</code> 文件，然后执行 <code>dir make.exe</code> ，会看到</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\Dev\mingw-w64\bin&gt;dir make.exe</div><div class="line"><span class="number">2018</span>/<span class="number">10</span>/<span class="number">04</span>  <span class="number">18</span>:<span class="number">17</span>    &lt;SYMLINK&gt;      make.exe [mingw32-make.exe]</div></pre></td></tr></table></figure>
<h4 id="Path-环境变量"><a href="#Path-环境变量" class="headerlink" title="Path 环境变量"></a>Path 环境变量</h4><p>跟 Go 安装类似的， MinGW-w64 的 bin 目录也要追加到 Path 变量的最后，详细可以参考 Go 的 系统环境变量部分。以我的设置为例，追加的是 <code>;D:\Dev\mingw-w64\bin</code> 。</p>
<p><strong>特别强调：mingw-w64 下面还有一套 mingw32，如果是 64 位系统，添加到 PATH 的是根目录的 bin，不是 mingw32 下面的！！</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mingw-w64</div><div class="line">├── bin <span class="comment"># 64位系统认准这个！！</span></div><div class="line">├── mingw32</div><div class="line">│   ├── bin <span class="comment"># 32位系统才选这个</span></div><div class="line">......</div></pre></td></tr></table></figure>
<h4 id="确认-2"><a href="#确认-2" class="headerlink" title="确认"></a>确认</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gcc --version</div><div class="line"><span class="comment"># 正常会输出 gcc 的版本，64位：x86_64, 32位：i686; 注意区分</span></div><div class="line">make -v</div><div class="line"><span class="comment"># 能调用就行，不需要留意位数</span></div></pre></td></tr></table></figure>
<h3 id="0x04-安装-VCS"><a href="#0x04-安装-VCS" class="headerlink" title="0x04 安装 VCS"></a>0x04 安装 VCS</h3><p>在使用 go get 命令之前，需要安装依赖托管服务对应的 VCS （Version Control System）。go get 会根据依赖所托管的网站反馈的信息，调用对应的工具 （git / hg / svn）拉取依赖。</p>
<p>就我的个人实践而言，绝大多数的第三方依赖都是基于 git 发布的（或者说直接就是放在 github 上），所以 <strong>直接安装 git 就好</strong> ，后面遇到基于其他工具的依赖，再安装不迟。</p>
<p>由于 git 本身就是一个大话题，基本的安装使用教程不难搜到，有时间时会另起文章讨论，这里只是提醒安装，不再展开。</p>
<h3 id="0x05-开始一个项目"><a href="#0x05-开始一个项目" class="headerlink" title="0x05 开始一个项目"></a>0x05 开始一个项目</h3><p>终于把环境都配置好了，然后就可以开始第一个 go 的项目了。由于 go modules 不再依赖 GOPATH，所以项目可以放在任何地方——这个 『任何』，是指可以不是 GOPATH ，但是要是习惯了，继续放在 <code>%GOPATH%/src</code> 也没问题。</p>
<p>好了，不管放在哪，现在新建一个项目的根目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir demo</div><div class="line"><span class="built_in">cd</span> demo</div></pre></td></tr></table></figure>
<p>然后执行 <code>go mod init &lt;module_path&gt;</code> ，生成 go.mod ，这个项目就算初始化完了，接下来就该敲代码了。随着开发的进行，还会自动生成 go.sum 文件，记录依赖的校验信息。注意 go.sum <strong>不是 lock 文件</strong> ，重现构建的信息已经包含在 go.mod 里，go.sum <strong>属于 checksum 文件</strong> ，用来 <strong>确保下载的依赖没有被篡改</strong> 。 go.mod 和 go.sum 需要一起提交<strong>参与版本控制</strong> 。关于 <code>go mod</code> 的详细用法，可以直接 <code>go help mod</code> 获取帮助信息，不展开。</p>
<p>关于 module path 的内容，以及 module 与 package 之间的关系，篇幅所限，另有一篇文章详细解释，请看《<a href="https://jaycechant.info/2020/golang-1-13-module-VS-package/">golang 1.13 - module VS package</a>》。</p>
<p>go 语法和开发，限于篇幅，也不是本文内容，后续可能需要开一个系列展开。</p>
<h3 id="0x06-IDE-推荐"><a href="#0x06-IDE-推荐" class="headerlink" title="0x06 IDE 推荐"></a>0x06 IDE 推荐</h3><h4 id="LiteIDE"><a href="#LiteIDE" class="headerlink" title="LiteIDE"></a>LiteIDE</h4><p>下载：<a href="https://github.com/visualfc/liteide/releases" target="_blank" rel="external">https://github.com/visualfc/liteide/releases</a> ，根据操作系统选择对应的下载</p>
<p>专门为 go 设计的 IDE，简单够用。</p>
<p>亮点：</p>
<ul>
<li>多套环境变量、编译参数的配置，方便交叉编译</li>
<li>支持直接搜索官方库的文档</li>
</ul>
<p>跟下面的 IDE 比，功能不算强，因为不能扩展插件。但是胜在简洁，没有多余功能干扰。</p>
<p>推荐初学者从它开始，熟悉 go 的工作流程。</p>
<h4 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h4><p>声名在外，不得不说真香。不同语言的开发，我都逐渐转移到这里了。</p>
<p>因为太过有名，地址和配置都不用写了，一搜一大堆。</p>
<p>默认是不支持 go 的。胜在有个强大的插件生态，装个插件就支持了。</p>
<p>优点：强大的插件生态，通过增加插件和个性化配置，可以不断变得更好用。</p>
<p>缺点：毕竟不是原生支持，初学者上来就安装配置插件，容易一开始就搞晕。而且因为不是专门开发 go，多余的功能会造成干扰。</p>
<h4 id="GoLand"><a href="#GoLand" class="headerlink" title="GoLand"></a>GoLand</h4><p>IntellJ 出品，本质上是 IDEA 的一个特化版本。</p>
<p>口碑很好，但是因为收费，然后 VSCode 已经够用，我没有用过。</p>
<p>如果你觉得好用，请购买授权。如果你觉得贵，那么免费本身就有很好的选择。</p>
<p>身为开发者却白Piao软件，而且还不是非用不可的软件，实在是不光彩的行为。希望你不会被甲方白Piao。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间为 go 1.13 写了 &lt;a href=&quot;../setup-golang-env-for-1-13-and-above/&quot;&gt;《配置 1.13+ 的 golang 环境》&lt;/a&gt; （注：现在go 1.14 都发布了），以区别于 1.9 还在用 GOPATH 时写的  &lt;a href=&quot;../../setup-golang-env/&quot;&gt;《配置 Golang 开发环境》&lt;/a&gt; 。考虑到后者写了 Win 环境下的配置，于是前者就写一下 Linux 环境。&lt;/p&gt;
&lt;p&gt;当下这个时间点，当然参考 1.13+ 那篇。可是在 Windows 配置怎么办？那就把文中系统相关的操作（主要是环境变量）换成 Win 的对应操作。两篇文章，分别涉及到了 “&amp;lt; 1.13 &amp;amp; Win” 和 “1.13+ &amp;amp; Linux”，看完举一反三，应该新旧版本两个系统平台，都会配置了。&lt;/p&gt;
&lt;p&gt;结果今晚让朋友看着新教程（1.13+）配置 Win 下 go 1.13+ 环境，证明我还是太天真：这些配置教程的目标读者很可能根本没有跨平台的经验，一个 Linux 的操作在 Windows 下对应着什么，他们完全没有概念 [摊手]。&lt;/p&gt;
&lt;p&gt;一气之下，只好再发一篇。注意，这篇 &lt;strong&gt;没有任何新内容&lt;/strong&gt;，纯粹是旧文的重新组合！（Windows &amp;amp; go 1.13+）&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>删除打开文件的正确方法（Linux）</title>
    <link href="https://jaycechant.info/2020/correct-way-to-delete-an-opened-file/"/>
    <id>https://jaycechant.info/2020/correct-way-to-delete-an-opened-file/</id>
    <published>2020-02-19T16:05:41.000Z</published>
    <updated>2020-03-05T19:04:56.500Z</updated>
    
    <content type="html"><![CDATA[<p>凭记忆复述一个坑，稍微带到 Linux 文件系统知识。时间久远，记忆可能存在差错。发现了错误请留言告知，感激不尽。</p>
<p>标题的中文断句上容易有歧义，重复一下英文：correct way to delete an opened file ，关键在 『打开了的文件』或者叫 『已经打开的文件』，怎么解释都比 opened 拗口。</p>
<p>（由于当时没有留下记录，文中 shell 输出均为写文章时 <strong>模拟重现</strong>，并非第一现场。）</p>
<a id="more"></a>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>惯例开头给结论</p>
<ul>
<li><strong>有进程引用</strong> 的文件在当下无法真正被删除，虽然 rm 之后 ls 等命令无法再看到文件，但是磁盘空间依然没有被释放，<strong>在 rm 之前就已经打开文件的进程</strong> 依然可以正常读写这个文件。</li>
<li>所以删除一个正在打开（rwx 都算）的文件，对打开的进程来说是安全的，并不会造成进程崩溃。这也是程序可以运行时更新的原因。rm 之后这个文件名（指包括路径在内的全名）被释放，可以新建同名文件，也可以把其他文件 mv、cp 过来，这时想办法重启进程，引用的就已经是新文件了。但注意，文件更新之后、进程重启之前，进程仍在 <strong>引用（已经看不见的）旧文件</strong>。</li>
<li>具体看删除的目的是什么：<ul>
<li>只是要删除文件，<strong>不关心磁盘空间什么时候释放</strong> ，直接 rm 即可，磁盘将在文件不再被引用之后释放。</li>
<li>只是为了释放磁盘空间，不关心这个文件名的释放，直接 <code>echo &gt; filename</code> 或者 <code>cat /dev/null &gt; filename</code> 清空内容是更有效的办法。</li>
</ul>
</li>
<li>如果像我一样，没想清楚就 rm 了，而磁盘还没释放，先 <strong>通过 lsof 找到打开的进程号</strong> ，有两种方法可以释放：<ul>
<li>进程可以重启，那就 <strong>重启进程</strong> ，释放文件句柄</li>
<li>进程不能重启，就在进程下找到被删除的文件的符号链接，通过这里把文件清空。（详细操作看正文）</li>
</ul>
</li>
</ul>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>还是去年 6 月的事，当时给熟人介绍的公司当远程技术顾问，帮他们实现一个服务。</p>
<p>考虑到远程调试的各种不便，服务用 go 实现，各种 feature 尽量做成了内置，同时预留了对接成熟组件的余地。例如数据库默认 sqlite3，但修改配置可以连接 MySQL。通过这样做到单文件部署即可测试，减少合作中的远程部署和沟通成本。（这段其实跟本文主旨无关，但是忍不住提一下 go）</p>
<p>不涉及数据的测试，项目组每个人在自己的电脑就能部署自测；涉及数据部分或者比较正式的测试、演示，甲方给了一个阿里云的服务器，服务部署在上面，然后大家一起测试，确保大家测试的是同一份配置，同一份数据。</p>
<p>这是背景。</p>
<h3 id="0x0-磁盘爆满"><a href="#0x0-磁盘爆满" class="headerlink" title="0x0 磁盘爆满"></a>0x0 磁盘爆满</h3><p>某天晚上，如常根据甲方反馈意见做了修改，部署，测试。</p>
<p>结果刚上线大家就反馈说，服务非常卡，完全没法用。</p>
<p>就这么几个人访问，不大可能有性能问题，根据以往经验，看了一下网络延时，正常。再去看日志，数据库一堆错误。这样顺藤摸瓜，最后得出结论 —— <strong>服务器磁盘满了</strong> ……居然满了！！？（当时内心小声嘀咕，贵司没有任何运维措施的吗？服务器上没有监控和告警的吗？）</p>
<p>询问甲方后，得知这是甲方一个即将到期的服务器，不打算续期，重要的服务都已经迁移到新的服务器。（不管好像也说得过去。）</p>
<p>浏览了一下磁盘，找到了几个比较大的文件，挑了最大的一个 <code>nohup.out</code> 去征求甲方意见，果然可以删。（不知道『 <code>nohup.out</code> 是什么，为什么大概率可以删』的童鞋，请自行了解，不展开。）</p>
<p>没细想，直接 rm 了。</p>
<h3 id="0x1-依然爆满"><a href="#0x1-依然爆满" class="headerlink" title="0x1 依然爆满"></a>0x1 依然爆满</h3><p>重新启动服务，测试，依然超卡。看日志，问题依旧。去看删掉的文件，不在。检查磁盘空间，<strong>依然是满的</strong> ……居然还是满的？！删了好几G东西，这么快又写满了？不可能啊。</p>
<p>然后有几秒陷入了沉思……（此处应有黑人问号脸）</p>
<p>（这里吐槽一下自己，明明前几天磁盘还有空间，今天突然就满了，数据写入的速度明显不是我写的服务能够造成的，下面的事情我就应该想得到，rm 前就应该 lsof 一下。）</p>
<p>还好，我很快反应过来是什么回事。</p>
<p>因为甲方说服务已经迁走了，想当然地认为这个服务器已经没有在跑什么应用，各种数据文件也应该是历史遗留。只是想当然，没有查进程，没有查文件的访问时间、修改时间。</p>
<p>现在的现象提醒我，文件应该是被进程打开了。</p>
<p>（如果在 rm 之前 lsof 一下，输出大概是这样。lsof 是 LiSt Open Files 的缩写。可惜当时没有先做这步。）</p>
<p>（再次提醒，以下 shell 输出是写文章时 <strong>写代码循环 print 模拟的</strong> ，真实情况当时没有保留。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># dummy 是为了模拟，写的一个只会循环向标准输出打印数字的程序，然后用 nohup 挂在后台运行，输出重定向到 nohup.out</span></div><div class="line"><span class="comment"># grep 之后不会输出表头，为了方便对比，特意把表头先打出来</span></div><div class="line">$ lsof | head -n 1</div><div class="line">COMMAND     PID   TID                USER   FD      TYPE             DEVICE  SIZE/OFF    NODE NAME</div><div class="line">$ lsof | grep nohup.out</div><div class="line">dummy     29627                jaycechant    1w      REG                8,7       287 3539805 /home/xxx/nohup.out</div><div class="line">dummy     29627                jaycechant    2w      REG                8,7       287 3539805 /home/xxx/nohup.out</div></pre></td></tr></table></figure>
<p>（从这个结果看，nohup.out 被 dummy 进程打开了。fd 部分 1 是标准输出，2 是标准错误，w 是只写打开。这里因为只有一个 nohup.out 被引用，所以 grep 直接以 nohup.out 为条件；实际上当时服务器上不止一个 nohup.out，所以用了更复杂的条件。但是这个没有模拟的必要，如果筛选出来的结果太多，再实时调整 grep 的搜索条件就好了。）</p>
<p>实际上当时直接就 rm 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm nohup.out</div></pre></td></tr></table></figure>
<p>rm 之后才反应过来，然后徒劳地用 重定向清空 挣扎了一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 完全多余的操作，inode 都不一样了</span></div><div class="line">$ cat /dev/null &gt; nohup.out</div><div class="line">$ ls -hail nohup.out</div><div class="line">3539813 -rw-rw-r-- 1 jaycechant jaycechant 0  2月 20 02:06 nohup.out</div></pre></td></tr></table></figure>
<p>新建的 nohup.out 是空白的（如果是 <code>echo &gt; nohup.out</code> 则有一个字节），但是磁盘依旧没有释放。留意 inode 已经不是同一个文件了。最后还是不得不 lsof。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ lsof | grep nohup.out</div><div class="line">dummy     29627                jaycechant    1w      REG                8,7      5030 3539805 /home/xxx/nohup.out (deleted)</div><div class="line">dummy     29627                jaycechant    2w      REG                8,7      5030 3539805 /home/xxx/nohup.out (deleted)</div></pre></td></tr></table></figure>
<p>可以看到，跟上面相比有两个变化：</p>
<ul>
<li>文件名后面多了 <code>(deleted)</code> ，表明文件已经被（标记）删除。</li>
<li>SIZE 变大了（因为进程还在持续写入），反正不是新建的文件大小。</li>
</ul>
<h3 id="0x2-找回文件句柄"><a href="#0x2-找回文件句柄" class="headerlink" title="0x2 找回文件句柄"></a>0x2 找回文件句柄</h3><p>这时进入了一个尴尬的境地：想删文件，结果被进程占用，只是标记删除，磁盘空间没释放；想清空文件大小，但是因为文件（实际上是文件的硬链接）已经被删除了，没有了操作的对象。现在任何对该目录下的 nohup.out 的操作，都指向了新文件。</p>
<p>这时只好请出 <code>/proc</code> 。</p>
<p><code>/proc</code> 是只存在于内存里的伪文件系统，通过文件的方式，提供访问内核和进程信息的接口。（Linux 一切皆文件）在上面，我们已经知道了 dummy 的进程号是 29627，那么我们就可以通过以下方式查找到它打开的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ls -hal /proc/29627/fd</div><div class="line">总用量 0</div><div class="line">dr-x------ 2 jaycechant jaycechant  0  2月 20 01:49 .</div><div class="line">dr-xr-xr-x 9 jaycechant jaycechant  0  2月 20 01:49 ..</div><div class="line">lr-x------ 1 jaycechant jaycechant 64  2月 20 01:49 0 -&gt; /dev/null</div><div class="line">l-wx------ 1 jaycechant jaycechant 64  2月 20 01:49 1 -&gt; /home/xxx/nohup.out (deleted)</div><div class="line">l-wx------ 1 jaycechant jaycechant 64  2月 20 01:49 2 -&gt; /home/xxx/nohup.out (deleted)</div></pre></td></tr></table></figure>
<p>注意这里的文件只是符号链接，所以大小都是 64，并非指向的文件的真实大小。</p>
<p>这些符号链接非常特殊，他们指向 <code>原文件名+空格(deleted)</code> （这个通过 <code>readlink /proc/29627/fd/1</code> 可以看到）， (deleted) 并非一个注释，而是实在的目标文件名的一部分。拿这个名字（中间有空格，所以要引号括起来）去访问，无论 ls、cat、stat 都访问不了（没有那个文件或目录）；而且这个名字可以创建新文件，inode 是新的。但是对符号链接重定向却起效了。估计内存引用做了特殊处理，只是我查了半天没有找到具体是什么处理，先把这个题外话搁下，不影响本文的主要内容。</p>
<h3 id="0x3-清空"><a href="#0x3-清空" class="headerlink" title="0x3 清空"></a>0x3 清空</h3><p>拿到了文件的句柄，就可以清空内容了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /dev/null &gt; /proc/29627/fd/1</div></pre></td></tr></table></figure>
<p>这时再看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ lsof | grep nohup.out</div><div class="line">dummy     29627                jaycechant    1w      REG                8,7        16 3539805 /home/xxx/nohup.out (deleted)</div><div class="line">dummy     29627                jaycechant    2w      REG                8,7        16 3539805 /home/xxx/nohup.out (deleted)</div></pre></td></tr></table></figure>
<p>文件大小就小很多了。为什么不是 0 呢？因为进程还在写入。[苦笑]</p>
<p>所以不用多久，很可能还是要再处理一次。如果确认进程已经没有用，还是停掉吧。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 正则式 /[d]ummy/ 和 /dummy/ 含义没有差别，但可以避免匹配自身</span></div><div class="line">$ <span class="built_in">kill</span> -9 `ps x | awk <span class="string">'/[d]ummy/&#123;print $1&#125;'</span>`</div><div class="line">$ lsof | grep nohup.out</div><div class="line"><span class="comment"># 没有输出，inode 彻底释放掉了</span></div></pre></td></tr></table></figure>
<h2 id="涉及的文件系统原理"><a href="#涉及的文件系统原理" class="headerlink" title="涉及的文件系统原理"></a>涉及的文件系统原理</h2><p>上面的内容要透彻理解，涉及到 Linux 的文件系统原理。直接上一张图</p>
<p><img src="../../images/linux_fs.png" alt=""></p>
<ol>
<li>首先目录本身也是文件，只是系统做了特殊处理。里面的内容非常简单，所有子文件的 <strong>文件名</strong> 以及对应的 inode 号，也就是 <code>ls -i</code> 输出的内容。</li>
<li>inode 储存 <strong>文件名 和 文件内容 以外</strong> 的所有信息（大小 / 所有者 / 分组 / 权限 / 时间戳 / 链接数 / 块的位置，基本上等于 <code>stat</code> 输出的内容）。访问文件时，根据文件名获取到对应的 inode，再从 inode 获取各个块的位置，从块里读取 <strong>内容</strong>。</li>
<li>访问一个文件，就是从根目录 <code>/</code> 的 inode 开始不断做 3 个操作： ① 读目录文件；② 找到对应的 inode； ③ 从对应的块读取内容。如果 ③ 读到的是一个目录文件，继续递归下去，直到读到目标文件为止。</li>
<li>inode 里储存了 引用计数（内存） 和 链接计数（磁盘）。只有两者都为 0 ，inode 才会被回收。而只有 inode 被回收，块才会被回收。</li>
<li>硬链接(hard link) 本质上是所有指向 inode 的文件名，记录在 <strong>目录文件</strong> 里，包括创建时第一个文件名。rm 本质是 unlink，删掉目录文件里的记录；每删除一个，<strong>链接计数</strong> 减 1。创建硬链接，就是在目标目录里加一条新记录，指向同一个 inode，链接计数 加 1。而在同一个文件系统里移动文件(mv)，等于在新旧目录分别做以上操作。</li>
<li>进程打开文件，则会增加 <strong>引用计数</strong>，并且在 <code>/proc</code> 中通过符号链接记录指向的文件。一旦完成了靠 文件名 查找 inode 的过程，在关闭重新打开之前，<strong>会直接访问 inode</strong> 。此时只针对文件名的操作，都不会影响进程访问文件。</li>
</ol>
<p>拿可能更多人了解的互联网打个不太准确的比方：</p>
<ul>
<li>文件名 相当于 域名，inode 相当于 IP，块相当于服务器。</li>
<li>硬链接相当于 A 记录，软链接相当于 CNAME 记录。不过软链接的类比不准确，因为软链接 <strong>不是在目录里直接指向目标文件的</strong> ，而是本身是一个普通文件，有 inode，有块；只是块里记录的是目标文件；相当于还是 A 记录，有 IP，有服务器，只不过服务器唯一的作用就是重定向到另一个域名。</li>
<li>访问文件时查询 inode 相当于 DNS 查询，一旦完成了，直接按 IP 通信。在断开重连之前，域名的修改不影响通信。</li>
</ul>
<p>大概是这样，继续深入还能写好长，篇幅所限先打住。</p>
<p>有些知识点我不是特别确定，所以行文期间参考了以下文章，如果想进一步了解，建议也看一下：</p>
<ul>
<li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="external">《理解 Linux 的硬链接与软链接》</a></p>
</li>
<li><p><a href="https://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="external">《理解 inode》</a></p>
</li>
<li><p><a href="https://blog.csdn.net/TheWindRisesll/article/details/86542137" target="_blank" rel="external">《Linux ： 文件系统（创建一个文件 inode号 、inode、数据块之间的关系）》</a></p>
</li>
<li><p><a href="https://www.linuxprobe.com/linux-proc-pid.html" target="_blank" rel="external">《简析Linux中 /proc/[pid] 目录的各文件》</a></p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;凭记忆复述一个坑，稍微带到 Linux 文件系统知识。时间久远，记忆可能存在差错。发现了错误请留言告知，感激不尽。&lt;/p&gt;
&lt;p&gt;标题的中文断句上容易有歧义，重复一下英文：correct way to delete an opened file ，关键在 『打开了的文件』或者叫 『已经打开的文件』，怎么解释都比 opened 拗口。&lt;/p&gt;
&lt;p&gt;（由于当时没有留下记录，文中 shell 输出均为写文章时 &lt;strong&gt;模拟重现&lt;/strong&gt;，并非第一现场。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="file-system" scheme="https://jaycechant.info/tags/file-system/"/>
    
  </entry>
  
  <entry>
    <title>golang 1.13 - module VS package</title>
    <link href="https://jaycechant.info/2020/golang-1-13-module-VS-package/"/>
    <id>https://jaycechant.info/2020/golang-1-13-module-VS-package/</id>
    <published>2020-01-20T08:50:37.000Z</published>
    <updated>2020-01-22T10:10:38.811Z</updated>
    
    <content type="html"><![CDATA[<p>在写 《<a href="https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/">配置 1.13+ 的 golang 环境</a>》时，花了大量篇幅解释 module 的概念，还有 module 与 package 之间的联系。眼看字数翻了一番，干脆把这部分另起一篇。</p>
<a id="more"></a>
<h2 id="module-与-package"><a href="#module-与-package" class="headerlink" title="module 与 package"></a>module 与 package</h2><h3 id="0x0-module-不是-package"><a href="#0x0-module-不是-package" class="headerlink" title="0x0 module 不是 package"></a>0x0 module 不是 package</h3><p>是的，他们不是同一个概念！！module（模块）是新引入的概念，一个 module 是 零到多个 package（包）的组合，不要把他们混为一谈。</p>
<table>
<thead>
<tr>
<th></th>
<th>package</th>
<th>module</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>本质</strong></td>
<td>一个目录下所有 go 源码的集合（不包括子目录，那是另一个 package）</td>
<td>同一个根目录下所有包的集合（包括子目录）</td>
</tr>
<tr>
<td><strong>共享</strong></td>
<td>代码 <strong>共享命名空间（包名）</strong>，包内可以 <strong>直接互相调用</strong>（包括小写开头的 unexported members）</td>
<td>同一个 module 下的 package <strong>共享 module path 作为 package path 的前缀</strong>，module 内可以 <strong>直接互相 import</strong></td>
</tr>
<tr>
<td><strong>单位</strong></td>
<td>（代码开头）<strong>import 的单位</strong></td>
<td>（go.mod）<strong>require 的单位</strong></td>
</tr>
</tbody>
</table>
<p><strong>package</strong>  具体体现为一个目录下所有 go 源码的集合（不包括子目录，那是另一个 package），它们 <strong>共享命名空间（包名）</strong>，包内可以 <strong>直接互相调用</strong>（包括小写开头的 unexported members）。package 是 <strong>import 的单位</strong> ，import 语句写在每一个 go 源码文件的开头。<br>包名跟目录名 <strong>可以一样也可以不一样</strong>。虽然允许不一样，但是大家习惯性认为目录就是包名；为了避免大家还要去查包名， <strong>没什么特别理由建议保持一致</strong>。<br>例如，<code>import path/to/pkg_dir</code> 中的 pkg_dir 是目录名，<code>package pkg</code> 和 <code>pkg.MyFunc()</code> 里的 pkg 是包名。</p>
<p><strong>module</strong> 则是同一个根目录下所有包的集合（包括子目录），它们 <strong>共享 module path 作为 package path 的前缀</strong>，module 内可以 <strong>直接互相 import</strong>。module 是 <strong>require 的单位</strong> ，require 语句在 go.mod 里。</p>
<h3 id="0x1-GOPATH-vendor-时代"><a href="#0x1-GOPATH-vendor-时代" class="headerlink" title="0x1 GOPATH + vendor 时代"></a>0x1 GOPATH + vendor 时代</h3><blockquote>
<p>这段解释 GOPATH 的机制，是为了对比，加深理解。</p>
<p>如果你不想了解已经被抛弃的 GOPATH ，可以直接跳过看 0x2 部分。</p>
</blockquote>
<p>在依赖 GOPATH 的时候，import 的查找范围如下：</p>
<ol>
<li><code>$GOROOT/pkg</code> 查找 <strong>内置包</strong></li>
<li><del>查找 <strong>相对路径</strong> 的包</del></li>
<li>项目根目录下的 vendor 目录查找 <strong>第三方包</strong></li>
<li><code>$GOPATH/src</code> 查找下载的 <strong>第三方包</strong> 和 <strong>本地包</strong>，如果不存在，尝试 <code>go get</code></li>
</ol>
<p>重点解释 2 和 4。</p>
<h4 id="相对路径-import？别用！"><a href="#相对路径-import？别用！" class="headerlink" title="相对路径 import？别用！"></a>相对路径 import？别用！</h4><p>假定有项目 A ，底下有两个包，分别为 A/alpha 和 A/beta。</p>
<p>为了方便，A/alpha 包使用相对路径引入 A/beta：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"../beta"</span></div></pre></td></tr></table></figure>
<p>如果 A 不在 GOPATH 里开发，换言之 A 不会被别的项目引用，那么是可以正常编译执行的。</p>
<p>可是如果 A 在 GOPATH 里开发，那么编译时会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">can<span class="string">'t load package: local import "../beta" in non-local package</span></div></pre></td></tr></table></figure>
<p>这是因为 go 使用全局递归 import，来确保每个用到的包都只 import 一次。（题外话，也因此，go 不允许循环 import，会死循环。）</p>
<p>假定有另一个项目 B，底下的 main 包引入了 A/alpha，那么就会触发以下 import 顺序：</p>
<ul>
<li>import “A/alpha”，递归 import “A/alpha” import 的包<ul>
<li>import “../beta”，（到这里会出错，因为 B 项目下找不到 “../beta”）</li>
</ul>
</li>
<li>运行 “A/alpha” 的 init()，然后 import 完成</li>
</ul>
<p>如果你觉得解释太啰嗦，记住 <strong>别用相对路径</strong> 就完了。</p>
<h4 id="一切靠-GOPATH"><a href="#一切靠-GOPATH" class="headerlink" title="一切靠 GOPATH"></a>一切靠 GOPATH</h4><p>既然相对路径会有各种问题，那么本地包的导入，就只剩下第 4 种 - GOPATH 一条路了。</p>
<p>这就导致了包管理高度依赖 GOPATH：</p>
<ul>
<li>为了本地开发的包 <strong>能被其它包引用</strong>，开发得在 GOPATH 下进行。</li>
<li>不仅引用其他项目包要经 GOPATH，<strong>连项目内的包互相引用</strong> ，也得经过 GOPATH。（实际上这时不存在 <strong>项目</strong> 的概念，即使共享一个项目根目录，还是不同的包。）</li>
<li>项目目录不能改名，一改，项目内外的引用全得改。（事实上，如果你要把项目托管到源码仓库，或者更换托管地址，项目目录是一定会改的。）</li>
</ul>
<p>这么打个比方，李明 爸爸叫 李雷，妈妈叫 韩梅梅，他们一家住 广东省广州市黄埔区。但是很奇怪，他们家互相称呼都得叫全名，而且是带地址那种。譬如 妈妈 喊老伴和儿子吃饭，就得喊『广东省 / 广州市 / 黄埔区 / VK花园10-204 / 李雷』和『广东省 / 广州市 / 黄埔区 / VK花园10-204 / 李明』。更诡异的是，如果他们过年回老家了，譬如说 长沙，然后妈妈忘记了改称呼，还按前面叫，明明都在一屋（项目）里，但他们俩都不知道在喊自己了。</p>
<p>根本原因，在于 import 中只有全局，没有本地（项目 / 模块）概念。全局以下就直接是包，包和包之间没有联系，哪怕我们在一个项目里，目录相邻。</p>
<p>如果你写过 Java，对比一下就发现，Java 的 classpath 默认为 <strong>当前目录</strong>；这个当前目录，是以执行 javac 的位置算的，其实就是项目的根目录。所以同一个项目下的包，用<strong>相对根目录的路径</strong> 就能 import，不管项目整体放哪、项目目录有没有改名。</p>
<h3 id="0x2-引入-module"><a href="#0x2-引入-module" class="headerlink" title="0x2 引入 module"></a>0x2 引入 module</h3><p>module 模式设为 on，背后主要是两个变化：<strong>引入 module （和 module path），放弃 GOPATH （和 vendor）</strong> 。</p>
<p>这个 module 就是介于 global 和 package 之间的概念，是 一系列的 package 集合。这个概念让在一个 module 里的 package 们产生了联系：整体管理， 互相可见。</p>
<h4 id="module-path-和-package-path"><a href="#module-path-和-package-path" class="headerlink" title="module path 和 package path"></a>module path 和 package path</h4><p>package path 具体来说，就是 import 后面那串路径；module path 则对应 require。</p>
<p>在使用上，package path 似乎没有任何变化，其实它的组成有了重要的变化：</p>
<h5 id="GOPATH-模式"><a href="#GOPATH-模式" class="headerlink" title="GOPATH 模式"></a>GOPATH 模式</h5><p>从 <code>$GOPATH/src</code> 起完整的路径。  </p>
<p>例如 <code>$GOPATH/src/github.com/jay/mymod/midware/router</code> 的 package path 是 <code>github.com/jay/mymod/midware/router</code> ，其它包（包括同一个项目<code>github.com/jay/mymod</code> 下的其它包）需要 import 这个路径。  </p>
<p>路径上的 <strong>任何变化</strong> 都要体现在 import 路径里，如果移出 GOPATH 则 <strong>直接找不到</strong> 。（是的，明明引用的包就在旁边目录都找不到。）</p>
<h5 id="module-模式"><a href="#module-模式" class="headerlink" title="module 模式"></a>module 模式</h5><p>module path + module 内的相对路径。（如果 package 在 module 根目录，也就是跟 go.mod 一个目录，当且仅当这种情况 module path 等于 package path。）  </p>
<p>例如 module path 是 <code>github.com/jay/mymod</code> ，module 内的 <code>midware/router</code>  的 package path 是 <code>github.com/jay/mymod/midware/router</code> ，其它包（包括同一个module <code>github.com/jay/mymod</code> 下的其它包）需要 import 这个路径。  </p>
<p>是不是感觉其实没啥差别，只是把路径截成了两段，把前面那段叫 module path。[苦笑]</p>
<p>差别在于：</p>
<ul>
<li>module path 是一个在 go.mod 内的声明，<strong>不需要是真实的路径</strong>。你的 module 可以放在任何地方开发，不需要放在 GOPATH 地下，路径里也不须包含  <code>github.com/jay/mymod</code> ！</li>
<li>基于这点，只要 go.mod 声明不改，<strong>挪位置，根目录重名，都不影响</strong> module 内 package 互相引用！</li>
</ul>
<h4 id="module-间引用"><a href="#module-间引用" class="headerlink" title="module 间引用"></a>module 间引用</h4><p>等等，这些便利都只是 module 内而已，那 module 之间的引用呢？</p>
<p>再来对比一下：</p>
<h5 id="GOPATH-模式-1"><a href="#GOPATH-模式-1" class="headerlink" title="GOPATH 模式"></a>GOPATH 模式</h5><p><strong>项目托管地址、本地存放路径、import 路径</strong> （的开头） 三者一致。  </p>
<p>仍然以上面的项目为例，三个都是 <code>github.com/jay/mymod</code> 。<br>具体到 托管地址是 <code>https://github.com/jay/mymod</code> ，<br>本地存放地址（无论手动新建项目，还是 go get 自动放）是 <code>$GOPATH/src/github.com/jay/mymod</code> ，<br>import 则是 <code>import &quot;github.com/jay/mymod/midware/router&quot;</code> （mymod 下面其中一个 package）。</p>
<h5 id="module-模式-1"><a href="#module-模式-1" class="headerlink" title="module 模式"></a>module 模式</h5><p>在上述三者基础上，加上 go.mod 声明的 module path 一致。   </p>
<p>也就是在 module 初始化时，执行 <code>go mod init github.com/jay/mymod</code> ，生成的 go.mod 里第一行就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module github.com/jay/mymod</div></pre></td></tr></table></figure>
<p>托管地址、import 路径都跟 GOPATH 一样。差别是本地存放路径：<code>$HOME/go/pkg/mod/github.com/jay/mymod</code> 。（<code>$HOME/go/pkg/mod</code> 叫 mod cache 目录）</p>
<p><br></p>
<p>看了这个对比，module 模式多了一个 go.mod 的声明要保持一致，存放路径还变长了，是不是又感觉根本没简化，还变复杂了。[苦笑]x2</p>
<p>关键在于，go.mod 里提供了一个关键字 <code>replace</code>。</p>
<h4 id="go-mod-里的-replace"><a href="#go-mod-里的-replace" class="headerlink" title="go.mod 里的 replace"></a>go.mod 里的 replace</h4><p>我们来设想一下 <strong>开发的不同阶段</strong> ：</p>
<ol>
<li><p>前期，<strong>一个人开发原型</strong> 。只有 module 内引用，爱放哪放哪。</p>
</li>
<li><p>继续前期，原型 <strong>新增了一个 mymod2</strong> ，而且 <strong>引用原来的 mymod</strong> ，有了 module 间引用，此时你有 <strong>两个选择</strong>：</p>
<ol>
<li><p><strong>继续随便放</strong> ，譬如 <code>~/mymod/</code> ，然后在 mymod2 根目录执行 <code>go mod edit -replace=github.com/jay/mymod@v=~/mymod@v</code> ，<code>@v</code> 是可选的。  </p>
<p> <code>go mod edit -replace=github.com/jay/mymod=~/mymod</code> 就是所有版本都替换。你也可以指定版本如 <code>@v1.0.1</code> 。</p>
</li>
<li><p>把 mymod 按照 module path  <strong>托管到对应地址</strong> ，mymod2 就会从托管服务下载 mymod 自动存放到 <code>$HOME/go/pkg/mod/github.com/jay/mymod@vX.Y.Z</code> 。下载过程是自动的，存放位置自动跟 “托管地址+版本” 映射，并不需要人工干预。  </p>
<p> <strong>需要注意</strong> 的是，mymod2 引用的是托管的代码，<code>~/mymod/</code> 下的最新修改如果没有push 到托管，是访问不到的。  </p>
<p> 如果 mymod2 后续也要发布或者跟其他开发者协作，<strong>建议一开始就选择这种方式</strong> 提供引用。否则按 2.1 处理，mymod2 在别人的环境无法获取 mymod 的依赖。</p>
</li>
</ol>
</li>
<li><p>中期，<strong>其他开发者加入</strong> 。为了其他开发者可以正常地访问依赖，需要把所有用到的 module 按 module path 放到托管服务上 。（同 2.2）</p>
<p> 托管服务可以是公共的，也可以是私有的。如果是私有的，需要配置 ssh 以达到免密访问。（ssh 配置不展开。）</p>
<p> 考虑到迟早需要发布到托管，最好初始化时就考虑 <strong>把托管地址作为 module path</strong> 。</p>
</li>
<li><p>后期，<strong>持续开发和维护</strong>。也许是 公共转私有（或者反过来，开源），又或者项目改名，或者某个公共托管撂挑子不干了——总之，有些 module 挪位置了。譬如说 <code>https://github.com/jay/mymod</code> 挪到 <code>https://bitbucket.com/jay/mymod</code>。  </p>
<p> 这时 replace 再次发挥作用，在所有引用这个 module 的 module 的根目录执行 <code>go mod edit -replace=github.com/jay/mymod=bitbucket.com/jay/mymod</code> ，那些 import 语句就不用一个一个修改了。  （原理同 2.1 ，只是映射的是 托管地址，不是本地，所以这个修改写入 go.mod 并提交之后， <strong>对其他开发者也能生效</strong> 。）</p>
<p> 不过 mymod 本身，除非你只挪托管不修改 go.mod 的 module path 声明（意味着 mymod 只作为依赖存在，自身没有 main 包需要编译执行），否则 mymod 内部的 import 语句还是得改为新的 module path。</p>
</li>
</ol>
<p><strong>需要注意</strong> 的是，replace <strong>只对当前 module 直接引用的依赖起作用</strong> ，对于间接引用不起作用。如果 mod1 引用 mod2，然后 mod2 引用 mod3；当 mod3 改动地址时，在 mod1 里 replace mod3 的地址，只会对 mod1 直接引用 mod3 起作用； mod2 对 mod3 的引用必须在 mod2 里改。</p>
<p>如果 mod2 是第三方的 module，而它引用的同样是第三方的 mod3 挪了位置之后，mod2 没有及时更新，那么可能你只能 fork 一个 mod2 自行修改了。</p>
<p>这个问题据说可以通过 <strong>自建 goproxy</strong> 来指定重定向解决。我还没到需要用到的时候，将来踩了自建 goproxy 的坑再回来写。</p>
<h3 id="0x3-semver-语义化版本"><a href="#0x3-semver-语义化版本" class="headerlink" title="0x3 semver 语义化版本"></a>0x3 semver 语义化版本</h3><p>要理解 go modules  的运作，还有一个是不得不提的，就是 Semantic Version - 语义化版本，缩写 semver。</p>
<p>关于 semver 是什么，请看 《<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0</a>》。</p>
<p>详细的解释，大家自己看官方文档，这里只强调格式：主版本号.次版本号.修订号</p>
<ol>
<li>主版本号：当你做了 <strong>不兼容</strong> 的 API 修改 (<strong>breaking changes</strong>)，</li>
<li>次版本号：当你做了 <strong>向下兼容</strong> 的功能性新增 (<strong>compatible features</strong>)，</li>
<li>修订号：当你做了 <strong>向下兼容的问题修正</strong> (<strong>compatible hotfixs</strong>)。</li>
</ol>
<p>譬如说当前版本号是 v1.2.3 ，在此基础上：</p>
<ul>
<li>fix 了个 bug，没有影响兼容性，v1.2.4</li>
<li>新增 / 改善了功能，依然没有影响兼容性，v1.3.0</li>
<li>任何影响兼容性的修改，无论是 fix bug （这 bug 得多严重），还是 API 签名（名字 or 参数）改动，或者干脆的删掉了 deprecated API，反正调用方会出错，必须跟着修改，v2.0.0</li>
</ul>
<p>一个特例是，主版本号为 0 的版本，被认为是初步开发的 <strong>不稳定版本</strong> ，可以不遵循兼容性的原则。</p>
<p>理解了这些，下面的一些做法就比较好理解了。</p>
<h4 id="导入兼容性原则"><a href="#导入兼容性原则" class="headerlink" title="导入兼容性原则"></a>导入兼容性原则</h4><p>一个 module 一定是 <strong>向下兼容</strong> 的。（又叫向后兼容 backwards compatible，指 newer 的版本兼容 older 的版本）反过来说，如果不兼容，会被视作 <strong>不同的 module</strong> 。</p>
<p>具体操作上，就是 2 以上的主版本号，会加入 module path，使得 <strong>module 声明、导入路径（包括 require 和 import）、缓存路径</strong> 都发生变化，从而被识别为不同的 module。唯独不变的是 托管地址，靠 tag 就可以区分，没有必要每个主版本新建一个项目。还是以 <code>github.com/jay/mymod</code> 为例：</p>
<table>
<thead>
<tr>
<th><strong>主版本号</strong></th>
<th>0 或 1</th>
<th>2 （3 或以上以此类推）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>module 声明</strong></td>
<td>module github.com/jay/mymod</td>
<td>module github.com/jay/mymod/v2</td>
</tr>
<tr>
<td><strong>require 列表</strong></td>
<td>github.com/jay/mymod v1.0.1</td>
<td>github.com/jay/mymod/v2 v2.0.2</td>
</tr>
<tr>
<td><strong>import 语句</strong></td>
<td>import “github.com/jay/mymod/midware/router”</td>
<td>import “github.com/jay/mymod/v2/midware/router”</td>
</tr>
</tbody>
</table>
<h4 id="选择最新版本"><a href="#选择最新版本" class="headerlink" title="选择最新版本"></a>选择最新版本</h4><p>在同一个主版本下，如果在添加依赖时你没有指定版本（也就是你没有手动 <code>go get github.com/jay/mymod@v1.0.1</code> ，或者只是指定了大版本 <code>go get github.com/jay/mymod@v1</code> 没有指定次版本），那么第一次获取依赖时，go 会自动 <strong>获取最新的版本</strong> 并将版本信息写入 go.mod。</p>
<p>在这之后，除非你手动更新，否则 go 会一直使用 go.mod 记录的版本，不会自动更新。</p>
<h4 id="最小版本选择"><a href="#最小版本选择" class="headerlink" title="最小版本选择"></a>最小版本选择</h4><p>依赖包括 <strong>直接依赖 和 间接依赖</strong>。mod1 依赖了 mod2，然后 mod2 又依赖了 mod3， mod2 是直接依赖， mod3 是间接依赖。间接依赖在 go.mod 里以 <code>//indirect</code> 结尾。</p>
<p>执行 <code>go mod graph</code> 可以输出所有 module 之间的依赖关系。如果项目稍大，内容会很长，长到超出 bash / cmd 的缓冲那种，建议重定向一个文件再搜索。或者 <code>go mod why &lt;package path&gt;</code> 查询某个 package 被谁依赖。</p>
<p>因为有 直接依赖 和 间接依赖，而且对某个 module 的间接依赖可能不止一处，就有可能出现依赖的版本不一致。这种不一致又分两种情况：</p>
<ul>
<li><p>主版本号不同：这个好办，参见上一个小节，主版本号不同直接被认为是不同 module，你依赖你的，我依赖我的，并行不悖。</p>
</li>
<li><p>主版本号相同：选择所有依赖里，<strong>最大的版本号</strong>。  </p>
<p>  例如 同时依赖 v1.0.1、v1.0.2、v1.1.3，那么选择 v1.1.3。因为同一个主版本下是向下兼容的，依赖 v1.0.1 和 v1.0.2 的代码，调用 v1.1.3 也是可以的；反过来说，v1.1.3 里可能增加了新功能，依赖它的地方再去调用老版本，很有可能会报错。  </p>
</li>
</ul>
<h4 id="伪版本"><a href="#伪版本" class="headerlink" title="伪版本"></a>伪版本</h4><p>go module 允许通过 commit-hash 指定版本 （可以通过 hash 前缀指定，有规定最小长度，但我忘了，这是不推荐的做法），但在获取时会自动跟 tag 比对，一旦命中会自动转换成 semver。</p>
<p>如果 module 完全没有打 tag，或者指定的 hash 不命中 tag，go 会生成一个伪版本号来记录，格式是 <code>vX.0.0-yyyymmddhhmmss-12位hash</code>。</p>
<h4 id="incompatible"><a href="#incompatible" class="headerlink" title="+incompatible"></a>+incompatible</h4><p>在 go.mod 里可以看见有些依赖后面带着一个 <code>+incompatible</code> 。这个标记的意思是，依赖的版本在 2 以上，但是这个 module 自身没有使用 module 模式（也就是根目录没有 go.mod），所以无法通过在路径添加版本来区分主版本。</p>
<p>更多版本选择的原理，请参考 《<a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="external">Minimal Version Selection</a>》。</p>
<h2 id="延伸：可重现构建"><a href="#延伸：可重现构建" class="headerlink" title="延伸：可重现构建"></a>延伸：可重现构建</h2><p>Java 从 ant、Maven 到 gradle，Python distutils、setuptools 到 pip，js 的 npm 和 yarn，go 经历了 vgo、glide、dep 到 内置 modules，再加上一系列 VCS 和 托管服务（目前是 git 和 github 统一了江湖），各种构建物仓库。</p>
<p>大家做了那么多工作，设计这么复杂的机制，本质上都是为了一个目的：<strong>构建过程可重复，构建产物可重现</strong> 。</p>
<p>在软件个人英雄主义的时代，这不成问题的，代码是大牛一个人开发的，构建所需要的代码和工具，都在大牛的电脑上。稍往后，多几个人加入，也是在一个公司、一个研究机构里，ftp 共享一下就完事了，最多搭建一个内部的 VCS 服务。</p>
<p>但是在软件开发网络大协作的年代，这就变成了一个工程难题。分布在世界各地，素未谋面的一群人一起开发，很多问题就会涌现。特别是开源的年代，即使是小公司的项目，一个学生的作业，也极少会从零开始开发，你不可避免地会引用其他人的工作成果。</p>
<p>哪怕只是和别人合作过一个简单的项目，你都大概率遇到过『你的代码在我这里 编译不过 / 运行报错。』『不可能，我本地一点问题都没有，是测试过才提交的。』这种对话。</p>
<p>上述那么多的 工具 和 机制，是为了保证分散各处的开发者（可能还有测试、运维团队），能够做到共享 <strong>一致的环境、一致的配置、一致的代码版本，一致的依赖，一致的构建脚本，重现一致的构建过程，得到一致的构建产物</strong> 。</p>
<p>话题很大，不是三言两语能够说清的，就到此为止。提那么一下，是希望帮助理解，为什么把事情搞得那么复杂。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写 《&lt;a href=&quot;https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/&quot;&gt;配置 1.13+ 的 golang 环境&lt;/a&gt;》时，花了大量篇幅解释 module 的概念，还有 module 与 package 之间的联系。眼看字数翻了一番，干脆把这部分另起一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>配置 1.13+ 的 golang 环境</title>
    <link href="https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/"/>
    <id>https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/</id>
    <published>2020-01-20T08:46:44.000Z</published>
    <updated>2020-03-10T15:10:25.969Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过《<a href="../../2018/setup-golang-env/">配置 Golang 开发环境</a>》（go &lt; 1.13, win64）。然后 1.13 是一个重大变更，大到需要原有的依赖管理要做迁移的程度（《<a href="../..//2019/golang-1-13-from-dep-to-mod/">golang 1.13 - 依赖管理从 dep 到 mod 踩坑</a>》）。</p>
<p>1.13 让原来的配置方式有了变化，撇开语言特性不谈，仅说和配置相关的，最大的变化，是 go module 的转正，和 GOPATH 和 vendor 的边缘化（1.13 仍然给你选择的余地，但是推荐选择 module，停用 GOPATH 和 vendor）。</p>
<p>那么如果你从 1.13 之后才刚刚开始接触 go， 那么前面两篇文章对你来说并不友好。</p>
<p>所以我找到了理由又水一篇。</p>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>之前的文章讲的 Win64 环境的配置，正好新版本重写，这次写 Linux 环境下。</p>
<h3 id="0x00-下载解压"><a href="#0x00-下载解压" class="headerlink" title="0x00 下载解压"></a>0x00 下载解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 为免你无脑复制黏贴，强迫你走一趟流程，也确保你下载最新版本，这不是有效的下载链接，请自行到官网找最新版本，替换掉版本号 x.y.z</span></div><div class="line">~ wget https://dl.google.com/go/gox.y.z.linux-amd64.tar.gz</div></pre></td></tr></table></figure>
<p>找下载链接请到官网 golang.org/dl ，如果国内不能访问，请到官方镜像站 golang.google.cn/dl 。</p>
<p>然后解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 记得改文件名里的 x.y.z</span></div><div class="line">~ tar -zxvf gox.y.z.linux-amd64.tar.gz</div><div class="line">mv -t /opt/ go</div></pre></td></tr></table></figure>
<p>个人习惯放到 /opt/ 下。</p>
<h3 id="0x01-系统环境变量"><a href="#0x01-系统环境变量" class="headerlink" title="0x01 系统环境变量"></a>0x01 系统环境变量</h3><p>然后将可执行文件加入系统路径。</p>
<p>在 <code>/etc/profile</code> 末尾加上，保存之后记得 source 一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># manually added</span></div><div class="line">GOROOT=/opt/go</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin:<span class="variable">$HOME</span>/go/bin</div></pre></td></tr></table></figure>
<p>我是想全局生效所以丢这里，如果你只是想当前账户生效，可以加在 <code>~/.bashrc</code>。</p>
<p>惯例地检查一下是否配置正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~ go version</div><div class="line">go version go1.13.6 linux/amd64</div></pre></td></tr></table></figure>
<p>如果不能正确执行 <code>go version</code> ，把当前版本输出，请回头检查哪里出错。</p>
<p>跟老版本不同的是，只要把 go 本身的可执行路径 和 go bin 的安装路径加入 PATH 就可以了，剩下的 go env 自行管理了。</p>
<h3 id="0x02-go-env"><a href="#0x02-go-env" class="headerlink" title="0x02 go env"></a>0x02 go env</h3><p>执行 <code>go env</code>，就会看到 go 内置的环境变量，以及部分默认值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">go env</div><div class="line">GO111MODULE=<span class="string">""</span></div><div class="line">GOARCH=<span class="string">"amd64"</span></div><div class="line">GOBIN=<span class="string">""</span></div><div class="line">GOCACHE=<span class="string">"/home/jaycechant/.cache/go-build"</span></div><div class="line">GOENV=<span class="string">"/home/jaycechant/.config/go/env"</span></div><div class="line">GOEXE=<span class="string">""</span></div><div class="line">GOFLAGS=<span class="string">""</span></div><div class="line">GOHOSTARCH=<span class="string">"amd64"</span></div><div class="line">GOHOSTOS=<span class="string">"linux"</span></div><div class="line">GONOPROXY=<span class="string">""</span></div><div class="line">GONOSUMDB=<span class="string">""</span></div><div class="line">GOOS=<span class="string">"linux"</span></div><div class="line">GOPATH=<span class="string">"/home/jaycechant/go"</span></div><div class="line">GOPRIVATE=<span class="string">""</span></div><div class="line">GOPROXY=<span class="string">"https://proxy.golang.org,direct"</span></div><div class="line">GOROOT=<span class="string">"/opt/go"</span></div><div class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></div><div class="line">GOTMPDIR=<span class="string">""</span></div><div class="line">GOTOOLDIR=<span class="string">"/opt/go/pkg/tool/linux_amd64"</span></div><div class="line">GCCGO=<span class="string">"gccgo"</span></div><div class="line">AR=<span class="string">"ar"</span></div><div class="line">CC=<span class="string">"gcc"</span></div><div class="line">CXX=<span class="string">"g++"</span></div><div class="line">CGO_ENABLED=<span class="string">"1"</span></div><div class="line">GOMOD=<span class="string">""</span></div><div class="line">CGO_CFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_CPPFLAGS=<span class="string">""</span></div><div class="line">CGO_CXXFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_FFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_LDFLAGS=<span class="string">"-g -O2"</span></div><div class="line">PKG_CONFIG=<span class="string">"pkg-config"</span></div><div class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build089244508=/tmp/go-build -gno-record-gcc-switches"</span></div></pre></td></tr></table></figure>
<h4 id="必改"><a href="#必改" class="headerlink" title="必改"></a>必改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~ go env -w GO111MODULE=on</div><div class="line">~ go env -w GOPROXY=https://goproxy.cn,direct</div></pre></td></tr></table></figure>
<p><strong>GO111MODULE</strong> : </p>
<ul>
<li>auto : 自 1.11 实验性加入之后就是默认值。auto 意味着由工具链自动判断是否启用 go modules。在 1.13 以前的启用条件是『项目根目录有 go.mod 且项目不在 GOPATH 内』，1.13+ 去掉了 『不在 GOPATH 内的限制』，也就是只要有 go.mod 就会启用。</li>
<li>on : 如果你觉得上面这段话太长懒得看，或者害怕以后启用条件还会变，那么 1.13 已经准备好全面启用 go modules，直接设为 on 就好了。设为 on 之后无条件启用 go modules。</li>
<li>off :  关闭 go modules，回到 GOPATH 时代。</li>
</ul>
<p><strong>GOPROXY</strong> :</p>
<p>国内环境必备，原因你懂的。甚至可以说这是新版本为中国开发者做出的最大改进之一也不为过。在 dep 的时代是靠自建的代理熬过来的，那么不会代理的朋友就很麻烦了。改用镜像就友好太多了。</p>
<p>目前国内最早最好的代理是 七牛云提供的 <code>https://goproxy.cn</code> 。如果团队内部还有搭建私有代理，可以用 <code>,</code> 隔开，go 会依次尝试。最后记得加上 <code>direct</code> ，让镜像上找不到的依赖回源查找。（包括但不限于 镜像还没同步，私有仓库 等情况）</p>
<p>目前自建代理的开源方案貌似有以下几个。由于我暂时没有自建代理的需要，没有实测，请自行对比选择。</p>
<ul>
<li><a href="https://github.com/goproxyio/goproxy" target="_blank" rel="external">https://github.com/goproxyio/goproxy</a></li>
<li><a href="https://github.com/gomods/athens" target="_blank" rel="external">https://github.com/gomods/athens</a></li>
<li><a href="https://github.com/goproxy/goproxy" target="_blank" rel="external">https://github.com/goproxy/goproxy</a></li>
</ul>
<h4 id="推荐改"><a href="#推荐改" class="headerlink" title="推荐改"></a>推荐改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~ go env -w GOBIN=<span class="variable">$HOME</span>/go/bin</div></pre></td></tr></table></figure>
<p><strong>GOBIN</strong> 如果没有设置，默认值为 <code>$GOPATH/bin</code> ，是通过 <code>go get</code> 或 <code>go install</code> 安装的可执行文件的存放目录。不设并不影响使用，但考虑到 GOPATH 正在被边缘化，未来不知道哪个版本就取消了，所以建议还是单独设置一下比较好。我为了保持使用习惯，设置了跟默认相同的目录（因为 GOPATH 默认值是 <code>$HOME/go</code>），区别只是这个值不依赖 GOPATH 的值。</p>
<p>值得 <strong>提醒</strong> 的是，这个目录也需要加入系统 PATH ，并且我已经在 系统环境变量 里加入（最后一个），如果你根据自己的习惯修改了 GOBIN 的位置，那么 0x01 里的配置也得相应修改。</p>
<p>更多的变量，推荐参考 《<a href="https://mp.weixin.qq.com/s/AsdCDodxZFxs2SkhSwOvpg" target="_blank" rel="external">干货满满的 Go Modules 和 goproxy.cn</a>》。</p>
<h3 id="0x03-cgo-和-build-tool"><a href="#0x03-cgo-和-build-tool" class="headerlink" title="0x03 cgo 和 build tool"></a>0x03 cgo 和 build tool</h3><p>go 语言的 cgo 特性允许 C 语言 和 go 语言互调，达到 <strong>复用已有的 C/C++ 庞大代码资源</strong> 的目的；又或者用 C 编写程序的一部分以达到某些 底层语言才能达到的目标。而要使用 cgo 特性，就需要有 C/C++ 的构建工具链 <strong>gcc</strong> 。</p>
<p>另一方面，随着项目规模变大，你会逐渐需要一个 <strong>构建工具</strong> （build tools）帮你管理构建细节，就像 ant / maven / gradle 之于 Java。由于 go 本身的构建比较简单（或者说 go 的构建规则比较清晰，自带的 build 命令够用），又有了现成的依赖管理（之前的 vgo / glide / dep，现在官方的 go modules），官方并没有一个专用的构建工具。这部分，因为依赖管理已有，管理额外的构建细节， <strong>Makefile (make) 足矣</strong> 。</p>
<p>gcc 和 make 在多数 Linux 发行版是自带的，你可以通过  <code>gcc -v</code> 和 <code>make -v</code> 来确认安装的版本。即使没有，视乎不同的包管理器，也就是一两句命令的事。Windows 下稍微麻烦一些，但仍然有解决方案，我在《<a href="https://jaycechant.info/2018/setup-golang-env/">配置 Golang 开发环境</a>》#2. gcc 和 make 部分有提及，go 的重大升级不影响这部分内容依然有效。</p>
<h3 id="0x04-安装-VCS"><a href="#0x04-安装-VCS" class="headerlink" title="0x04 安装 VCS"></a>0x04 安装 VCS</h3><p>在使用 go get 命令之前，需要安装依赖托管服务对应的 VCS （Version Control System）。go get 会根据依赖所托管的网站反馈的信息，调用对应的工具 （git / hg / svn）拉取依赖。</p>
<p>就我的个人实践而言，绝大多数的第三方依赖都是基于 git 发布的（或者说直接就是放在 github 上），所以 <strong>直接安装 git 就好</strong> ，后面遇到基于其他工具的依赖，再安装不迟。</p>
<p>由于 git 本身就是一个大话题，基本的安装使用教程不难搜到，有时间时会另起文章讨论，这里只是提醒安装，不再展开。</p>
<h3 id="0x05-开始一个项目"><a href="#0x05-开始一个项目" class="headerlink" title="0x05 开始一个项目"></a>0x05 开始一个项目</h3><p>终于把环境都配置好了，然后就可以开始第一个 go 的项目了。由于 go modules 不再依赖 GOPATH，所以项目可以放在任何地方——这个 『任何』，是指可以不是 GOPATH ，但是要是习惯了，继续放在 <code>$GOPATH/src</code> 也没问题。</p>
<p>好了，不管放在哪，现在新建一个项目的根目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">~ mkdir testproj</div><div class="line">~ <span class="built_in">cd</span> testproj</div></pre></td></tr></table></figure>
<p>然后执行 <code>go mod init &lt;module_path&gt;</code> ，生成 go.mod ，这个项目就算初始化完了，接下来就该敲代码了。随着开发的进行，还会自动生成 go.sum 文件，记录依赖的校验信息。注意 go.sum <strong>不是 lock 文件</strong> ，重现构建的信息已经包含在 go.mod 里，go.sum <strong>属于 checksum 文件</strong> ，用来 <strong>确保下载的依赖没有被篡改</strong> 。 go.mod 和 go.sum 需要一起提交<strong>参与版本控制</strong> 。关于 <code>go mod</code> 的详细用法，可以直接 <code>go help mod</code> 获取帮助信息，不展开。</p>
<p>关于 module path 的内容，以及 module 与 package 之间的关系，原本是在这篇文章里接着继续写；结果发现这部分内容让字数足足翻了一番。为了避免让本文又臭又长，就另起了一篇文章，请看《<a href="https://jaycechant.info/2020/golang-1-13-module-VS-package/">golang 1.13 - module VS package</a>》。</p>
<p>go 语言开发不是（篇幅上也不可能是）本文的话题，另起系列展开。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>在写这篇文章时，留意到 gradle 的一个插件 <strong>gogradle</strong>，可以为 gradle 添加对 go 的支持。由于我没有使用过这个插件，所以不好评价；不过基于以下理由，我认为除非有什么困难只有它能解决，不然 make 足以完成绝大多数的任务，不推荐尝试：</p>
<ul>
<li>go 除了某些特性（如 cgo）编译时依赖某些二进制工具（如 gcc，二进制是区别于基于虚拟机的工具），基本是一个完全自给自足的语言，环境配置简单且基本一劳永逸，编译结果可以单执行文件零依赖部署，在某些情况下简直是杀手级的特性。（想想 C/C++ 以外多少语言能做到）而 gradle 是基于 groovy （一种 JVM 上的脚本语言），等于 <strong>给 go 的开发环境引入了 JVM 依赖</strong> 。即使我作为一个长期写 Java 的人，环境里一定有 JVM，仍然觉得这种依赖是别扭的。</li>
<li>gogradle 官方文档自荐的理由，是 make 学习曲线陡峭，和 make 基于 bash 的跨平台性不好。make 和 gradle 的学习曲线见仁见智，但是由于 go 自带的 build 已经完成了构建的大多数工作（包括依赖推导和文件新旧比较），也不需要处理依赖管理，make 的 <strong>工作任务非常轻</strong> ， 不会涉及太复杂的规则编写。至于跨平台，引入 MinGW-w64 已经可以解决大多数的问题。</li>
<li>go 1.13 自带 go modules 作为依赖管理，大方向是 <strong>淡化 GOPATH 和 vendor</strong>；而 gogradle 受 glide 启发，自带依赖管理，自称相当于 glide + make，依然使用 GOPATH 和 vendor，这 <strong>跟官方的发展方向冲突</strong> 。这可能是最关键的一点，如果你习惯了 gradle 的工作方式，有一天这种工作方式可能跟官方的最新版本不兼容。</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前写过《&lt;a href=&quot;../../2018/setup-golang-env/&quot;&gt;配置 Golang 开发环境&lt;/a&gt;》（go &amp;lt; 1.13, win64）。然后 1.13 是一个重大变更，大到需要原有的依赖管理要做迁移的程度（《&lt;a href=&quot;../..//2019/golang-1-13-from-dep-to-mod/&quot;&gt;golang 1.13 - 依赖管理从 dep 到 mod 踩坑&lt;/a&gt;》）。&lt;/p&gt;
&lt;p&gt;1.13 让原来的配置方式有了变化，撇开语言特性不谈，仅说和配置相关的，最大的变化，是 go module 的转正，和 GOPATH 和 vendor 的边缘化（1.13 仍然给你选择的余地，但是推荐选择 module，停用 GOPATH 和 vendor）。&lt;/p&gt;
&lt;p&gt;那么如果你从 1.13 之后才刚刚开始接触 go， 那么前面两篇文章对你来说并不友好。&lt;/p&gt;
&lt;p&gt;所以我找到了理由又水一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>S/L 大法 —— 平凡人的做事方法</title>
    <link href="https://jaycechant.info/2020/save-load-a-solution-for-ordinary-people/"/>
    <id>https://jaycechant.info/2020/save-load-a-solution-for-ordinary-people/</id>
    <published>2020-01-01T16:41:47.000Z</published>
    <updated>2020-01-02T15:38:01.467Z</updated>
    
    <content type="html"><![CDATA[<p>博客和公众号改名了，改成了同一个。</p>
<p>这事儿值得说一下。</p>
<a id="more"></a>
<h2 id="壹"><a href="#壹" class="headerlink" title="壹"></a>壹</h2><p>最早在网上写字儿，得从 06 年 QQ 空间算起。中二少年，为赋新词强说愁。</p>
<p>在其他少年努力花钱让 Q-ZONE 更炫时，我想办法让它不那么晃眼，别抢文字的风头。后来百度空间出来了，支持自定义样式（CSS）。不花钱，风格却有更大自由度，于是逐渐挪了过来。高中为此专门自学 CSS 。大学时的师兄据说因为我会 CSS 把我招进 团委网络部，又是一段经历；可惜后面一直做后端，基本再也没有做前端 。</p>
<p>然后专门开了一个新的百度空间叫『片言断章』放那段时间酸腐的 诗词，开了一个新浪博客写游戏，在辩论队搞了一个网易群博 …… 毕业前搞了一个 Octopress 。</p>
<p>然后微博来了，没那么多人写博客了；再往后是微信，然后公众号。潮流一波一波来了又走，每次都是狂欢；而我，别说写出个名堂，那点字数，对自己都没法交代。对了，后来我也开了公众号。</p>
<h2 id="贰"><a href="#贰" class="headerlink" title="贰"></a>贰</h2><p>Octopress 托管在 Github pages 上，后来生成工具换成了 Hexo （插一句，如果你现在弄的话，推荐 Hugo），绑了自己的域名 <a href="https://jaycechant.info">https://jaycechant.info</a> 。在主动关了 Q-ZONE，百度空间 服务被下线之后，这里是写字最多的地儿了。因为源码在自己手，别说 Github 很难关门，就算它关了 pages 服务，静态页面放哪不行，这儿写的东西，能一直留住。</p>
<p>这个内容最多的博客，叫 『Jayce 的技术博客』，直白得没有解释的需要。之所以这么叫，除了当初想名字时偷懒，可能还存在一点人设幻想，希望读者有清晰的主题预期，好吸引同好：这里 Geek 风写技术，那里文艺风写诗（彼时『片言断章』还在），这个语言活泼写游戏 …… 当然，事实证明想得太多，都是挖坑不填。</p>
<p>应该先尝试写好一个博客。如果有一天，某个主题的文章已经多到和原来的博客格格不入，让读者发生困扰了，这时还有余力，就可以考虑新开一个，相关主题都挪过去。文章没几篇，既没有形成自己的风格，也没有读者群体，瞎操心。过早优化 都是瞎折腾。</p>
<p>不过就算是专注于写技术，这名字也没提供任何信息量。</p>
<h2 id="叁"><a href="#叁" class="headerlink" title="叁"></a>叁</h2><p>公众号的名字叫 『JayceIO』。 Jayce 是我名字，IO 是 Input / Ouput ，原意是 『以知识的输出促进输入』。当然，也可以事后诸葛地说，IO 像 1 和 0 ，IO 是致敬 Google I/O 的 『Innovation in Open』（开放中创新）。</p>
<p>公众号上只有 6 篇文章，而且都是旧文，没有一篇是专为公众号写的；就这样，排版就费了老大的劲，在 10 天冲刺拿到了原创认证之后，就泄了气，一停更就是一年。</p>
<p>写得这么少，懒，时间管理又差，当然是首要原因，得认。公众号出于它自身的考虑，功能做了很多限制，也给新手制造了一些难度。</p>
<h2 id="肆"><a href="#肆" class="headerlink" title="肆"></a>肆</h2><p>如果早些年，发现自己这么不争气，大概会给自己定一系列目标，列个详细计划，自灌几碗鸡汤，打几针鸡血。短期内狂飙一波，然后无法坚持，慢慢松懈，甚至比原来更糟。不仅写博客这样，很多事情都是这样运动式反复 —— <strong>码字只是困境的一个缩影。</strong></p>
<p>这些年过去，开始跟自己和解，不再跟人性作对。不再简单地强迫自己，开始去思考：<strong>做这件事初衷是什么？ 为什么没能做下去？ 阻力来自外部还是内部？ 是内心不愿意，还是害怕些什么？</strong></p>
<p>问初衷，是看这件事在当下是否依然有价值。</p>
<p>阻力来自外部，那就想办法绕过它，降低它；绕不过，降不了，就跟价值比较一下，是否值得，是不是时机不对。</p>
<p>这些都相对容易理清。难测的是心魔。</p>
<p>如果潜意识不想做这件事，或者害怕些什么，靠鸡血也许可以勉力『坚持』着；但这种坚持，需要消耗额外的注意力，去不断提醒自己。时间已经够宝贵了，注意力则是比时间更宝贵的资源，人没办法一直保持清醒，而即使是清醒时也未必能一直保持专注。有一天你太累了，或者突如其来的意外打乱了计划，那脆弱的『坚持』就会不堪一击。</p>
<p>如果是喜欢做一件事，本身是不需要坚持的。想想那些在被窝里打灯看小说的日子，想想年少时半夜翻墙去游戏厅、去网吧。</p>
<h2 id="伍"><a href="#伍" class="headerlink" title="伍"></a>伍</h2><p>玩过单机游戏的大概会知道 S/L 大法。</p>
<p>S/L 是 Save &amp; Load 的缩写，就是存档 / 读档大法。在艰难的关卡、BOSS 之前存个档，如果输了或者结果不好，读档再来。甚至在一些随机事件之前存档，譬如一个抽奖事件，本来只有 1% 的机会可以得到最好的奖品，用了 S/L 之后，只要你愿意耗，理论上一定能拿到。有些游戏一个选择能影响后面很久远的结果，那就存很多个档，不覆盖旧档；发现选错了，总能读到一个做选择之前的。</p>
<p>做到这种程度，在游戏设计者眼里，大概算是作弊了（所以才会有些游戏只许存一个档，而且重要事件过后自动保存覆盖）。努力提升游玩水平，一口气通关的体验多好。如果不慎进了糟糕的剧情分支，那就重头再来嘛，设计者鼓励你多体验不同故事线。</p>
<p>可我游戏水平不高，又没有那么多时间一次次重头再来，只好用这种办法，尽量往希望体验的游戏结局靠拢。</p>
<h2 id="陆"><a href="#陆" class="headerlink" title="陆"></a>陆</h2><p>生活与游戏有相似的地方。</p>
<p>我当然希望自己是个天选之子（难道你不曾想过？）。我也说过『长大要当科学家』，也曾烦恼过将来长大了应该报清华还是北大。新手村太容易，让我以为可以 一命、无伤、全成就收集、满分 拿到 Best Ending 。</p>
<p>然而世界服从正态分布，大多数人都是普通人，很快就卡关了。这时偷瞄一下周围的人，却有人遥遥领先，甚至已经通关——还很轻松的样子。</p>
<p>你身边也总能找到这些人，他站在了你无法想像路径的悬崖峭壁之上。</p>
<p>不，我没有强调悬崖的高度，我强调的是险，是无路可达。再高的山，只要给了路线，给了阶梯，山顶就是可以想像的，无论是笨鸟先飞，还是愚公移山。可他好像省略了过程，直接出现在无路峭壁顶上。你会想， <strong>这种事情，我大概是做不来的。</strong> 我只会走，又不会飞。 <strong>大概是天赋的差异。</strong></p>
<h2 id="柒"><a href="#柒" class="headerlink" title="柒"></a>柒</h2><p>有些事情，我到了后来才慢慢懂得。</p>
<p>那些惊世的画作，看 X 光扫描，原来也是打了草稿，反复纠结，反复修改。</p>
<p>那些浑然天成，没有半分修改余地的句子，等到公布作者原稿，原来也是在你我都能买到的普通稿纸上，涂涂抹抹出来的。</p>
<p>那些功能无比强大的开源软件，如果你愿意翻看提交历史，原来也是这么一行一行改了又改，偶尔重写把某块推倒重来，从很可能只是原作者的一时兴起，变成了今天的庞然大物。</p>
<p>……</p>
<p><strong>他们从来就不是突然出现在崖顶。只是走过的路，他们反反复复试错的痕迹，被隐去了。</strong></p>
<p>大多数人无意隐藏这点，只是他们没有机会说起，你也没有机会问，没有近距离去看。</p>
<p>这是生活中的 S/L 大法。</p>
<h2 id="捌"><a href="#捌" class="headerlink" title="捌"></a>捌</h2><p><strong>Q: 写博客初衷是什么？</strong></p>
<p>A: <strong>记录</strong>。<br>后来可能逐渐冒出诸如 与人交流、博得名气 等等越来越不靠谱的想法。<br>但最初，只是想记录走过的路，给未来的自己，提供一个坐标。<br>这个出发点，现在仍然具有意义。（或者说，随着儿子的出生，更有意义了！）</p>
<p><strong>Q: 为什么没能写下去？阻力在外部还是内部？</strong></p>
<p>A: 初期遇到困难，容易归结为外因。譬如说工作忙，譬如说工具不好用。但当把这些外因都改善乃至解决掉之后，事情仍然僵持，我就知道原因不在外部，起码不是关键。</p>
<p><strong>Q: 内心在抗拒记录吗？还是在害怕什么？</strong></p>
<p>我不抗拒记录。在回顾过去的时候，还往往遗憾当时做的记录太少。<br>准确地说，我在焦虑。</p>
<p>我在害怕自己写得不够好。明明只是写给自己看的记录，却过早萌生了杂念。明明并没有什么读者，却总觉得有眼睛在看着我，有着作者的包袱。</p>
<h2 id="玖"><a href="#玖" class="headerlink" title="玖"></a>玖</h2><p>我是一个缺乏安全感的人，总是感觉只有这一次尝试机会，而我很可能会把事情搞砸。于是总是处在一种『做好万无一失准备』的状态中——仿佛只要不轻易地开始，就没有人可以宣布我失败。</p>
<p>具体到生活中，就会表现为 完美主义、强迫症、拖延症。出门前要数几次随身物品；在重要事件前很可能会失眠；会梦到人生中经历过的人生节点，然后在梦里把它搞砸了——最常见的是考试，醒来之后庆幸自己不用重新经历。</p>
<p>具体到码字上，明明还在写，却忍不住冒出想象中读者的评价，去打断作为作者的思路。害怕『半成品』展现在他人面前，害怕会因此自我降低标准，或者让大家觉得你水平不过如此；但另一方面，也不知道『成品』该是什么样子，如果成果一直漂浮不落地，就如同从来没有过成果，大家、以及未来的自己，也无从去判断，没有记录，也就没有了进步的基线（Baseline）。</p>
<p>公众号的规则（每天只能发一篇，发了之后不允许修改）强化了只有一次机会的恐惧。这也是为什么虽然还是很少， Github pages 还是有几十篇水文，而公众号发旧文勉强坚持到拿到原创认证就放弃了。</p>
<p><strong>码字不过是烦恼的一个缩影。</strong></p>
<p>从不开始确实躲开了失败——但机会有其时效，成功的可能也随之流逝。</p>
<p>我并非一开始就想明白这些，而是过去的十多年，经历了一些事情，发现自己有轻微的强迫症，而且很容易焦虑。<br>中间经历过各种与自己、与父母、与爱人的对话，有过冲突、不解、歇斯底里，从对抗、到尝试接纳、和解。其中滋味，不足为外人道，只道天凉好个秋。特别感谢一直陪伴我多年的女友——现在是妻子和孩子他妈，在最艰难的时候，都没有放弃过我。</p>
<h2 id="拾"><a href="#拾" class="headerlink" title="拾"></a>拾</h2><p>与其简单粗暴地当自己的暴君，下达永远不可能完成的 KPI，不如好好跟自己谈谈，对症下药。 </p>
<ul>
<li>尽量在固定时间抽空写一小段，先不要求多少，养成习惯。</li>
<li>用 Markdown 写原稿，用排版插件自动排版，不搞花里胡哨，不增加排版负担。</li>
<li>既然原稿是纯文本，版本控制必须有，写乱了甚至全删了都可以读档重来。</li>
<li>先发 Github pages 再转到公众号，给自己修订的机会。</li>
<li><strong>改名</strong>。</li>
</ul>
<p>既然害怕搞砸，与其跟自己对抗，不如在技术手段上让自己不会搞砸——起码不可能全部搞砸。S/L 大法任意折腾的资本，在于那个存档。感谢 git ，起码在电子文档上，给了我们 S/L 大法的利器。</p>
<p>技术上做到了，名字也很重要。<strong>名不正则言不顺，言不顺则事不成。</strong> 有句话说，命名是程序员最头疼的两件事之一（变量、函数、类 等等，都要命名）。我认为这不是一句玩笑——命名是概念模型的外在体现，命名不对，意味着还没想透彻。</p>
<p>我花了一些时间梳理想法，也和朋友讨论过。一开始想就叫 『S/L 大法』，但是在很多地方，斜杠都是一个麻烦。最后定了现在的名字 『存档 Save &amp; Load』。</p>
<ul>
<li><p>首先明确了博客的性质， <strong>这是我的一份存档</strong> ，是回头看时的路标。不再以内容区分。无论是技术上的记录，让我不用解决重复的问题；还是生活记录和感悟，让我日后记得。在存档的意义上，并无差别。</p>
</li>
<li><p>其次用博客名提醒自己， <strong>做事有存档，搞砸了不过回到上一个存档</strong> ，不是清零重来，不必焦虑。</p>
</li>
<li><p>第三层意思，是希望以此为契机，摸索出一套易于遵循的做事方法，让像我这样资质平庸而又焦虑的人，减轻注意力负担——包括但不限于码字和写代码——姑且称之为『S/L 法』。以目前我的理解，可能会以纯文本文档记录 + 版本控制 作为技术基础，日后可以尝试梳理这方面的内容。</p>
</li>
</ul>
<p>既然我在这个问题上纠结过思考过， <strong>以蚌之痛，育彼珍珠</strong> ，能结出一些成果当然最好。 不过第三点只是一个延伸，是更长远的事情，留个可能性，不强求。没什么野心，不要想太多，单纯的记录，反而更有可能做好。</p>
<p>希望以博客为起点，我能在做不同的事情上，掌握（各种意义上）存档的技巧，出错了读档重来。时间和注意力放在『新关卡』的尝试上，胜过耗在对清零的恐惧上。既然时间不多，能前进一点是一点。</p>
<hr>
<p>P.S. 此文发端于 2019 年 3 月 5 日博客改名前，结果后面因为 赶项目、娃早产、家里装修，一直拖到现在。如果你读完了，你会知道，我并不责备自己，而是感激自己还能继续写完——用正面情绪激励，而非用负面情绪惩罚。我并非思路清晰了，才开始落笔；恰恰是行文至此，思路才算逐渐清晰，后续不排除继续修改，或另起一文。</p>
<p>P.S. 2 再次感谢我的爱人一直以来的理解和陪伴。她其实是个容易不耐烦的暴脾气，正因如此，在那些艰难时刻超乎寻常人的耐心，显得更加难能可贵。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-禁止演绎” 4.0 (CC BY-NC-ND 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-禁止演绎” 4.0 (CC BY-NC-ND 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，原文引用（不可发布基于本作品的二次创作），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客和公众号改名了，改成了同一个。&lt;/p&gt;
&lt;p&gt;这事儿值得说一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="https://jaycechant.info/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>golang 1.13 - 依赖管理从 dep 到 mod 踩坑</title>
    <link href="https://jaycechant.info/2019/golang-1-13-from-dep-to-mod/"/>
    <id>https://jaycechant.info/2019/golang-1-13-from-dep-to-mod/</id>
    <published>2019-10-16T16:37:07.000Z</published>
    <updated>2020-01-07T16:47:44.091Z</updated>
    
    <content type="html"><![CDATA[<p>接触 golang 很晚，实际用来开发大概在 1.9 左右，所以我的主要印象是在 1.9 、 1.10 上的，依赖管理经过一些尝试之后，选择了 『官方』（后来实际被抛弃了）的 dep（<a href="https://jaycechant.info/2018/glide-from-start-up-to-give-up/">《golang 依赖管理：glide 从入门到放弃》</a>）。<br><!-- https://mp.weixin.qq.com/s/dWDfu_9sV5WSkF9h27E4uA --></p>
<p>后来 1.11、1.12 推出了 module （亦即 go mod 命令），考虑到尚不稳定又有切换成本，就继续留守在 vendor 目录上。</p>
<p>2019 年 9月终于 1.13 出来了，做了几个比较大的改动，同时 module 也终于转正，所以我终于下定决心迁移到 1.13，并改用 mod 做依赖管理。</p>
<a id="more"></a>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>迁移过程主要参考了<a href="https://mp.weixin.qq.com/s/AsdCDodxZFxs2SkhSwOvpg" target="_blank" rel="external">《干货满满的 Go Modules 和 goproxy.cn》</a>（实操主要是 <strong>#快速迁移项目至 Go Modules</strong> 部分），讲得非常清楚，也推荐大家参考，一些细节就不再赘述，只强调我踩坑的地方。</p>
<p>简单来说是这么个过程：</p>
<ul>
<li><p>卸载原有的 go，并下载安装 1.13 版本。  </p>
<p>  官网 golang.org 因为是谷歌的服务器，也在屏蔽之列，部分同学可能连访问这个都有困难，其实国内有官方的镜像站 golang.google.cn 。</p>
</li>
<li><p>用 <code>go env -w</code> 重新设置你的环境变量 。  </p>
<p>  注意 go env 的内容保存在 <code>$HOME/.config/go/env</code> ，不会覆盖原来的系统环境变量。在读取环境变量时， go env 的值优先。为了避免后续增加判断环境变量的负担，建议 go env 里有的、只有 go 会读取的环境变量，在系统环境变量里删除。  </p>
<p>  因为国情特殊，一定要设置 GOPROXY。</p>
</li>
<li><p>针对依赖工具和项目情况迁移（以下主要讲这部分的坑）。因为我之前用的是 dep，下面全部是关于从 dep 的迁移。</p>
</li>
</ul>
<p>特别提一下一个细节，在安装好的 1.13 下获取 <code>mod</code> 子命令的帮助，下面有一段提醒：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;go <span class="built_in">help</span> mod</div><div class="line">Go mod provides access to operations on modules.</div><div class="line"></div><div class="line">Note that support <span class="keyword">for</span> modules is built into all the go commands,</div><div class="line">not just <span class="string">'go mod'</span>. For example, day-to-day adding, removing, upgrading,</div><div class="line">and downgrading of dependencies should be <span class="keyword">done</span> using <span class="string">'go get'</span>.</div><div class="line">See <span class="string">'go help modules'</span> <span class="keyword">for</span> an overview of module functionality.</div></pre></td></tr></table></figure>
<p>大意渣翻：</p>
<blockquote>
<p>注意对 modules 的支持已经内建在所有 go 子命令内，而不仅仅是 ‘go mod’ 。</p>
<p>举例说，每天添加、移除、升级、降级依赖，都应该使用 ‘go get’ 完成。</p>
</blockquote>
<p>也就是说所有跟依赖管理相关的命令，譬如 <code>go get</code> ，都是用新逻辑在处理。</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="坑01：GOPROXY-特定情况不起效"><a href="#坑01：GOPROXY-特定情况不起效" class="headerlink" title="坑01：GOPROXY 特定情况不起效"></a>坑01：GOPROXY 特定情况不起效</h3><p>本来直接在项目根目录敲 <code>go mod init &lt;mod_path&gt;</code> ，是可以自动从 <code>Gopkg.toml</code> 和 <code>Gopkg.lock</code> 导入依赖信息，自动完成迁移的。但是在国内直接这样做是会出错的，部分包获取超时（留意 <code>golang.org/x/</code> 开头的包）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;go mod init myapp</div><div class="line">go: creating new go.mod: module myapp</div><div class="line">go: copying requirements from Gopkg.lock</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> github.com/360EntSecGroup-Skylar/excelize@v2.0.0: github.com/360EntSecGroup-Skylar/excelize@v2.0.0: invalid version: module contains a go.mod file, so major version must be compatible: should be v0 or v1, not v2</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> golang.org/x/text@v0.3.0: unrecognized import path <span class="string">"golang.org/x/text"</span> (https fetch: Get https://golang.org/x/text?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time,</div><div class="line">or established connection failed because connected host has failed to respond.)</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> gopkg.in/russross/blackfriday.v2@d3b5b032dc8e8927d31a5071b56e14c89f045135: gopkg.in/russross/blackfriday.v2@v2.0.1: invalid version: go.mod has non-....v2 module path <span class="string">"github.com/russross/blackfriday/v2"</span> at revision v2.0.1</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> golang.org/x/net@9b4f9f5ad5197c79fd623a3638e70d8b26cef344: unrecognized import path <span class="string">"golang.org/x/net"</span> (https fetch: Get https://golang.org/x/net?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.)</div><div class="line">go: converting Gopkg.lock: <span class="built_in">stat</span> golang.org/x/image@61b8692d9a5c9886248d7f96e0ba50ad77baab4c: unrecog</div><div class="line">nized import path <span class="string">"golang.org/x/image"</span> (https fetch: Get https://golang.org/x/image?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.)</div></pre></td></tr></table></figure>
<p>这其实是一个 bug，init 导入依赖部分没有引用 GOPROXY。已经有人向官方提交了 issue，只是修复不知道要等到哪个版本合入。当前可以创建一个空白的 <code>go.mod</code> 然后执行 <code>go mod tidy</code> 来绕过。</p>
<p>go.mod 只需要包含 module path 和 go 版本即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module myapp</div><div class="line"></div><div class="line">go 1.13</div></pre></td></tr></table></figure>
<h3 id="坑02：import-和-module-path-不一致"><a href="#坑02：import-和-module-path-不一致" class="headerlink" title="坑02：import 和 module path 不一致"></a>坑02：import 和 module path 不一致</h3><p>增加了 go.mod 之后，执行 <code>go mod tidy</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;go mod tidy</div><div class="line">go: finding github.com/mojocn/base64Captcha latest</div><div class="line">......</div><div class="line">go: myapp/model/data imports</div><div class="line">        github.com/go-xorm/core: github.com/go-xorm/core@v0.6.3: parsing go.mod:</div><div class="line">        module declares its path as: xorm.io/core</div><div class="line">                but was required as: github.com/go-xorm/core</div></pre></td></tr></table></figure>
<p>这个好解决，把项目里对这个 module 的引用，都指向它声明的路径即可。</p>
<p>下面梳理一下出错的原因：</p>
<p><code>xorm.io/core</code> 这个 module，同时在 github.com 和 xorm.io 都有提供访问。</p>
<p>在使用 dep 的时候，从哪个路径 import，都是可行的。当我从 <code>github.com/go-xorm/core</code> import 时，dep 就从 github 下载，并保存到 <code>vendor/github.com/go-xorm/core</code> 下。到编译的时候，到 vendor 下对应的路径去找。也就是无论选哪个，<strong>下载、保存、import 的路径，三者是对应的就行</strong>。</p>
<p>但是 mod 会读取 module 的 go.mod，它自称是 <code>xorm.io/core</code> ，那么从 github import 就是非法的。也就是现在要 <strong>加上跟 module 自身 go.mod 声明的路径一致</strong>。（当然，现在保存不在 vendor 目录了，而是在 <code>$HOME/go/pkg/mod/</code> 底下，从原来每个项目存一份，变成每个 module 的每个版本，全局只存一份。）</p>
<p>退一步讲，如果将来 xorm.io 因为某些原因不再提供访问，而 github 那份还在，可以在 go.mod 通过 replace 关键字将下载地址指向 github，但其余的路径，依然要跟声明的路径保持一致（主要是 import 路径，下载保存是自动的，并不需要人工干预）。</p>
<h3 id="坑03：最新版本-module-不兼容"><a href="#坑03：最新版本-module-不兼容" class="headerlink" title="坑03：最新版本 module 不兼容"></a>坑03：最新版本 module 不兼容</h3><p>好了，依赖的分析和获取终于不报错了，<code>go.mod</code> 和 <code>go.sum</code> 也成功生成了。接下来让我们编译一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;make build</div><div class="line">go build -ldflags <span class="string">'-s -w'</span></div><div class="line">go: finding gopkg.in/yaml.v2 v2.2.2</div><div class="line">// 省略若干行...</div><div class="line"><span class="comment"># myapp/model/data</span></div><div class="line">model\data\csv.go:59:6: xng.QuoteStr undefined (<span class="built_in">type</span> *xorm.Engine has no field or method QuoteStr)</div><div class="line">model\data\csv.go:61:6: xng.QuoteStr undefined (<span class="built_in">type</span> *xorm.Engine has no field or method QuoteStr)</div><div class="line">make: *** [Makefile:28: build] Error 2</div></pre></td></tr></table></figure>
<p><code>Engine.QuoteStr()</code> 是一个返回当前数据库引擎使用的引号的方法，我当时特意使用这个方法，用来同时兼容不同的数据库，避免额外的判断。所以我确定这个方法是存在的。</p>
<p>这很容易想到是版本兼容性的问题。查看 <code>go.mod</code> 里的是 v0.7.9，再翻看 <code>Gopkg.toml</code> 之前用的是 v.0.7.1 。坑爹的是，新版本居然删掉了这个方法。</p>
<p>这里稍微提一下 <strong>版本号的问题</strong> 。go mod 强制使用 SemVer（如果不知道什么是 SemVer，看这篇 <a href="https://semver.org/lang/zh-CN/" target="_blank" rel="external">语义化版本 2.0</a>），默认大版本没有改动的话，一定是兼容修改。所以会自动获取当前大版本下最新的版本，并不会参考 <code>Gopkg.toml</code> 的版本。不过话说回来， 即使按照 SemVer 的语义，也没办法埋怨 xorm 的团队，1.0 之前的版本默认为不稳定版本，没有义务保持兼容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;go mod edit -require=github.com/go-xorm/xorm@v0.7.1</div></pre></td></tr></table></figure>
<p>这样就可以指定依赖的版本。如果你觉得敲命令太麻烦，直接手动改 go.mod 也可以。一般不推荐直接改，因为你的修改会在下次更新时被覆盖，唯独版本信息是会保留的。</p>
<p>改完再 tidy 一次。</p>
<h3 id="坑04：module-path-不统一"><a href="#坑04：module-path-不统一" class="headerlink" title="坑04：module path 不统一"></a>坑04：module path 不统一</h3><p>再编译一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;make build</div><div class="line">go build -ldflags <span class="string">'-s -w'</span></div><div class="line">go: finding github.com/go-xorm/xorm v0.7.1</div><div class="line">// 省略若干行...</div><div class="line"><span class="comment"># myapp/model/data</span></div><div class="line">model\data\engine.go:117:17: cannot use level (<span class="built_in">type</span> <span class="string">"xorm.io/core"</span>.LogLevel) as <span class="built_in">type</span> <span class="string">"github.com/go-</span></div><div class="line">xorm/core".LogLevel <span class="keyword">in</span> argument to xng.SetLogLevel</div><div class="line">make: *** [Makefile:28: build] Error 2</div></pre></td></tr></table></figure>
<p>还是 xorm 的错误。还记得我们在 坑02 中的修改吗，在 go mod 底下，要统一按照声明路径去 import。</p>
<p>因为 坑03 ，xorm 改回了跟我代码兼容的 v0.7.1 ，那与之关联的 core 呢？跟上面类似地，看前后的配置，之前用的 v0.6.0 ，现在的是 v0.7.2 。<strong>关键的一点是</strong>，在 2019 年 6 月，在这两个版本之间的 v0.6.3，module path 从 <code>github.com/go-xorm/core</code> 改成了 <code>xorm.io/core</code> ， xorm 对它的引用在那个时间也做了相应的修改。</p>
<p>为了跟 v0.7.1 的 xorm 兼容，必须使用 &lt; v0.6.3 的 core —— 实际上直接使用 v0.6.0 是最保险的。因为回退到了修改 module path 之前的版本，所以 坑02 的修改白改了，回退掉。</p>
<p>当然记录 坑02 仍然有意义，它提醒我 <strong>有时声明的 module path 未必和仓库地址一致</strong> 。</p>
<p>跟上面类似，core 包改回对应的 v0.6.0 ，重新 tidy。</p>
<h3 id="坑05：主版本号变更"><a href="#坑05：主版本号变更" class="headerlink" title="坑05：主版本号变更"></a>坑05：主版本号变更</h3><p>再一次编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;make build</div><div class="line">go build -ldflags <span class="string">'-s -w'</span></div><div class="line"><span class="comment"># myapp/api</span></div><div class="line">api\survey.go:189:9: assignment mismatch: 2 variables but ex.GetCellValue returns 1 values</div><div class="line">// 省略若干相似的错误...</div><div class="line">api\survey.go:216:9: too many errors</div><div class="line">make: *** [Makefile:28: build] Error 2</div></pre></td></tr></table></figure>
<p>依然是版本的兼容问题。</p>
<p>不过这次的错误跟前面的比，是反过来的：我的代码引用的是最新的 v2 代码，这在原来 dep 下是不需要区分包名的。但在 mod 里，大于 1 的大版本是需要体现在路径里的。</p>
<p>在 module 眼里，<strong>主版本号不同，相当于两个不同的 module</strong>。 这是因为根据 SemVer 的约定，大版本号的改变，意味着引入了 breaking changes。那么如果很不巧地，代码 直接 / 间接 依赖同一个包的不同大版本时，mod 是可以同时导入的，就不会存在依赖上的冲突。</p>
<p>把 import 里 <code>github.com/360EntSecGroup-Skylar/excelize</code> 改为 <code>github.com/360EntSecGroup-Skylar/excelize/v2</code> ，重新 tidy，这次编译就不再报错了，编译的结果也是可以正常运行的。到此，我踩的坑已经全部记录完毕。</p>
<p>临了 Mark 一篇文章 <a href="https://www.cnblogs.com/apocelipes/p/10295096.html" target="_blank" rel="external">《再探go modules：使用与细节》</a>。这篇文章对于 go mod 的一些细节做了分析，虽然发表于 1.12 发布前，但是现在来看仍然有效。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触 golang 很晚，实际用来开发大概在 1.9 左右，所以我的主要印象是在 1.9 、 1.10 上的，依赖管理经过一些尝试之后，选择了 『官方』（后来实际被抛弃了）的 dep（&lt;a href=&quot;https://jaycechant.info/2018/glide-from-start-up-to-give-up/&quot;&gt;《golang 依赖管理：glide 从入门到放弃》&lt;/a&gt;）。&lt;br&gt;&lt;!-- https://mp.weixin.qq.com/s/dWDfu_9sV5WSkF9h27E4uA --&gt;&lt;/p&gt;
&lt;p&gt;后来 1.11、1.12 推出了 module （亦即 go mod 命令），考虑到尚不稳定又有切换成本，就继续留守在 vendor 目录上。&lt;/p&gt;
&lt;p&gt;2019 年 9月终于 1.13 出来了，做了几个比较大的改动，同时 module 也终于转正，所以我终于下定决心迁移到 1.13，并改用 mod 做依赖管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 预置 json 包的值覆盖测试</title>
    <link href="https://jaycechant.info/2019/golang-json-overlaying/"/>
    <id>https://jaycechant.info/2019/golang-json-overlaying/</id>
    <published>2019-05-19T16:45:38.000Z</published>
    <updated>2019-05-20T16:02:48.506Z</updated>
    
    <content type="html"><![CDATA[<p>json 作为一种可读性高、跨平台的序列化手段，常用在持久化和网络间传输。一般情况下，只需考虑是否按照作者的意图序列化和反序列化；反序列化的目标一般是一个 <strong>空白的对象</strong>，供写入得到的值。</p>
<p>但有一些特殊情况，还要考虑反序列化过程中，值的覆盖性：用到的字段非常多，给每个都赋值很麻烦，所以提供一套默认值（注意默认值不一定是 0 值），只要 json 中没有指定，就转而使用默认值。这在 jQuery 中只需要使用 <code>$.extend(default, opts1, opts2...)</code>；而如果想递归合并，则只需要把 <code>true</code> 作为第一个参数。</p>
<a id="more"></a>
<p>这一般出现在用 json 写配置文件，还有传递运行参数时，要求调用方即使默认值也要写上非常麻烦；而通过检测读到的是否 0 值再设置默认值则更麻烦，而且不合理（因为没法区分缺省值还是设置值，在 go 中除非全部使用指针）。所以，如果可以以初始化了默认值的对象作为反序列化的目标，将 json 中有指定的值覆盖上去，就是最好的选择。</p>
<p>json 在 go 中只是字符串，不像在 js 中有原生身份可以直接合并，所以在 Unmarshal 时能顺便进行覆盖是最好的了。前面我做了一些简单的测试，发现在 go 中这个思路可行，所以就这样实现了；但随着实现深入，特别是我为调用方编写文档时，我才意识到准确的覆盖对应的值，并不简单。（指定的值有覆盖，不指定的值保留默认，slice 和 map 的 value 可以准确覆盖到正确的 index / key）</p>
<p>话不多说，直接先跑，然后看输出结合源码分析：</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"encoding/json"</span></div><div class="line">    <span class="comment">//json "github.com/json-iterator/go"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Inner <span class="keyword">struct</span> &#123;</div><div class="line">    A <span class="keyword">int</span></div><div class="line">    B <span class="keyword">float64</span></div><div class="line">    C <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Mid <span class="keyword">struct</span> &#123;</div><div class="line">    I  Inner</div><div class="line">    Ip *Inner</div><div class="line">    D  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Outer <span class="keyword">struct</span> &#123;</div><div class="line">    Inner</div><div class="line">    M    Mid</div><div class="line">    Mp   *Mid</div><div class="line">    Mids <span class="keyword">map</span>[<span class="keyword">int</span>]*Mid</div><div class="line">    Ins []*Inner</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    o := &amp;Outer &#123;</div><div class="line">        Inner: Inner &#123;</div><div class="line">            A: <span class="number">111</span>, <span class="comment">// 按同名 field 覆盖，不影响其他 field</span></div><div class="line">            B: <span class="number">222.22</span>,</div><div class="line">            C: <span class="literal">true</span>,</div><div class="line">        &#125;,</div><div class="line">        M: Mid &#123;</div><div class="line">            I: Inner &#123;</div><div class="line">                A: <span class="number">111</span>, <span class="comment">// 嵌套的 struct 也是按 field 覆盖</span></div><div class="line">                C: <span class="literal">true</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        Mp: &amp;Mid &#123;</div><div class="line">            I: Inner &#123;</div><div class="line">                A: <span class="number">111</span>, <span class="comment">// 指针指向的 struct 内部 field 同理</span></div><div class="line">                C: <span class="literal">true</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        Mids: <span class="keyword">map</span>[<span class="keyword">int</span>]*Mid &#123;</div><div class="line">            <span class="number">0</span>: &amp;Mid&#123; <span class="comment">// map elem 被整体覆盖</span></div><div class="line">                I: Inner &#123;</div><div class="line">                    C: <span class="literal">true</span>, <span class="comment">// 被覆盖为默认值</span></div><div class="line">                &#125;,</div><div class="line">                Ip: &amp;Inner &#123;</div><div class="line">                    B: <span class="number">333</span>, <span class="comment">// 被覆盖为默认值</span></div><div class="line">                &#125;,</div><div class="line">                D: <span class="number">444</span>, <span class="comment">// 被覆盖为默认值</span></div><div class="line">            &#125;,</div><div class="line">            <span class="number">1</span>: &amp;Mid&#123; <span class="comment">// 但是不影响 map 的其他 elem，值被完整保留</span></div><div class="line">                I: Inner &#123;</div><div class="line">                    A: <span class="number">555</span>,</div><div class="line">                &#125;,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        Ins: []*Inner &#123;</div><div class="line">            &amp;Inner &#123; <span class="comment">// slice elem 内部被按 field 覆盖</span></div><div class="line">                A: <span class="number">666</span>,</div><div class="line">                B: <span class="number">77.7</span>,</div><div class="line">            &#125;,</div><div class="line">            &amp;Inner &#123; <span class="comment">// 同上</span></div><div class="line">                A: <span class="number">888</span>,</div><div class="line">                B: <span class="number">99.9</span>,</div><div class="line">            &#125;,</div><div class="line">            &amp;Inner &#123; <span class="comment">// 但其他 elem 反而丢失了</span></div><div class="line">                A: <span class="number">1010</span>,</div><div class="line">                B: <span class="number">11.11</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">    b, _ := json.Marshal(o)</div><div class="line">    fmt.Println(<span class="string">"baseline:"</span>, <span class="keyword">string</span>(b))</div><div class="line">    </div><div class="line">    bv := []<span class="keyword">byte</span>(<span class="string">`</span></div><div class="line">&#123;</div><div class="line">    "A": 123,</div><div class="line">    "M": &#123;</div><div class="line">        "I": &#123;</div><div class="line">            "B": 222</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    "Mp": &#123;</div><div class="line">        "I": &#123;</div><div class="line">            "B": 222</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    "Mids": &#123;</div><div class="line">        "0": &#123;</div><div class="line">            "I": &#123;</div><div class="line">                "A": 234</div><div class="line">            &#125;,</div><div class="line">            "Ip": &#123;</div><div class="line">                "A": 777</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    "Ins": [</div><div class="line">        &#123;</div><div class="line">            "A": 456</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            "B": 765</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">`)</div><div class="line">    json.Unmarshal(bv, o)</div><div class="line">    b, _ = json.Marshal(o)</div><div class="line">    fmt.Println(<span class="string">"overlay:"</span>, <span class="keyword">string</span>(b))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<p>（重点看在 json string 里没有指定的值是否会被覆盖，以及 slice 、map 里其他成员的情况。为了更方便地看，我把对比的结果用注释写在了测试代码里。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">baseline: &#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:333,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:444&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:666,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:99.9,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:1010,<span class="string">"B"</span>:11.11,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div><div class="line">overlay: &#123;<span class="string">"A"</span>:123,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:234,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:777,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:0&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:456,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:765,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<h3 id="结合源码分析"><a href="#结合源码分析" class="headerlink" title="结合源码分析"></a>结合源码分析</h3><p>下面结合 <code>encoding/json/decode.go</code> 的源码，大概梳理一下结论：</p>
<h4 id="1-struct-内的基本类型-field"><a href="#1-struct-内的基本类型-field" class="headerlink" title="1. struct 内的基本类型 field"></a>1. struct 内的基本类型 field</h4><p>（struct 对应 json 中的 object，以 {} 包裹；基本类型对应 json 中的 字面量 literal，内容是一个数字或者字符串）</p>
<p>值按同名覆盖，没有指定的的 field 保留原值；这条即使是 嵌套的 struct 内部的 field 也成立，包括匿名嵌套，还有指针指向的 struct 的 field。</p>
<h4 id="2-slice-类型"><a href="#2-slice-类型" class="headerlink" title="2. slice 类型"></a>2. slice 类型</h4><p>（对应 json 中的 array，以 [] 包裹）</p>
<p>slice elem 按 index 一一对应， struct 内部 field 同规则 1；但是 slice 会调整长度跟 json 保持一致： json 多出的会添加，反之原 slice 多出的会因为长度调整被丢弃。从源码看，如果是 array，因为长度无法调整，json 数量比较少的话不会丢弃原 array 的内容；反之 json 多出的内容会被丢弃。不过很少使用 array，没有实际测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// array consumes an array from d.data[d.off-1:], decoding into the value v.</span></div><div class="line"><span class="comment">// the first byte of the array ('[') has been read already.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decodeState)</span> <span class="title">array</span><span class="params">(v reflect.Value)</span></span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">		<span class="comment">// Get element of array, growing if necessary.</span></div><div class="line">		<span class="keyword">if</span> v.Kind() == reflect.Slice &#123;</div><div class="line">			<span class="comment">// Grow slice if necessary</span></div><div class="line">			<span class="keyword">if</span> i &gt;= v.Cap() &#123;</div><div class="line">				newcap := v.Cap() + v.Cap()/<span class="number">2</span></div><div class="line">				<span class="keyword">if</span> newcap &lt; <span class="number">4</span> &#123;</div><div class="line">					newcap = <span class="number">4</span></div><div class="line">				&#125;</div><div class="line">				newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)</div><div class="line">				reflect.Copy(newv, v)</div><div class="line">				v.Set(newv)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> i &gt;= v.Len() &#123;</div><div class="line">				v.SetLen(i + <span class="number">1</span>)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> i &lt; v.Len() &#123;</div><div class="line">			<span class="comment">// Decode into element.</span></div><div class="line">			d.value(v.Index(i))</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// Ran out of fixed array: skip.</span></div><div class="line">			d.value(reflect.Value&#123;&#125;)</div><div class="line">		&#125;</div><div class="line">		i++</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<h4 id="3-map-类型"><a href="#3-map-类型" class="headerlink" title="3. map 类型"></a>3. map 类型</h4><p>（对应 json 中的 object，以 {} 包裹）</p>
<p>json 中指定的 key 会整个 elem 被覆盖；没有指定的 key 则完整保留。</p>
<p>其中最主要的差别是 struct filed 和 map elem 之间：虽然在 json 中同样以 object 表示，但 struct 设置时，获得的是 field 的 pointer，如果 field 本身也是一个 struct，那么就会递归处理，一直到最里层的基本类型才被覆盖；而 map elem 是直接覆盖， <strong>如果这个 map elem 本身是一个 struct，那么它原有的数据就会丢失</strong> 。</p>
<p>由于 map 和 struct 都对应 object，所以它们的代码是在一起的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// object consumes an object from d.data[d.off-1:], decoding into the value v.</span></div><div class="line"><span class="comment">// the first byte ('&#123;') of the object has been read already.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *decodeState)</span> <span class="title">object</span><span class="params">(v reflect.Value)</span></span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">var</span> mapElem reflect.Value</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// Figure out field corresponding to key.</span></div><div class="line">		<span class="keyword">var</span> subv reflect.Value</div><div class="line">		destring := <span class="literal">false</span> <span class="comment">// whether the value is wrapped in a string to be decoded first</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> v.Kind() == reflect.Map &#123;</div><div class="line">			elemType := v.Type().Elem()</div><div class="line">			<span class="keyword">if</span> !mapElem.IsValid() &#123;</div><div class="line">				mapElem = reflect.New(elemType).Elem()</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				mapElem.Set(reflect.Zero(elemType))</div><div class="line">			&#125;</div><div class="line">            <span class="comment">// 如果是 map，subv 指向一个新初始化的 elem</span></div><div class="line">			subv = mapElem</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            subv = v</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// 如果是 struct，则得到对应 field 的指针</span></div><div class="line">            subv = subv.Field(i)</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// 解析下一层并把内容放到 subv，如果是 map，subv 指向一个空白的对象</span></div><div class="line">        &#123;</div><div class="line">            d.value(subv)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Write value back to map;</span></div><div class="line">		<span class="comment">// if using struct, subv points into struct already.</span></div><div class="line">		<span class="keyword">if</span> v.Kind() == reflect.Map &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            <span class="comment">// 把 subv 设置到对应的 key，该 key 对应的原有的数据全部丢失</span></div><div class="line">            <span class="comment">// struct 没有这步，因为 subv 直接就是指向 field 的指针</span></div><div class="line">            v.SetMapIndex(kv, subv)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>为什么 slice 可以直接 <code>d.value(v.Index(i))</code> 把对应的 elem 递归交给下一层去合并， 而 map 却不能直接 <code>d.value(v.MapIndex(key))</code> ，而是在这一层直接把 elem 给覆盖掉了？ 是因为什么原因做不到，还是出于什么考虑不这样实现？时间关系，我还没找到答案，这里先留一个问号。</p>
<h3 id="初步结论"><a href="#初步结论" class="headerlink" title="初步结论"></a>初步结论</h3><p>为了达到『指定值覆盖，缺省值保留』的效果：</p>
<ul>
<li>如果需要嵌套 struct，内层 struct 最好作为一个 field 存在，指针还是对象都可以；</li>
<li>如果是一组确定数量的 struct，最好以 array 的方式定义，并且确保 index 正确；缺省的 struct 传参时可以用空 objecct <code>{}</code> 占位以确保顺序对应；</li>
<li>如果是一组数量不确定的 struct，则要权衡 slice 和 map 的利弊：<ul>
<li>slice 内的 struct 可以正常合并，但是 slice 比 json 多出的 elem 会被丢弃；如果 json 的数量比默认数量少，则不仅中间的缺省 struct 要用 <code>{}</code> 占位，后续缺省的 struct 也得占位——这需要默认值的数量是确定的；</li>
<li>map 刚好反过来，没有指定的 key 也不会被删除，但是指定了的 key 对应的 value 是直接覆盖，不能合并。</li>
</ul>
</li>
</ul>
<h3 id="流行的第三方库：jsoniter"><a href="#流行的第三方库：jsoniter" class="headerlink" title="流行的第三方库：jsoniter"></a>流行的第三方库：jsoniter</h3><p>再看当下比较流行的第三方库 jsoniter 。同样的代码，只是单纯的把 <code>&quot;encoding/json&quot;</code> 换成 <code>json &quot;github.com/json-iterator/go&quot;</code> ，再看结果，是完全一样的，说明在覆盖性的兼容上，jsoniter 是兼容官方库的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">baseline: &#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:0,<span class="string">"B"</span>:333,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:444&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:666,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:99.9,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:1010,<span class="string">"B"</span>:11.11,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div><div class="line">overlay: &#123;<span class="string">"A"</span>:123,<span class="string">"B"</span>:222.22,<span class="string">"C"</span>:<span class="literal">true</span>,<span class="string">"M"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mp"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:111,<span class="string">"B"</span>:222,<span class="string">"C"</span>:<span class="literal">true</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;,<span class="string">"Mids"</span>:&#123;<span class="string">"0"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:234,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:&#123;<span class="string">"A"</span>:777,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"D"</span>:0&#125;,<span class="string">"1"</span>:&#123;<span class="string">"I"</span>:&#123;<span class="string">"A"</span>:555,<span class="string">"B"</span>:0,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,<span class="string">"Ip"</span>:null,<span class="string">"D"</span>:0&#125;&#125;,<span class="string">"Ins"</span>:[&#123;<span class="string">"A"</span>:456,<span class="string">"B"</span>:77.7,<span class="string">"C"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"A"</span>:888,<span class="string">"B"</span>:765,<span class="string">"C"</span>:<span class="literal">false</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>详情请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">协议</a>具体内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;json 作为一种可读性高、跨平台的序列化手段，常用在持久化和网络间传输。一般情况下，只需考虑是否按照作者的意图序列化和反序列化；反序列化的目标一般是一个 &lt;strong&gt;空白的对象&lt;/strong&gt;，供写入得到的值。&lt;/p&gt;
&lt;p&gt;但有一些特殊情况，还要考虑反序列化过程中，值的覆盖性：用到的字段非常多，给每个都赋值很麻烦，所以提供一套默认值（注意默认值不一定是 0 值），只要 json 中没有指定，就转而使用默认值。这在 jQuery 中只需要使用 &lt;code&gt;$.extend(default, opts1, opts2...)&lt;/code&gt;；而如果想递归合并，则只需要把 &lt;code&gt;true&lt;/code&gt; 作为第一个参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
      <category term="json" scheme="https://jaycechant.info/tags/json/"/>
    
  </entry>
  
</feed>
