<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>存档Save&amp;Load</title>
  <subtitle>存档意味着放下包袱，搞砸了不过回来读档</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jaycechant.info/"/>
  <updated>2020-10-05T16:37:15.491Z</updated>
  <id>https://jaycechant.info/</id>
  
  <author>
    <name>Jayce Sigit Chant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>价值十亿美元的 Go 语言错误（翻译）</title>
    <link href="https://jaycechant.info/2020/translation-billion-dollar-mistake-in-go/"/>
    <id>https://jaycechant.info/2020/translation-billion-dollar-mistake-in-go/</id>
    <published>2020-10-01T15:52:05.000Z</published>
    <updated>2020-10-05T16:37:15.491Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<strong>Billion-Dollar Mistake in Go ?</strong></p>
<p>地址：<a href="https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc" target="_blank" rel="external">https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc</a></p>
<p>作者：<strong>Harri Lainio</strong>（<a href="https://hackernoon.com/u/lainio" target="_blank" rel="external">@lainio</a>）</p>
<p>翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）</p>
<a id="more"></a>
<blockquote>
<p>十亿美元（billion dollar）的错误 / bug 貌似是美国的一个梗，大概的意思是，对于那些市值上几千亿的大企业，如果一个错误能够导致市值下跌个百分之零点几，就已经是十亿左右了。</p>
<p>在计算机领域，最著名的 BDM 大概是 图灵奖得主Tony Hoare 说他在 1965 年发明的 null 引用。</p>
<p>但我不确定这是不是最早的出处，毕竟在商业领域这样的说法也很常见。</p>
</blockquote>
<p>以下为译文：</p>
<hr>
<p><img src="../images/billion-dollar-mistake.png" alt=""></p>
<p>以下示例代码来自 Go 的 <a href="https://golang.org/pkg/os/" target="_blank" rel="external">标准库文档</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</div><div class="line">count, err := file.Read(data)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatal(err)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"read %d bytes: %q\n"</span>, count, data[:count])</div></pre></td></tr></table></figure>
<p>代码看起来没什么问题。出自标准库官方文档的代码，肯定不会错，对吧。</p>
<p>在阅读介绍 <code>Read</code> 函数的 <code>io.Reader</code> <a href="https://golang.org/pkg/io/#Reader" target="_blank" rel="external">文档</a> 之前，我们先花几秒钟来弄清楚这里面有什么问题。</p>
<p>例子里的 <code>if</code> 语句（至少）应该这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</div></pre></td></tr></table></figure>
<p>你也许在想，我是不是在自欺欺人：我们不是应该查看 <code>File.Read</code> 函数的 <a href="https://golang.org/pkg/os/#File.Read" target="_blank" rel="external">文档</a> 吗？那个才是正确的文档吧？是的，但那不应该是唯一正确的文档。</p>
<blockquote>
<p>译者注：读到这里的朋友可能会云里雾里，又未必愿意 / 方便（特别是公众号不能外链）看完文档再回来。我简单介绍一下。</p>
<p>在 <code>io.Reader</code> 接口的文档里，当 <code>Read</code> 遇到文件结束时，<code>io.EOF</code> 可能跟着非 0 的 n （读取的有效字节数）一起返回，也可能在下次调用跟 n = 0 一起返回。（这部分文档很长，有 1300 多个单词，还介绍了 <code>Read</code> 方法其它可能的行为，但多数是建议而不是强制的口吻。）</p>
<p><code>File.Read</code> 的文档则只有一句话，非常明确地指出遇到文件结尾时，会返回 <code>0, io.EOF</code> 。（换言之，<code>io.EOF</code> 不会跟有效字节一起返回。）</p>
</blockquote>
<p>如果我们不能真的用接口隐藏实现细节，那接口有什么用处？一个接口应该规定（set）它的语义，而不是像 <code>File.Read</code> 那样规定它的实现者。当接口的实现者是 <code>File</code> 以外的其他东西，但仍是一个 <code>io.Reader</code> 时，上面的代码会发生什么？当它把数据和 <code>io.EOF</code> 一起返回时，它退出得太早了，但这对所有的 <code>io.Reader</code> 实现者都是允许的。</p>
<h2 id="接口（Interface）-vs-实现者（Implementer）"><a href="#接口（Interface）-vs-实现者（Implementer）" class="headerlink" title="接口（Interface） vs 实现者（Implementer）"></a>接口（Interface） vs 实现者（Implementer）</h2><p>在 Go 里面，你不需要显式标记接口的实现者。这是一个强大的特性。但这是否意味着我们总是应该根据静态类型来使用接口语义呢？例如，下面的 <code>Copy</code> 函数是否应该使用 <code>io.Reader</code> 的语义？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</div><div class="line">    src.Read() <span class="comment">// 现在 read 的语义是来自 io.Reader 吗?</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那这个版本是不是应该只使用 <code>os.File</code> 的语义呢？(注意，这些只是虚构的例子)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst os.File, src os.File)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</div><div class="line">    src.Read() <span class="comment">// 那现在 read 的语义是不是来自 os.File 的 Read 函数呢 ?</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实践中认为，使用接口语义总是比绑定自己的实现要更好——这就是有名的 <a href="https://zh.wikipedia.org/wiki/%E6%9D%BE%E8%80%A6%E5%90%88" target="_blank" rel="external">松耦合</a>。</p>
<h2 id="io-Reader-的问题"><a href="#io-Reader-的问题" class="headerlink" title="io.Reader 的问题"></a>io.Reader 的问题</h2><p>这个接口有以下问题：</p>
<ul>
<li>如果不学习 <code>io.Reader</code> 的文档，你就不能安全地使用任何 <code>Read</code> 函数的实现。</li>
<li>如果不仔细研究 <code>io.Reader</code> 的文档，你就无法实现 <code>Read</code> 函数。</li>
<li>由于缺少对错误（error）的分类（distinction），接口不够直观、完整和符合习惯。</li>
</ul>
<p>正因为 <code>io.Reader</code> 是一个接口，前面提到的问题才多了起来。这给 <code>io.Reader</code> 的每个实现者 和 <code>Read</code> 函数的每个调用者之间带来了跨包依赖。</p>
<p>标准库本身就有很多其它 <a href="https://golang.org/pkg/io/#Reader" target="_blank" rel="external"><code>io.Reader</code></a> 的调用者误用（misuse）该接口的例子。</p>
<p>根据这个 <a href="https://github.com/golang/go/issues/21852" target="_blank" rel="external">问题单（issue）</a>，标准库——尤其是里面的测试——都坚持使用 <code>if err != nil</code> 这个写法，这就阻止了 <code>Read</code> 实现中的优化。</p>
<p>例如，当检测到 <code>io.EOF</code> 时，如果（连同剩余的数据）立即返回 <code>io.EOF</code> ，就会让一部分调用者无法正确运行。原因是显而易见的。reader 接口文档允许两种不同类型的实现：</p>
<blockquote>
<p><code>Read</code> 在成功读取 n &gt; 0 个字节后，如果遇到错误或文件结束的情形，它会返回读取的字节数。它可能会在同一个调用中返回（非 nil）错误，也可能会在后续调用中返回错误（同时 n = 0）。</p>
</blockquote>
<p>接口应该是直观的、并且是通过编程语言本身正式地定义的，使得你无法实现或者误用它们（cannot implement or misuse them）。开发者不应该需要先阅读文档才能进行必要的错误传递。</p>
<blockquote>
<p>译者注：这里的 ‘cannot implement’ 感觉意思不对，不知道原作者是不是想表达错误实现的意思，却只在 use 上加了 mis，忘了 implement。个人猜测本意是 ‘cannot implement or use them in a wrong way’ ，不能错误地实现或者使用它们。但这只是我个人的猜测，写在这里，译文还是忠实于原文。</p>
</blockquote>
<p>允许接口函数有多个（本例中是两个）不同的显式行为是有问题的。接口的思想，是隐藏实现细节，实现松散耦合。</p>
<p>最明显的问题是，<code>io.Reader</code> 接口既不直观，也不符合 Go 典型的错误处理惯例。它还打乱了程序推导中正常和错误分离的控制路径。这个接口使用错误传递机制来处理一些实际上不是错误的东西：</p>
<blockquote>
<p><code>EOF</code> 是 <code>Read</code> 没有更多输入时返回的错误。函数应该只返回 <code>EOF</code> 来表示输入的正常（grateful）结束。如果 <code>EOF</code> 在结构化数据流中意外发生，相应的错误应该是 <code>ErrUnexpectedEOF</code> 或其他能给出更多细节的错误。</p>
</blockquote>
<h2 id="作为可辨识联合（Discriminated-Unions）的错误"><a href="#作为可辨识联合（Discriminated-Unions）的错误" class="headerlink" title="作为可辨识联合（Discriminated Unions）的错误"></a>作为可辨识联合（<a href="https://en.wikipedia.org/wiki/Disjoint_sets" target="_blank" rel="external">Discriminated Unions</a>）的错误</h2><p><code>io.Reader</code> 接口和 <code>io.EOF</code> 指出了 Go 目前的错误处理中所缺少的东西，那就是 <strong>错误的分类（the error distinction）</strong>。例如，Swift 和 Rust 不允许部分失败。函数调用要么成功，要么失败。这就是 Go 的错误返回值的问题之一。编译器无法提供任何支持。众所周知，这同样也是 C 语言的非标准错误返回的问题——当你有一个重叠的错误返回通道时就会这样。</p>
<p>Herb Shutter（译者注：C++ 程序设计专家，曾担任 ISO C++ 的秘书和会议召集人，原文有笔误，应为 Sutter）特意在他的 C++ 提案《<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf" target="_blank" rel="external">零开销的确定性异常：抛出值（Zero-overhead deterministic exceptions: Throwing values）</a>》中提到：</p>
<blockquote>
<p>『正常』与 『错误』（控制流）是一个非常基础的语义区分，而且可能是任何编程语言中最重要的区分，尽管这一点通常被低估了。</p>
</blockquote>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>Go 当前 <code>io.Reader</code> 接口存在问题，是因为违反了语义的区分。</p>
<h3 id="增加语义上的区别"><a href="#增加语义上的区别" class="headerlink" title="增加语义上的区别"></a>增加语义上的区别</h3><p>首先，我们通过声明一个新的接口函数，停止使用返回错误来处理不是错误的东西。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, left <span class="keyword">bool</span>, err error)</div></pre></td></tr></table></figure>
<h3 id="只允许明显的行为"><a href="#只允许明显的行为" class="headerlink" title="只允许明显的行为"></a>只允许明显的行为</h3><p>其次，为了 避免混淆 以及 阻止明确的错误，我们引导使用下面的助手包装器（helper wrapper）来处理这两种允许的 <code>EOF</code> 行为。包装器只提供了一个显式行为来处理数据的结束。因为文档中说，必须允许在没有任何错误（包括 <code>EOF</code>）的情况下返回零字节（<strong>不鼓励在无错误的情况下返回零字节</strong>），所以我们不能将读取的零字节作为 <code>EOF</code> 的标志。当然，包装器也保持了错误的区分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</div><div class="line">    r   io.Reader</div><div class="line">    eof <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *MyReader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, left <span class="keyword">bool</span>, err error)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> mr.eof &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>, !mr.eof, <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    n, err = mr.r.Read(b)</div><div class="line">    mr.eof = err == io.EOF</div><div class="line">    left = !mr.eof</div><div class="line">    <span class="keyword">if</span> mr.eof &#123;</div><div class="line">        err = <span class="literal">nil</span></div><div class="line">        left = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们做了一个错误区分规则，错误和成功的结果是排他的。我们也对返回值 <code>left</code> 进行了区分。当我们已经读取了所有的数据，我们会将其设置为 <code>false</code>，使得函数变得更加易用，这在下面的 <code>for</code> 循环中可以看到：只有在 <code>left</code> 设为 <code>true</code> ，即数据可用时，才需要处理传入的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> n, left, err := src.Read(dst); err == <span class="literal">nil</span> &amp;&amp; left; n, left, err = src.Read(dst) &#123;</div><div class="line">    fmt.Printf(<span class="string">"read: %d, data left: %v, err: %v\n"</span>, n, left, err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如示例代码所示，它允许将正常路径（happy path）和错误控制流分开，这使得程序推导变得更加容易。我们在这里展示的解决方案并不完美，因为 Go 的多个返回值之间并无区别。</p>
<p>在我们这里，它们都应该是这样的。无论如何，我们已经了解到，每个新人（包括刚接触 Go 的人）都可以在没有文档或示例代码的情况下使用我们新的 <code>Read</code> 函数。这就是一个很好的例子，说明 <strong>正常路径和错误路径的语义区分是多么重要</strong>。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们可以说 <code>io.EOF</code> 是一个错误吗？我想说是的。这里有一个错误应该与预期的返回（expected returns）区分开的完美的理由。我们应该始终构建 鼓励正确路径（praise happy path）和 <a href="https://github.com/97-things/97-things-every-programmer-should-know/blob/master/en/thing_66/README.md" target="_blank" rel="external">防止错误</a> 的算法。</p>
<p>Go 的错误处理实践还缺少语言特性来帮助语义的区分。幸运的是，我们大多数人已经在清楚区分的控制流中处理错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;strong&gt;Billion-Dollar Mistake in Go ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc&quot;&gt;https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;strong&gt;Harri Lainio&lt;/strong&gt;（&lt;a href=&quot;https://hackernoon.com/u/lainio&quot;&gt;@lainio&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（3）： 类型</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-3/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-3/</id>
    <published>2020-09-10T09:14:28.000Z</published>
    <updated>2020-09-24T18:44:56.149Z</updated>
    
    <content type="html"><![CDATA[<p>这期讲 Go 的类型。</p>
<p>Go 的数据类型分为基本类型和派生类型。篇幅关系，这期主要讲 基本类型，派生类型简单带过。</p>
<a id="more"></a>
<p>往期内容：</p>
<ul>
<li><a href="../../categories/Go-语言实战/">Go 语言实战</a></li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>下面的内容，会反复提到一个词：零值。如果声明一个变量，却不指定它的值，又或者直接 <code>new(T)</code> （T 是某个类型）申请一块内存，Go 会把这块内存置零。但同样是 0，在不同的类型下，会有不同的语义。了解零值，就是要知道不同类型的默认值的含义和行为。</p>
<h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><p>基本类型又分为 布尔类型、数字类型 和 字符串类型。</p>
<h4 id="1-1-布尔类型"><a href="#1-1-布尔类型" class="headerlink" title="1.1 布尔类型"></a>1.1 布尔类型</h4><p>类型标识符 <code>bool</code>，零值为 false。bool 没有直接的字面量，<code>true</code> 和 <code>false</code> 在 Go 是预定义的 bool 常量，不过使用上跟字面量没有太大区别。而很多时候，用到的不是这两个常量，而是 关系运算的结果 （关系运算符 <code>==</code> ， <code>!=</code> ，<code>&gt;</code> ， <code>&gt;=</code> ， <code>&lt;</code> ， <code>&lt;=</code>）和 函数返回值。</p>
<p>要注意的是，不像有些语言 bool 其实是数值类型的一种特例，可以或显式或隐式转换成数值。<strong>Go 的 bool 不是数值，也无法转换为数值，无法参与任何 数值运算（加减乘除） 和 位运算（按位与、或、取反等）；反之，数值也不能转换为 bool</strong>。</p>
<p>假设现在有 int 数组 <code>nums</code> ，要统计其中大于 0 的数的个数：</p>
<p>C 里面可以这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">    <span class="comment">// C 里面没有专门的布尔值，所以 true 本来就以整型数 1 代表</span></div><div class="line">    <span class="comment">// 反过来，所有非零值都会被看作 true</span></div><div class="line">    <span class="comment">// 括号非必要，只是为了看起来清晰</span></div><div class="line">    count += (nums[i] &gt; <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但在 Go 里会报错</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</div><div class="line">    <span class="comment">// 编译器报错 cannot convert nums[i] &gt; 0 (untyped bool value) to int</span></div><div class="line">    <span class="comment">// 即使加上显式转换 int(nums[i] &gt; 0) 也不行</span></div><div class="line">    count += (nums[i] &gt; <span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只能老老实实用 <code>if</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</div><div class="line">    <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</div><div class="line">        count++</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-数字类型"><a href="#1-2-数字类型" class="headerlink" title="1.2 数字类型"></a>1.2 数字类型</h4><p>包括整型数、浮点数、复数等，区分有符号、无符号，还有不同字节长度选择（对应不同的内存占用和数值范围），有多种组合，具体看表格。</p>
<table>
<thead>
<tr>
<th></th>
<th>1 字节</th>
<th>2 字节</th>
<th>4 字节</th>
<th>8 字节</th>
<th>16字节</th>
<th>架构相关</th>
</tr>
</thead>
<tbody>
<tr>
<td>无符号整型</td>
<td>uint8</td>
<td>uint16</td>
<td>uint32</td>
<td>uint64</td>
<td></td>
<td>uint</td>
</tr>
<tr>
<td>有符号整型</td>
<td>int8</td>
<td>int16</td>
<td>int32</td>
<td>int64</td>
<td></td>
<td>int</td>
</tr>
<tr>
<td>浮点数</td>
<td></td>
<td></td>
<td>float32</td>
<td>float64</td>
<td></td>
<td></td>
</tr>
<tr>
<td>复数</td>
<td></td>
<td></td>
<td></td>
<td>complex64</td>
<td>complex128</td>
<td></td>
</tr>
<tr>
<td>特殊类型</td>
<td>byte</td>
<td></td>
<td>rune</td>
<td></td>
<td></td>
<td>uintptr</td>
</tr>
</tbody>
</table>
<ul>
<li>数字类型的零值均为 0，各种意义上的零（整数零 <code>0</code> ，浮点数零  <code>0.0</code> ， 复数零 <code>0+0i</code>）。</li>
<li>数字类型的字面量，涉及类型推断，参考上一期的字面量部分。</li>
<li><code>byte</code> 是 <code>uint8</code> 的别名，<code>rune</code> 是 <code>int32</code> 的别名。类型别名以后再详细展开，你只要知道它们是同一个类型就可以了。</li>
<li><strong>除了复数以外，所有数值类型的变量之间可以互相转换。</strong> 规则参考上期的类型转换部分。</li>
<li>复数需要经由内置函数提取 实部 和 虚部（都是浮点数），或者将两个浮点数组合成复数。如果不是科学计算，一般很少用到复数，可以留个印象，用到再查。</li>
</ul>
<h5 id="位宽、范围与精度"><a href="#位宽、范围与精度" class="headerlink" title="位宽、范围与精度"></a>位宽、范围与精度</h5><p>位宽是类型后面的数字，它表示该类型占用了多少个二进制位。因为计算机以 字节（byte，等于 8 bit）为组织单位，位宽总是 8 的 2 整数次方倍。</p>
<p><code>uint</code> 、<code>int</code> 和 <code>uintptr</code> 三个类型的位宽与系统架构相关。其中 <code>uint</code> 和 <code>int</code> 不小于 32 位，在 64 位系统则为 64 位；但需要注意它们是独立的类型，以 <code>int</code> 在 64 位系统为例，尽管范围完全一样，<code>int</code> 变量跟 <code>int64</code> 变量之间仍需转换。</p>
<p><code>uintptr</code> 的范围则保证可以存下当前系统架构下的地址，无需特别考虑。</p>
<p>既然有不同的字节长度，就涉及到表示范围。范围太小，会导致数字溢出；范围太大，则引起内存的浪费。当然，如果只是个别变量，几个字节的差异可以忽略，可以直接用范围较大的类型；但涉及大数组或者大量生成的结构体的字段，则最好确定数据范围然后挑选合适的类型。（事实上，如果真的有需要节省空间和访问时间，还得考虑 内存对齐（memory alignment）或者 数据结构对齐（data structure alignment），那又是另一个话题了。）</p>
<ul>
<li>对于无符号整型，假设位宽为 N（下同），表示范围为 $ 0 \sim 2^N - 1 $ ，如 <code>uint8</code> 表示的最大值为 $ 2^8 - 1 = 255 $ 。这个值除了自己算，也可以通过 <code>math</code> 包的常量 <code>math.MaxUint8</code> 获得。16、32、64 位以此类推。</li>
<li>对于有符号整型，最高位表示符号位，正负数的范围分别只有无符号数的一半（实际上因为不需要表示 负零，负数范围多一个），表示范围为 $ -2^{N-1} \sim 2^{N-1} - 1 $ ，如 <code>int8</code> 最小值为 -128，最大值为 127。这两个值也可以通过 <code>math</code> 包的常量 <code>math.MinInt8</code> 和 <code>math.MaxInt8</code> 获得。其它有符号整型以此类推。</li>
<li>浮点数实际上是 科学记数法 的二进制实现，二进制位除了最高位的符号位，剩下的分成了 尾数 和 指数 两部分。跟整型不同的是，浮点数的范围包括 绝对值最大值 和 非零绝对值最小值（跟指数位宽有关），还有小数精度的问题（跟尾数位宽有关）。这些规范其实是 IEEE-754 国际标准规定的。因为精度还涉及进制转换问题，就不在这里展开。<code>float32</code> 的绝对值范围可以通过 <code>math.SmallestNonzeroFloat32</code> 和 <code>math.MaxFloat32</code> 获得。64 位以此类推。</li>
<li>复数实际上由实部和虚部两个浮点数（各占一半位宽）组成，具体范围参考浮点数。</li>
</ul>
<p>既然数字类型都有表示范围，而浮点数还可能有精度损失（有可能是超出尾数范围，也可能是进制转换造成），那么就有可能表示范围或者精度不足。如果需要表示超出范围的值，或者涉及金钱等业务需要非常高的精度，则需要用到 <code>math/big</code> 包的几个大数类型，包括整型 <code>big.Int</code> 、浮点型 <code>big.Float</code> 和 分数 <code>big.Rat</code> 。留个印象，后续再介绍。</p>
<h4 id="1-3-字符串类型"><a href="#1-3-字符串类型" class="headerlink" title="1.3 字符串类型"></a>1.3 字符串类型</h4><p>类型标识符 <code>string</code> ，就是一串有固定长度的字符序列。</p>
<ul>
<li>字符串的底层是一个 byte 数组（以 UTF-8 编码，所以支持中文），可以当做 byte 数组访问读取。例如读取 <code>str[i]</code> 得到的就是一个 byte 类型的值。 </li>
<li><strong>字符串是不可变类型，内容不可修改；对字符串变量的修改实质上是整个替换</strong>。试图修改字符串的内容（如 <code>str[0] = &#39;a&#39;</code>），会引起报错。而 <code>str1 = str1 + str2</code> 中则是合法，因为 <code>str1</code> 和 <code>str2</code> 的内存都没有被修改，而是开辟新的内存存放拼接后的字符串，然后 <code>str1</code> 指向新的内存。原来 <code>str1</code> 的内存如果没有被其它地方引用，会在后续的 GC 被回收。这点有点像 Java 的 String。大量频繁拼接字符串的场景，需要考虑优化。</li>
<li>如果需要修改，则要转换成切片 <code>[]byte</code> 或者 <code>[]rune</code> ；修改完之后也可以重新转换为 <code>string</code>。<strong>无论哪个方向的转换，内存都发生了拷贝（copy），返回的新切片 / 新字符串指向新分配的内存，所以互不影响。</strong> 频繁转换时需要考虑性能损耗。</li>
<li><code>[]byte</code> 和 <code>[]rune</code> 差别是前者每个字符的范围是只有一个字节的 Unicode （只存得下 ASCII 码 + 拉丁符号扩展1），后者则是 四个字节的 Unicode。包含中文等等内容、字符编码可能大于一个字节的字符串只能转换为 <code>[]rune</code> 否则会出现乱码；反之 ASCII 码的内容转换为 <code>[]rune</code> 并不影响内容正确性，只是有一定的性能浪费而已。</li>
<li><strong>跟很多语言不同，Go 字符串的零值是空串 <code>&quot;&quot;</code> 。</strong> 而不是特殊的空值 <code>nil</code>、<code>null</code>、<code>None</code> 等。未初始化的字符串和空白字符串不像 Java 那样需要区分，判断都是 <code>if str == &quot;&quot;</code> 。</li>
<li>字符串有两种字面量形式，除了以双引号包裹内容，还可以用反引号（&#96; ，<code>Esc</code> 下方的键）包裹。区别是双引号内支持转义，不支持换行；反引号字符串恰恰相反，不支持转义，所有字符都会原样保留，包括换行（但为了跨平台兼容性，换行符统一替换成 <code>newline</code>，去掉 <code>carriage return</code>）。反引号字符串常用于一大段的内容（为了保留换行）和 正则表达式（为了保留特殊符号不被转义）。</li>
<li>字符串支持的转义字符跟字符字面量一致，只有一个差别：不支持 <code>\&#39;</code> 改为支持 <code>\&quot;</code> ；这是因为字符串以双引号界定，单引号不再是特殊字符。</li>
</ul>
<p>string 本身值得专门开一篇文章，先说这么多。</p>
<h3 id="2-派生类型"><a href="#2-派生类型" class="headerlink" title="2. 派生类型"></a>2. 派生类型</h3><p>派生类型，又叫衍生类型。顾名思义，它是在其它类型的基础上衍生出来的。</p>
<p>一个派生类型，严格来说，是一个大类，底下可以包含多种具体类型。例如 <code>*int</code> 和 <code>*bool</code> 虽然同为指针类型，但由于指向的类型不同，它们也是不同的类型（称作 <code>int</code> 指针 和 <code>bool</code> 指针）；<code>int</code> 数组 和 <code>bool</code> 数组也是不同的类型；甚至，长度为 10 的 <code>int</code> 数组 <code>[10]int</code> 和 长度为 11 的数组 <code>[11]int</code> 也是不同的类型。</p>
<p>派生类型是个比较大的话题，个别类型光一个类型就够写一篇文章，所以这里不详细展开，只作简单罗列：</p>
<ul>
<li><p>指针：从 C / C++ 一脉相承，内存管理的高阶操作；不过 Go 的指针比 C / C++ 要简单和安全得多，类型安全，也不用关心内存的释放和悬挂指针。</p>
<p>  <code>var iptr *int</code> 声明了一个指向 <code>int</code> 的指针 <code>iptr</code> ，零值为 <code>nil</code> （相当于某些语言的 <code>null</code> ，<code>None</code> ）。</p>
</li>
<li><p>数组（array）和 切片（slice）：类似其它语言的数组和动态数组。（注意这是两个不同类型，只是性质相近一起介绍）</p>
<p>  <code>var a [10]int</code> 声明了一个长度为 10 的 <code>int</code> 数组 <code>a</code>，零值为成员都是零值的数组，可以直接使用。</p>
<p>  <code>var s []int</code> 则声明了一个 <code>int</code> 切片 <code>s</code>，零值为 <code>nil</code> 。</p>
</li>
<li><p>映射（map）：类似其它语言的 map。不过不像 C++ 和 Java 作为库引入，Go 的 map 是语言内置的。因为 Go 没有 集合（set），很多时候也需要用 map 模拟。</p>
<p>  <code>var m map[string]int</code> 声明了一个 key 为 <code>string</code> ，value 为 <code>int</code> 的 map <code>m</code> ，零值为 <code>nil</code> 。</p>
</li>
<li><p>函数（function）：Go 里面函数也是第一等公民。函数既然是一种类型，那么就可以作为变量和参数。Go 支持函数式编程。</p>
<p>  <code>var f func(int)bool</code> 声明了一个 『接受一个 <code>int</code> 参数并返回一个 <code>bool</code> 值的函数』变量 <code>f</code> ，零值为 <code>nil</code> 。</p>
<p>  当然你也可以用 <code>func</code> 关键字直接声明一个函数 <code>f</code> ：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">    <span class="comment">// 函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  两者都是通过 <code>f()</code> 调用（当然，实际调用要提供一个 <code>int</code> 参数）。后者只能用于全局（包级）函数，必须给出函数体，<code>f</code> 不是一个变量，<code>f</code> 的值是一个具体的函数而且不能修改。从效果上接近一个函数常量（但不是）。</p>
</li>
<li><p>结构体（struct）：类似 C / C++ 的结构体，但是可以定义行为（方法）。Go 没有 类（class）和 继承（inheritance），而是通过 结构体 和 组合（composition）实现面向对象。</p>
<p>  下面声明了一个『拥有一个 <code>string</code> 字段 和一个 <code>int</code> 字段 的结构体』的变量 <code>alice</code> ，零值是所有字段都为对应零值的结构体：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> alice <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    age  <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  但这样写，每次声明都要把结构体重新写一遍，啰嗦还容易错——只要字段的名称、类型或者顺序，随便一样有差别，都会被认为是不同的类型。一般情况下，除非这个结构体只使用这么一次，否则都不应该这样写。</p>
<p>  正确的做法，是给结构体一个类型名，然后用名字来声明：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    alice person</div><div class="line">    bob   person</div><div class="line">)</div></pre></td></tr></table></figure>
<p>  在这里 <code>person</code> 成了一个新的自定义类型，与之相对应，前面没有定义名称的结构体称为匿名结构体。</p>
</li>
<li><p>接口（interface）：接口是一系列行为（方法签名，方法是一种特殊的函数）的集合。跟其它语言不同，Go 的接口不需要显式声明实现（implementation），一个类型只要实现了接口的所有方法，它就隐式地满足接口。是否满足接口可以在编译期静态检查，所以是类型安全的。<strong>Go 实现了类型安全的鸭子类型（duck typing）</strong> 。这种设计是 Go 的组合式面向对象的重要组成部分。</p>
<p>  跟结构体类似，接口的定义比较长，也应该定义成一个自定义类型：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> runner <span class="keyword">interface</span> &#123;</div><div class="line">    <span class="comment">// 满足 runner 接口的类型，应该具有 walk() 和 run() 两个方法</span></div><div class="line">    walk() <span class="comment">// walk 是一个没有参数也没有返回值的方法</span></div><div class="line">    run(<span class="keyword">int</span>)<span class="keyword">bool</span> <span class="comment">// run 方法接收一个 int 参数，并返回一个 bool 值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    cindy runner</div><div class="line">    danny runner</div><div class="line">)</div></pre></td></tr></table></figure>
<p>  这里声明了两个 『拥有两个方法的接口』的变量。接口变量的零值是 <code>nil</code> ，可以接受任何满足接口的类型的值。</p>
</li>
<li><p>通道（channel）：channel 用于并发时在协程间通信，是 CSP 模型的重要部分。</p>
<p>  channel 除了区分传递的消息的类型，还分读写和缓冲区大小。其中缓冲区在初始化时决定，剩下的在类型上体现：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">    ich <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 可以读写的通道，消息类型是 int</span></div><div class="line">    bch &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span> <span class="comment">// 只读的通道，消息类型是 bool</span></div><div class="line">    fch <span class="keyword">chan</span>&lt;- <span class="keyword">float64</span> <span class="comment">// 只写的通道，消息类型是 float64</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>  channel 的零值为 <code>nil</code> 。</p>
</li>
</ul>
<p>关于派生类型，最后补充两点：</p>
<ol>
<li><p>所有零值不是 <code>nil</code> 的变量，都可以声明之后直接使用（只不过值都是零）；而零值为 <code>nil</code> 的类型，意味着需要额外的初始化，其中 切片（slice）、映射（map）和 通道（channel）都是通过内置函数 <code>make()</code> 申请内存并初始化。</p>
</li>
<li><p>先定义为自定义类型，再用新类型声明变量，对 结构体 和 接口 来说，既不是必选项，也不是特权。这句话的意思是：</p>
<ul>
<li>不是必选项：匿名结构体 和 匿名接口 也是合法的代码。只不过由于这两种类型的定义太长（一定会换行），匿名使用会有很多麻烦，还是推荐先定义类型。这虽然不是强制选项，却是最佳实践。</li>
<li>不是特权：只要你愿意，所有类型都可以定义为自定义类型（参考下一节），只不过有没有必要而已。</li>
</ul>
</li>
</ol>
<p>这部分内容只是为了让大家对派生类型有一个整体的印象。细节会在用到这些类型时详细展开。</p>
<h3 id="3-自定义类型"><a href="#3-自定义类型" class="headerlink" title="3. 自定义类型"></a>3. 自定义类型</h3><p>Go 使用 <code>type</code> 关键字自定义类型，有两种用法：</p>
<h4 id="3-1-类型定义"><a href="#3-1-类型定义" class="headerlink" title="3.1 类型定义"></a>3.1 类型定义</h4><p>语法 <code>type TypeName TypeDefinition</code></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NewInt <span class="keyword">int64</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> NewStruct <span class="keyword">struct</span> &#123;</div><div class="line">    val <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Bitmap []<span class="keyword">uint64</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Runner <span class="keyword">interface</span> &#123;</div><div class="line">    Run()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Handler <span class="function"><span class="keyword">func</span><span class="params">(req Request)</span><span class="title">Response</span></span></div></pre></td></tr></table></figure>
<p><strong>类型定义</strong> 看起来很像 C / C++ ，只是把名字移到了前面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">&#125; NewStruct;</div></pre></td></tr></table></figure>
<p>或者 Java 的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然像，差别也很明显：</p>
<ul>
<li>Java 里，新名字只能是一个类（即使里面只有一个值）；Go 既能创建新结构体 / 接口，也能复用已有的类型——包括基本类型和内置的派生类型。</li>
<li>C 的 <code>typedef</code> 倒是也可以用于基本类型，但得到的实际上是一个别名，新旧类型仍然是同一种类型；而 Go 声明了一种新的类型。</li>
</ul>
<p>以 <code>type NewInt int64</code> 举例，虽然它们共享同样的内存实现（8 个字节的连续内存），在基本运算符上有同样的结果，但是 <code>NewInt</code> 被认为是跟 <code>int</code> 不同的一个类型，可以拥有自己的方法。两种类型不能直接一起运算，也不能用作另一种类型的参数，需要经过转换。</p>
<p>不直接使用原类型，而是定义命名的新类型，我认为有以下几个原因：</p>
<ol>
<li><p>使用方便。</p>
<p> 这是对冗长的派生类型——尤其是 结构体 和 接口 而言的。简洁的名字当然比冗长的结构方便且不易出错。</p>
</li>
<li><p>自注释。</p>
<p> 名字可以体现用途和意图。</p>
</li>
<li><p>借用静态检查发现错误。</p>
<p> 将底层实现一样但是业务逻辑不一致的类型分别定义为不同的类型，可以借由静态检查发现逻辑错误。这在上一期类型转换部分，我用 砧板 和 地板 的 底层类型都是 木板 做了一个类比。</p>
</li>
<li><p>添加方法。</p>
<p> Go 可以（且只可以）给当前包定义的类型添加方法。内置类型和导入类型定义成新类型之后，就可以给新类型添加方法，实现面向对象编程。</p>
<p> 需要注意的是，定义成新类型之后，原来类型的方法就全部丢失，不能再访问了（毕竟已经不是同一个类型）。如果需要保留原来的方法，应该选择将旧类型匿名嵌入新类型的结构体。匿名嵌入效果上接近继承，实际上是组合，只是跟一般成员组合相比，被匿名嵌入类型的成员和方法可以直接访问。具体在 方法 和 结构体 部分展开。</p>
</li>
</ol>
<h4 id="3-2-类型别名"><a href="#3-2-类型别名" class="headerlink" title="3.2 类型别名"></a>3.2 类型别名</h4><p>语法 <code>type TypeAlias = AnotherType</code></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IntAlias = <span class="keyword">int</span></div><div class="line"><span class="keyword">type</span> StructAlias = NewStruct</div></pre></td></tr></table></figure>
<p><strong>类型别名</strong> <code>type IntAlias = int</code> 中，<code>IntAlias</code> 被认为是 <code>int</code> 的别名，看作是同一类型，可以直接一起运算或者作为参数，无需转换。类型别名自 Go 1.9 引入，用来解决迁移、升级等重构场景下，类型重命名的兼容性问题，以及方便引用外部导入的类型。</p>
<p><strong>实际上，类型别名仅在代码中存在，编译时会全部替换成实际的类型。只有类型定义产生了新的类型。</strong></p>
<h3 id="4-枚举（模拟）"><a href="#4-枚举（模拟）" class="headerlink" title="4. 枚举（模拟）"></a>4. 枚举（模拟）</h3><p>说到自定义类型，就顺便提一下枚举。</p>
<p>在数学和计算机科学上，枚举是指列出一个有限集合的所有成员。而枚举类型是一种特殊的类型，只能取限定的某几个值。有些语言只是限定了枚举类型的取值（C / C++）；而有些语言则（以常量的形式）直接预先初始化了枚举类型所有可能值的实例，变量不仅仅只能取有限的值，而是只能是这几个实例之一（Java，Python）。</p>
<p><strong>Go 没有提供对枚举的支持</strong>。是的，Go 跟谁都不像，根本没有枚举。相对应地，在 Go 里一般通过 自定义类型 + 常量 模拟枚举。我们来看看官方库里面 <code>time</code> 包对 月份 <code>Month</code> 和 周几 <code>Weekday</code> 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> time</div><div class="line"></div><div class="line"><span class="comment">// A Month specifies a month of the year (January = 1, ...).</span></div><div class="line"><span class="keyword">type</span> Month <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 如果理解不了这部分，请翻看上一期常量部分关于自动补全和 iota 的内容</span></div><div class="line">    January Month = <span class="number">1</span> + <span class="literal">iota</span></div><div class="line">    February</div><div class="line">    March</div><div class="line">    April</div><div class="line">    May</div><div class="line">    June</div><div class="line">    July</div><div class="line">    August</div><div class="line">    September</div><div class="line">    October</div><div class="line">    November</div><div class="line">    December</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// String returns the English name of the month ("January", "February", ...).</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Month)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> January &lt;= m &amp;&amp; m &lt;= December &#123;</div><div class="line">        <span class="comment">// longMonthNames 是一个预先定义的字符串切片，里面按顺序保存了每个月份的字符串</span></div><div class="line">        <span class="keyword">return</span> longMonthNames[m<span class="number">-1</span>]</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果 m 的值不在范围内，返回表示错误的字符串</span></div><div class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">20</span>)</div><div class="line">    n := fmtInt(buf, <span class="keyword">uint64</span>(m))</div><div class="line">    <span class="keyword">return</span> <span class="string">"%!Month("</span> + <span class="keyword">string</span>(buf[n:]) + <span class="string">")"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// A Weekday specifies a day of the week (Sunday = 0, ...).</span></div><div class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Sunday Weekday = <span class="literal">iota</span></div><div class="line">    Monday</div><div class="line">    Tuesday</div><div class="line">    Wednesday</div><div class="line">    Thursday</div><div class="line">    Friday</div><div class="line">    Saturday</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// String returns the English name of the day ("Sunday", "Monday", ...).</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Weekday)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> Sunday &lt;= d &amp;&amp; d &lt;= Saturday &#123;</div><div class="line">        <span class="comment">// 跟月份类似，longDayNames 也是预先定义好的字符串切片</span></div><div class="line">        <span class="keyword">return</span> longDayNames[d]</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 同样地，超出范围就返回表示错误的字符串</span></div><div class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">20</span>)</div><div class="line">    n := fmtInt(buf, <span class="keyword">uint64</span>(d))</div><div class="line">    <span class="keyword">return</span> <span class="string">"%!Weekday("</span> + <span class="keyword">string</span>(buf[n:]) + <span class="string">")"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子里，<code>Month</code> 和 <code>Weekday</code> 都是底层类型为 <code>int</code> 的自定义类型；然后这两个类型定义了一系列的常量作为取值范围，并且定义了一个 <code>String()</code> 方法，返回对应值的字符串形式。</p>
<p>在 1.4 之后，Go 工具链提供了 <code>go generate</code> 命令，配合 <code>stringer</code> 工具可以自动生成常量的 <code>String()</code> 方法。除此之外，也可以按需给新类型添加各种方法，模拟其他语言里的枚举，或者增加需要的功能。详情可以自己查阅，这里不再展开。</p>
<p>有独立的类型、通过常量给定取值、能返回字符串，肯定比直接用一个整型数来表示要强。自定义类型被认为是跟原来不一样的类型，在赋值或者传参过程中，如果使用了不同类型的变量，直接在编译时就报错了；另一方面，如果只通过常量引用这些 “枚举类型” 的值，取值范围也限制住了。基本实现了枚举的目的。</p>
<p>但也只能说部分实现。提供的常量只是给出了范围的建议值，而不是强制值。Go 没有提供『把类型的取值范围硬性限制在某几个值』的语义。新类型的取值范围仍然是和底层类型一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 这是合法的，-1 作为字面量是 untyped 的，可以自动转换类型</span></div><div class="line">    <span class="keyword">var</span> m1 time.Month = <span class="number">-1</span></div><div class="line">    </div><div class="line">    <span class="comment">// 又或者是忘了赋值，那么 m2 的值就为 零值，即 0，也不在常量范围内</span></div><div class="line">    <span class="keyword">var</span> m2 time.Month</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果说 <code>m1</code> 是违反了（模拟的）枚举类型只使用常量引用的原则，注意一下就可以避免；那么 <code>m2</code> 这种忘记赋值的情况可能更难发现一些。</p>
<p>既然没有办法通过类型安全本身限制取值，就只能在使用时注意判断值的范围，特别要处理意外的情况。在判断枚举值时，一般使用 <code>if-else</code> 或者 <code>switch-case</code>  代码块，这时记得加上一个 <code>else</code> 或者 <code>default</code> 处理无效值。又或者干脆给类型添加一个 <code>IsValid()bool</code> 方法，判断值是否有效。</p>
<p>当然这种实现方式也并不全是坏处。Go 没有限定枚举必须是什么样子，就可以按自己的需要设计：</p>
<ul>
<li>枚举的底层值不一定是整数，可以是任意基本类型。</li>
<li>枚举的值允许重复；这个有些时候可能会引起错误，有些时候又可能有用。</li>
<li>没有增加特殊情况，保持了类型系统的简单和高效；引入专门的枚举类型其实涉及很多问题，例如序列化和反序列化怎么处理。</li>
</ul>
<p>总的来说，我个人觉得在枚举这个问题上处理得不够好，好像不太符合 Go 一向强类型和自带最佳实践的风格。当然也有可能是我理解得不够深入。但无论怎么说，目前的实现方式在官方库非常普遍，出于兼容性的考虑，至少在 Go 1.x 阶段不太会改动的样子。那就接受这个设定，并且小心避开潜在的坑吧。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>问题1 ：</p>
<p>假设程序中需要储存一个状态，有 待办、进行中、完成 三种状态，应该怎么样定义类型？</p>
<p>如果这样的状态需要储存非常多个，定义成一个大数组储存，该如何节省空间？</p>
<p>问题 2：</p>
<p>问以下程序的输出，为什么。老规矩，不用运行就得出答案更佳。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> str1 = <span class="string">"hello world"</span></div><div class="line">    <span class="keyword">var</span> tmp1 = <span class="string">"hello"</span></div><div class="line">    <span class="keyword">var</span> tmp2 = <span class="string">"world"</span></div><div class="line">    <span class="keyword">var</span> str2 = tmp1 + <span class="string">" "</span> + tmp2</div><div class="line">    fmt.Println(str1 == str2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="上期练习答案"><a href="#上期练习答案" class="headerlink" title="上期练习答案"></a>上期练习答案</h2><p>第二期最后的练习，答案如下</p>
<p>如果还没做练习，不要直接看答案</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局常量和变量是经过依赖分析后统一初始化的</span></div><div class="line"><span class="comment">// 只要没有依赖环，声明先后不影响引用</span></div><div class="line"><span class="comment">// 但局部常量和变量不能这样做</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    A <span class="keyword">uint8</span> = B <span class="comment">// uint8, 255</span></div><div class="line">    B       = <span class="number">255</span> <span class="comment">// 整型字面量默认类型为 untyped int，255</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    a <span class="keyword">uint64</span> = A / <span class="number">2</span> <span class="comment">// 类型报错！A 的 uint8 是显式类型，2 自动转换为 uint8 参与运算，所以 A / 2 表达式整体也是 uint8，不能自动转换为 uint64</span></div><div class="line">    b <span class="keyword">int8</span>   = B / <span class="number">2</span> <span class="comment">// B 是 untyped 无类型，表达式整体也是 untyped int，结果自动转换为 int8，结果为 127（整数除法），刚好不超过 int8 的范围</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 以下的 A, B, a, b 均没有重复声明，这是因为作用域不同，发生了 shadow</span></div><div class="line">    </div><div class="line">    A := <span class="keyword">byte</span>(<span class="string">'0'</span>) <span class="comment">// '0' 为 untyped rune，显式转换为 byte，值范围没有超出，所以类型为 byte；byte 实际是 uint8 的别名，'0' 的值为 48，只有作为字符格式化时才输出字符 '0'</span></div><div class="line">    B := <span class="keyword">byte</span>(<span class="string">'1'</span>) <span class="comment">// 类型同上，值为 49</span></div><div class="line">    C := A - B <span class="comment">// A, B 均为 byte 类型，所以表达式的结果也是 byte，C 也是 byte；计算结果为 -1，但 byte（即 uint8，无符号 8 位整型）最小值是 0，下溢出，截取得到 255 （惊不惊喜，意不意外）；这种截取很容易导致意料以外的结果，需要尽量避免</span></div><div class="line">    fmt.Println(C) <span class="comment">// 输出 255</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> a = <span class="string">'0'</span> <span class="comment">// 没有指定类型，类型为 untyped rune，值为 48</span></div><div class="line">    <span class="keyword">const</span> b = <span class="string">'1'</span> <span class="comment">// 类型为 untyped rune，值为 49</span></div><div class="line">    fmt.Println(<span class="keyword">byte</span>(a - b)) <span class="comment">// 类型转换错误！a - b 的结果类型为 untyped rune，值为 -1，转换成 byte 会下溢出；常量在转换中不允许溢出</span></div><div class="line"></div><div class="line">    i := <span class="number">0x1e</span>+<span class="number">2</span> <span class="comment">// 这其实是一个表达式，格式化后会自动在加号两边添加空格；加号前面的数是十六进制的 30，整体就是 30 + 2；两个数都是整型字面量，所以表达式和变量的类型都是 untyped int，值为 32</span></div><div class="line">    j := <span class="number">1e+2</span> <span class="comment">// 浮点数字面量，表示 1 x 10^2，即 100，类型为 untyped float；注意 j 没有任何有效使用，会报 not used 错误！</span></div><div class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ &#123; <span class="comment">// i 在这里是赋值，在循环条件 i &lt; 1 中算有效使用（涉及到了循环，略有超纲，但有其它语言经验的话问题不大）</span></div><div class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1</span>; j++ &#123; <span class="comment">// 短声明产生了一个新的 j ，跟前面的 j 无关</span></div><div class="line">            <span class="comment">// 空循环体</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 现在 i, j 分别是多少</span></div><div class="line">    <span class="comment">// i 在循环中先是被赋值为 0，然后自增，到 1 时不满足循环条件退出，所以 i 为 1</span></div><div class="line">    <span class="comment">// （外层）j 没有被使用，还是 1e+2 （100）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你答对了吗？</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这期讲 Go 的类型。&lt;/p&gt;
&lt;p&gt;Go 的数据类型分为基本类型和派生类型。篇幅关系，这期主要讲 基本类型，派生类型简单带过。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（2）： 常量与变量</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-2/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-2/</id>
    <published>2020-08-30T04:15:12.000Z</published>
    <updated>2020-09-22T04:16:44.541Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇《<a href="../golang-in-action-day-1/">Go 语言实战（1）： 初识</a>》开了头，今天我们接着打卡。</p>
<a id="more"></a>
<blockquote>
<p>注意，文中出现的大多数代码都只是关键片段，如果想尝试运行，需要补充程序的必要成分。关于一个完整 Go 程序的结构，请看第一期的内容。</p>
</blockquote>
<h2 id="Go-的定位"><a href="#Go-的定位" class="headerlink" title="Go 的定位"></a>Go 的定位</h2><p>接着上一期，这期还是先介绍一些概念性的话题。</p>
<p>如果用一句话来描述，Go 的定位就是 <del>保留 C 语言的简洁性和执行效率的前提下，重新设计放下历史包袱，增加现代特性，表达力和易用性向 Python 等现代语言靠拢</del> <strong>服务于软件工程的语言设计</strong>。（划掉的是我啰嗦又辞不达意的总结，加粗的是 Rob Pike 2012 年一个演讲的主题。）</p>
<p>我在写这一段时，发现无论如何都很难概括好。然后我就放弃了自己概括，改为学习大佬讲话了。我还把这个演讲翻译了分享给大家：</p>
<p><a href="../translation-language-design-in-the-service-of-software-engineering/">Go 在 Google：服务于软件工程的语言设计（翻译）</a></p>
<p>我个人看这篇文章的感受是受益匪浅。Rob 在 8 年前 Go 1 时提到的内容，8 年后仍然有效。8 年里 Go 的语言设计只是在保持兼容的基础上做了微调，更多的投入，是在运行时和工具链的改进上。他们从一开始就知道要做什么，怎么到达。作为对比，很多语言流行后的主要用途跟当年创造的目的大相径庭：一开始的目标没有达成，却意外收获了一个新阵地，然后被新的状况推着前进。</p>
<p>而这几个从 贝尔实验室 干到 Google ，参与过创造 Unix、Plan 9、UTF-8 再到 Go 的老大爷（Ken 今年 77 岁，Rob 也 64 岁了），四五十年的开发生涯，清楚地知道在工程实践中，什么是重要的。</p>
<h2 id="语法与风格"><a href="#语法与风格" class="headerlink" title="语法与风格"></a>语法与风格</h2><p>Go 的语法大致是类似 C 语言的，有 C 族语言经验的话，很容易习惯，没有也不难学。这里只是提几个比较特别的点。这些语言风格和惯例的内容，一开始就要接触到，又很难归入哪个话题，先留个印象，后续如果涉及到会再次说明。</p>
<h3 id="命名在前的声明"><a href="#命名在前的声明" class="headerlink" title="命名在前的声明"></a>命名在前的声明</h3><p>这可能是最显眼的差别。Go 里面所有的声明，都是统一的 <code>关键字 命名 定义内容</code> 这样的顺序。Rob 称这样的语法为『类型语法（type syntax）』，而是 C 的语法是『表达式语法（expression syntax）』。</p>
<p>Go 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常量</span></div><div class="line"><span class="comment">// 声明是 = 前面部分。常量必须在声明同时绑定值，否则编译器会报 'missing constant value'</span></div><div class="line"><span class="keyword">const</span> Pi <span class="keyword">float64</span> = <span class="number">3.14</span></div><div class="line"></div><div class="line"><span class="comment">// 变量</span></div><div class="line"><span class="comment">// 变量可以只声明，此时变量的值为对应类型的零值。</span></div><div class="line"><span class="keyword">var</span> Name <span class="keyword">string</span></div><div class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span></div><div class="line"><span class="keyword">var</span> iPtr *<span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="comment">// 类型</span></div><div class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></div><div class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// 结构体内部也是名称在前</span></div><div class="line">    <span class="comment">// 只是外面已经有了 struct &#123;&#125;，不需要再给关键字了</span></div><div class="line">    Count <span class="keyword">int</span></div><div class="line">    Price <span class="keyword">float64</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数</span></div><div class="line"><span class="comment">// func 可以当做关键字</span></div><div class="line"><span class="comment">// 只是名称 Add 和 函数体定义之间没有空格隔开而已</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div><div class="line"><span class="comment">// func 也可以当做类型</span></div><div class="line"><span class="keyword">var</span> mul <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><span class="title">int</span> = <span class="title">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> a * b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 甚至连 import 语句都满足这个规则</span></div><div class="line"><span class="comment">// 当然，多数情况下，用默认包名即可，不需要给包命名，所以中间的命名可以省略</span></div><div class="line"><span class="keyword">import</span> mylog <span class="string">"example.com/lib/log"</span></div><div class="line"><span class="comment">// 没有指定名称，就是用它原来的包名，一般为路径最后一级目录，即 log</span></div><div class="line"><span class="keyword">import</span> <span class="string">"another.com/different/log"</span></div></pre></td></tr></table></figure>
<p>阅读代码时，经历一个『是什么——什么名字——具体内容』理解的过程，还是很自然的。关键是，不同的声明都很统一，不需要切换思维模式。用 Rob 的话说，无论对人对计算机来说，都好解析。</p>
<p>C 的表达式语法，大部分情况下不过不失，但是考虑上数组和指针，情况就变得脑筋急转弯起来：</p>
<p>（如果你没有接触过 C 族语言，以下对比可以先跳过）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14</span>;</div><div class="line"></div><div class="line"><span class="comment">// 变量（等于是因为变量最常用，比其他声明少一个关键字）</span></div><div class="line"><span class="keyword">int</span> val;</div><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> *iPtr</div><div class="line"></div><div class="line"><span class="comment">// 结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">float</span> price;</div><div class="line">&#125; Goods;</div></pre></td></tr></table></figure>
<p>C 是很多人接触计算机的第一门语言，不知道你初学时是否有过跟我类似的困惑：</p>
<p><code>array[10]</code> 的类型是 <code>int</code> ，这我知道了，数组在哪？是 <code>array[10]</code> 还是 <code>array</code> ？</p>
<p>同样 <code>*iPtr</code> 的类型也是 <code>int</code> ，但 <code>*iPtr</code> 是什么东西？指针在哪里？</p>
<p>表达式语法试图通过告诉我们『变量引用时指向什么』，来让我们知道『这是个什么变量』；下标引用得到 <code>int</code> ，就是 int 数组，这有点跳跃；声明的数字是大小而不是下标，容易产生 <code>array[10]</code> 是 <code>int</code>  那 0 到 9 呢的疑惑；最主要的问题，还是 <code>array[10]</code> 视觉上连在一起，需要特意去识别，这在复杂的函数指针上就更严重了。这是个历史遗留问题，这么多年我们早已习惯，但不代表这就不糟糕。</p>
<p>相比之下，<code>var array [10]int</code> 和 <code>var iPtr *int</code> 就直接多了，起码变量名一眼可见，没有粘连；类型也很好理解，<code>[10]int</code> 10 个 int 的数组，<code>*int</code> 指向 int 的指针。</p>
<p>好比向别人介绍一款他没见过的食物，正常情况应该是『它的名字叫饺子（array），馅料是猪肉末（[10]int）』；没有人会上来就『饺子馅（array[10]）是猪肉末（int）』，对方会疑惑，这个食物叫 饺子馅？</p>
<h3 id="首字母大小写控制可见性"><a href="#首字母大小写控制可见性" class="headerlink" title="首字母大小写控制可见性"></a>首字母大小写控制可见性</h3><p>Go 没有常见的 <code>public</code> 和 <code>private</code> 关键字，而是 <strong>靠名称首字母的大小写来控制可见性</strong>。因为代码组织的单位是包（package），包内都是可见的，区别在于是否能被包外面访问。</p>
<p>首字母大写的名称像 <code>Name</code> 称为导出（exported）标识符，包外可以访问，相当于 public；除此以外的情况，像 <code>name</code> 或者 <code>_name</code> 对包外都不可见，相当于 private。这条规则对所有标识符，包括常量、变量、类型、函数、方法、字段 …… 统统有效。你只要看一眼名字，就能知道是否可以被包外访问，不需要再查看声明。</p>
<p>唯一的例外是内置类型，像 <code>int</code> 、<code>float64</code>  、<code>string</code> 、 <code>map</code> 都是未导出标识符，但却可以全局访问，甚至连导入（import）都不用。</p>
<p>Go 支持下划线命名（又叫蛇形命名 snake case，像 <code>snake_case</code>），但不推荐。按惯例除模块名和包名以外，推荐所有标识符都是用驼峰式命名（camel case，像 <code>CamelCase</code> 或者 <code>camelCase</code>），包括常量。</p>
<h3 id="格式化工具-gofmt"><a href="#格式化工具-gofmt" class="headerlink" title="格式化工具 gofmt"></a>格式化工具 gofmt</h3><p>大多数 IDE 会在保存时自动执行。如果你习惯使用记事本，手动执行一下也不难。<code>gofmt</code> 会把合法的 Go 代码格式化为统一的规范。它多管闲事到，缩进是 Tab 而不是空格，左花括号 <code>{</code> 不用换行，哪些地方有空格哪些没有，代码块之间要不要空行空多少行 …… 都管。</p>
<p>不要以为只是自带了一个工具这么简单。因为自带了，所以大家都有，不用额外安装第三方和产生不同的规范（即使有第三方，也是考虑兼容官方规范之后再增强）；因为有官方规范，所以大家不用争论那种风格好；提交时不会产生因为格式不同产生的差异和冲突 …… 等等。</p>
<p>请务必把这个功能用上。要么打开 IDE 的自动格式化，要么记得手动执行一下。</p>
<h3 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h3><p>Go 总是以清晰明确为第一目标，让人易读无歧义，让机器好解析编译快。所以 Go 不一味追求表达力强，甚至有点逆潮流地刻意区分一些语句和表达式，以避免某些单行长表达式的写法。</p>
<p>既然反正都是要换行的，分号就给省掉了。</p>
<p>而上面提到的声明格式，其实有省略的余地。</p>
<p>第一个是类型推断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 省略了类型，根据字面量推断</span></div><div class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></div><div class="line"><span class="keyword">var</span> Name = <span class="string">"Golang"</span></div><div class="line"></div><div class="line"><span class="comment">// 其中变量还能进一步省略 var 关键字，改用变量短声明 := （不能用于全局变量）</span></div><div class="line"><span class="comment">// 以下 i 自动推断为 int 型，f 为 float64 型</span></div><div class="line">i := <span class="number">0</span></div><div class="line">f := <span class="number">0.0</span></div></pre></td></tr></table></figure>
<p>第二个是集中声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Pi = <span class="number">3.1415</span></div><div class="line">    prefix = <span class="string">"go:"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    Name <span class="keyword">string</span></div><div class="line">    array [<span class="number">10</span>]<span class="keyword">int</span></div><div class="line">    iPtr *<span class="keyword">int</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> (</div><div class="line">    <span class="comment">// ...</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 除了 func，都可以集中声明</span></div></pre></td></tr></table></figure>
<p>集中声明除了节省敲几个关键字的时间，更重要的是让同类声明放在一起，更有条理。</p>
<h2 id="常量-与-变量"><a href="#常量-与-变量" class="headerlink" title="常量 与 变量"></a>常量 与 变量</h2><p>啰嗦一番之后，这里正式进入本期的主题。内容较多，如果通读有压力，可以跳着看留个印象，遇到问题回来翻阅。</p>
<p>在下一期的数据类型之前，先讲常量 和 变量。我们从 值（value）说起。</p>
<p>计算机科学中，值是指『无法进一步求值的表达式（expression）』。像 <code>1 + 3</code> 这个式子，可以进一步求值得到 <code>4</code>，但是 4 已经无法进一步简化，那么 4 就是一个值，是 <code>1 + 3</code> 这个表达式（还有 <code>2 + 2</code> 、 <code>5 - 1</code> …… 还有 <code>4</code> 本身）的值。简单一点理解，可以认为本质上就是一个 数。</p>
<p>当需要用到一个值，就需要表示、储存和引用它，涉及到三种量（quantity）：字面量、常量、变量。</p>
<h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1. 常量"></a>1. 常量</h3><p>广义上的常量包括 字面量。</p>
<p>字面量又被称作 <strong>无名常量（unnamed constant）或 字面常量 （literal constant）</strong>。与之对应，一般所说的常量因为关联了标识符，又被称作 <strong>有名常量（named constant）</strong>。</p>
<p>字面量 和 常量 在很多语言里，底层实现都类似甚至一致，都是 编译期确定、储存在静态只读数据区、值不能修改，而且很多使用场景，两者都能互相替代。</p>
<p>但是，多数语言（包括 Go）只支持基本类型的（有名）常量，所以严格来说，字面量 和 常量 不能等同。派生类型想表示一个固定的值，只能使用字面量，或者用变量的同时对修改加以限制。</p>
<h4 id="1-1-字面量"><a href="#1-1-字面量" class="headerlink" title="1.1 字面量"></a>1.1 字面量</h4><p><strong>字面量（literal）是源码中对一个固定值的表示</strong>。换言之，它的值，如字面所示。</p>
<p>几乎所有类型都有对应的字面量表示方法。基本类型的字面量举例：</p>
<ul>
<li>整型数（int）： <code>1</code> ， <code>2</code> ， <code>100</code> ， <code>1000</code> ， <code>0b101</code> （二进制 5）， <code>0xff</code> （十六进制 255）；</li>
<li>浮点数（float）： <code>1.0</code> ，<code>1.1</code> ，<code>1e4</code> （科学记数法 10000）；</li>
<li>字符（byte）：<code>&#39;a&#39;</code> ， <code>&#39;B&#39;</code> ；</li>
<li>字符串（string）：<code>&quot;字符串被双引号包围&quot;</code> ，还有一种反引号（<code>Esc</code> 键下方的键）包裹的字符串；</li>
<li>……</li>
</ul>
<p>需要注意的是，<code>bool</code> 没有字面量，在其它语言被定义为字面量的 <code>true</code> 和 <code>false</code> ， 在 Go 是内置的 <code>bool</code> 型的（有名）常量。</p>
<p>对于派生类型，字面量的表示是在类型后面加花括号 <code>{}</code> ，并在花括号内指定成员的值（如有），未指定的成员则为零值。例如 <code>a := [4]int{7}</code> 得到这样一个数组 <code>{7, 0, 0, 0}</code> 。具体到介绍具体类型时讨论。</p>
<p>在实际使用上，那些可以在编译期确定的值，像编译期求值的 表达式 和 内置函数返回值，也可以近似看作字面量（无名常量），因为编译器会求值并用得到的值替换它们。</p>
<h4 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h4><p>常量（constant，关键字 <code>const</code>）则是<strong>编译期就确定的，在程序运行中不能被修改的有名值</strong>。</p>
<p>因为需要在编译期就确定值，常量必须在声明时就指定它的值，而且只能是 <strong>引用 字面量 或其它 常量 的表达式 或 内置函数的返回值</strong> ；编译器会对表达式或内置函数求值，原来的表达式或函数不再保留：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    Pi        = <span class="number">3.14</span> <span class="comment">// 字面量</span></div><div class="line">    R         = <span class="number">1</span>&lt;&lt;<span class="number">2</span> <span class="comment">// 引用了字面量的表达式，等价于 R = 4</span></div><div class="line">    Area      = Pi * R * R <span class="comment">// 引用了其它常量的表达式，等价于 Area = 50.24</span></div><div class="line">    Name      = <span class="string">"Rob"</span> + <span class="string">" "</span> + <span class="string">"Pike"</span> <span class="comment">// 字符串字面量的连接表达式，等价于 Name = "Rob Pike"</span></div><div class="line">    NameLen   = <span class="built_in">len</span>(Name) <span class="comment">// 引用常量的内置函数返回值，等价于 NameLen = 8</span></div><div class="line">    ComplexA  = <span class="number">2</span> + <span class="number">3i</span> <span class="comment">// 复数字面量</span></div><div class="line">    RealA     = <span class="built_in">real</span>(ComplexA) <span class="comment">// 内置函数求实部，等价于 RealA = 2.0 （real 返回的是浮点数）</span></div><div class="line">    ImagA     = <span class="built_in">imag</span>(ComplexA) <span class="comment">// 内置函数求虚部，等价于 ImagA = 3.0</span></div><div class="line"></div><div class="line">    AreaSqrt  = math.Sqrt(Area) <span class="comment">// 报错！ math.Sqrt() 不是语言内置的函数</span></div><div class="line">    Perimeter = Pi * Diameter <span class="comment">// 报错！Diameter 是变量，编译时无法确定值</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    Diameter <span class="keyword">int</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// Go 支持局部声明的常量</span></div><div class="line">    <span class="comment">// 局部声明只是限定了有效作用域（这个例子里，main 函数以外无法引用 local）</span></div><div class="line">    <span class="comment">// 局部常量依然满足常量的所有特征，在编译期就确定值并且不再修改</span></div><div class="line">    <span class="keyword">const</span> local = <span class="number">42</span></div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所述，常量可以看作给字面量绑定了一个名称，后续用名称引用。</p>
<p>实际上，在程序里使用 <code>Pi</code> （声明为 <code>const Pi = 3.14</code>）和直接使用字面量 <code>3.14</code> 的效果是完全一样的。两种做法 在 Go 里，甚至连生成的汇编代码都几乎一样，常量名实际上只在代码里起作用，编译后都是替换成直接访问存放在 SRODATA （即 static read-only data，静态只读数据）区的值。</p>
<p>既然效果一样，为什么需要常量呢？一般基于以下两个理由：</p>
<ul>
<li><p>通过命名提高可读性：命名可以描述一个值的用途，提供值以外的信息，提高代码的可读性。</p>
<p>  试想在一个程序里，既需要用到 π 的近似值 3.14，然后刚好另外有一个常数也是 3.14 （例如，计算材料时，某种标准石膏柱的体积是 3.14 立方米）。那么如果都直接使用字面量 <code>3.14</code> ，编码中就需要额外的精力去区分 <code>3.14</code> 究竟是指哪一个。而如果改用标识符 <code>Pi</code> 和 <code>Volume</code> ，就非常明确了。</p>
<p>  这种光看字面量无法识别含义的值，称为魔数（Magic Number），是开发中需要避免的。</p>
</li>
<li><p>命名还能提高代码的可维护性：命名常量只需要修改声明处的值，就能改变所有引用的值。</p>
<p>  还是 3.14 的例子。如果后面石膏柱的体积改变了，变为 10。那么我们就要把所有含义为石膏柱体积的 <code>3.14</code> 改为 <code>10</code> ；与此同时，π 的值当然没有变，含义为 π 的 <code>3.14</code> 必须保持不变。又或者 π 的值需要提高精度到 <code>3.141593</code> ，保持另一个常数不变。 当这两个值在代码中被大量引用时，即使有搜索功能的辅助，要正确地把值改过来，既不遗漏也不错改，也是一件吃力不讨好的差事。</p>
<p>  如果使用了常量，就只需要修改常量声明处的值即可。</p>
</li>
</ul>
<p>反过来说，如果一个字面量满足以下至少一点，就应该考虑定义为常量：</p>
<ul>
<li>不能光从字面量和使用上下文看出含义（即魔数）；</li>
<li>相同含义的字面量在代码中多处反复出现。</li>
</ul>
<p><strong>再次提醒注意的是，在 Go 里面常量（的底层实现）只能为 基本类型</strong> （即 布尔型、数字类型、字符串类型 3 类，后面会讲到）， 不可以是各种派生类型。</p>
<h5 id="1-2-1-自动补全"><a href="#1-2-1-自动补全" class="headerlink" title="1.2.1 自动补全"></a>1.2.1 自动补全</h5><p>对于集中声明的常量，编译器允许省略标识符以外的内容，省略的部分自动补全为上一行的内容。注意，要自动补全， <strong>常量</strong> 和 <strong>集中声明</strong> （共用一个 <code>const</code> 关键字）这两个条件缺一不可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    b <span class="comment">// 自动补全 int64 = 1，注意，连类型信息也补全了</span></div><div class="line">    c <span class="comment">// 仍然 int64 = 1</span></div><div class="line">    </div><div class="line">    d <span class="comment">// 空行后补全仍然有效</span></div><div class="line">    </div><div class="line">    s, t = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    u, v <span class="comment">// 自动补全</span></div><div class="line">    w, _ <span class="comment">// 因为补全为两个右值，如果要跳过需要显式提供 空标识符（下划线 '_'）</span></div><div class="line">    _, x <span class="comment">// 当然也能跳过第一个</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    b <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    c <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    </div><div class="line">    d <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    </div><div class="line">    s, t = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    u, v = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    w, _ = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    _, x = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>错误示范：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a <span class="keyword">int</span> = <span class="number">10</span></div><div class="line"><span class="keyword">const</span> b <span class="comment">// 不是集中声明，报错 'missing constant value'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    c = <span class="number">3.6</span></div><div class="line">    d <span class="keyword">float64</span> <span class="comment">// 只允许有标识符（命名），不能指定类型；指定了类型就不会自动补全，报错 'missing constant value'</span></div><div class="line">    </div><div class="line">    e, f = <span class="string">"允许同时声明多个不同类型"</span>, <span class="literal">true</span></div><div class="line">    g <span class="comment">// 报错！因为 true 没有标识符对应，需要空标识符显式跳过</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h5 id="1-2-2-常量计数器-iota"><a href="#1-2-2-常量计数器-iota" class="headerlink" title="1.2.2 常量计数器 iota"></a>1.2.2 常量计数器 iota</h5><p>除此之外，Go 还预定义了一个特殊的标识符 <code>iota</code> （iota 是第九个希腊字母的发音），来方便定义常量。</p>
<p><code>iota</code> 的值的变化规律是：遇到 <code>const</code> 就归零，每遇到一行常量声明（无论是否引用 <code>iota</code>）就加一。或者换句话说，<code>iota</code> 是 <code>const</code> 声明块的声明行行号（从 0 开始）。看例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a = <span class="literal">iota</span> <span class="comment">// 0</span></div><div class="line">    <span class="comment">// 空行、注释行不算</span></div><div class="line">    b = <span class="literal">iota</span> <span class="comment">// 1</span></div><div class="line">    c = <span class="number">999</span> <span class="comment">// 尽管没有引用 iota，iota 还是自增为 2</span></div><div class="line">    d = <span class="literal">iota</span> <span class="comment">// 3</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>结合 自动补全，能够大大简化一些有规律的常量声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A, B, C, D, E 五档评价</span></div><div class="line"><span class="comment">// A 最好加 2 分，C 不好不坏，E 最差 扣 2 分，以此类推</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    E = <span class="literal">iota</span> - <span class="number">2</span> <span class="comment">// 0 - 2</span></div><div class="line">    D <span class="comment">// 1 - 2</span></div><div class="line">    C <span class="comment">// 2 - 2</span></div><div class="line">    B <span class="comment">// 3 - 2</span></div><div class="line">    A <span class="comment">// 4 - 2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 声明 一个字节上 每个比特位的掩码</span></div><div class="line"><span class="comment">// 涉及左位移操作，有兴趣可以自行查阅位操作的知识，后续有机会再展开</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    mask0 <span class="keyword">uint8</span> = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></div><div class="line">    mask1</div><div class="line">    mask2</div><div class="line">    mask3</div><div class="line">    mask4</div><div class="line">    mask5</div><div class="line">    mask6</div><div class="line">    mask7</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    a = <span class="literal">iota</span> <span class="comment">// 0</span></div><div class="line">    b <span class="comment">// 1</span></div><div class="line">    _ <span class="comment">// 可以用空标识符跳过，这里 iota 为 2</span></div><div class="line">    c <span class="comment">// 3</span></div><div class="line">    d, e = <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// 都是 4</span></div><div class="line">    f, g <span class="comment">// 都是 5</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>这样声明还有一个好处：有些常量对具体的值没有要求，但是要求一组常量之间总是保持一个先后关系；用 <code>iota</code> 声明，就不需要一个一个手动输入后续的值；而当需要加入新的常量时，直接插入中间，后续的值会自动后延。</p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p>因为常量要在编译期确定，而且后续无法修改，所以无法保存在运行时运算得到的值，也无法在运行过程中对值进行修改。这时就需要用到变量了。</p>
<p>变量（variable，关键字 <code>var</code>），本质上是 <strong>一个关联了标识符（命名）的储存地址，用来保存 允许运行时确定或者改变的值</strong>。稍复杂一点的程序，都很难不使用中间结果直接运算出最终结果，变量允许我们 储存、引用、修改 中间结果，把复杂的运算层层分解成简单运算，再把中间结果拼接成最终结果。所以变量是实际编程最常打交道的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">    <span class="comment">// 1. 仅声明，变量被初始化为类型对应的零值，这里 int 的零值为 0</span></div><div class="line">    a <span class="keyword">int</span></div><div class="line">    <span class="comment">// 2. 声明同时赋初始值</span></div><div class="line">    b <span class="keyword">float32</span> = <span class="number">3.14</span></div><div class="line">    <span class="comment">// 3. 类型推断</span></div><div class="line">    <span class="comment">// c 的类型跟 b 一致</span></div><div class="line">    c = b</div><div class="line">    <span class="comment">// d 的类型根据字面量 3.14 推断为 float64（下面讲为什么）</span></div><div class="line">    d = <span class="number">3.14</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    s := <span class="string">"局部变量可以使用 短声明"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 Go 的局部变量还有两个常量和全局变量没有的特点：</p>
<ul>
<li>可以使用短声明；</li>
<li>声明了必须使用。</li>
</ul>
<h4 id="2-1-短声明"><a href="#2-1-短声明" class="headerlink" title="2.1 短声明"></a>2.1 短声明</h4><p>前面在语法与风格部分有提到，可以省略常量和变量声明中的类型，让编译器根据赋值的字面量推断类型。</p>
<p>而局部变量还能更进一步，把 <code>var</code> 关键字也省略掉，改用短声明赋值符号 <code>:=</code> （就是冒号后面紧接等号），表示声明同时赋值的语义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 局部变量是指在函数或者代码块内部声明的变量，与之对应的是全局（包级）变量</span></div><div class="line"><span class="comment">// 只有局部变量可以使用短声明</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 1. 完整声明，赋值不是必须的；如果不赋值，则初始化为零值</span></div><div class="line">    <span class="keyword">var</span> a <span class="keyword">int</span></div><div class="line">    <span class="comment">// 2. 类型推断，根据赋值推断类型</span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">3.14</span></div><div class="line">    <span class="comment">// 3. 短声明，连 var 关键字也省略</span></div><div class="line">    c := <span class="string">"声明一个变量 c，同时根据赋值推断类型"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是严格来说，短声明跟 <code>var</code> + 类型推断还是有区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function2</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// var + 类型推断</span></div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span></div><div class="line">    <span class="keyword">var</span> a, b = <span class="number">2</span>, <span class="number">3</span> <span class="comment">// 报错，a 被重复声明了</span></div><div class="line">    </div><div class="line">    <span class="comment">// 短声明</span></div><div class="line">    x := <span class="number">2.78</span></div><div class="line">    x := <span class="number">3.14</span> <span class="comment">// 报错，x 被重复声明了</span></div><div class="line">    x, y := <span class="number">3.14</span>, <span class="string">"不会报错，短声明的左边只要至少声明了一个新变量即可"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>var</code> 关键字后面跟着的，都必须是新声明的变量；而短声明则意味着『至少声明了一个新变量』，不需要都是新变量。这种特性加上局部变量遮盖（shadow），容易产生一些非常难以察觉的错误，所以短声明要谨慎使用：</p>
<ul>
<li>引用范围很广，引用位置距离声明比较远的变量，不要用短声明；</li>
<li>除非是用完即弃的临时变量，不要用短声明同时声明 / 赋值 多个变量。</li>
</ul>
<h4 id="2-2-局部变量未使用错误"><a href="#2-2-局部变量未使用错误" class="headerlink" title="2.2 局部变量未使用错误"></a>2.2 局部变量未使用错误</h4><p>Go 不允许局部变量定义了却不使用。这是一个编译错误，不是警告。常量 和 全局（包级）变量 无此限制，只有局部变量有。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function3</span><span class="params">()</span></span> &#123;</div><div class="line">    a := <span class="number">2</span> <span class="comment">// 编译错误：'a declared but not used'</span></div><div class="line">    a = <span class="number">3</span> <span class="comment">// 赋值（写）不算，必须是引用了变量的值</span></div><div class="line">    </div><div class="line">    b := <span class="number">6.18</span></div><div class="line">    <span class="comment">// 以下任意一种都算对 b 有效使用</span></div><div class="line">    c := b <span class="comment">// 赋值给其它变量；不过这时 c 如果不用又要报错了</span></div><div class="line">    b + <span class="number">1</span> <span class="comment">// 作为表达式的一部分；不过这时 b + 1 作为一个整体 'is not used'</span></div><div class="line">    fmt.Println(b) <span class="comment">// 作为函数参数</span></div><div class="line">    _ = b <span class="comment">// 赋值给空标识符也算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-作用域（scope）-与-遮盖（shadow）"><a href="#3-作用域（scope）-与-遮盖（shadow）" class="headerlink" title="3. 作用域（scope） 与 遮盖（shadow）"></a>3. 作用域（scope） 与 遮盖（shadow）</h3><p>无论 常量 还是 变量，都不允许重复声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">777</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">888</span> <span class="comment">// 重复声明</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="number">3.14</span></div><div class="line"><span class="keyword">var</span> b = <span class="number">3.1415</span> <span class="comment">// 重复声明</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">    c := <span class="string">"第一次声明"</span></div><div class="line">    c := <span class="string">"重复声明，报错"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是以下代码却是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">777</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="number">3.14</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">const</span> a = <span class="number">888</span> <span class="comment">// 正常</span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">3.1415</span> <span class="comment">// 正常</span></div><div class="line">    fmt.Println(a, b) <span class="comment">// 888 3.1415</span></div><div class="line"></div><div class="line">    c := <span class="string">"外部 c"</span></div><div class="line">    <span class="comment">// 这个 if 随便写的，纯粹为了制造一个新的代码块，switch、for 代码块也一样</span></div><div class="line">    <span class="keyword">if</span> b &gt; <span class="number">0</span> &#123;</div><div class="line">        c := <span class="string">"if 代码块里的 c"</span></div><div class="line">        fmt.Println(c) <span class="comment">// if 代码块里的 c</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(c) <span class="comment">// 外部 c</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">otherFunc</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 外部常量 / 变量的值并没有被覆盖</span></div><div class="line">    fmt.Println(a, b) <span class="comment">// 777 3.14</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是因为常量 / 变量有作用域。第二个例子里面，后声明的 <code>a, b, c</code> 实际上是 <strong>不同作用域下的新常量 / 变量</strong>，所以不会产生『重复声明』的错误，它们可以同时存在。</p>
<p>而在引用的时候，会从引用位置的作用域开始往外查找，引用最近作用域的值。一旦更内层的作用域声明了新的 常量 / 变量，外部的值就无法引用到，这种情况称为 遮盖（shadow，又译作 遮挡、隐藏）。</p>
<p>多数语言都是这样的设计。但是在 Go 里，遮盖 跟 变量短声明 放在一起，很容易产生不起眼的错误。先看正常的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    result := <span class="number">0</span></div><div class="line">    <span class="comment">// 省略一些中间过程</span></div><div class="line">    result, success := tryPerform() <span class="comment">// 只有 success 是新声明的变量</span></div><div class="line">    <span class="keyword">if</span> !success &#123;</div><div class="line">        <span class="comment">// 失败时的处理</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(result) <span class="comment">// 42</span></div><div class="line">    <span class="comment">// 后续用 result 参与其它运算...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryPerform</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// 如果执行成功，返回 运算结果 和 true</span></div><div class="line">    <span class="comment">// 否则 返回 0 和 false</span></div><div class="line">    <span class="comment">// 这里为了简化逻辑，直接返回固定值</span></div><div class="line">    <span class="keyword">return</span> <span class="number">42</span>, <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后很自然地，随着其他代码的加入， <code>main</code> 函数改成了这样（<code>tryPerform</code> 函数不变）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    result := <span class="number">0</span></div><div class="line">    <span class="comment">// 尝试其它操作，结果保存在 result</span></div><div class="line">    <span class="comment">// result = ...</span></div><div class="line">    <span class="comment">// 这里假设 0 表示无效结果，还得继续尝试</span></div><div class="line">    <span class="keyword">if</span> result == <span class="number">0</span> &#123;</div><div class="line">        result, success := tryPerform() <span class="comment">// 注意，两个都是新变量，result 发生了 shadow</span></div><div class="line">        <span class="keyword">if</span> !success &#123;</div><div class="line">            <span class="comment">// 失败时的处理</span></div><div class="line">        &#125;</div><div class="line">        fmt.Println(result) <span class="comment">// 内层 result，42</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(result) <span class="comment">// 外层 result，还是 0</span></div><div class="line">    <span class="comment">// 后续用 result 参与其它运算都是错的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键是，这个错误编译器无法检查出来，因为 <code>:=</code> 有歧义，在声明多个变量时，同时混合了 <strong>赋值</strong> 和 <strong>声明</strong> 的语义。在第一份代码中，<code>result</code> 已经存在，同时新变量 <code>success</code> 满足了短声明至少声明一个新变量的要求，所以短声明『很聪明』地理解了 <code>result</code> 只是要赋值。当因为某些修改，创建新的作用域时，在这个作用域内 <code>result</code> 还没被声明（尽管可以访问到外层的 <code>result</code>），短声明又『很聪明』地声明了新的 <code>result</code> 。</p>
<p>这导致超出预期的行为。</p>
<p>解决办法也很简单：<strong>大跨度（特别是跨作用域）使用的变量，不要用短声明，老老实实用 <code>var</code> 关键字</strong>。<code>var</code> 很明确地告诉我们，是新声明的变量，没有 <code>var</code> 则只是赋值。视觉上，<code>var</code> 关键字比等号前的冒号好辨认；语义上不存在歧义，编译器很容易发现错误。</p>
<p>需要特别提醒一下的是，在代码块开头声明的变量，作用域也限于代码块内，哪怕声明位置在花括号 <code>{}</code> 以外：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> result, ok := tryPerform(); !ok &#123;</div><div class="line">        <span class="comment">// 失败处理</span></div><div class="line">        fmt.Println(result) <span class="comment">// 正常</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(result) <span class="comment">// result 未声明</span></div><div class="line">    </div><div class="line">    <span class="comment">// for 循环等代码块也一样</span></div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">        <span class="comment">// 循环体</span></div><div class="line">        fmt.Println(i) <span class="comment">// 正常</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(i) <span class="comment">// i 未声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果变量在代码块之后还需要引用，就应该在代码块之外事先声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// i 在 for 代码块之前声明</span></div><div class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</div><div class="line">        <span class="comment">// 循环体</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(i) <span class="comment">// 11</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-类型、推断与转换"><a href="#4-类型、推断与转换" class="headerlink" title="4. 类型、推断与转换"></a>4. 类型、推断与转换</h3><p>Go 是静态强类型（static strongly typed）语言。换句话说，Go 的类型是编译期确定的（静态），而且需要显式的类型转换（强类型）。在这个基础上，Go 又引入了类型推断（隐式类型 implicity typed，但类型仍然是在编译期可以推导得到，运行时不允许修改，仍然是静态强类型），加上 常量 和 变量 的处理不一样，显得好像有点复杂。下面梳理一下。</p>
<p>字面量、常量 和 变量 放在这里一起讲，做个对比。</p>
<p><strong>Go 有两种意义上类型</strong> ：</p>
<ul>
<li><p>一个是显式的类型 <code>type</code> 。</p>
<p>  它可以在声明时指定，也可以在赋值时推断出来。在绝大多数语境下，<strong>当我们提到『类型  type』这个术语，说的就是这个类型。没有指定类型称为无类型 <code>untyped</code></strong> 。</p>
</li>
<li><p>一个是编译器根据 字面量 或 表达式的值 推断得到的 <strong>常量专用类型</strong>  <code>Ctype</code> （constant type 的缩略）。</p>
<p>  编译器源码里的注释是：</p>
<blockquote>
<p>Ctype describes the constant kind of an “ideal” (untyped) constant.</p>
</blockquote>
<p>  翻译过来就是：Ctype 描述了一个理想情况下的（无类型）常量的常量种类。</p>
<p>  换言之，<code>Ctype</code> 是 <code>untyped</code> 常量（包括字面量）特有的，是作为没有显式 <code>type</code> 时的补充的隐式类型。一个值允许在逻辑上没有类型，也就是无类型 <code>untyped</code> ；但这个值又有储存、运算 的需要，所以编译器就给它推断一个 <code>Ctype</code> （和对应的默认 <code>type</code>）。</p>
</li>
</ul>
<p>一个常量，如果显式指定了 <code>type</code>，就没有 <code>Ctype</code>  的事；如果没有指定，则根据绑定的值确定，究竟是有类型 <code>type</code> 还是无类型 <code>untyped Ctype</code>。</p>
<p>对于绝大多数类型，这两者差别不大，只是 <code>untyped</code> 逻辑上没有类型，允许自动转换（当然还需要满足转换规则，除数字类型以外的类型，都必须底层类型一致才能转换），一般的使用没有差别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">bool</span> = <span class="literal">true</span> <span class="comment">// a 的类型是 bool；true 本身的类型是 untyped bool （后面的 bool 是 Ctype）</span></div><div class="line">    aa     = a <span class="comment">// aa 虽然没有指定类型，但跟 a 一样，类型是 bool</span></div><div class="line">    b      = <span class="literal">true</span> <span class="comment">// b 没有指定类型，类型是 untyped bool</span></div><div class="line">    bb     = b <span class="comment">// bb 和 b 都没有指定类型，类型是 untyped bool</span></div><div class="line">    </div><div class="line">    c <span class="keyword">string</span> = <span class="string">"有类型"</span> <span class="comment">// c 的类型是 string</span></div><div class="line">    d        = <span class="string">"无类型"</span> <span class="comment">// d （以及两个字符串字面量）的类型是 untyped string</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>a  和 b（以及 aa、bb），c 和 d， 在语义上有差别，但不涉及类型转换的话，使用上完全没差别。</p>
<p>因为不同的数字类型之间允许转换，<code>type</code> 和 <code>Ctype</code> 的差异 <strong>主要体现在数字类型上。</strong></p>
<p>因为还没讲到，先稍微列一下数字类型：</p>
<p><img src="../../images/golang-in-action-day2/number-type.png" alt=""></p>
<p>其中特殊类型里，<code>byte</code> 是 一个字节的 ASCII 字符（<code>uint8</code> 的别名）， <code>rune</code> 是四个字节的 Unicode 字符（<code>int32</code> 的别名），可以归为字符类型；<code>uintptr</code> 实际上也是一个整型，只是这个数字表示一个内存地址。</p>
<table>
<thead>
<tr>
<th>大类</th>
<th>type</th>
<th>Ctype（默认 type / 储存宽度）</th>
</tr>
</thead>
<tbody>
<tr>
<td>整型</td>
<td>uint8, int8, uint16, int16, uint32, int32, uint64, int64, uint, int, uintptr</td>
<td>int （int）</td>
</tr>
<tr>
<td>浮点数</td>
<td>float32, float64</td>
<td>float（float64）</td>
</tr>
<tr>
<td>复数</td>
<td>complex32, complex64</td>
<td>complex（complex64）</td>
</tr>
<tr>
<td>字符</td>
<td>byte, rune</td>
<td>rune（rune，即 int32）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>整型看起来很多类型，其实只是 有没有符号 和 位宽 的差别，下一期讲基本类型会讲。</p>
</blockquote>
<h4 id="4-1-字面量"><a href="#4-1-字面量" class="headerlink" title="4.1 字面量"></a>4.1 字面量</h4><p>字面量无法指定 <code>type</code> ，只有 <code>Ctype</code> 。</p>
<p>数字类型可以分为四个大类（kind），每个大类下面根据表示范围又可以分为很多个类型（type）。每个大类对应一个 <code>Ctype</code> ，同时对应一种默认的 <code>type</code> 。<strong>字面量会根据表示形式，自动推断为对应的 <code>Ctype</code> ，并以默认类型储存。</strong></p>
<h5 id="整型数"><a href="#整型数" class="headerlink" title="整型数"></a>整型数</h5><p>整型数字面量会被推断为 <code>untyped int</code> ，默认类型为 <code>int</code> （<code>int</code> 的位宽与架构相关，64 位系统为 64 位，32 位系统为 32 位）。</p>
<p>以下字面量都被认为是整型数（二进制和八进制从 1.13 开始支持）：</p>
<ul>
<li>十进制整数（即没有小数部分），如 <code>159</code> 。</li>
<li>二进制整数，为了区分以 <code>0b</code> 或 <code>0B</code> 开头（大写有效，但 <code>gofmt</code> 会自动格式化为小写，下同），如  <code>0b10011111</code> （即十进制 159）。</li>
<li>八进制整数，以 <code>0</code> 、 <code>0o</code> 或 <code>0O</code> 开头，如 <code>0o237</code> （即十进制 159）。</li>
<li>十六进制整数，以 <code>0x</code> 或 <code>0X</code> 开头，如  <code>0x9f</code> （即十进制 159）。</li>
</ul>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>浮点数字面量会被推断为 <code>untyped float</code> ，默认类型则为 <code>float64</code> 。</p>
<p>浮点数的字面量形式有：</p>
<ul>
<li><p>普通十进制小数，如 <code>15.9</code> ；整数和小数部分都可以为零，<code>1.0</code> 和 <code>0.0</code> 虽然 和 <code>1</code> 和 <code>0</code> 值是一样的，但是推断类型不同。</p>
</li>
<li><p>整数或者小数部分如果为零，可以省略，但不能同时省略（毕竟不能只剩下一个小数点），如 <code>.9</code> 等同于 <code>0.9</code> ， <code>1.</code> 等同于 <code>1.0</code> 。</p>
</li>
<li><p>科学记数法：十进制整数或符合前面两条的浮点数 + <code>e</code> / <code>E</code> + 十进制整数的指数，如 <code>1.59e2</code> 表示 $ 1.59 \times 10^2 $ 也就是 159，<code>314E-2</code> 表示 $ 314 \times 10^{-2} $ ，即 3.14 。 </p>
</li>
<li><p>从 1.13 开始，支持十六进制的科学记数法：十六进制的整数或小数 + <code>p</code> / <code>P</code> + 十进制整数作为指数，如 <code>15.9p7</code> 表示 $ (1 \times 16^1 + 5 \times 16^0 + 9 \times 16^{-1} ) \times 2^7 $ （即十进制的 2760）；<code>p</code> 后的指数是以 2 为底的，注意指数即使为 0 也不能省略。</p>
<p>  这种表示法用于二进制（十六进制）小数比十进制清晰简单，像 <code>0x.01p0</code> ，对应十进制的 0.00390625；一般很少用到，了解一下即可，不展开。</p>
</li>
</ul>
<h5 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h5><p>复数字面量会被推断为 <code>untyped complex</code> ，默认类型为 <code>complex128</code> 。</p>
<p>复数由实部和虚部组成。实部和虚部分别都是一个整型数或者浮点数，只是虚部后面跟着一个 <code>i</code>；实部和虚部允许用不同的进制分别表示，具体规则参考整型数和浮点数部分。只是为了兼容 1.13 以前的旧代码，虚部的八进制必须以 <code>0o</code> 或 <code>0O</code> 开头， <code>0</code> 开头会被当做十进制的前导零。</p>
<p>例如 <code>159 + 7i</code> ，实部 159，虚部 7；<code>0111 + 010i</code> 实部为 73（八进制），虚部为 10；等等。实部如果为零，可以省略；但虚部不可以省略：<code>0i</code> 会被认为是复数，<code>0</code> 和 <code>0.0</code> 则分别被认为是 整型数 和 浮点数——尽管它们都是零值，值是相等的。</p>
<p><br></p>
<p>从数学上讲，浮点数（小数）是复数的特例（虚部为 0）；整型数则是浮点数的特例（小数部分为 0）。但是从计算机更有效储存和运算的角度，需要把它们区分开来，一直为 0 的部分，就不必开辟储存空间。</p>
<p>从 1.13 开始，允许在数字中间加下划线 <code>_</code> 作为分段符来提升字面量的可读性。按英文惯例每三位加一个分段符，那么 十万八千 就写作 <code>108_000</code> ；对于十六进制数，一般每两位（一个字节）作为一个分段，如 <code>0x_15_ef</code>。当然这只是惯例，也可以根据需要分段。分段符每次只能加一个，只能加在数字之间或者进制前导符和数字之间。这个实际试一下就知道了。</p>
<h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><p>字符字面量会被推断为 <code>untyped rune</code> ，默认类型为 <code>rune</code>。</p>
<p>两种字符类型只是两种整型数的别名。</p>
<blockquote>
<p>字符及字符串相关部分会涉及到字符编码的知识，篇幅关系，不一一展开。初学者如果觉得难以理解，可以先跳过，先使用普通字符字面量。</p>
</blockquote>
<p><code>byte</code> 对应 <code>uint8</code> ，储存的是 1 字节长度的 Unicode 码（相当于 Unicode 开头 ASCII 码加上 Latin-1 辅助字符部分）；</p>
<p><code>rune</code> 对应 <code>int32</code> ，储存的是一个 4 字节长度的 Unicode 码。</p>
<p>字符型的字面量均以单引号 <code>&#39;</code> 包裹，形式有：</p>
<ul>
<li><p>普通字符，如 <code>&#39;a&#39;</code> （十进制码值 97），<code>&#39;汉&#39;</code> （十进制码值 27721，十六进制 0x6c49）。</p>
</li>
<li><p>码值转义，又分四种情况：</p>
<ul>
<li><code>\</code> 后接 3 位八进制数，前导零不能省略，如 <code>&#39;\141&#39;</code> 对应十进制码值为 97，即 <code>&#39;a&#39;</code> ；<code>&#39;\041&#39;</code> 对应十进制码值 33，即 <code>&#39;!&#39;</code> ，不能写作 <code>&#39;\41&#39;</code> ；3 位八进制数最大能表示十进制的 511，但由于这种表示法用来表示 1 字节的 Unicode，大于 377  （即十进制 255）的值均无效。</li>
<li><code>\x</code> 后接 2 位十六进制数，前导零不能省略，表示 1 字节长度的 Unicode，<code>&#39;a&#39;</code> 表示为 <code>&#39;\x61&#39;</code> 。</li>
<li><code>\u</code> 后接 4 位十六进制数，前导零不能省略，表示 2 字节长度的 Unicode （或者说高 2 位为 0 的 4 字节 Unicode），<code>&#39;a&#39;</code> 表示为 <code>&#39;\u0061&#39;</code> ；这个范围已经可以表示大部分的常用汉字了（严格说是『中日韩统一表意文字』的 初期统一汉字 + 扩展 A 区），如 <code>&#39;汉&#39;</code> 表示为 <code>&#39;\u6C49&#39;</code> 。</li>
<li><code>\U</code> （大写 U）后接 8 位十六进制数，前导零不能省略，表示完整 4 字节的 Unicode ，这个范围已经可以表示绝大多数的 Unicode 字符了（Unicode 标准仍在扩展中）， <code>&#39;a&#39;</code> 表示为 <code>&#39;\U00000061&#39;</code> ，<code>&#39;汉&#39;</code> 表示为 <code>&#39;\U00006C49&#39;</code> 。</li>
</ul>
</li>
<li><p>如果 <code>\</code> 后面接的字符不是 数字、<code>x</code> 、<code>u</code> 或 <code>U</code> ，则被当做转义字符。转义字符实际上是常用的不可见字符的表示方式，避免记忆 Unicode 码值，常见的转义有：</p>
<ul>
<li><code>&#39;\b&#39;</code> 退格符（backspace），对应 <code>&#39;\x08&#39;</code> ，作用是光标往左一个字符，有些情况下意味着删除一个字符；</li>
<li><code>&#39;\n&#39;</code> 换行符（newline），对应 <code>&#39;\x0A&#39;</code> ，作用是光标往下一行；</li>
<li><code>&#39;\r&#39;</code> 回车符（carriage return），对应 <code>&#39;\x0D&#39;</code> ，作用是光标回到行首；</li>
<li><p>……</p>
<p>比较特殊的是 <code>&#39;\\&#39;</code> 和 <code>&#39;\&#39;&#39;</code> ，就表示 <code>\</code> 和 <code>&#39;</code> ，并非不可见字符；但由于单个符号有特殊含义，必须转义才能原义输出。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>以上内容总结起来就是：数字类型的字面量，根据具体形式，会被推断为 4 种 <code>Ctype</code> ，并按范围最大的类型作为默认类型储存（整型除外，<code>int</code> 不能包含整型的最大范围）。</p>
<h5 id="值溢出（overflow）"><a href="#值溢出（overflow）" class="headerlink" title="值溢出（overflow）"></a>值溢出（overflow）</h5><p>超出默认类型范围的值，会引起溢出错误，无法储存和使用。整型比较特殊，默认底层类型是 <code>int</code> ：在 64 位系统为 64 位有符号数，<code>1 &lt;&lt; 63</code> 到 <code>1 &lt;&lt; 64 -1</code> 之间的数可以以 <code>uint64</code> 储存；在 32 位系统为 32 位有符号数，<code>uint32</code> 、<code>int64</code> 、<code>uint64</code> 都有超出 <code>int</code> 的范围；当然如果连 <code>int64</code> （负数最大范围）和 <code>uint64</code> （正数最大范围）都超了，还是只能溢出。</p>
<p>网上有教程说，<strong>字面量（和常量）不限范围，这种说法是错的</strong>。他们的依据是以下的代码可以正常编译运行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 超出了 int 的最大值 1 &lt;&lt; 63 - 1 （64 位系统）</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 其它操作，唯独没有引用 a</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子里，如果看了生成的汇编代码就会发现，<code>a</code> 和 <code>1 &lt;&lt; 64 - 1</code> 都不见了。因为编译器很聪明地发现，<code>a</code> 没有被引用到，在编译时就把它们优化删除掉了，所以没有报错。</p>
<p>还有这个例子也可以正常运行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 超出了 int 的最大值 1 &lt;&lt; 63 - 1 （64 位系统）</span></div><div class="line">    b = a &gt;&gt; <span class="number">2</span> <span class="comment">// 等价于 b = 1 &lt;&lt; 62</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了汇编结果就会知道，编译器实际上把上面的代码里的 <code>a</code> 优化掉了，<code>b</code> 绑定的值变成了 <code>4611686018427387904</code> （<code>1 &lt;&lt; 62</code>）。</p>
<p>换言之，<strong>溢出的字面量只能存在于代码里，而且溢出值不能超出显式类型范围，不能被直接引用</strong> 。如果这个溢出的值，经过编译器求值之后发现，是一个可以优化的中间值，实际上没有被引用，编译器就不会报错；反之，如果有溢出值被引用到了，或者虽然没有直接引用溢出值，但超出了显式类型的范围，就会报 overflow：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 字面量被自动推断为 untyped int，报错 1 &lt;&lt; 64 - 1 (untyped int constant 18446744073709551615) overflows int</span></div><div class="line">    fmt.Println(<span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span>)</div><div class="line">    <span class="comment">// 显式转换为 uint64 后正常</span></div><div class="line">    fmt.Println(<span class="keyword">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span>))</div><div class="line"></div><div class="line">    <span class="comment">// 1&lt;&lt;64 连 uint64 的范围也超出了，报错 cannot convert uint64</span></div><div class="line">    fmt.Println(<span class="keyword">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span>))</div><div class="line">    <span class="comment">// float32 又可以了</span></div><div class="line">    fmt.Println(<span class="keyword">float32</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span>))</div><div class="line"></div><div class="line">    <span class="keyword">const</span> a <span class="keyword">int8</span> = <span class="number">128</span> <span class="comment">// 报错！虽然 a 会被优化掉，但因为指定了类型，超出显式类型范围可能隐藏着错误</span></div><div class="line">    <span class="keyword">const</span> b = a / <span class="number">2</span> <span class="comment">// b 的类型也是 int8，128 / 2 = 64 可以存得下</span></div><div class="line">    fmt.Println(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于转换，在下面会提到。</p>
<h4 id="4-2-常量"><a href="#4-2-常量" class="headerlink" title="4.2 常量"></a>4.2 常量</h4><p>（有名）常量则有可能有 <code>type</code> ，也可能无类型只有 <code>Ctype</code> 。</p>
<p>常量在声明时：</p>
<ul>
<li>没有指定 <code>type</code> ，常量的类型跟绑定的值一致，前面用 <code>bool</code> 和 <code>untyped bool</code> 、<code>string</code> 和 <code>untyped string</code> 举过例子；</li>
<li>指定了 <code>type</code> ，如果跟绑定的右值类型不一致，就涉及到转换；如果无法转换，就报错。</li>
</ul>
<p>常量被引用时，类型与所需类型不一致，就需要转换，这时要看常量的类型。</p>
<h5 id="无类型（untyped）"><a href="#无类型（untyped）" class="headerlink" title="无类型（untyped）"></a>无类型（untyped）</h5><p>Go 是强类型语言，必须显式转换类型，但这仅限于类型确定 <code>typed</code> 的情况，<code>untyped</code> 会隐式转换。<strong>常量的转换跟变量不同，要求值要相等</strong>。只要一个 <code>untyped</code> 值可以以另一种类型表示，编译器会做自动的隐式转换；但转换过程中不允许有任何溢出（和因此导致的截取（truncated））；而浮点数除了溢出，还有精度丢失，浮点数之间的转换中允许精度丢失。</p>
<p>溢出和精度丢失的差别，用一个简化的十进制字符串的例子来说明：</p>
<p>假定我们用一个长度为 8 的字符串储存一个小数，符号和小数点不能省略，那么可以表示的最大和最小的数分别是 “+999999.” 和 “-999999.” ，比前者大就是上溢出，比后者小就是下溢出。与此同时，最小精度（非零绝对值最小）是 “+.000001” ，比这更小的值无法表示。1000000（6 个 0）要转换为 “+000000.” 保存是溢出后截取低位，0.1234567 转换为 “+.123456” 保存则是精度丢失。</p>
<p>浮点数的二进制指数表示比这个复杂，还涉及到编码和进制转换，但溢出和精度丢失的原理是一致的。一句话总结就是，精度范围内超出是溢出，精度范围以外超出是精度丢失。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 整型</span></div><div class="line">    a        = <span class="number">1.0</span> <span class="comment">// a 为 untyped float，默认类型是 float64</span></div><div class="line">    b <span class="keyword">int</span>    = a <span class="comment">// 1.0 可以无截取转换为 int 类型 1，类型自动转换</span></div><div class="line">    c <span class="keyword">int</span>    = <span class="number">1.1</span> <span class="comment">// 报错！转换到 int 类型不允许截取整数部分丢弃小数</span></div><div class="line">    d <span class="keyword">int</span>    = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 报错！范围上溢出</span></div><div class="line">    e <span class="keyword">uint64</span> = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 正常</span></div><div class="line">    </div><div class="line">    f      = <span class="number">128</span> <span class="comment">// untyped int</span></div><div class="line">    g <span class="keyword">int8</span> = f <span class="comment">// 报错！上溢出， int8 的最大值为 127，即使 g int8 = int8(f) 显式转换也不行</span></div><div class="line">    </div><div class="line">    <span class="comment">// 浮点数</span></div><div class="line">    <span class="comment">// 注: float64 的最大值是 1.797693134862315708145274237317043567981e+308</span></div><div class="line">    h <span class="keyword">float64</span> = <span class="number">1.8e308</span> <span class="comment">// 报错！上溢出</span></div><div class="line">    i         = <span class="number">1.8e308</span> <span class="comment">// 也报错！类型为 untyped float，默认类型就是 float64</span></div><div class="line">    j         = <span class="number">1.79769313486231581e+308</span> <span class="comment">// 报错！上溢出</span></div><div class="line">    k         = <span class="number">1.7976931348623158e+308</span> <span class="comment">// 正常，但是后面部分在二进制上已经超出精度范围，超出部分已丢弃， k 的值 跟 float64 的最大值一样</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>从十进制角度看，浮点数在某一位左边就是溢出，右边就是精度丢失，会非常费解。因为实际上这些数是以二进制保存的，从二进制的角度看就会顺理成章。这里不展开，有兴趣的朋友可以自己去看 IEEE-754 的标准。</p>
<p>一般程序不容易超出这些范围，但还是需要知道范围的存在。<code>math</code> 包有一系列常量给出了不同数字类型的最小值（MinXXX）、最大值（MaxXXX）和浮点数的最小小数（SmallestXXX）。如果涉及大数运算和对精度有特殊需求，则需要用到 <code>math/big</code> 包。</p>
<p>理解 整型数 和 浮点数 的转换之后，复数 和 字符 也很好理解。</p>
<p>复数的实部和虚部分别是一个浮点数，复数之间的转换可以直接参考浮点数。虚部为 0 的复数可以向浮点数自动转换，实部如果没有小数部分还能向整型转换；但是虚部不为 0 不能被截断（truncated）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a         = <span class="number">256</span> + <span class="number">0i</span> <span class="comment">// untyped complex</span></div><div class="line">    b         = a <span class="comment">// 还是 untyped complex</span></div><div class="line">    c <span class="keyword">float64</span> = a <span class="comment">// 虚部为 0，自动转换</span></div><div class="line">    d <span class="keyword">int</span>     = a <span class="comment">// 实部的小数部分也为 0，可以转换为 int</span></div><div class="line">    </div><div class="line">    e <span class="keyword">float64</span> = <span class="number">256</span> + <span class="number">1i</span> <span class="comment">// 虚部不为 0，无法截断为浮点数</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>字符则本质上就是整型，只是字面量形式不同：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 以下的自动转换都是合法的</span></div><div class="line">    a <span class="keyword">int</span>  = <span class="string">'a'</span> <span class="comment">// 97</span></div><div class="line">    b <span class="keyword">byte</span> = <span class="number">97</span> <span class="comment">// 也是 97，只是 用 %c 动词作为字符格式化会得到 a</span></div><div class="line">    </div><div class="line">    c <span class="keyword">int</span>   = <span class="string">'汉'</span> <span class="comment">// 27721</span></div><div class="line">    d <span class="keyword">rune</span>  = <span class="number">27721</span> <span class="comment">// 也是 27721，只是作为字符输出会得到 汉</span></div><div class="line">    e <span class="keyword">int16</span> = <span class="string">'汉'</span> <span class="comment">// '汉' 虽然是一个 rune（即 int32）字面量，但是 27721 没有超出 int16 的范围</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h5 id="确定类型（typed）"><a href="#确定类型（typed）" class="headerlink" title="确定类型（typed）"></a>确定类型（typed）</h5><p>自动转换限于 <code>untyped</code> ，如果一个常量已经指定了类型，那么哪怕值满足了转换条件，也必须显式转换；而且在显式转换中，值仍然要保持相等（显式转换是 <code>T(src)</code> ，T 是目标类型，src 是来源值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">int16</span> = <span class="number">128</span> <span class="comment">// 明确给 a 指定了类型，不是 untyped int 了</span></div><div class="line">    b       = a <span class="comment">// b 的类型也是 int16</span></div><div class="line">    c <span class="keyword">int32</span> = a <span class="comment">// 报错！cannot use int16 as int32，尽管 int32 存 int16 完全存得下</span></div><div class="line">    d <span class="keyword">int32</span> = <span class="keyword">int32</span>(a) <span class="comment">// 显式转换，正常</span></div><div class="line">    e       = <span class="keyword">int32</span>(a) <span class="comment">// 反正都显式转换类型了，左边的类型声明可以省略</span></div><div class="line">    f       = <span class="keyword">int8</span>(a) <span class="comment">// 报错！显式转换也不行，int8 最大值是 127，常量不能截取值的一部分</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3 变量"></a>4.3 变量</h4><p>变量一定有显式的类型 <code>type</code> ，不存在 <code>untyped</code> 的变量。</p>
<p>变量声明时，类型可以指定，也可以推断；如果声明时没有指定 <code>type</code> ，则类型跟赋值的右值一致；如果右值是 <code>untyped</code> 常量，则类型是对应的默认类型（而不是 <code>Ctype</code> ，数字类型的默认类型分别是 <code>int</code> ，<code>float64</code>，<code>complex128</code>，<code>rune</code>）。</p>
<p>跟常量类似，变量被引用时也会出现与需要的类型不一致，需要转换类型：</p>
<ul>
<li><p>由于变量一定有确定类型 （<code>typed</code>），只能是显式转换。</p>
</li>
<li><p>非常量（包括变量）的转换允许溢出也允许精度丢失：</p>
<ul>
<li>整型（包括字符型）在高位宽向低位宽类型转换时如果溢出，直接丢弃高位保留低位，如 256（二进制 100000000，8 个 0）向 <code>int8</code> 转换时，保留低 7 位（去掉一位符号位，<code>int8</code> 数字位只有 7 位），得到 0 。</li>
<li>浮点数转整型，直接丢弃小数部分（绝对值变小）；如果得到的整型还是溢出，参考上一条继续转换；如 257.1 向 <code>int8</code> 转换，得到 1。</li>
<li>整数或浮点数转浮点数，允许发生精度丢失，如 <code>1&lt;&lt;64 - 1</code> （18446744073709551615，最大的 <code>uint64</code>）转 <code>float32</code> 得到 <code>1.8446744e+19</code> ，73709551615 丢失。</li>
<li><strong>非常量的复数不允许直接转换成其他数值类型</strong>，只能通过内置函数 <code>real()</code> 和 <code>imag()</code> 提取实部和虚部；复数之间转换，实部和虚部分别是一个浮点数，跟浮点数之间的转换一致，也允许精度丢失。</li>
<li>除整型以外的转换，如果来源值溢出目标范围，结果不确定，依赖于具体的编译器实现；目前我测试的版本（1.15）是会产生无穷值（浮点数是 <code>+Inf</code>  和 <code>-Inf</code> ，复数则是具体实部或虚部是无穷）。</li>
</ul>
</li>
</ul>
<h4 id="4-4-其它情况"><a href="#4-4-其它情况" class="headerlink" title="4.4 其它情况"></a>4.4 其它情况</h4><p>注意到我在提到变量的转换时，提到了『非-常量』（注意断句），而不是直接说变量。</p>
<p>难道还存在常量和变量以外的量？是的。</p>
<p>首先是前面提到的，可以在编译期求值的 表达式 和 内置函数的返回值，实际使用上跟字面量一致，差别是 字面量一定是 <code>untyped</code> 的，而这种值视乎具体情况，有可能是有类型的。不过 <strong>转换规则仍然跟常量一致，差别仅仅是没有标识符，算广义的常量</strong>：</p>
<ul>
<li><p>仅引用了字面量 / 常量的 内置函数返回值，如 <code>len(&quot;1234&quot;)</code> ，字符串 <code>&quot;1234&quot;</code> 是字面量，<code>len()</code> 是内置函数，字符串的长度在编译期就可以算出来是 4，这个值在编译的时候就会替换掉函数；但类型受函数返回值影响为 <code>int</code> ，跟 <code>4</code> 这个整型字面量的 <code>untyped int</code> 仍然有差别（有了确定类型就不能自动转换）。</p>
<p>  相对地，如果 <code>a</code> 不是常量，那么 <code>len(a)</code> 就不能在编译期求值了；内置函数则是指不需要导入就可以调用的函数，<code>math.Abs()</code> 这样还要导入的函数不算（尽管是官方库）。</p>
</li>
<li><p>仅引用了字面量 / 常量的 表达式的值，如 <code>1 + 2 + 3</code> 就不必说了， <code>len(&quot;1234&quot;) + 1.1</code> 也是。</p>
<p>  类型方面，如果表达式引用了多种类型，则会往一个统一类型转换，然后以该类型运算。范围窄的向范围广的类型转，<code>untyped</code> 往 <code>typed</code> 转；如果有多个不同的 <code>type</code> ，则需要显式转换。如果无法统一类型，就会报错。如 <code>1 + 2</code> 的类型是 <code>untyped int</code> ；<code>1 + 2.0</code> 是 <code>untyped float</code> ；<code>len(&quot;1&quot;) + 1.0</code> 是 <code>int</code> ；而 <code>len(&quot;1&quot;) + 1.1</code> 会报错，因为确定类型 <code>int</code> 无法自动转换，而 <code>1.1</code> 自动转换成 <code>int</code> 会造成截取，丢弃小数。</p>
</li>
</ul>
<p>然后跟第一种情况相反，表达式或函数里出现了 <strong>非常量或者非内置函数</strong>，就无法编译期求值。它既不是常量，又没有像变量给一个内存空间，实际运行中可能会在编译器生成的临时变量或者寄存器上保存和运算。这就是前面提到的 『非-常量』。</p>
<p>不过这里只是提一下它们的存在，转换方式其实没有超出上述的情况的组合：</p>
<ul>
<li><p>看类型，如果是 <code>typed</code> 就必须显式转换；<code>untyped</code> 则可以自动转换；</p>
</li>
<li><p>看是否常量（广义的，包括字面量），是常量就必须值相等不允许值的截取；常量以外则允许值按一定规则截取。</p>
</li>
</ul>
<p>这样一组合，一共就四种情况而已，上面提到的那么多种情况都包括在内。</p>
<p>需要注意的是，当赋值时涉及转换，转换规则按 <strong>来源值</strong> 决定，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">1.1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = a <span class="comment">// a 赋值给 b 类型不一致，涉及类型转换</span></div></pre></td></tr></table></figure>
<p>就属于 <code>untyped float</code>  常量 转换为 <code>int</code> ：<code>untyped</code> 允许自动转换，但是常量决定了不能截断小数，会报错。</p>
<h4 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h4><p>到这里，想再提一下强类型的显式转换。</p>
<p>可以看到， <code>untyped</code> 的值允许自动转换。字面上的理解，就是『无类型』（尽管底层实现需要保存需要运算，带着一个默认类型）没有类型限制，值可表达为对应类型，就可以自动转换。</p>
<p>那么相对地，有类型 <code>typed</code> 的值需要显式转换（程序员主动表达意图），就是一种设计上的有意为之，让类型系统承担了一部分的逻辑表达功能。</p>
<p>因为还没讲到，解释一下自定义类型： <code>type NewInt int</code> 定义了一个自定义类型 <code>NewInt</code>，它的底层类型是 <code>int</code> ，会具有 <code>int</code> 的内置行为，并且能增加自定义行为（方法）。但是 Go 会认为它们是完全不同的两个类型，直接运算会报错，必须显式转换；当然，两个底层类型同为 <code>int</code> 的自定义类型之间也是一样。 <code>int</code> 转 <code>int8</code> 虽然都是整型，毕竟位宽不同范围不同，需要显式转换还可以理解为担心值溢出；那么 <code>int</code> 和 <code>NewInt</code> 之间的转换，就是纯粹出于行为和逻辑上的考虑。</p>
<p>举个例子，地板、砧板 两种自定义类型，底层实现都是木板。为了简化讨论，我们姑且认为是一样的木板，并没有额外的特殊加工。即使是这样，在使用中，两者还是不能搞混。如果在弱类型环境中，不去检查木板的类型，只要能用就给你用，可能出现：『这砧板怎么有个鞋印』『这地板怎么有肉沫菜叶』这样的问题。</p>
<p>自动转换的假设是，程序员清楚知道自己要做什么，编译器不应该干预增加工作量；显式转换的假设是，程序员有可能出错，编译器要帮忙检查类型的不匹配，这里面可能隐藏着逻辑错误。</p>
<p>在需要快速写个脚本、刷个算法题的时候，强类型语言像自带啰嗦严谨的老管家，一旦做了不确定的事都要确认一下，写得很不爽。但如果是维护一个大型项目，在里面人工排查类型误用引起的错误，工作量可比增加一点确认大多了，最后往往还是得引入类型检查工具——等于最后还是去雇了一个管家，那为什么不一开始就让管家参与呢？老管家并不会真的干预你做事，只是需要你额外的确认；如果特殊情况，你明确表示要用地板切菜（显式转换），他也不会拦你。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>大家不要被上面的篇幅吓到，感觉光 常量 和 变量 都这么复杂。这是把 原理、边界情况 和 容易犯的错误 都给罗列出来。有些内容一般使用很难涉及，留个印象日后碰到知道往哪个方向排查；有些内容看着复杂，实际操作一遍其实很直观——<strong>IDE 都会有提示，并不需要人肉 check</strong>，这里只是让你知道为什么会报错。另外，还有部分内容涉及到类型系统的知识，需要结合下一篇类型的介绍一起理解。</p>
<p>下面给出一系列的 常量 和 变量声明，大家可以试着判断一下，哪些会报错、为什么；合法的声明具体是什么类型，值是多少。有自信的朋友可以试着人工检查一下，暂时做不到可以把代码补全之后实际运行一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写出以下 常量 和 变量 的类型和值，或者哪些声明会报错</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    A <span class="keyword">uint8</span> = B</div><div class="line">    B       = <span class="number">255</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    a <span class="keyword">uint64</span> = A / <span class="number">2</span></div><div class="line">    b <span class="keyword">int8</span>   = B / <span class="number">2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    A := <span class="keyword">byte</span>(<span class="string">'0'</span>)</div><div class="line">    B := <span class="keyword">byte</span>(<span class="string">'1'</span>)</div><div class="line">    C := A - B</div><div class="line">    fmt.Println(C)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> a = <span class="string">'0'</span></div><div class="line">    <span class="keyword">const</span> b = <span class="string">'1'</span></div><div class="line">    fmt.Println(<span class="keyword">byte</span>(a - b))</div><div class="line"></div><div class="line">    i := <span class="number">0x1e</span>+<span class="number">2</span></div><div class="line">    j := <span class="number">1e+2</span></div><div class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ &#123;</div><div class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1</span>; j++ &#123;</div><div class="line">            <span class="comment">// 空循环体</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 现在 i, j 分别是多少</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Go语言101 / 《基本类型和它们的字面量表示》 ：<a href="https://gfw.go101.org/article/basic-types-and-value-literals.html" target="_blank" rel="external">https://gfw.go101.org/article/basic-types-and-value-literals.html</a></li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇《&lt;a href=&quot;../golang-in-action-day-1/&quot;&gt;Go 语言实战（1）： 初识&lt;/a&gt;》开了头，今天我们接着打卡。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 在 Google：服务于软件工程的语言设计（翻译）</title>
    <link href="https://jaycechant.info/2020/translation-language-design-in-the-service-of-software-engineering/"/>
    <id>https://jaycechant.info/2020/translation-language-design-in-the-service-of-software-engineering/</id>
    <published>2020-08-23T11:09:37.000Z</published>
    <updated>2020-08-30T03:14:05.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在写 Go 语言实战系列的文章，中间想聊一下 Go 的设计原则，发现自己理解得还是不够深入，写得辞不达意。然后找到了 Rob Pike 在 8 年前的演讲稿，拜读学习之后，想推荐给我的读者作为学习资料。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>结果在中文互联网只找到了 OSCHINA 上 13 年的众包翻译，再也没找到其他翻译版本。这个版本，不同译者，以及同一译者的不同段落，翻译水平差异极大：个别地方翻译得非常传神，更多时候是忠实的术语翻译，偶有生硬直译和机翻的感觉，同时也能找到一些明显的理解错误和低级的笔误。</p>
<p>总的来说，如果对 Go、C 家族语言 以及 并发、垃圾回收等 涉及的主题有一定了解，翻译的瑕疵不影响理解。译文翻译于 13 年，很早，应该对中文世界早期 Go 的推广起了一定的作用，向这些译者致谢。但是如果是刚接触编程或者 Go 语言的初学者，个别错误可能会让人看得云里雾里。</p>
<p>所以我不自量力地尝试自己翻译一遍。首先是试图提供一个质量稍微高一点点的版本（不一定能成功），其次也是希望通过这样再深入学习一遍。</p>
<p>为了符合中文的阅读习惯，在（尽量）不影响原意的前提下，一些句子（特别是长从句）的语序作了调整，个别不符合中文表达习惯的表述做了删减或者补充。文中的加粗也是我个人划的重点。水平所限，译文在（计算机）专业上和英语理解上不可避免地会有理解偏差乃至错误，存疑的地方请结合原文理解。翻译过程有借助 辞典 和 DeepL 翻译器作为参考，个别表述有借鉴 OSCHINA 版译文。</p>
</blockquote>
<p>原文：<strong>Go at Google: Language Design in the Service of Software Engineering</strong></p>
<p>地址：<a href="https://talks.golang.org/2012/splash.article" target="_blank" rel="external">https://talks.golang.org/2012/splash.article</a></p>
<p>作者：Rob Pike</p>
<p>翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）</p>
<blockquote>
<p>Rob Pike：Unix 小组成员，参与了 Plan 9 计划，1992 年和 Ken Thompson 共同开发了 UTF-8。他和 Ken Thompson 也是 Go 语言最早期的设计者。</p>
</blockquote>
<h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h2><blockquote>
<p>这是 Rob Pike 2012 年 10 月 25 日在 亚利桑那州 图森市 举行的 SPLASH 2012 会议上发表的主题演讲稿的修订版。</p>
</blockquote>
<p>我们在 Google 开发软件基础设施时遇到一些问题，针对这些问题，Go 语言在 2007 年末被构思出来。今天的计算环境与正在使用的语言（主要是 C++、Java 和 Python）创建时的环境几乎毫无关系。多核处理器、网络系统、大规模计算集群和网络编程模型所带来的问题，人们只是用变通办法暂时绕开（being worked around），而不是正面解决（addressed head-on）。另外，软件的规模也发生了变化：今天的服务器程序由数千万行代码组成，需要成百上千的程序员共同协作，并且每天都在更新。更糟糕的是，即使是在大型编译集群上，构建（build）时间也会延长到几分钟，甚至几小时。</p>
<p><strong>设计和开发 Go 就是为了在这种环境下提高工作效率。</strong> Go 设计的考虑因素，除了众所周知的像 内置并发 和 垃圾回收，还包括 严格的依赖管理、软件架构在系统增长时的适应性，以及跨组件的健壮性。</p>
<p>本文将解释在构建一个高效的、编译型的、轻量级的、使人愉悦的编程语言的过程中，如何解决这些问题。例子 和 解释 都来自 Google 实际遇到的问题。</p>
<h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2. 简介"></a>2. 简介</h2><p>Go 是 Google 开发的一种编译型、支持并发、带垃圾回收、静态类型的语言。它是一个开源项目：Google 从公共代码库导入代码，而不是反过来。</p>
<p>Go 运行效率高、可伸缩性强，而且工作效率也高。有些程序员觉得用它干活很有趣；有些则觉得它缺乏想象力，甚至很无聊。在本文中，我们将解释为什么这些观点并不矛盾。<strong>Go 是为解决 Google 在软件开发中面临的问题而设计的，这导致 Go 并不是一门在研究领域有突破性的语言；尽管如此它仍是大型软件项目工程化的优秀工具。</strong></p>
<blockquote>
<p>译者注：这是 8 年前的演讲。Go 初期确实是为了解决 Google 内部的问题而诞生的。但如今已经是诞生的第 11 个年头，Go 早已被寄予更多的期待。它要解决的问题没变，只是不再局限于 Google 的内部场景。</p>
</blockquote>
<h2 id="3-Go-在-Google"><a href="#3-Go-在-Google" class="headerlink" title="3. Go 在 Google"></a>3. Go 在 Google</h2><p>Google 设计 Go 用来帮助解决 Google 自己的问题，而 Google 的问题很 <strong>大</strong>。</p>
<p>硬件大，软件也大。软件有好几百万行，服务器大部分用 C++，剩余的部分大量使用 Java 和 Python。成千上万的工程师在代码上工作，这些代码位于一个包含了所有软件的单棵大树的『头部』，所以树的各个层次一天到晚都有重要变更。使用大型的、定制的分布式构建系统使这种规模的开发变得可行，但它仍然很大。</p>
<p>当然，所有这些软件都运行在无数（zillions）台机器上，这些机器被看作数量不多的独立的、互相联网的计算集群。</p>
<p>简而言之，Google 的开发规模很大，速度可能很慢，而且经常显得很笨拙。但它是有效的。</p>
<p>Go 项目的目标，是消除 Google 软件开发中的缓慢和笨拙，从而使开发过程更加高效和获得更强的可伸缩性。<strong>这个语言是由编写、阅读、调试和维护大型软件系统的人设计的，也是为这些人设计的。</strong></p>
<p>因此，Go 的目的不是要做编程语言设计的研究，而是要改善语言设计者及其同事的工作环境。Go 考虑的更多是软件工程的问题，而不是编程语言方面的科研。换句话说，<strong>它围绕的是『服务于软件工程的语言设计』</strong>。</p>
<p>但是，一门语言如何对软件工程有所助益呢？本文剩下的内容就是对这个问题的回答。</p>
<h2 id="4-痛点"><a href="#4-痛点" class="headerlink" title="4. 痛点"></a>4. 痛点</h2><p>在 Go 刚推出时，有人声称，它缺少现代语言所必需的某些特性或方法论。缺少这些的 Go 能有什么价值呢？我们的回答是，Go 所具备的某些特性，可以解决严重困扰大规模软件开发的一些问题。这些问题包括</p>
<ul>
<li>构建速度慢</li>
<li>失控的依赖关系</li>
<li>每个程序员使用相同语言的不同子集</li>
<li>程序难以理解（代码难以阅读，文档不完善等）</li>
<li>重复劳动</li>
<li>更新代价大</li>
<li>版本偏斜（version skew）</li>
<li>难以编写自动化工具</li>
<li>跨语言构建</li>
</ul>
<p>一门语言的单个特性并不能解决这些问题。这需要有软件工程的大局观（larger view），所以在 Go 的设计中，我们试图把重点放在解决这些问题上。</p>
<p>作为一个简单而且独立的例子，我们来看一下程序结构的表示方式。一些观察者反对 Go 用花括号（<code>{...}</code>）来表示类似于 C 的块状结构，他们更喜欢用 Python 或 Haskell 风格的空格来缩进。然而，我们见过太多由跨语言构建引起的构建和测试失败：嵌入到另一种语言里的 Python 代码段（例如通过 SWIG 调用），会因为周围代码缩进的变化而被意外地破坏，而且非常难以察觉。因此，我们的观点是，虽然空格缩进对于小程序来说是不错的选择，但它并不具有大程序所需要的可伸缩性；而且代码库越大，异构性越强，就会带来越多的麻烦。<strong>为了安全和可靠，最好还是放弃这点便利</strong>，所以 Go 使用花括号表示的代码块。</p>
<h2 id="5-C-和-C-中的依赖关系"><a href="#5-C-和-C-中的依赖关系" class="headerlink" title="5. C 和 C++ 中的依赖关系"></a>5. C 和 C++ 中的依赖关系</h2><p>更能实质性地说明上面提到的可伸缩性和其他问题的，是包依赖关系的处理。我们从回顾 C 和 C++ 如何处理依赖关系开始讨论。</p>
<p>最早于 1989 年标准化的 ANSI C 在标准头文件里推广了 <code>#ifndef</code> 『防护（guards）』的概念。这个做法现在已经是无处不在，就是每个头文件都要用一个条件编译语句（clause）包裹起来，这样做就算这个头文件被多次包含（include）也不会出错。例如，Unix 头文件 <code>&lt;sys/stat.h&gt;</code> 的结构是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 大段的版权和许可证声明 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SYS_STAT_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _SYS_STAT_H_</span></div><div class="line"><span class="comment">/* 类型和其他定义 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>这样做的目的，是让 C 语言预处理器在第二次以及后续读到该文件时，忽略被包裹的内容。符号<code>_SYS_STAT_H_</code> 在第一次读取文件时被定义，避免（guards）了后续的调用。</p>
<p>这样设计有一些好处，最重要的是每个头文件可以安全地 <code>#include</code> 它所有的依赖，即使其他头文件也包含这些依赖，都不会有问题。如果遵循这个规则，并且按字母顺序排列 <code>#include</code> 语句，可以写出有条理的代码。</p>
<p><strong>但它的可伸缩性非常差。</strong></p>
<p>1984 年，有人发现编译 ps.c（Unix ps 命令的源码）时，整个预处理过程会遇到 37 次 <code>#include &lt;sys/stat.h&gt;</code> 。<strong>尽管后面 36 次头文件的内容都会被忽略，但大多数 C 语言的实现每次都会打开文件、读取文件、完整扫描内容，一连串动作下来，一共 37 次。</strong> 这样做非常不聪明，但是 C 预处理器需要处理非常复杂的宏语义，使它只能这样实现。</p>
<p>这对软件造成的影响是， C 程序里 <code>#include</code> 语句会不断累积。添加 <code>#include</code> 语句不会破坏程序，却很难知道什么时候不再需要它们。删除一条 <code>#include</code> 后再编译一次也检查不出来，因为可能另一条 <code>#include</code> 本身就包含你刚刚删除的那条  <code>#include</code>。</p>
<p>从技术的角度讲，没必要弄成这样子。意识到使用 <code>#ifndef</code> 防护的长期问题，Plan 9 库的设计者们采取了一种不同的、非 ANSI 标准的做法。在 Plan 9 里，头文件禁止包含更多的 <code>#include</code> 语句；所有的 <code>#include</code> 都要放在顶层 C 文件里。当然，这需要一些纪律：程序员需要按照正确的顺序、准确地列出必要的依赖关系；但文档可以帮上忙，而且在实践中效果非常好。这样做的结果是，无论一个 C 源文件有多少依赖，在编译该文件时，每个 <code>#include</code> 文件都只会被读取一次。而且，只要把 <code>#include</code> 语句先删掉就能很容易地看出来它是否必要：当且仅当删除的依赖不是必要的依赖时，编辑后的程序才能通过编译。</p>
<p>Plan 9 做法最重要的结果是编译速度更快：编译所需的 I/O 量比使用带有 <code>#ifndef</code> 防护的库时大大减少。</p>
<p>但在 Plan 9 之外，『防护』法仍是 C 和 C++ 的公认做法。事实上，<strong>C++ 在更细的粒度上使用同样的做法还加剧了这个问题</strong> 。按照惯例，C++ 程序的结构通常是每个类有一个头文件，也可能是一小组的相关类有一个头文件，这种分组方式比像 <code>&lt;stdio.h&gt;</code> 这样的头文件要小得多。因此，它的依赖树要复杂得多，反映的不是库之间的依赖关系，而是完整的类型层次结构。此外，C++ 头文件通常包含真正的代码——类型、方法和模板声明——而不仅仅是一般 C 头文件里常见的简单常量和函数签名。因此，C++ 不仅向编译器推送了更多的信息，而且推送的内容更难编译，编译器的每次调用都必须重新处理这些信息。在构建一个大型的 C++ 二进制文件时，编译器可能要成千上万次地处理头文件 <code>&lt;string&gt;</code> 去学会如何表示一个字符串。（据记录，1984 年左右，Tom Cargill 就提到，使用 C 预处理器进行依赖管理将是 C++ 的长期负担，应该加以解决。）</p>
<p>在 Google，构建一个 C++ 二进制文件，打开和读取不同的头文件可以达到数百个，次数可以达到数万次。2007 年，Google 的构建工程师对 Google 的一个主要二进制文件的编译进行了检测。这个二进制文件包含了大约两千个源文件，如果简单地连在一起，总共有 4.2 MB。在所有  <code>#include</code> 语句被展开后，超过 8 GB 内容被送到编译器的输入端，也就是源码里的每个字节膨胀了 2000 倍。</p>
<p>另一个数据是，2003 年，Google 的构建系统从单一的 Makefile 转变为每个目录都有 Makefile 的设计，有了更好的管理，更明确的依赖关系。仅仅是因为有了更精确的依赖关系记录，一个典型的二进制文件在文件大小上就缩减了 40%。即便如此，C++ （或 C 语言）的特性使得自动验证这些依赖关系难以实现，直到今天，我们对 Google 的大型 C++ 二进制文件的依赖关系需求仍然没有一个准确的把握。</p>
<p>依赖关系失控和规模太大的后果是，在单台计算机上构建 Google 服务器的二进制文件变得不切实际，一个大型的分布式编译系统应运而生。有了这个加了很多机器、很多缓存、很多复杂的东西的系统（构建系统本身就是一个大程序），Google 的构建总算可以进行，虽然还是很麻烦。</p>
<p>即使采用分布式构建系统，Google 的一次大型构建仍然需要很长时间。前面提到 2007 年的那个二进制程序使用上一版的分布式构建系统花了 45 分钟；同一程序今天的版本花了 27 分钟，当然这期间程序和它的依赖关系也还在增长。<strong>扩大构建系统的工程投入，只能勉强比它所构建的软件的增长速度领先一点。</strong></p>
<h2 id="6-走进-Go"><a href="#6-走进-Go" class="headerlink" title="6. 走进 Go"></a>6. 走进 Go</h2><p>当构建速度很慢时，就有了时间去思考。Go 有那么一个起源传说（origin myth），声称 Go 正是在其中一次 45 分钟的构建过程中被构思出来的。设计一门新的语言，使它适合编写像 Web 服务器这样的大型 Google 程序，同时考虑到软件工程的因素，可以提高 Google 程序员的生活质量。人们相信这个目标值得一试。</p>
<p>虽然到目前为止的讨论都集中在依赖关系上，但还有许多其他问题需要注意。一门语言要想在上述背景下取得成功，主要的考虑因素是：</p>
<ul>
<li>它必须适应大规模开发。能在有大量依赖关系、大量程序员团队一起协作的大型程序项目上很好地工作。</li>
<li>它必须是大家熟悉的，大致上类似于 C 语言的。在 Google 工作的程序员处于职业生涯的早期，对过程式编程语言（procedural languages），尤其是来自 C 家族的语言最熟悉。要想让程序员在新语言中快速提高工作效率，意味着语言不能太激进。</li>
<li>它必须是现代的。C、C++ 以及 Java 的某些方面都相当老旧，是在多核机器、网络 和 web 应用开发 出现之前设计的。新的做法可以更好地适应现代世界的一些特点，比如内置的并发支持。</li>
</ul>
<p>那么，在这样的背景下，让我们从软件工程的角度来看看 Go 的设计。</p>
<h2 id="7-Go-的依赖关系"><a href="#7-Go-的依赖关系" class="headerlink" title="7. Go 的依赖关系"></a>7. Go 的依赖关系</h2><p>既然我们已经详细了解过 C 和 C++ 中的依赖关系，那么我们可以从 Go 如何处理依赖关系开始。依赖关系是由语言在语法和语义上定义的。它们是明确的、清晰的和『可计算』的，也就是说，很容易写工具来分析。</p>
<p>Go 的语法是，在 <code>package</code> 语句（下一节的主题）之后，每个源文件可以有一个或多个导入语句，每个导入语句由 <code>import</code> 关键字和一个字符串常量组成，标识要导入到当前源文件（且只限当前源文件）的包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></div></pre></td></tr></table></figure>
<p>让 Go 可以做到规模化、依赖智能化的第一步，是语言将 <strong>未使用的依赖</strong> （unused dependencies）定义为编译期错误（注意不是警告，是错误）。如果源文件导入了一个它不用的包，程序就不会通过编译。这保证了任何 Go 程序构建中的依赖关系树都是精确的，没有多余的边。另一边又保证了在构建程序时不会有多余的代码被编译，从而最大限度地减少了编译时间。</p>
<p>第二步是在编译器的实现上，更进一步保证效率。假设一个有三个包的 Go 程序，依赖关系如下：</p>
<ul>
<li><code>A</code> 包导入了 <code>B</code> 包</li>
<li><code>B</code> 包导入了 <code>C</code> 包</li>
<li><code>A</code> 包没有导入 <code>C</code> 包</li>
</ul>
<p>这意味着 A 包只是在引用 B 包的过程中，间接地引用了 C 包；换句话说，尽管 A 引用的来自 B 的某些代码引用了 C，但在 A 的源码里没有直接涉及来自 C 的标识符。例如， A 包可能会引用一个在 B 里面定义的结构体类型，该结构体有一个字段的类型是在 C 里定义的，但 A 本身并不直接引用 C 里面的类型。一个更具体的例子是，A 导入了一个格式化 I/O 包 B，B 使用了 C 提供的缓冲 I/O 实现，但 A 本身并没有调用缓冲 I/O。</p>
<p>要构建这个程序，首先 C 被编译；被依赖的包必须在依赖它们的包之前构建。然后，B 被编译；最后 A 被编译，然后就可以链接程序。</p>
<p>在 A 被编译时，编译器读取的是 B 的目标文件而不是源代码。B 的目标文件包含了编译器在 A 的源代码里执行 <code>import &quot;B&quot;</code> 语句所需的所有类型信息。这些信息包括 B 的调用方（clients）在编译时需要的任何关于 C 的信息。换句话说，当 B 被编译时，生成的目标文件包含了 B 所有公共接口所需的依赖关系的类型信息。</p>
<p>这种设计的一个重要的效果，就是 <strong>当编译器执行一条 <code>import</code> 语句时，只会打开一个文件</strong> ，那就是导入语句里的字符串所标识的目标文件。这让人不由得想起 Plan 9 C（相对于 ANSI C）的依赖管理方法，但实际上编译器在编译 Go 源文件的时候就会写入头文件。考虑到导入时读取的数据只是『导出的（exported）』数据，而不是一般的程序源代码，这个过程比 Plan 9 C 更自动，甚至更高效。这对整体编译时间可以造成巨大的影响，还能随着代码库的增长弹性地伸缩。与 C 和 C++ 的 『include 文件里还有 include』的模式相比，生成依赖图（dependency graph）并编译的时间可以指数级地减少。</p>
<p>值得一提的是，这种通用的依赖管理方法并不是独创的，其思想可以追溯到 20 世纪 70 年代，流传于 Modula-2 和 Ada 等语言中。在 C 语言家族中，Java 也有这种方法的元素。</p>
<p>为了使编译更有效率，目标文件的内容是经过编排的，导出数据就在文件的开头，所以编译器只要读到导出数据的结尾就可以结束，不需要读取整个文件。</p>
<p>这种依赖管理方法是 Go 编译比 C 或 C++ 快的一个最大原因。另一个因素是 Go 把导出数据放在目标文件里，作为对比有些语言需要作者手写或编译器生成包含这些信息的另外的文件。这就需要打开两倍数量的文件。在 Go 里，导入一个包只需要打开一个文件。另外，单文件的方式意味着导出数据（类似 C / C++ 里的头文件）相对于目标文件来说，永远不会过时。</p>
<p>为了做一个对比，我们测量了一个用 Go 编写的大型 Google 程序的编译情况，看看源代码的扇出量与前面做的 C++ 分析相比如何。（译者注：这里指第五节提到的 C++ 头文件展开后的内容量和源代码的比值，为 2000 倍。）我们发现大约是 40 倍，比 C++ 好了 50 倍（同时也更简单，因此处理速度更快），但还是比我们预期的大。这有两个原因。首先，我们发现了一个 bug：Go 编译器在导出部分生成了大量不需要的数据。其次，导出数据使用的是一种冗长的编码，还有改进的余地。我们已经计划解决这些问题。（译者注：Go 在 2012 年 3 月才发布了 1.0 版本，到现在已经过去了 8 年多，到了 1.15 。这中间 Go 团队投入了大量时间在 编译器、运行时 和 工具链的优化上，这两个问题应该已经得到了很大的改善，甚至可能已经彻底解决。）</p>
<p>尽管如此，减少到五十分之一，就足以把几分钟变成几秒钟，把茶歇时间变成交互式构建。</p>
<p>Go 依赖图的另一个特点是它没有依赖环。<strong>语言定义了依赖中不能有循环导入</strong>，编译器和链接器都会检查确保不存在循环依赖。虽然循环导入偶尔有用，但它在规模上会带来严重的问题。循环导入要求编译器一次性处理更多的源文件，这就减缓了增量构建的速度。<strong>更重要的是，根据我们的经验，如果允许这样的导入，最终会把大片的源码树，纠缠成难以独立管理的几大块，使二进制文件膨胀，并使初始化、测试、重构、发布和其他软件开发任务变得复杂。</strong></p>
<p>缺少循环导入偶尔会造成烦恼，但却能保持依赖树的干净，迫使包之间有明确的边界。<strong>就像 Go 里的许多设计决策一样，它迫使程序员更早地考虑一个更大范围的问题（在这里，这个问题是包的边界），这些问题如果留到以后，可能永远不会得到令人满意的解决。</strong></p>
<p>Go 设计标准库的过程中，花费了大量精力在控制依赖关系上。<strong>如果只是需要一个函数，拷贝一点代码可能比直接拉来一个大库强。</strong>（如果出现新的核心依赖关系，系统构建中的测试就会报告问题。）依赖关系清晰胜过代码重用。实践中的一个例子是，（底层的）<code>net</code> 包有自己的 整型 到 小数 的转换程序，以避免依赖更大的、依赖关系更复杂的格式化 I/O 包。另一个例子是字符串转换包 <code>strconv</code> 有一个私有的 『可打印』字符定义的实现，而不是引入大块头的 Unicode 字符类表；<code>strconv</code> 通过包的测试来确保符合 Unicode 标准。</p>
<h2 id="8-包"><a href="#8-包" class="headerlink" title="8. 包"></a>8. 包</h2><p>Go 的包系统设计，将库、命名空间、模块的一些特性结合在一起，变成一个统一的结构。</p>
<blockquote>
<p>译者注：2012 年 Go 1.0 ，包管理使用的还是最简单的 GOPATH 模式。之后这种基于 Google 单一代码库的设计造成了各种不便，第三方包管理工具百花齐放。2015 年 Go 1.5 引入 Vendor 机制，到后面发现还是没有解决问题。第三方工具 dep 一度最有希望转正，结果 2018 年官方推出 vgo （后改名 Go Modules 并入 <code>go</code> 工具链）统一了机制，到 2020 年的 1.14 正式宣布 Go Modules “ready for production”。</p>
<p>跟 20102 相比，现在 Go 的包管理已经有了很多变化，最主要的是引入了 module 的概念。</p>
</blockquote>
<p>每一个 Go 源文件，例如 <code>&quot;encoding/json/json.go&quot;</code>，都会以一个 <code>package</code> 语句开始，像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> json</div></pre></td></tr></table></figure>
<p>其中 <code>json</code> 是 『包名』，一个简单的标识符。包名通常是简明扼要的。</p>
<p>要使用一个包，导入语句里的包路径标识了要导入的文件。『路径』的含义并未在语言中指定，但在实践中，按照惯例，它是源包在代码库里的目录路径，以斜杠 <code>/</code> 分隔，像：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></div></pre></td></tr></table></figure>
<p>然后，在导入的源文件（importing，调用方）里引用时，用包名（区别于路径）来修饰（qualify）被导入（imported）包的包中成员：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dec = json.NewDecoder(reader)</div></pre></td></tr></table></figure>
<p>这种设计清晰明确。<code>Name</code> 对比 <code>pkg.Name</code> ，人们总是可以从语法中判断出一个名字是否来自本地包。（这一点后面会有更多的介绍。）</p>
<p>在我们的例子中，包的路径是 <code>&quot;encoding/json&quot;</code>，而包名是 <code>json</code>。在标准仓库之外，惯例是将项目或公司名称放在命名空间的根部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"google/base/go/log"</span></div></pre></td></tr></table></figure>
<p>重要的是要认识到包的路径是唯一的，但对包名却没有这样的要求。路径必须唯一地标识要导入的包，而包名只是一个约定，让包的调用方可以引用它的内容。包名不需要是唯一的，可以在每个导入（importing）的源文件里，通过在导入语句中提供一个本地标识符来重命名。下面两个导入都引用了包名为 <code>log</code> 的包，但要在同一个源文件里导入它们，必须（在本地）重命名其中一个包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"log"</span> <span class="comment">// 标准包</span></div><div class="line"><span class="keyword">import</span> googlelog <span class="string">"google/base/go/log"</span> <span class="comment">// Google专用包</span></div></pre></td></tr></table></figure>
<p>每个公司可能都有自己的 <code>log</code> 包，没有必要让包名独一无二。恰恰相反：<strong>Go 的风格建议保持包名短小精悍、清晰明确，而不是担心重名</strong> 。</p>
<p>还有一个例子：在 Google 的代码库里，有很多个 <code>server</code> 包。</p>
<h2 id="9-远程包"><a href="#9-远程包" class="headerlink" title="9. 远程包"></a>9. 远程包</h2><p>Go 包系统的一个重要特性是，包的路径一般可以是任意字符串，可以用它标识托管代码仓库的站点 URL ，以此来引用远程代码库。</p>
<p>下面是使用 <code>github</code> 上的 <code>doozer</code> 包的方法。<code>go get</code> 命令使用 <code>go</code> 构建工具从站点获取仓库并安装它。一旦安装完毕，它就可以像其他普通的包一样被导入和使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/4ad/doozer // 获取包的 Shell 命令</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/4ad/doozer"</span> <span class="comment">// Doozer 调用方的 import 语句</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> client doozer.Conn         <span class="comment">// 调用方对包的引用</span></div></pre></td></tr></table></figure>
<p>值得注意的是，<code>go get</code> 命令以递归的方式下载依赖，正是因为依赖关系是显式的所以才可以这样实现。另外，区别于其它语言使用的集中式包注册，Go 导入路径的命名空间分配依赖于 URL，这使得包的命名是去中心化的，因而是可扩展的。</p>
<h2 id="10-语法"><a href="#10-语法" class="headerlink" title="10. 语法"></a>10. 语法</h2><p>语法就是一门编程语言的用户界面。<strong>尽管语法对语义影响有限，而语义很可能才是语言更重要的组成部分，但语法决定了语言的可读性，继而决定了语言的清晰度。</strong>同时，语法对工具链而言至关重要：如果一门语言难以解析，就很难为其编写自动化工具。</p>
<p>因此，Go 在设计时就考虑了语言的清晰度和工具链，并且拥有简洁的语法。与 C 家族的其他语言相比，它的语法规模不大，只有 25 个关键字（C99 有 37 个；C++11 有 84 个；而且这两个数字还在继续增加）。更重要的是，语法很规范，所以很容易解析（应该说大多数规范；也有个别怪异的语法我们本可以改善结果发现得太晚）。与 C 和 Java，尤其是 C++ 不同，Go 可以在没有类型信息或符号表的情况下进行解析；不需要类型相关的上下文。语法容易推导，工具自然就容易编写。</p>
<p>Go 语法里有一个细节会让 C 程序员感到惊讶，那就是声明语法更接近 Pascal 而不是 C。声明的名称出现在类型之前，并且使用了更多关键字（译者注：指 <code>var</code> 和 <code>type</code>关键字）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>)</span> <span class="title">int</span></span></div><div class="line"><span class="title">type</span> <span class="title">T</span> <span class="title">struct</span> &#123; a, b <span class="keyword">int</span> &#125;</div></pre></td></tr></table></figure>
<p>对比 C 语言</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*fn)(<span class="keyword">int</span>[]);</div><div class="line"><span class="keyword">struct</span> T &#123; <span class="keyword">int</span> a, b; &#125;</div></pre></td></tr></table></figure>
<p>无论对人还是对计算机来说，由关键字引入的声明都更容易解析，而且使用 <strong>类型语法</strong> 而不是 C 那样的 <strong>表达式语法</strong> ，对解析有很大的帮助：它增加了语法，但消除了歧义。你还有另外一个选择：对于初始化声明，可以丢弃 <code>var</code> 关键字，直接从表达式中推断变量的类型。这两个声明是等价的；第二个声明更短也更地道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buf *bytes.Buffer = bytes.NewBuffer(x) <span class="comment">// 显式指定类型</span></div><div class="line">buf := bytes.NewBuffer(x)                  <span class="comment">// 类型推断</span></div></pre></td></tr></table></figure>
<p>在 <a href="https://golang.org/s/decl-syntax" target="_blank" rel="external">golang.org/s/decl-syntax</a> 有一篇博客文章，详细介绍了 Go 的声明语法，以及为什么它与 C 语言如此不同。</p>
<p>对于简单的函数来说，函数语法是很直接的。这个例子声明了函数 <code>Abs</code>，它接受一个类型为 <code>T</code> 的变量 <code>x</code>，并返回一个 <code>float64</code> 的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(x T)</span> <span class="title">float64</span></span></div><div class="line"></div><div class="line">// 译者补充调用示例:</div><div class="line">// 假定已经初始化了一个变量 <span class="title">t</span>，类型为 <span class="title">T</span>，下同</div><div class="line"><span class="title">absT</span> := <span class="title">Abs</span><span class="params">(t)</span></div></pre></td></tr></table></figure>
<p>方法（method）只是有一个特殊参数的函数，这个特殊参数就是它的接收者（receiver），可以通过点号 <code>.</code> 传递给函数。方法声明的语法将接收者放在函数名前面的括号里。下面是同一个函数，现在定义成 <code>T</code> 类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x T)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span></div><div class="line"></div><div class="line">// 译者补充调用示例:</div><div class="line"><span class="title">absT</span> := <span class="title">t</span>.<span class="title">Abs</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>而这里是一个函数变量（闭包），参数类型为 <code>T</code>；Go 有一等函数（first-class function）和闭包：</p>
<blockquote>
<p>译者注：一等函数是指函数可以作为普通变量，可以作为其他函数的参数和返回值；作为对比， Java 只有类是一等公民，其他语言成分必须作为类的成员。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">negAbs := <span class="function"><span class="keyword">func</span><span class="params">(x T)</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> -Abs(x) &#125;</div><div class="line"></div><div class="line"><span class="comment">// 译者补充调用示例:</span></div><div class="line">negT := negAbs(t)</div></pre></td></tr></table></figure>
<p>最后，在 Go 里函数可以返回多个值。常见的做法是将函数结果和错误值作为一对返回，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></div><div class="line"></div><div class="line"><span class="title">c</span>, <span class="title">err</span> := <span class="title">ReadByte</span><span class="params">()</span></div><div class="line"><span class="title">if</span> <span class="title">err</span> != <span class="title">nil</span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>错误处理我们后面再聊。</p>
<p>Go 缺少了一个特性，那就是它不支持函数的默认参数（default function arguments）。这是一个故意的简化。经验告诉我们，默认参数会让修复 API 显得太容易，仿佛只要添加更多参数就可以弥补设计上的缺陷，结果导致添加了过多的参数，参数之间的关系变得难以拆分、甚至无法理解。缺少默认参数的情况下，因为一个函数无法承载整个接口，就需要定义更多的函数或方法，但这会导致 API 更清晰、更容易理解。这些函数也都需要单独命名，这使得有哪些函数、分别接受哪些参数一目了然，同时也鼓励人们对命名进行更多的思考，这是清晰度和可读性的一个关键方面。</p>
<p>作为缺少默认参数的补偿，Go 支持易用的、类型安全的可变参数函数（variadic functions）。</p>
<h2 id="11-命名"><a href="#11-命名" class="headerlink" title="11. 命名"></a>11. 命名</h2><p>Go 采用了一种不同寻常的方法来定义标识符的可见性（所谓可见性，是指一个包的调用方是否可以通过标识符使用包内的成员）。不同于使用 <code>private</code> 和 <code>public</code> 等关键字，在 Go 里，命名本身就带有信息：标识符首字母的大小写决定了标识符的可见性。如果首字母是大写字母，标识符就会被导出（公共）；否则就是私有的：</p>
<ul>
<li>首字母大写：<code>Name</code> 对包的调用方可见</li>
<li>首字母小写：<code>name</code> （或 <code>_Name</code>）对包的调用方不可见</li>
</ul>
<p>这条规则适用于变量、类型、函数、方法、常量、字段 …… 所有一切。这就是全部规则。</p>
<p>这个设计不是一个容易做的决定。我们纠结了一年多的时间，去考虑用什么符号指定标识符可见性。而一旦我们决定使用命名的大小写，我们很快就意识到它已经成为了语言里最重要的特性之一。名称毕竟是给包的调用方使用的；<strong>把可见性放在名称里而不是类型里，意味着只要看一眼，就能确定一个标识符是否公共 API 的一部分</strong> 。在使用 Go 一段时间之后，再去看其他语言，还要查找声明才能发现这些信息，就会觉得很累赘。</p>
<p>目标仍然是清晰度：程序源码要简单直接地表达程序员的意图。</p>
<p>另一个简化是，Go 有一个非常紧凑的作用域（scope）层次结构：</p>
<ul>
<li>全局（预先声明的标识符，像 <code>int</code> 和 <code>string</code>）</li>
<li>包（包的所有源文件都在同一个作用域）</li>
<li>文件（仅用于导入包的重命名，实践中不是特别重要）</li>
<li>函数（跟其它语言一样）</li>
<li>代码块（跟其它语言一样）</li>
</ul>
<p>没有什么命名空间（name space）作用域、类（class）作用域或者其它结构的作用域。在 Go 里，名称只来自很少的地方，而且所有名称都遵循相同的作用域层次：在源码的任意位置，一个标识符只表示一个语言对象，和它的用法无关。（唯一的例外是语句标签 （用作 <code>break</code> 等语句的目标）；它们总是具有函数作用域。）</p>
<p>这使代码更清晰。例如，请注意到方法声明了一个显式的接收者（explicit receiver），访问该类型的字段和方法必须用到它。没有隐式的（implicit） <code>this</code> 。也就是说，我们总是写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rcvr.Field</div></pre></td></tr></table></figure>
<p>（其中 <code>rcvr</code> 是给接收者变量随便起的名称）所以在词法上（lexically），该类型的所有元素，总是绑定到一个接收者类型的值上。类似地，对于导入的名称，包的限定符总是存在；人们写的是 <code>io.Reader</code> 而不是 <code>Reader</code> 。这样不仅清楚，而且释放了标识符 <code>Reader</code> 作为一个有用的名称，可以在任何包中使用。事实上，在标准库中有多个导出的标识符都叫 <code>Reader</code>，类似的还有很多 <code>Printf</code>，但具体引用了哪一个永远不会弄混。</p>
<p>最后，这些规则结合在一起，保证除了顶层的预定义名称如 <code>int</code> 之外，每个名称（点号 <code>.</code> 前的第一部分）总是在当前包中声明。</p>
<p>简而言之，名称总是本地的（local）。在 C、C++ 或 Java 里，名称 <code>y</code> 可以指向任何东西。在 Go 里，<code>y</code> （甚至大写的 <code>Y</code> ）总是在包内定义，而 <code>x.Y</code> 的解释很清楚：在本地找到<code>x</code> ，<code>Y</code> 就在里面。</p>
<p>这些规则为可伸缩性提供了很重要的特性，因为它们保证了在一个包里添加导出的名称永远不会破坏这个包的调用方。<strong>命名规则解耦了包，提供了可伸缩性、清晰度和健壮性。</strong></p>
<p>关于命名还有一个方面需要提及：方法查找总是只按名称，而不是按方法的签名（类型）。换句话说，一个类型永远不可能有两个同名的方法。给定一个方法 <code>x.M</code> ，永远只有一个 <code>M</code> 与 <code>x</code> 关联。同样，这使得只给定名称就能很容易地识别引用了哪个方法。这也使得方法调用的实现变得简单。</p>
<blockquote>
<p>译者注：换句话说，Go 不支持函数和方法重载。</p>
<p>Go 的内置函数其实是有重载的。<code>make</code> 和 <code>len</code> 这些函数，参数类型不同，具体的行为也不一样。<code>make</code> 甚至还有一个到三个参数的三个版本。这些函数根据参数不同，在编译时被替换成了不同的函数实现。</p>
<p>但为了保持代码清晰，实现简单和运行高效，Go 不支持用户代码的函数重载。</p>
</blockquote>
<h2 id="12-语义"><a href="#12-语义" class="headerlink" title="12. 语义"></a>12. 语义</h2><p>Go 语句的语义一般跟 C 语言类似。它是一种带有指针等特性的、编译型、静态类型的过程式语言。设计上，习惯 C 族语言的程序员应该会感到熟悉。在推出一门新语言时，目标受众能够快速学会它是很重要的；将 Go 植根于 C 家族有助于确保年轻程序员能很容易学会 Go（他们大多数都知道 Java、JavaScript，也许还有 C）。</p>
<p>尽管如此，Go 对 C 的语义还是做了很多小的改变，主要是出于健壮性的考虑。这些变化包括：</p>
<ul>
<li>没有指针运算</li>
<li>没有隐式数字转换</li>
<li>总是检查数组边界</li>
<li>没有类型别名（声明 <code>type X int</code> 之后， <code>X</code> 和 <code>int</code> 是不同的类型，而不是别名）</li>
<li><code>++</code> 和 <code>--</code> 是语句（statements）而不是表达式（expressions）</li>
<li>赋值不是表达式</li>
<li>对栈上变量取址是合法的（甚至是被鼓励的）</li>
<li>其它</li>
</ul>
<blockquote>
<p>译者注：</p>
<ol>
<li><p>Go 在 1.9 还是引入了类型别名，语法是 <code>type X = int</code> 。用来解决迁移、升级等重构场景下，类型重命名的兼容性问题，以及方便引用外部导入的类型。</p>
<p> 实际上，类型别名仅在代码中存在，编译时会全部替换成实际的类型，不会产生新类型。</p>
</li>
<li><p>语句和表达式的差别是：语句是计算机角度的一个可执行动作，不一定有值；表达式是数学角度的可求值算式，一定有值，这个值可以放在赋值符号的右边，或者成为更大的表达式的一部分。</p>
<p> 不再区分语句和表达式，是编程语言演化的其中一个趋势，这可以增强语言的表达能力。一般的做法，是增加求值规则（像语句的值是语句中最后一个表达式的值），给原本没有值的语句提供一个值，这样就可以通过拼接非常复杂的表达式，用很少的代码解决问题。例如，如果赋值语句有值，那么 <code>e = d = c = b = a = 10</code>  就是合法的；因为赋值运算符从右到左结合，这些赋值最后都会成功，都是 10。</p>
<p> 但这很容易引起表达式的 滥用 和 误用。人们有可能写出非常难以理解的复杂表达式。或者因为不熟悉某些（本来是语句的）表达式的求值规则而制造难以排查的错误。</p>
<p> Go 首先追求代码的清晰明确，而不是追求单纯的表达能力强或者代码行数少，所以反其道而行，反而去掉了某些语句的值。</p>
</li>
<li><p>栈上分配的内存会在函数返回后被回收，对栈上的变量取址并返回，会导致函数外部引用到已被回收的内存。这就是悬挂指针问题，困扰着大多数有指针的语言。Go 的解决方案是，在编译期做逃逸分析，识别出可能超出当前作用域的指针引用，将对应的内存分配到堆上。所以在 Go 里面，取址操作不用考虑变量究竟是栈上还是堆上的，编译器会反过来配合你。当然，如果是高频操作，可能要考虑一下拷贝和 GC 哪个开销大，传值（栈上分配，需要拷贝，不需要 GC）还是 传指针（如果发生逃逸，堆上分配，不需要拷贝，需要 GC）。</p>
</li>
</ol>
</blockquote>
<p>还有一些更大的变化，远离了传统的 C、C++ 甚至 Java 的模式。这些包括在语言级别上支持：</p>
<ul>
<li>并发</li>
<li>垃圾回收</li>
<li>接口类型</li>
<li>反射</li>
<li>类型判断（type switches）</li>
</ul>
<p>下面的章节主要从软件工程的角度简要讨论 Go 中的两个主题：并发 和 垃圾回收。关于语言语义和用途的完整讨论，请参见 <a href="https://golang.org" target="_blank" rel="external">golang.org</a> 网站上的更多资料。</p>
<h2 id="13-并发"><a href="#13-并发" class="headerlink" title="13. 并发"></a>13. 并发</h2><p>web 服务器运行在多核机器上，并有大量的调用方，这可以称之为一个典型的 Google 程序；而并发对于这种现代计算环境非常重要。C++ 或 Java 都不是特别适合这类软件，它们在语言层面上缺乏足够的并发支持。</p>
<p>Go 有作为一等公民的通道（channel），实现了 CSP （译者注：Communicating Sequential Processes，通信顺序进程）的一个变种。选择 CSP 的部分原因是熟悉（我们其中一个人曾经研究过某种基于 CSP 思想的前辈语言），同时也是因为 CSP 很容易被添加到过程化编程模型中，而无需对模型进行深入的修改。也就是说，<strong>给定一个类似于 C 的语言，CSP 基本就能够以正交的方式添加到语言中，提供额外的表达能力，而不限制该语言的其他用途。</strong> 总之，语言的其他部分可以保持『普通』。</p>
<p><strong>这个方法就是，将独立执行的函数，与其他普通的过程式代码结合。</strong></p>
<p>这样得到的语言允许我们将 并发 和 计算 平滑地结合起来。假设有一个 web 服务器，必须验证每次客户端调用的安全证书；在 Go 里面，很容易利用 CSP 来构造这样一个软件：用独立的执行过程来管理客户端，同时还能火力全开为昂贵的加密计算提供编译型语言的高执行效率。</p>
<p>综上所述，CSP 对于 Go 和 Google 来说都很实用。在编写 web 服务器这种典型的 Go 程序时，这个模型是再适合不过了。</p>
<p>有一个重要的注意事项：在并发的情况下，Go 并不是纯粹的内存安全（purely memory safe）语言。内存共享是合法的，在通道上传递指针也是符合惯例的（同时也是高效的）。</p>
<p>一些 并发 和 函数式编程 的专家对于 Go 在并发计算的上下文没有采用『只写一次（write-once）』来处理值语义感到失望，看起来没有其它并发语言（如 Erlang）那么像回事。同样地，原因主要还是在于对问题领域的熟悉度和适用性。Go 的并发特性在大多数程序员熟悉的上下文中都能很好地发挥作用。<strong>Go 可以实现简单、安全的并发编程，但并不禁止不良的编程方式。</strong> 我们提供约定俗成的做法作为弥补，训练程序员将消息传递视为所有权控制的一种实现方式。我们的座右铭是：『<strong>不要通过共享内存来通信，要通过通信来共享内存</strong>』。</p>
<blockquote>
<p>译者注：『只写一次（write-once）』变量，在某些语言的实现里又叫『单次赋值（single-assignment）』变量（Erlang），或者『不可变（immutable）』变量（函数式编程）。换言之，这种变量只能在初始化时赋值（写入）一次，之后不能再修改；如果需要新的值，只能创建新的变量。这样可以避免在并发上下文意外修改了变量的值。</p>
<p>虽然都不能修改，但还是要区分它和常量的区别。常量是在编译期就已经存在并确定了值；而不可变变量虽然赋值后不可修改，但其创建 / 赋值的时机和具体的值还是在运行时决定的。</p>
<p>这其实是来自函数式编程『无副作用（side effect）』和『不修改状态（state）』的概念，虽然可以保证程序的正确性，却跟 C 家族的过程式编程模型差异很大，照搬过来需要对这个模型进行比较大的改动，这就违背 Go 的设计初衷了。</p>
</blockquote>
<p>从我们对 Go 和 并发编程 的新手程序员的有限了解来看，这是一种实用的做法。程序员享受着并发支持给网络软件带来的简单性，而简单性产生了健壮性。</p>
<blockquote>
<p>译者在网上看到一种说法：『Java 里多种同步方法、各种 Lock、并发调度等一系列复杂的功能在 Golang 里 <strong>都不存在</strong>，只靠 goroutine 和 channel 去处理并发。』，这种说法是错的。</p>
<p>如上面所说，CSP 模型是以基本正交的方式添加到 C 家族的过程式编程模型里的，增加了新的、简洁的表达方式，但并没有限制原本的做法。</p>
<p>Go 常用的并发控制的工具，除了内置的消息通道 <code>chan</code> （CSP 模型），还有：</p>
<ul>
<li><code>sync</code> 包提供的同步原语（其中包括互斥锁和读写互斥锁 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code>，还有其它三个原语 <code>sync.WaitGroup</code> ， <code>sync.Once</code> 和 <code>sync.Cond</code> 。实际上你去看 <code>chan</code> 的源码，也是基于 runtime 内部的 <code>mutex</code> 实现的）；</li>
<li>上下文 <code>context.Context</code></li>
<li>其它扩展包中提供的工具</li>
</ul>
<p>可以看到，在 C 家族里常见的并发控制方式，基本都有提供，只是不再像 Java 那样以关键字的方式，而是以内置包的方式提供。</p>
<p>Go 把 CSP 模型实现并把支持上升到内置类型和关键字的层面，却并没有强迫程序员必须使用这个模型。</p>
</blockquote>
<h2 id="14-垃圾回收"><a href="#14-垃圾回收" class="headerlink" title="14. 垃圾回收"></a>14. 垃圾回收</h2><p>对于一门系统级编程语言来说，垃圾回收可能是一个有争议的特性，然而我们只花了很少时间就决定 Go 将是一门带垃圾回收的语言。Go 没有显式的内存释放操作：已分配的内存返回内存池的唯一途径就是垃圾回收器。</p>
<p>这是一个很容易做出的决定，因为内存管理对一门语言的实际工作方式有着深远的影响。在 C 和 C++ 中，编程时太多的精力都花在了内存的分配和释放上。这样的设计倾向于暴露本可以隐藏得很好的内存管理细节；但反过来说，对内存管理的过多顾虑又限制了内存的使用。相比之下，垃圾回收使得编程接口更清晰明确（garbage collection makes interfaces easier to specify）。</p>
<p>此外，在支持并发的面向对象语言中，自动内存管理几乎是必不可少的，因为当一块内存的所有权在并发执行中来回传递时，管理起来是很棘手的。<strong>将行为和资源管理分开是很重要的。</strong></p>
<p>一旦有了垃圾回收，语言使用起来就容易多了。</p>
<p>当然，垃圾回收会带来巨大的成本：资源开销、执行延迟和实现的复杂性。尽管如此，我们相信，主要由程序员感受到的好处，要大于主要由语言实现者承担的成本。</p>
<p>用 Java 作为服务器开发语言的经验，让一些人对面向用户的系统中的垃圾回收感到紧张。开销不可控，延迟随时可能变大，而且为了获得良好的性能，还需要进行很多参数调整。然而 Go 却不同，语言的特性能缓解其中一部分的担忧，虽然不是全部。</p>
<p>关键的一点是，<strong>Go 为程序员提供了工具，可以通过控制数据结构的布局来限制内存分配</strong> 。假设有一个简单的数据结构的类型定义，它包含一个字节型（数组）的缓冲区：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;</div><div class="line">    a, b, c <span class="keyword">int</span></div><div class="line">    buf [<span class="number">256</span>]<span class="keyword">byte</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Java 里，<code>buf</code> 字段需要第二次内存分配，对它的访问也需要第二层的间接访问。但在 Go 里面，缓冲区和包含它的结构体一起被分配在一个内存块中，不需要任何间接分配和访问。对于系统编程来说，这种设计可以获得更好的性能，同时减少回收器需要管理的内存块数量。在规模化的情况下，它可以带来显著的差异。</p>
<p>举个更直接的例子，在 Go 里面，提供二阶内存分配器（second-order allocators）是很容易和很高效的，例如一个 arena 内存分配器可以一口气分配一大组的结构体，并用一个空闲链表（free list）将它们连接起来。像这样要反复使用很多小结构体的库，只要做适当的提前安排，就可以不产生垃圾，还能保持高效和快速响应。</p>
<blockquote>
<p>译者注：arena 是 Go 里面用来分配内存的连续虚拟地址区域，堆中分配的内存都来自这一区域，可以近似地看作堆。Go 有自主内存管理策略（基于 Thread-Caching Malloc 改进），会一次性向系统预申请一大块内存，并将空闲内存用 free list 连在一起。分配内存时会按照一定策略，根据大小优先从 free list 获取内存；如果对象销毁，则把内存归还 free list。只有空闲内存不够才会向系统申请新的内存，只有空闲内存特别多才会向系统释放内存，减少内存申请和释放的系统调用。</p>
<p>这部分内容根据 Go 实现的改进可能会发生变化，请参考最新的文章，或者直接查看源码。 <code>https://github.com/golang/go/blob/master/src/runtime/malloc.go</code></p>
</blockquote>
<p>虽然 Go 是一种带垃圾回收的语言，但是一个资深的程序员可以通过减少施加给回收器的压力，来提高性能。（另外，Go 安装时还附带了很多好用的工具，可以用来分析程序运行时的动态内存性能。）</p>
<p>为了给程序员提供这种灵活性，Go 必须支持指向堆上分配对象的指针，我们称之为<strong>内部指针</strong>（interior pointers）。上面例子中的 <code>X.buf</code> 字段就存在于结构体内部，但获取这个内部字段的地址是合法的，例如将这个地址传递给一个 I/O 子程序。在 Java 以及很多支持垃圾回收的语言里，构造这样的内部指针是不可能，但在 Go 里面，这是很自然的做法。这个设计点会影响到可以使用哪些回收算法，并且可能会增加算法的实现难度，但是经过仔细考虑，我们决定有必要允许使用内部指针，因为这对程序员有好处，并且能够减少垃圾回收器的压力（尽管这样可能会让垃圾回收器更难实现）。到目前为止，我们将类似的 Go 和 Java 程序进行对比的经验表明，使用内部指针可以对总的 arena 大小、执行延迟 和 回收时间产生显著影响。</p>
<p>总而言之，Go 支持垃圾回收，但给程序员提供了一些工具来控制回收开销。</p>
<p>垃圾回收器仍然是一个活跃的开发领域。目前的设计是一个并行的标记并清理（mark-and-sweep）回收器，仍然有机会改进它的性能甚至设计。（语言规范并没有规定回收器必须要使用任何特定实现。） 不过，如果程序员注意更巧妙地使用内存，目前的实现已经可以在生产环境工作得很好。</p>
<blockquote>
<p>译者注：Go 1.3 以前使用 mark-and-sweep 回收器，整个过程需要 STW（stop the world），对于内存的申请和释放量比较大和频繁的程序而言，回收造成的停顿会比较明显。</p>
<p>后续的版本逐渐分离标记和清理过程，引入三色标记法，还有引入混合写屏障。总的趋势是将 GC 分散成多个可以（跟程序执行）并发的过程，将不得不 STW 的阶段和时间压缩到最小（通常小于 1ms），跟演讲发表时相比已经有了很大的改善。</p>
</blockquote>
<h2 id="15-组合，而不是继承"><a href="#15-组合，而不是继承" class="headerlink" title="15. 组合，而不是继承"></a>15. 组合，而不是继承</h2><p>Go 采用了一种不同寻常的面向对象编程方法，它允许在任何类型上添加方法，而不仅仅是类；但没有任何形式的基于类型的继承，比如子类。这意味着没有类型层次体系（type hierarchy）。这是一个有意的设计选择。虽然类型体系已经被用来构建了很多成功的软件，但我们认为这个模型已经被过度使用，应该后退一步。</p>
<p>取而代之的是 Go 的接口，这个想法在其他地方已经被详细讨论过了（例如参见<a href="https://research.swtch.com/interfaces" target="_blank" rel="external">research.swtch.com/interfaces</a>），但这里还是做一个简单的总结。</p>
<p>在 Go 里面，一个接口 <strong>仅仅</strong> 是一组方法的集合。例如，这里是标准库中 <code>Hash</code> 接口的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</div><div class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></div><div class="line">    Reset()</div><div class="line">    Size() <span class="keyword">int</span></div><div class="line">    BlockSize() <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有实现这些方法的数据类型都隐式地满足这个接口，没有 <code>implements</code> 声明。尽管如此，是否满足接口是在编译期静态检查的，所以接口是类型安全的。</p>
<p>一个类型通常会满足许多接口，每个接口对应于其方法的一个子集。例如，任何满足 <code>Hash</code> 接口的类型也会满足 <code>Writer</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</div><div class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种接口满足的流动性鼓励了一种不同的软件构造方法。但在解释这个之前，我们应该先解释一下为什么 Go 没有子类。</p>
<p>面向对象编程提供了一个强大的洞见：<strong>数据的行为可以独立于数据的表示进行泛化（generalized）。</strong> 当行为（方法集）是固定的时候，这个模型的效果最好，但是一旦你对一个类型进行了子类化，并添加了一个方法，行为就不再相同。相反地如果行为集是固定的，就好像 Go 静态定义的接口那样，行为的统一性使得数据和程序可以统一、正交、安全地组合。</p>
<p>一个极端的例子是 Plan 9 内核，所有的系统数据项都实现了完全相同的接口，即由 14 个方法定义的文件系统 API。这种统一性允许的对象组合水平，即使在今天也极少能在其它系统上看到。这样的例子比比皆是。这里还有一个：一个系统可以将 TCP 协议栈导入（import，这是 Plan 9 的术语）到一台没有 TCP 甚至没有以太网（Ethernet）的计算机上，然后通过这个网络连接到一台 CPU 架构不同的机器上，导入它的 <code>/proc</code> 树，并运行一个本地调试器对远程进程进行断点调试。这种操作在 Plan 9 上简直稀松平常，根本没有任何特别之处。做这种事情的能力完全来自它的设计，不需要特殊的安排（而且都是用普通 C 语言代码完成的）。</p>
<p>我们认为，这种组合式的系统构造风格已经被那些推崇按类型体系设计的语言所忽视。<strong>类型体系会造就脆弱易碎的代码。</strong> 体系结构必须在早期设计，通常是作为设计程序的第一步，而一旦程序写好就很难改动早期的决定。<strong>因此，该模型鼓励在早期做过度设计，程序员试图预测软件可能需要的每一种使用方式，增加多个类型和抽象层，仅仅为了以防万一。这是本末倒置的做法。系统各个部分的交互方式应该随着系统的发展去适配，而不是在一开始就固定下来。</strong></p>
<p>因此，Go 鼓励组合而不是继承，使用简单的、通常只有一个方法的接口来定义琐碎的行为，作为组件之间干净、可理解的边界。</p>
<p>上面提到的 <code>Writer</code> 接口，它被定义在 <code>io</code> 包里：任何有 <code>Write</code> 方法的类型，只要有以下这个方法签名，就可以和补充的 <code>Reader</code> 接口一起工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个互补的方法可以类型安全地跟丰富的行为进行连接（chaining），就像通用的 Unix 管道（pipes）一样。文件、缓冲区、网络、加密器、压缩器、图像编码器等都可以连接在一起。格式化 I/O 子程序 <code>Fprintf</code> 采用一个 <code>io.Writer</code> 接口作为参数，而不是像在 C 语言里那样采用 <code>FILE*</code> 。格式化输出程序并不了解内容是写到了哪里，它可能是一个图像编码器，背后又输出给一个压缩器，压缩器又输出给一个加密器，加密器又输出给一个网络连接。</p>
<p>接口组合是一种不同的编程风格，习惯了类型层次体系的人需要调整思路才能适应，但这样可以获得设计的适应性，这是通过类型体系很难实现的。</p>
<p>还要注意的是，消除类型层次结构也消除了一种形式的依赖层次结构。接口的满足允许程序有机地生长，而不需要预先确定的合约。而且它是一种线性的增长形式，对一个接口的改变只影响该接口的直接用户，不需要再更新子树。缺乏 <code>implements</code> 声明会让一些人感到不安，但它能让程序自然、优雅、安全地生长。</p>
<p>Go 的接口对程序设计有重大影响。其中一个地方是用接口作为参数的函数的使用。这些不是方法，而是函数。一些例子应该可以说明它们的力量。<code>ReadAll</code> 返回一个字节切片（数组），包含了所有可以从 <code>io.Reader</code> 接口读取的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></div></pre></td></tr></table></figure>
<p>封装器（指接受一个接口参数并返回一个接口的函数）的使用也很普遍。下面是一些原型。 <code>LoggingReader</code> 记录传入的 <code>Reader</code> 的每个 <code>Read</code> 调用。 <code>LimitingReader</code> 在读取 <code>n</code> 个字节后停止。 <code>ErrorInjector</code> 通过模拟 I/O errors 来辅助测试。我们还能找到更多例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoggingReader</span><span class="params">(r io.Reader)</span> <span class="title">io</span>.<span class="title">Reader</span></span></div><div class="line"><span class="title">func</span> <span class="title">LimitingReader</span><span class="params">(r io.Reader, n <span class="keyword">int64</span>)</span> <span class="title">io</span>.<span class="title">Reader</span></div><div class="line"><span class="title">func</span> <span class="title">ErrorInjector</span><span class="params">(r io.Reader)</span> <span class="title">io</span>.<span class="title">Reader</span></div></pre></td></tr></table></figure>
<p>这些设计与分层的、子类型继承的方法完全不同，它们是更松散的（甚至是临时的）、有机的、解耦的、独立的，因此是可弹性伸缩的。</p>
<h2 id="16-错误处理"><a href="#16-错误处理" class="headerlink" title="16. 错误处理"></a>16. 错误处理</h2><p>Go 没有传统意义上的异常机制，也就是说，没有与错误处理相关的控制结构。（Go 确实提供了处理异常情况（例如除零异常）的机制。一对名为 <code>panic</code> 和 <code>recover</code> 的内置函数允许程序员处理类似的情况。然而，这些函数是故意设计得不好用，也很少使用，而且没有像 Java 库使用异常那样集成到代码库中。）</p>
<p>错误处理的关键语言特性是一个预先定义的接口类型 <code>error</code> ，它代表了一个有 <code>Error</code> 方法可以返回字符串的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</div><div class="line">    Error() <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码库使用 <code>error</code> 类型来返回错误的描述。结合函数多值返回的能力，很容易将计算结果与错误值（如果有）一起返回。例如，Go 里等价于 C 的 <code>getchar</code> 的函数不会在遇到 <code>EOF</code> 时返回一个超出范围的值，也不会抛出一个异常；它只是在字符旁返回一个 <code>error</code> 值， <code>nil error</code> 值表示成功。下面是缓冲 I/O 包的 <code>bufio.Reader</code> 接口类型的 <code>ReadByte</code> 方法的签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></div></pre></td></tr></table></figure>
<p>这是一个简单清晰的设计，很容易理解。错误只是值，程序用它们来计算，就像用任意其他类型的值来计算一样。</p>
<p>在 Go 中不加入异常是一个刻意的选择。虽然有很多批评者不同意这个决定，但有几个原因让我们相信它可以让软件变得更好。</p>
<p>首先，计算机程序中的错误并不是真的『异常』（nothing truly exceptional，译者注：也可以翻译成：没有什么特别，平平无奇，这里翻译成异常，是为了跟 exception 的中文术语对应）。例如，无法打开文件是一个常见的问题，不值得使用特殊的语言结构； <code>if</code> 和 <code>return</code> 就可以了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f, err := os.Open(fileName)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，如果使用特殊的控制结构，错误处理会扭曲（distorts）程序处理错误的控制流（control flow）。Java 风格的 <code>try-catch-finally</code> 块跟多个重叠的控制流互相交错，而这些控制流本身的交互就很复杂。相比之下，虽然 Go 使代码在检查错误时更加啰嗦，但显式的设计使控制流保持了真正的（literally）简单直接。</p>
<p>毫无疑问，由此产生的代码可能会更长，但这种代码的清晰和简单可以弥补它的啰嗦。<strong>明确的错误检查迫使程序员在错误出现时就考虑并处理它们。</strong> 异常太容易让人们忽略而不是处理它们，将责任推给调用栈，直到为时已晚，无法很好地修复乃至诊断问题。</p>
<h2 id="17-工具"><a href="#17-工具" class="headerlink" title="17. 工具"></a>17. 工具</h2><p>软件工程需要工具。每一种语言都是在一个有其他语言和大量工具的环境中运行，这些工具用来编译、编辑、调试、性能分析、测试和运行程序。</p>
<p>Go 的语法、包系统、命名惯例和其他特性在设计时就已经将工具易于编写考虑在内，库里面包括了 Go 的词法分析器、解析器和类型检查器。</p>
<p>控制 Go 程序的工具非常容易编写，以至于这样的工具现在已经有很多，有些工具对软件工程产生了很有趣的影响。</p>
<p>其中最著名的是 <code>gofmt</code> ，Go 的源代码格式化工具。从项目一开始，我们就打算用机器来格式化 Go 程序代码，从而消除程序员之间争论的一整个问题分类：该如何排版代码？ <code>gofmt</code> 运行在我们编写的所有 Go 程序上，大多数开源社区也在用它。它是作为代码仓库的『提交前（presubmit）』检查来运行的，以确保所有检入（check-in）的 Go 程序格式都是一样的。</p>
<p><code>gofmt</code> 经常被用户推崇为 Go 最好的特性之一，尽管它根本不是 Go 语言的一部分。 <code>gofmt</code> 的存在和使用意味着，从一开始，社区里看到的代码总是按照 <code>gofmt</code> 的格式，所以 Go 程序有一个现在大家都很熟悉的统一风格。统一的表现形式使得代码更容易阅读，因此工作起来也更快。不用花时间格式化代码，时间就可以节省下来干别的。 <code>gofmt</code> 还影响了可伸缩性：<strong>既然所有的代码看起来都是一样的，团队就更容易一起合作，也更容易使用其他人的代码</strong>。</p>
<blockquote>
<p>译者注：</p>
<p>这个功能虽然看起来不起眼，但在实际的团队开发中其实是很实用的。在使用别的没有统一风格的语言时，总是要为统一团队的代码风格付出额外的精力（尤其是有新成员加入时）。</p>
<p>我们要么给团队制定统一的风格规范，并落实到每个人（最好使用格式化插件并应用相同的配置）；要么忍受代码里同时存在好几种风格穿插，影响阅读。</p>
<p>更糟糕的情况是，几个人都启用了格式化插件，却应用了不同的配置，先后修改同一份代码，提交时就很容易出现大量差异乃至冲突，实际上仅仅是代码风格的差异。这些无关紧要的差异如果不小心提交到仓库，真正重要的修改就将被淹没其中，干扰我们日后查看历史分析问题。</p>
</blockquote>
<p><code>gofmt</code> 还使另一类我们之前没有清晰预见到的工具得以实现。 <code>gofmt</code> 的工作原理是解析源代码，并从解析树本身重新格式化。这使得在格式化之前可以编辑解析树，于是一套自动重构工具应运而生。这些工具很容易编写，由于它们直接在解析树上工作，所以语义丰富，可以自动生成规范格式化的代码。</p>
<p>第一个例子是 <code>gofmt</code> 本身的 <code>-r</code> （rewrite）标志参数，它使用简单的模式匹配语言来实现表达式级别的重写。比如有一天，我们为切片表达式的右侧引入了一个默认值：切片本身的长度。只需一条命令，整个 Go 源代码树就被更新为使用这个默认值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gofmt -r <span class="string">'a[b:len(a)] -&gt; a[b:]'</span></div></pre></td></tr></table></figure>
<p>这个转换的一个关键点是，因为输入和输出都是规范格式，所以对源代码所做的唯一改变是语义上的改变。</p>
<p>一个类似但更复杂的处理是，当 Go 语言里以换行结束的语句，不再需要分号作为终止符时， <code>gofmt</code> 可以用来更新源码树。</p>
<p>另一个重要的工具是 <code>gofix</code>，它可以运行用 Go 本身编写的『源码树重写模块（tree-rewriting modules）』，因此能够进行更高级的重构。 <code>gofix</code> 工具让我们在 Go 1 发布之前对 API 和 语言特性 进行了全面的修改，包括修改 map 删除条目的语法，为操作时间值引入全新的 API ，等等。随着这些变化的推出，用户只需要运行简单的命令就能更新他们的所有代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gofix</div></pre></td></tr></table></figure>
<p>请注意，这些工具允许我们，在旧代码仍然可以正常工作的前提下，更新代码。因此，Go 的代码仓库很容易随着库的演化保持更新。旧的 API 可以快速自动地被废弃，因此只需要维护一个版本的 API。例如，我们最近改变了 Go 的协议缓冲区实现，改为使用 “getter” 函数，而之前的接口并没有这些函数。我们在 Google 所有 Go 代码上运行 <code>gofix</code> 来更新所有使用协议缓冲区的程序，现在只有一个版本的 API 在使用。在 Google 的代码库规模下，对 C++ 或 Java 库进行类似的全面修改几乎是不可能实现的。</p>
<p>Go 标准库里的解析包，让其他一些工具也得以实现。例如 <code>go</code> 工具，它可以管理程序的构建，包括从远程代码仓库获取包；<code>godoc</code> 文档提取器，是一个验证 API 兼容性合约是否随着库的更新而得到维护的程序；等等。</p>
<p>虽然像这样的工具在语言设计中很少被提及，但它们是语言生态系统中不可缺少的一部分，事实上，Go 在设计时就考虑到了工具的问题，这对语言、库和社区的发展都有巨大的影响。</p>
<h2 id="18-结论"><a href="#18-结论" class="headerlink" title="18. 结论"></a>18. 结论</h2><p>Go 在 Google 内部用得越来越多。</p>
<p>一些面向用户的大型服务都在使用它，包括 <code>youtube.com</code> 和 <code>dl.google.com</code> （提供 Chrome、Android 和其他下载的下载服务器），以及我们自己的 <code>golang.org</code> 。当然也有很多小的服务，大多是使用 Google App Engine 对 Go 的原生支持构建的。</p>
<p>很多其他公司也在使用 Go；这个名单很长，但其中比较著名的几个是：</p>
<ul>
<li>BBC Worldwide</li>
<li>Canonical</li>
<li>Heroku</li>
<li>Nokia</li>
<li>SoundCloud</li>
</ul>
<p>看来，Go 正在实现它的目标。不过，现在宣布成功还为时过早。我们还没有足够的经验，尤其是在大型程序（数百万行代码那种）方面的经验，去断言我们已经成功创造了一门弹性可伸缩的语言。尽管所有的指标都是正面的。</p>
<p>在较小的范围内，一些小事情还不够好，可能会在 Go 以后的版本里微调（Go 2？）。例如，变量声明语法的形式太多，程序员很容易被非 nil 接口里面的 nil 值的行为搞糊涂，还有很多库和接口的细节可以再进行一轮设计。</p>
<p>不过值得注意的是， <code>gofix</code> 和 <code>gofmt</code> 在 Go 1 的前期给了我们修复许多其他问题的机会。正因为有这些工具，Go 在今天得以更接近它的设计者的期待，而这些工具本身也是由于语言的设计才得以实现。</p>
<p>不过，不是所有事情都已经确定。我们还在学习中（但语言暂时是冻结的）。</p>
<blockquote>
<p>译者注：根据译者的理解，这里的语言冻结，应该是指为了兑现 Go 1 backwards compatibility 的承诺，Go 1.x 的 API 已经基本固定，后续只会新增特性和对现有特性做兼容的微调，更多是在底层实现上做改进。破坏兼容性的修改，只能等到 Go 2。</p>
</blockquote>
<p>Go 语言的一个主要的弱点，是它的实现仍需努力改进。编译器生成的代码，尤其是运行时的性能应该更好，这方面的工作还在继续。目前已经取得了一些进展；事实上，一些基准测试显示，与 2012 年初发布的第一版 Go 相比，当前开发版的性能已经翻了一番。</p>
<h2 id="19-小结"><a href="#19-小结" class="headerlink" title="19. 小结"></a>19. 小结</h2><p>软件工程指导了 Go 的设计。与大多数通用编程语言相比，Go 的设计是为了解决我们在构建大型服务器软件时接触到的一系列软件工程问题。这么一说，这可能会让 Go 听起来相当沉闷和工业化，但事实上，在整个设计过程中，对清晰、简单和可组合性的关注反而导致了一门工作效率高且有趣的语言，很多程序员都觉得它表达力强而且功能强大。</p>
<p>造就这个结果的特性包括：</p>
<ul>
<li>清晰的依赖关系</li>
<li>清晰的语法</li>
<li>清晰的语义</li>
<li>组合而非继承</li>
<li>编程模型提供的简单性（垃圾回收、并发）</li>
<li>易用的工具（<code>go</code> 工具、<code>gofmt</code> 、 <code>godoc</code> 、 <code>gofix</code> ）</li>
</ul>
<p>如果你还没有尝试过 Go，我们建议你去尝试：</p>
<p><a href="https://golang.org" target="_blank" rel="external">https://golang.org</a></p>
<blockquote>
<p>译者小结：</p>
<p>一万八千多字，终于翻译完了。</p>
<p>一开始我没有留意原文的字数，以为最多花两个晚上，就能翻译完。实际上，如果不涉及那么多专业概念，没有那么多上下文省略和带歧义的表述，这个长度两晚也是可以勉强完成的。</p>
<p>可本文就是有很多地方，需要有相关的背景知识，无法单纯从原文确定作者的准确意思。没办法，有歧义又了解不够的地方，只好查资料、翻源码，猜测原作者最大可能想表达什么。所以导致翻译进度又慢又累。而即使这样，如开头所说，仍然无法避免会有理解偏差和错误。</p>
<p>这样一来，对之前的译文就变得更加宽容了。笔误和排版混乱仍然不应该。但那些在我看来像是显而易见的错误，也许只是刚好落入了我的知识范围；而我的译文里，可能也有落在我知识盲区最后只好瞎蒙的地方，成为别人眼里的低级错误。</p>
<p>欢迎留言指出错误，或者提出你不同的见解。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在写 Go 语言实战系列的文章，中间想聊一下 Go 的设计原则，发现自己理解得还是不够深入，写得辞不达意。然后找到了 Rob Pike 在 8 年前的演讲稿，拜读学习之后，想推荐给我的读者作为学习资料。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（1）： 初识</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-1/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-1/</id>
    <published>2020-08-18T04:15:12.000Z</published>
    <updated>2020-08-20T15:32:30.259Z</updated>
    
    <content type="html"><![CDATA[<p>前几年接触到 Go ，使用一段时间之后就发现这就是我需要的语言。作为一个诞生了只有 10 年的语言，Go 的上升趋势非常之快，尤其受到 web 后端开发者的欢迎。</p>
<a id="more"></a>
<p>可是根据我的了解，身边的朋友多数还是停留在听说的阶段。了解不多，好处不明确，看起来很折腾，然后就算了。所以我想写一个关于 Go 语言的系列，希望给大家一些直观的认识。</p>
<p>这个系列的标题『Go 语言实战』（英文 Golang In Action）跟一本 Go 的入门书撞了，但我实在觉得这个名字很好，也想提醒自己先实战落地，尽量不要一下子涉及太多干巴巴的理论，所以先用着。我没看过那本书，内容如有雷同，纯属巧合。</p>
<h2 id="目标读者"><a href="#目标读者" class="headerlink" title="目标读者"></a>目标读者</h2><p>本系列的目标读者，暂时定位是：</p>
<ul>
<li>有其它语言编程经历，对 Go 感兴趣，希望快速了解和上手 Go；</li>
<li>尝试过 Go，希望进一步系统了解和学习。</li>
</ul>
<p>对于零编程基础、希望同时学习如何编程的朋友来说，这些文章可能省略了部分编程的基础知识。我不确定是否能达到学习编程的效果。如果你们愿意，可以尝试关注我的文章，并参与讨论。文章没有涉及的基础知识和练习，我尝试给出自学建议，或者在评论、群聊中解答。</p>
<p>如果你不愿意或者抽不出时间练习和讨论，希望只是看文章就能学会，我想很难达到效果。</p>
<p>而如果你已经用 Go 写过一些项目，对 Go 有一定的认知，这个系列的文章为了迁就不同人的水平，对你来说也许会过于浅显。当然，如果有大佬愿意指正，甚至参与讨论，在群聊里指导，那是求之不得。</p>
<h2 id="为什么是-Go"><a href="#为什么是-Go" class="headerlink" title="为什么是 Go"></a>为什么是 Go</h2><h3 id="主流的语言"><a href="#主流的语言" class="headerlink" title="主流的语言"></a>主流的语言</h3><p>主流编程语言的排名，根据不同的统计口径略有差异，但前几名基本逃脱不了： C、C++、Java、Python、JavaScript。它们各有所长，互相补充，选择它们当中某几种的组合，就可以包揽几乎所有类型的开发：</p>
<ul>
<li><p>C / C++：硬件相关、操作系统相关、性能极端敏感</p>
<p>  直接跟硬件设备、系统接口打交道，亲自管理内存，避免中间层浪费性能。可以写驱动、嵌入式软件、系统组件、桌面软件和大型游戏。当然，如果对性能足够敏感，对开发成本不敏感，理论上除了 web 前端外的所有软件都可以用 C / C++ 完成。</p>
</li>
<li><p>Java：桌面、Android、web 服务</p>
<p>  如果不需要跟硬件和系统深入打交道，对性能要求不那么极端，又考虑开发效率，Java 则是最主流的选择。JVM 屏蔽了部分技术细节，背后又有多年积累的强大第三方类库（尤其是 Spring 的一系列框架），使 Java 成为企业级软件开发的不二之选。</p>
</li>
<li><p>Python：脚本、数据处理、web 服务</p>
<p>  如果对性能要求进一步放宽，希望提升开发效率，Python 就成了首选。在各种内部使用场景，或者是用户不多的小型服务，性能根本不重要；相反快速落地跑起来特别重要。Python 语法简洁直观，表达能力强，类库也相当丰富（尤其是数据处理、机器学习这一块），大幅降低了非计算机科学科班人员（统计学家、数学家、AI 研究员）的编程门槛，成为了计算机与其他学科交叉领域以及快速原型的第一语言。</p>
</li>
</ul>
<blockquote>
<p>JavaScript 比较特殊。它是 web 前端的唯一语言（浏览器不支持别的），不可被替代。另一方面，虽然通过 node.js 具备了全栈能力，js 的语言特性决定了在前端以外的领域跟专门的语言还是有一定差距，可以作为小团队或者小服务的快速落地选择，却很难替代其它语言。这两点决定了，js 跟其它语言的比较没有太大意义。</p>
</blockquote>
<p>你可能会产生一个疑问：</p>
<p><strong>这些语言还不够吗，为什么还要费劲巴拉再学一个 Go 语言？</strong> </p>
<h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>看一下这样的场景：</p>
<ul>
<li><p>C / C++ 适合开发偏底层、性能敏感的需求。C 简洁但表达力比较弱； C++ 范式较多容易出错；内存管理和并发都是大坑。</p>
<p>  一般的做法，是通过自行开发和引用第三方库，引入相关的类库和规范，去解决这些问题。小心翼翼地挑选库，没有合适的就自行开发，制定规范，说服团队的人达成一致，开发辅助工具和编写静态检查…… 然后，<strong>你基本上等于自行发明了 Go 的部分特性</strong> 。但肯定没有 Go 实现语言级支持那么简洁方便。</p>
<p>  实际上，前金山和盛大的架构师、现七牛云 CEO 许式伟就做过这种事，他用 C++ 开发出了 CERL 库。<strong>但在他用了一周 Go 之后，彻底放弃 CERL，改为使用 Go。</strong> 大家可以看他的自述 《<a href="https://mp.weixin.qq.com/s/_YsuoX4OyWT6CSXuOwc1EA" target="_blank" rel="external">许式伟：我与Go语言的这十年</a>》。</p>
</li>
<li><p>Java（实际上是 Spring 套件）是web 服务最主流的选择。Java 有大量从业人员、企业级的框架，也在过去积累了大量的成功案例。与这些优点相比，语法稍显啰嗦、新特性大幅改动语言、线程重所以大规模并发需要额外引入协程支持等等，都不算什么问题。</p>
<p>  让 Java 略显老态的，可能是（微）服务化 和 容器化 的大背景下，JVM 的摆放位置。从前，编译语言需要为不同平台解决依赖并编译，而 Java 只需要安装一个 JVM，就把平台差异给抹平。单体应用时代，服务器不多，JVM 是配置环境早期一劳永逸的事，当然比每个版本都折腾依赖和交叉编译省事。</p>
<p>  <strong>微服务 和 容器 把这个对比给逆转了。</strong> 微服务大量的应用实例，手动配置环境变得不再现实；JVM 对容器而言，无论容量还是启动速度，都有点太重。另一边，容器把依赖和编译变成了几个镜像的事，不再复杂，编译成二进制开始比虚拟机语言和解释器语言更便利。</p>
<p>  远程开发过一个系统，使用者毫无技术背景。服务除了部署在阿里云上，也有备份在个人电脑上离线演示的需求。很难想象该如何远程指导他们安装 JVM 并配置环境变量，可能还需要 Tomcat，然后正确启停服务。<strong>最后他们并没有去安装 JVM，只是直接运行收到的可执行文件，Go 写的。</strong> 注意这里还没有涉及服务化，没有 Docker 容器。这是我的亲身经历。</p>
</li>
<li><p>Python 分做大项目还是小工具。</p>
<p>  大项目的问题是，规模上去之后，难以通过静态分析发现潜在问题，后续对开发团队的素质要求会越来越高。因为这点，也因为性能问题，Python 开发大型项目似乎不是主流，更多用在脚本、小项目、内部工具上。坚持使用 Python 的团队，往往对代码简洁清晰有追求。这时候，简洁程度相近，更容易发现错误、速度更快的 Go，就很有诱惑力了。</p>
<p>  Python 也有一个运行时，有跟 JVM 类似的问题。Python 自然是脚本和小工具的首选语言，我曾经写过不少。在自己机器和固定几个服务器执行时，没有任何问题。可当需要把工具分享出去时，特别是分享给非开发岗的同事和朋友时，类似 JVM 的问题就出现了。<strong>这些需要分享出去的工具，最后都用 Go 重写了一遍。</strong></p>
</li>
</ul>
<p>借网上两张图来说明（来源：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65）" target="_blank" rel="external">https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65）</a></p>
<p>这篇文章我也做了简单的评论，请看《<a href="https://jaycechant.info/2020/review-why-should-you-learn-go/">为什么你应该学 Go？</a>》</p>
<p><img src="../../images/fast-for-human-vs-fast-for-computer.png" alt=""></p>
<blockquote>
<p>Go 寻求对人友好和对机器友好的平衡。</p>
</blockquote>
<p>Go 诞生得晚，所以对于并发的支持可以从一开始就考虑在内。协程（coroutine）和 CSP 等理论虽然很早就有，但是在早些年还不够流行。现在像 Java 也通过一些第三方库引入了对 协程 和 CSP 模型的支持，但这种支持肯定不如语言内置支持来得简洁有效。</p>
<p><img src="../../images/concurrency-vs-beautiful-code.png" alt=""></p>
<blockquote>
<p>Go 内置 goroutine（go 协程） 和 CSP （Communicating Sequential Processes 通信顺序进程）支持，帮助写出既直观又高效的并发代码。</p>
<p>左下角的语言在诞生之初就没有考虑并发的问题。</p>
</blockquote>
<p>这两张图可能略有点夸张，显得不需权衡就可以我都要；Go 比较靠近右上角，只是可能没有那么右上。但 Go 平衡得比较好，横轴和纵轴都有很好的表现是真的。</p>
<p>即使是 Go 吹，也得承认 Go 有很多不足。除非是底层技术或者计算理论的重大革新，<strong>新语言不过是重新做一次前人做过的选择题</strong>。Go 诞生得晚，吸收了更多经验教训，更符合一部分人的需要。但为了保持最主要的几个优势（像更快的编译和执行速度、更低的心智负担），也做出很多让步，有做不到做不好的地方（如泛型）。</p>
<p>这些选择解决了一批人的痛点，不可能满足所有应用场景和需要：</p>
<ul>
<li>设备或系统深度绑定、极端的性能或者资源要求，还是得 C 和 C++。Go 处理这些场景需要借助 cgo 访问 C，如果项目规模不大，还不如直接写 C。</li>
<li>对于性能、正确性、可用性要求非常苛刻的业务，特别是不必做服务治理的单体应用，Java 的开发框架久经考验，积累了更多成熟的类库和调优经验。相比之下年轻的 Go 虽然在快速追赶，类库的选择范围暂时还窄一些。</li>
<li>至于处理各种数据，追求快速改动、只在本地运行的脚本，Python 就很好。静态强类型反而是累赘。</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我之前已经写过几篇关于 Go 语言环境配置的文章，在 1.13 包管理正式转向 go module 后，又重新写了两篇。</p>
<p>当前 Go 的最新版本是 1.15。Go 1 承诺接口稳定，向后兼容（backwards compatibility，兼容老代码），最近版本的改动主要集中在编译器、工具链 和 bug fix 上。从使用的角度最大的变动是 1.11 ~ 1.14 之间持续改进的 go module ，所以环境配置直接参考 1.13 时的文章即可。</p>
<p>请根据平台选择：（先把下面的配置教程看完，再接着往下走）</p>
<ul>
<li>Linux / Mac ：<a href="https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/">配置 1.13+ 的 golang 环境</a></li>
<li>Windows：<a href="https://jaycechant.info/2020/golang-1-13-env-for-win/">配置 1.13+ 的 golang 环境（Windows 篇）</a></li>
</ul>
<p>IDE 方面，大家普遍对 GoLand 和 VS Code 评价很高。不差钱可以选择前者，功能更强响应更快；开源的后者也很不错，机器配置低时偶有卡顿不至于影响使用。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>不能免俗地，我们从 Hello World 程序开始。</p>
<p>都这样开头是有原因的，打印一句话仅仅依赖一个函数，涉及的知识点最少。今天的导入有点长，尽量避免再展开更多复杂的内容。</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>这里假定你已经完成了环境配置，并按照建议将 <code>GO111MODULE</code> 设为 on。（国内为了默认启用 proxy，只能为 on。如果你不知道我说什么，请回到配置教程。）</p>
<p>换言之，包管理使用 Go Module 模式，哪怕只是写最简单的 Hello World，也需要建立 module。</p>
<p>Module 模式下，项目可以随便放在任何方便的地方。为项目新建一个目录，然后在根目录打开一个命令行（Win: cmd / Linux&amp;Mac: Terminal，你也可以在 IDE 里打开，VS Code: View &gt; Terminal，后续不再解释），执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go mod init hello</div></pre></td></tr></table></figure>
<p>你会看到根目录多了一个 <code>go.mod</code> 文件，里面记录了模块名、go 版本，以后还会用来记录依赖信息。</p>
<p>这就建立了一个名为 hello 的 module。这个名字你可以自己改。命名规范等讲到托管再说。现在可以先用小写字母、数字、减号<code>-</code> 的组合（字母开头）先随便起。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>然后新建一个 <code>main.go</code> 写代码。</p>
<p>以下代码请务必自己敲键盘输入。只有这样，才能明确了解这些到底都是什么符号。</p>
<p>如果误输了看起来相似的符号，像输入中文标点，就会出错。这是复制粘贴无法体会的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 程序必须以 main 包作为入口</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">// Println 函数在内置的 "fmt" 包，需要导入</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// main 包必须有一个 main 函数作为入口函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 调用 fmt 包下的 Println 函数，向标准输出打印一个字符串</span></div><div class="line">    <span class="comment">// Println 是 print line 的意思，自带换行</span></div><div class="line">    <span class="comment">// 你可以试着修改引号内的内容</span></div><div class="line">    <span class="comment">// 或者尝试换成 Print 函数看看效果</span></div><div class="line">    fmt.Println(<span class="string">"Hello World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码跑起来有几个选择，初期可以按方便的来。仍然是在刚才的命令行，为了熟悉，也请手敲不要复制：</p>
<ol>
<li><p>直接运行 <code>go run main.go</code></p>
</li>
<li><p>编译后运行</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先编译</span></div><div class="line">go build</div><div class="line"><span class="comment"># 编译结果是模块名，执行时替换成你的模块名</span></div><div class="line">./hello</div></pre></td></tr></table></figure>
</li>
<li><p>IDE 有执行插件，可以直接运行</p>
</li>
</ol>
<p>为了帮助理解后续的加载流程，试着加入 常量、变量和初始化函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 程序必须以 main 包作为入口</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">// Println 函数在内置的 "fmt" 包，需要导入</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// 常量</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    prefix = <span class="string">"Go-in-action:"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// （包级）全局变量</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    sentence <span class="keyword">string</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// init 函数，包第一次加载初始化时调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 你可以试着修改引号内的内容</span></div><div class="line">    sentence = prefix + <span class="string">"第一天打卡！"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main 包必须有一个 main 函数作为入口函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 调用 fmt 包下的 Println 函数，向标准输出打印一个字符串</span></div><div class="line">    <span class="comment">// Println 是 print line 的意思，自带换行</span></div><div class="line">    fmt.Println(sentence)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>理论知识可能枯燥，但绕不过去，只好尽量分散每次讲一点。</p>
<p>现在你已经把第一个 Go 程序跑起来，我们接着聊聊一个程序的结构。</p>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>Go 语言程序组织的基本单位是包（package）。</p>
<p>这点有点像 Java，都是通过一个类似 URL 的地址来唯一确定一个包，并以此引用。但是两者又有很多的不同。</p>
<blockquote>
<p>以下对比主要方便有 Java 经验的朋友快速理解。没写过 Java 的朋友可以跳过 Java 部分。</p>
<p>myproj/src/com/example/foo/bar/pkg1/MyClass.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.foo.bar.pkg1;</div><div class="line"></div><div class="line"><span class="comment">// 导入包</span></div><div class="line"><span class="keyword">import</span> com.example.foo.bar.pkg2.MyClass2;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 各种成员必须从属于某个类</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    <span class="comment">// 已导入的类直接使用类名访问</span></div><div class="line">    MyClass2 mc2 = <span class="keyword">new</span> MyClass2();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>myproj/foo/bar/pkg1/whatever.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pkg1</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="comment">// 一般情况下，这个包就叫 pkg2</span></div><div class="line">    <span class="string">"example.com/myproj/foo/bar/pkg2"</span></div><div class="line">    <span class="comment">// 又来一个 pkg2，导入时可以指定一个名字，避免引用时跟上面重名</span></div><div class="line">    other <span class="string">"example.com/other/pkg2"</span></div><div class="line">    <span class="comment">// 下面这个包的包名定义为 "package special"，与路径不一致，一般不推荐这样定义</span></div><div class="line">    <span class="string">"example.com/other/dir"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 跟 Java 不同，常量、变量、类型、函数等成员可以作为『第一公民』</span></div><div class="line"><span class="comment">// 直接从属于包</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ( <span class="comment">// 常量</span></div><div class="line">    MyConst <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> ( <span class="comment">// 变量</span></div><div class="line">    MyVar float = <span class="number">2.3</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123; <span class="comment">// 结构体</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">    <span class="comment">// 引用 example.com/myproj/foo/bar/pkg2</span></div><div class="line">    <span class="keyword">var</span> ms2 pkg2.MyStruct2</div><div class="line">    pkg2.MyFunc2()</div><div class="line">    <span class="comment">// 引用 example.com/other/pkg2 （导入同时重命名为 other）</span></div><div class="line">    other.OtherFunc()</div><div class="line">    <span class="comment">// 引用的是 example.com/other/dir，为什么会这样，下面看它的定义</span></div><div class="line">    c := special.SomeConst</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>example.com/other/dir/file-name-not-matters.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入路径最后一级目录是 dir，包名却是 special</span></div><div class="line"><span class="comment">// 没有特殊理由不推荐这样操作，会给调用方造成困扰</span></div><div class="line"><span class="keyword">package</span> special</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    SomeConst = <span class="number">42</span></div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>包名<ul>
<li>Java 包名类似 URL 域名部分，以 <code>.</code> 隔开。为了确保全网唯一性，一般以作者的域名作为前缀（如 <code>example.com</code>，作为包名前缀时倒序从顶级域名写起）。无论声明还是导入，都需要写完整的包名。</li>
<li>Go （基于 Go Module 的包管理）则多出 module 这个概念：module 是一到多个放在一起的包的集合。完整的包路径包含 module 名 和 相对 module 的文件夹路径（module 名如 <code>example.com/myporj</code> ，在 module 根目录的 <code>go.mod</code> 里定义，一般对应托管地址）。<strong>Go 的 包名 与 包路径互相独立：声明、引用时用包名；导入时用包路径。没有特殊理由，包名一般与所在目录保持一致，避免调用方还要查看包名。</strong></li>
</ul>
</li>
<li>最小单位<ul>
<li>Java 中类（广义的类，包括 抽象类 和 接口）是唯一的一等公民，所有成员都无法脱离类存在。所以包管理的最小单位其实是 类。同一个包允许有多个 <code>.java</code> 文件，每个文件是一个类。导入时也是导入类。</li>
<li>Go 则以包为最小单位。同一个包允许有多个 <code>.go</code> 文件，但都属于同一个包，分开写只是方便管理，编译时会自动合并。导入包后，通过包名引用该包下的公开成员（更准确的说法是 exported 成员）。</li>
</ul>
</li>
</ul>
<p>对于 module 和 package ，这里先留个印象，如果觉得信息量大可以先不深究。更多关于 Go 包管理的讨论，可以看这篇 《<a href="https://jaycechant.info/2020/golang-1-13-module-VS-package/">golang 1.13 - module VS package</a>》。</p>
<h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p>Go 的可执行程序，必定包含一个 main 包，里面有一个签名为 <code>main()</code>  的函数。<strong>这就是程序的执行入口</strong>。这跟 C style 语言非常类似，不过 Go 的 main 函数既没有参数，也没有返回值。</p>
<p>如果需要解析命令行参数，需要导入 <code>os</code> 包通过 <code>os.Args</code> 获取（也有第三方包封装了更方便易用的接口）。类似地，如果错误退出想返回错误码，也是通过 <code>os</code> 包的 <code>os.Exit(code)</code> 进行。</p>
<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>会自动调用的特殊函数除了 main 包的 main 函数以外，还有就是签名为 <code>init()</code> 的函数。</p>
<p>每个包允许有零到多个 init 函数。它们会在包被第一次导入时，常量、变量初始化之后被调用。<strong>同包的多个 init 函数会按照某种顺序依次执行。官方没有对顺序作出任何保证，最好当作乱序执行，程序逻辑不要依赖执行顺序。</strong></p>
<p>整个程序的初始化顺序从加载 main 包开始，然后递归加载导入的包。</p>
<p>在被加载的包内部，先完成所有依赖包的加载和初始化（如果是加载过的包，则跳过初始化），然后初始化当前包的常量、变量，执行所有 init 函数。</p>
<p><img src="../../images/go-starter-package-init.svg" alt=""></p>
<blockquote>
<p>main 包 import pkg2 时，pkg2 已经完成了初始化，直接导入即可</p>
</blockquote>
<p>在依赖最底层的包（同时不依赖任何别的包）最晚被加载，却最早完成初始化。相反 main 包第一个被加载，却最后完成初始化，然后调用 main 函数。</p>
<p><strong>Go 不允许循环导入。</strong></p>
<p>被依赖方的初始化过程，不能依赖任何依赖方创建的东西。如， A import B，则不仅 B 不能导入 A，而且在 B 初始化的过程中要当 A 不存在，不能依赖于 A 创建的全局状态 或 依赖注入。</p>
<p>特别地，main 作为所有初始化完成之后才调用的函数，不能被任何初始化过程依赖。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>第一篇不可避免要导入一些概念，尽管一再删减，抽象的内容还是聊得有点多，先到这里。理论的内容，等接触一段时间，有了实际体会再补不迟。</p>
<p>因为照顾不同读者的需要，也因为是第一篇，我对内容的深浅繁简没有把握，需要根据反馈调整。没有涉及到的内容，只能通过评论和群聊补充。新朋友可以添加微信号『存档君（MrArchive）』，说明来意后加群讨论。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>掌握编程语言仅仅是软件开发的第一步，后面还要掌握一定的 数据结构、算法 以及 具体业务的知识。就像掌握了画笔和颜料的使用，不代表就能画出漂亮的画作。</p>
<p>从头学编程的朋友，推荐在掌握语言基础之后，尝试去解决 <a href="https://leetcode-cn.com/" target="_blank" rel="external">https://leetcode-cn.com/</a>  easy 的题目。</p>
<p>做现实中的项目，我们要先识别需求（有时产品的同学会帮忙），将需求转换为技术描述，定义和分解问题，然后把问题逐个解决，组装成最终的软件。新手可能还没开始写代码就被难住了。相比之下，LeetCode 将经典问题抽象简化，直接给定了输入输出的数据类型和范围，你只需要考虑代码的实现。这种命题作文乃至看图说话，是一个很好的开始。</p>
<p>有编程经验的朋友，当然也可以刷题来加强，难度根据自己的实际情况挑选。我也会不定期发布用 Go 刷 LeetCode 的题解。</p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p>推荐一些 Go 的学习资源作为补充：</p>
<ul>
<li><p>菜鸟教程：<a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="external">https://www.runoob.com/go/go-tutorial.html</a></p>
<p>  比较简略，很多知识没有涉及。但是胜在足够简略，初学者看了不会晕。可以当做入门的手册。</p>
</li>
<li><p>Go by samples：<a href="https://gobyexample.com/" target="_blank" rel="external">https://gobyexample.com/</a></p>
<p>  不废话，直接上例子。适合有一定基础的朋友，直接看例子学习。</p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几年接触到 Go ，使用一段时间之后就发现这就是我需要的语言。作为一个诞生了只有 10 年的语言，Go 的上升趋势非常之快，尤其受到 web 后端开发者的欢迎。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 解题：统计全 1 子矩阵</title>
    <link href="https://jaycechant.info/2020/leetcode-1504-count-submatrices/"/>
    <id>https://jaycechant.info/2020/leetcode-1504-count-submatrices/</id>
    <published>2020-07-10T13:05:25.000Z</published>
    <updated>2020-08-12T09:21:58.819Z</updated>
    
    <content type="html"><![CDATA[<p>上周末试着参加了一下 LeetCode 的周赛。</p>
<a id="more"></a>
<blockquote>
<p>文章是 7/10 写的，所以这里指的是 7/5 的周赛</p>
</blockquote>
<p>90 分钟，总共四题，分别一题简单，两题中等，一题困难。在我看来，第 1、2 题都算简单，第 3 题的中等我很多年前做过；只有第 4 题最优解要用到比较少见的算法，不过还是有网友暴力解通过。</p>
<p>就是这样的难度，第 2 题一开始没反应过来，先做后面，然后在第 3 题耗费了太多时间（约 1H），留给 2 、4 的时间都不太够，最后只 AC  1、3。相比之下，最快的参加者 17 分钟全部 AC。自尊心受到暴击，只能用刚刚恢复刷题，太生疏给自己台阶。做的时候感觉很顺畅，回头一看时间，都不知道怎么跑掉的。是中年人反应迟钝了吗？</p>
<p>不管怎样，3、4 题还是值得说一下的。今天先讲第 3 题，对应 1504 号。</p>
<p>英文：<a href="https://leetcode.com/problems/count-submatrices-with-all-ones/" target="_blank" rel="external">https://leetcode.com/problems/count-submatrices-with-all-ones/</a></p>
<p>中文：<a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones/" target="_blank" rel="external">https://leetcode-cn.com/problems/count-submatrices-with-all-ones/</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h3><p>给定由 0, 1 组成的矩阵，<strong>求 元素全是 1 的子矩阵</strong> 的数量。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">输入：</div><div class="line">1,0,1</div><div class="line">1,1,0</div><div class="line">1,1,0</div><div class="line"></div><div class="line">输出：13</div><div class="line"></div><div class="line">解释：</div><div class="line">有 6 个 1x1 的矩形。</div><div class="line">有 2 个 1x2 的矩形。</div><div class="line">有 3 个 2x1 的矩形。</div><div class="line">有 1 个 2x2 的矩形。</div><div class="line">有 1 个 3x1 的矩形。</div><div class="line">矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13</div></pre></td></tr></table></figure>
<p>更多例子看测试用例</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul>
<li>行列最小 1，最大 150</li>
<li>矩阵元素只有 0 和 1</li>
</ul>
<p>为了后续方便讨论，约定行数为 R，列数为 C。</p>
<h2 id="测试代码先行"><a href="#测试代码先行" class="headerlink" title="测试代码先行"></a>测试代码先行</h2><blockquote>
<p>《<a href="../rapidly-generate-unit-tests-in-vs-code/">如何快速生成单元测试</a>》</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_numSubmat</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	tests := []<span class="keyword">struct</span> &#123;</div><div class="line">		name <span class="keyword">string</span></div><div class="line">		mat  [][]<span class="keyword">int</span></div><div class="line">		want <span class="keyword">int</span></div><div class="line">	&#125;&#123;</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"min0"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">0</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">0</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"min1"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">1</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"1"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">13</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"2"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">				&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">24</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"3"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">21</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"4"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</div><div class="line">				&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">5</span>,</div><div class="line">		&#125;,</div><div class="line">        <span class="comment">// 现在 LeetCode 周赛一次错误提交只罚时 5 分钟，代价不算大</span></div><div class="line">        <span class="comment">// 简单添加一些能马上想到的 case 即可，折腾超过 5 分钟不值</span></div><div class="line">        <span class="comment">// 能通过简单的 case 可以先提交一次，不行再针对强化</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> got := numSubmat(tt.mat); got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"numSubmat() = %v, want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>暴力做法非常简单，一句话带过：首先 O(RC) 遍历左上角选点，然后 O(RC) 遍历右下角选点，再用 O(RC) 判断选定的矩阵是否全 1，<strong>时间复杂度为 O((RC)^3)</strong> ，空间复杂度 O(1)。（提醒：R 是行数，C 是列数）也许数据弱的话能 AC（我没试），比赛时间不够也许可以蒙一下，但没有讨论价值。</p>
<p>这道题明显有大量重复子问题，稍有经验都应该马上往动态规划上靠。关于动态规划的基础常识，可以先看之前的文章：《<a href="../leetcode-10-regular-expression-matching/">LeetCode 题解： Regular Expression Matching</a>》，以后考虑围绕基础知识点写一些文章。</p>
<p>想到 DP 容易，难点是定义子问题，状态如何转移。多年前那次和这次，都第一时间知道是 DP 的题，仍然耗费不少时间想具体的状态转移方程。（虽然做过，相似的矩阵题太多，过了一阵才认出来，又花了一点时间回想有哪些方案。）</p>
<h3 id="思考方向"><a href="#思考方向" class="headerlink" title="思考方向"></a>思考方向</h3><p>最明显的重复运算，是对候选矩阵做全 1 判断。能否记录某些中间状态，根据少数点是否为 1， 结合这些中间状态得到下一个状态，避免前面判断过的 位置 再来一遍？</p>
<p>根据以往做 DP 的经验，一般是 <code>dp[r][c]</code> 代表到 r 行 c 列为止的某个结果。例如，我们定义两个矩阵 <code>width[r][c]</code> 和 <code>height[r][c]</code> 代表以 (r, c) 为右下角的矩阵的最大宽度和最大高度，从左上到右下运算。有没有可能从前面的状态，推算出以(r, c) 为右下角的极大矩阵呢？</p>
<p><img src="../../images/leetcode1504/leetcode1504-try-dp.svg" alt=""></p>
<blockquote>
<p>绿色表示已经处理过的点，白色表示待处理的点。下同。</p>
</blockquote>
<p>很难。我们找极大矩阵，是因为知道极大矩阵的大小，就很容易计算它有多少个子矩阵。但极大矩阵可以有很多个，光凭最大宽度和最大高度两个信息，无法计算出这么多个极大矩阵。那还要记录多少信息才够？</p>
<p><img src="../../images/leetcode1504/leetcode1504-extreme-matrix.svg" alt=""></p>
<blockquote>
<p>极大矩阵是指，这个矩阵在边界上碰到了 0，没办法变得更大了。但它不一定是最大的矩阵。</p>
<p>记录最大宽和最大高之所以很难用得上，是因为它们很可能不是在同一个矩阵上记录的，也很难用来计算那么多个极大矩阵。</p>
</blockquote>
<p>换一个角度看为什么这么难。假定可以用 O(1) 完成状态转移，计算出 (r, c) 点为右下角的所有极大矩阵，由于右下角只有 O(RC) 种情况，换言之时间复杂度从 O((RC)^3) 降到了 O(RC)，优化幅度非常大 。但多个极大矩阵真的能用 O(1) 时间就计算出来吗？要借用哪些中间结果？</p>
<p>事实上，这个方向是可行的。但我们先从简单一点的开始。</p>
<h2 id="压缩-DP"><a href="#压缩-DP" class="headerlink" title="压缩 + DP"></a>压缩 + DP</h2><p>二维的情况复杂，是因为长宽有多种组合；如果长宽不能同时达到最大，就会产生大量极大矩阵。</p>
<p>那就 <strong>从一维开始找规律</strong> 。</p>
<h3 id="一维问题：全-1-子段数"><a href="#一维问题：全-1-子段数" class="headerlink" title="一维问题：全 1 子段数"></a>一维问题：全 1 子段数</h3><p><img src="../../images/leetcode1504/leetcode1504-1d-dp.svg" alt=""></p>
<p>一维的情况，问题简化成『统计全 1 子段数』，其中任意长度不为 0 的连续区间 ，都是子段（interval）。假定数组长度为 N，Brute-Force 的做法是，O(N) 选左端点，O(N) 选右端点，O(N) 判断是否全 1，时间复杂度 O(N^3)。</p>
<p>这时用 DP，状态转移方程很好写。假定有一维数组 A，里面同样是 0 或 1。定义 L[i] 为 以第 i 个元素为右边界的子段的最大长度（换言之，连续多少个 1），很容易得到</p>
<p>$$<br>\left{<br>\begin{array}{lr}<br>L<em>i = L</em>{i-1} + 1, &amp; (A_i = 1)\<br>L_i = 0 &amp; (A_i = 0)<br>\end{array}<br>\right.<br>$$</p>
<p>大白话就是，<strong>遇到 1，最大长度加 1；遇到 0，长度清零</strong> 。</p>
<p>再定义 C[i] 为到 第 i 个元素为止，累计的的字段数，状态转移方程为</p>
<p>$$<br>\left{<br>\begin{array}{lr}<br>C<em>i = C</em>{i-1} + L_i, &amp; (A_i = 1)\<br>C<em>i = C</em>{i-1} &amp; (A_i = 0)<br>\end{array}<br>\right.<br>$$</p>
<p>大白话就是，遇到 1，就增加『当前子段最大长度 L[i] 这么多个子段数』；遇到 0，统计数字不变。为什么是 L[i] ？因为 <strong>以 A[i] 为右端点的子段刚好是 L[i] 个，分别为长度为 1、长度为 2、长度为 … 长度为 L[i] </strong> 。</p>
<p>DP 跟 BF 相比，省略了重复运算，但思维不严谨的话，很容易出现重复或者遗漏。我们来确认一下，是否每个左端点和右端点的组合都包含了一次：对于右端点，每个 A[i] = 1 ，都访问且只访问了一次；在确定右端点之后，每个和右端点连续（中间没有 0）的左端点都刚好统计了一次（L[i] 个）。</p>
<p>对于每个元素 A[i]，分别需要常数时间计算 L[i] 和 C[i] ，时间复杂度为 O(N)。由于 L 和 C 都只和当前元素和前一个状态相关，只需保留最后一个状态，没有必要保存数组，空间复杂度为 O(1)。</p>
<p>代码非常简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numInterval</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	length := <span class="number">0</span></div><div class="line">	count := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> _, elem := <span class="keyword">range</span> A &#123;</div><div class="line">		<span class="keyword">if</span> elem == <span class="number">1</span> &#123;</div><div class="line">			length++</div><div class="line">			count += length</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			length = <span class="number">0</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维问题：压缩成一维"><a href="#二维问题：压缩成一维" class="headerlink" title="二维问题：压缩成一维"></a>二维问题：压缩成一维</h3><p>一维的情况简单，我还是尽量详细地讲，因为这是理解接下来内容的基础。</p>
<p>对于高度为 2 的矩阵，求全 1 子矩阵数。这些子矩阵，高度要么为 1，要么为 2。<strong>对于高度为 1 的子矩阵，情况退回到 一维，分别对每一行应用一维的算法即可</strong> 。而对于高度为 2 的子矩阵，可以『压缩』成高度为 1，再应用一维的算法。</p>
<p><img src="../../images/leetcode1504/leetcode1504-2d-to-1d.svg" alt=""></p>
<p><strong>以此类推，任意高度的子矩阵，也可以压缩成一行处理</strong> 。而且，<strong>R 行压缩成一行，并不需要每次从头开始压缩；只需要在前 R - 1 行的结果上，再合并一行</strong> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSubmat</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	count := <span class="number">0</span></div><div class="line">	rowNum := <span class="built_in">len</span>(mat)</div><div class="line">	colNum := <span class="built_in">len</span>(mat[<span class="number">0</span>])</div><div class="line"></div><div class="line">	<span class="comment">// 压缩的结果只需要保留一行进行运算</span></div><div class="line">	<span class="comment">// 用 bool 值保存节省空间</span></div><div class="line">	mymat := <span class="built_in">make</span>([]<span class="keyword">bool</span>, colNum)</div><div class="line"></div><div class="line">	<span class="comment">// 遍历开始压缩的行数</span></div><div class="line">	<span class="keyword">for</span> rowSt := <span class="number">0</span>; rowSt &lt; rowNum; rowSt++ &#123;</div><div class="line">		<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">			mymat[col] = <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 遍历结束的行数</span></div><div class="line">		<span class="keyword">for</span> rowEd := rowSt; rowEd &lt; rowNum; rowEd++ &#123;</div><div class="line">			length := <span class="number">0</span></div><div class="line">			<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">				<span class="keyword">if</span> mat[rowEd][col] == <span class="number">0</span> &#123;</div><div class="line">					<span class="comment">// 同一列上任意一行为0，这个位置就断开了</span></div><div class="line">					mymat[col] = <span class="literal">false</span></div><div class="line">				&#125;</div><div class="line">				<span class="comment">// 压缩后，应用一维的算法</span></div><div class="line">				<span class="keyword">if</span> mymat[col] &#123;</div><div class="line">					length++</div><div class="line">					count += length</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					length = <span class="number">0</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>O(R) 遍历开始行，O(R) 遍历结束行，O(C) 的时间压缩每一行并应用一维的算法，时间复杂度为 O(R^2 * C)。只用了一行的额外空间保存压缩行，空间复杂度为 O(C)。由于 R 比 C 遍历多了一层，如果行数比列数大得多，可以将行列交换运算。代码比较麻烦，不再展开。</p>
<p>回到正确性的问题，是否不重不漏？横向在一维时已经讨论过了。纵向，O(R^2) 把所有开始行和结束行的组合都遍历了。换言之，所有的左上角和右下角的组合，都刚好地访问了一遍。</p>
<h2 id="单调栈-DP"><a href="#单调栈-DP" class="headerlink" title="单调栈 + DP"></a>单调栈 + DP</h2><p>上述解法已经相当优秀，将六次方的 BF 解法，降了 3 个阶。（这里为了方便讨论，把 R、C 看做相近的数量级，都当成 N 处理，相当于从 O(N^6) 降到了 O(N^3) 时间复杂度）</p>
<p>当年第一次遇到这道题，我甚至都没能一下子想到这种办法，想通时已经不够时间实现和调试。还是事后同事 Lucy 跟我们讲了思路。之后很长一段时间，没有再细想，把这当成最优解。</p>
<p>直到这次，顺便逛了一下讨论区，居然发现还能 O(RC) ！？</p>
<blockquote>
<p>以下解法并非我的原创，而是看了 LeetCode 美国站讨论区后，根据网友提供的思路，重新实现和用自己的话解释一遍。主要为了分享和加深理解。</p>
<p>平时做的答案，其核心思想，其实也是学来的（主要是大学算法课）。毕竟常见，不需要特别声明。</p>
<p>这次的解法比较绕，不敢掠美，特此声明。</p>
</blockquote>
<h3 id="子问题：分割极大矩阵"><a href="#子问题：分割极大矩阵" class="headerlink" title="子问题：分割极大矩阵"></a>子问题：分割极大矩阵</h3><p>我们回到一开始想到用 动态规划 时提出的问题：『<strong>能不能遍历为 1 的点作为右下角，结合少量中间状态，算出新的中间状态，并逐渐推导出答案？</strong>』</p>
<p>这个问题难在子问题和中间状态的定义。怎么定义，中间状态定义多少个，才能应付最多时跟 R、C 同量级的极大矩阵？</p>
<p>我们把问题简化，先不想怎么判断和划分，假定已经找到了一个 r 行 c 列的极大全 1 矩阵，里面有多少个 <strong>包含右下角的点</strong> 的子矩阵？</p>
<p>答：r x c 个。</p>
<p><img src="../../images/leetcode1504/leetcode1504-submat-with-same-right-bottom-point.svg" alt=""></p>
<p>包含右下角（最后一行结束），子矩阵高度（开始行）有 r 种可能；包含右下角（最后一列结束），矩阵宽度（开始列）有 c 种可能。组成起来有 r x c 种 子矩阵。换言之，<strong>只要找到以当前点为右下角的极大子矩阵，就能直接算出以此为右下角的全部子矩阵数量</strong> 。</p>
<p><img src="../../images/leetcode1504/leetcode1504-extreme-matrix-2.svg" alt=""></p>
<p>难点在于极大子矩阵根本不止一个，叠在一起可能是锯齿状的，也可能是驼峰状的，极难记录和统计。不过只要用递归分治的思想划分一下子问题，难点就变简单了。</p>
<p><img src="../../images/leetcode1504/leetcode1504-extreme-matrix-3.svg" alt=""></p>
<p>我们定义 C[i][j] 为 『以点 (i, j) 为右下角的子矩阵数量』。mat[i][j] 为 0 时，这个点不能构成任何子矩阵，所以只讨论为 1 的情况。如图所示，以第一个白色点 (4, 5) 为右下角的极大子矩阵，一共有 3 种宽高组合（1x6, 2x4, 4x2），它们重叠在一起，构成了一个不规则的形状。将其纵向划分成 3 个互不重叠的 3 个矩阵 X, Y, Z。（不一定是 3 个，实际可能更多，最多时可以分成每列一个）</p>
<p>那么 C[4][5] 就等于 X （包含右下角）的子矩阵数（4x2），加上 C[4][3]。之所以这样算，是因为所有以 (4, 3) 为右下角的子矩阵，都可以列数加 2 ，变成以 (4, 5) 为右下角。通过这样划分子问题，<strong>无论有多少个极大子矩阵，我们只需要计算包含当前右下角最右（同时也是最高）的一个极大子矩阵，再引用之前的子问题即可</strong> 。</p>
<p>为什么最右的极大子矩阵一定是最高的呢？因为子矩阵的高度无法超过右下角所在列的高度。上图中 列4 的高度为 5 （蓝色的(0, 4)点），但是这个点无法跟右下角构成矩阵。</p>
<h3 id="引入-高度记录-和-高度栈"><a href="#引入-高度记录-和-高度栈" class="headerlink" title="引入 高度记录 和 高度栈"></a>引入 高度记录 和 高度栈</h3><p>不过问题还没解决：</p>
<ul>
<li>如何知道最右的极大子矩阵的宽高？（4 和 2 怎么得到）</li>
<li>如何知道上一个子问题是哪个？（怎么得知要引用 (4, 3) 的子问题） </li>
</ul>
<p>后面这个问题好回答，要引用的子问题，就是当前子问题减掉当前极大子矩阵宽度（2）的子问题。问题变成了：<strong>当前极大子矩阵的宽高如何获取</strong> 。</p>
<p>为此，引入两个记录：</p>
<ul>
<li>高度记录 h[i][j] ，记录每列到当前点的最大高度（连续 1 的个数）。</li>
<li>每行的高度栈，记录单调递增的高度序列。</li>
</ul>
<p>先说高度记录，计算方法跟上一个解法的最大长度一样，只是变成纵向。有了它，极大子矩阵的宽高都能获得：高，就是当前列的高度（例子中为 4）；宽则稍复杂一点，需要找到左边第一个比当前列低的列（例子中为 列 3），两列之间宽度就是极大子矩阵的宽度（5 - 3 = 2）。</p>
<p>如果不考虑时间复杂度，高度记录就足以解决问题。但是每次都要搜索左边的高度记录，导致每行的复杂度为 O(C^2) ，乘以行数后整体为 O(R*C^2)，则跟第一种解法相比并无改进。所以引入高度栈，维护一个严格单调递增的高度序列。每当拿到新一列的高度，先将栈里大于等于当前列的高度出栈，剩下的栈顶的列，就是左边第一个比当前列低的列。完成之后将当前列进栈，继续下一步。</p>
<blockquote>
<p>实际实践中，栈里一般储存列号，方便计算宽度，高度根据列号到 高度数组查询。</p>
</blockquote>
<p><img src="../../images/leetcode1504/leetcode1504-height-stack.svg" alt=""></p>
<p>由于高度一旦下降，之前更高的列就无法与后续的点构成矩阵，所以出栈的高度再也不会用到。每个列都只会进栈一次，也（最多）只会出栈一次，遍历一行的时间复杂度就降低到了 O(C)。</p>
<p>如果这部分感觉有点迷糊，跟其它难点混在一起难以理解，可以先尝试做 LeetCode 84 ，在一维的情况下，把高度栈搞懂。</p>
<p>上代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSubmat</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	count := <span class="number">0</span></div><div class="line">	rowNum := <span class="built_in">len</span>(mat)</div><div class="line">	colNum := <span class="built_in">len</span>(mat[<span class="number">0</span>])</div><div class="line"></div><div class="line">	<span class="comment">// 高度记录只用到最后一行，保留一行即可</span></div><div class="line">	heights := <span class="built_in">make</span>([]<span class="keyword">int</span>, colNum)</div><div class="line">	<span class="comment">// DP 解，以当前点为右下角的子矩阵数，同样只用到最后一行，只保留一行</span></div><div class="line">	dpCount := <span class="built_in">make</span>([]<span class="keyword">int</span>, colNum)</div><div class="line">	<span class="comment">// 高度栈，注意保存的是列号，列高还得到 heights 取</span></div><div class="line">	hStack := newStack()</div><div class="line">	<span class="comment">// 行循环</span></div><div class="line">	<span class="keyword">for</span> row := <span class="number">0</span>; row &lt; rowNum; row++ &#123;</div><div class="line">		<span class="comment">// 只有一个高度栈循环利用，每行开始前摇清空</span></div><div class="line">		hStack.clear()</div><div class="line"></div><div class="line">		<span class="comment">// 列循环</span></div><div class="line">		<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">			<span class="comment">// 计算当前列高度</span></div><div class="line">			<span class="keyword">if</span> mat[row][col] == <span class="number">1</span> &#123;</div><div class="line">				heights[col]++</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				heights[col] = <span class="number">0</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 将栈里高度 大于等于当前列 的列出栈</span></div><div class="line">			<span class="keyword">for</span> hStack.size() &gt; <span class="number">0</span> &amp;&amp; heights[hStack.top()] &gt;= heights[col] &#123;</div><div class="line">				hStack.pop()</div><div class="line">			&#125;</div><div class="line"></div><div class="line"></div><div class="line">			<span class="keyword">if</span> hStack.size() == <span class="number">0</span> &#123;</div><div class="line">				<span class="comment">// 一直到最左，没有列比当前列 低，宽度直接为 列号 + 1 （列号从 0 开始）</span></div><div class="line">				dpCount[col] = heights[col] * (col + <span class="number">1</span>)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// 找到左边第一个比当前列低的列，宽度为列号的差，并加上该列的子矩阵数</span></div><div class="line">				preCol := hStack.top()</div><div class="line">				dpCount[col] = dpCount[preCol] + heights[col]*(col-preCol)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 当前列进栈</span></div><div class="line">			hStack.push(col)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 结束本行前，将本行结果累计，下一循环就会被覆盖</span></div><div class="line">		<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">			count += dpCount[col]</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 基于切片自行实现了一个简单的栈</span></div><div class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</div><div class="line">	data []<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStack</span><span class="params">()</span> *<span class="title">stack</span></span>      &#123; <span class="keyword">return</span> &amp;stack&#123;data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)&#125; &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span>  &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s.data) &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123; s.data = <span class="built_in">append</span>(s.data, v) &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">top</span><span class="params">()</span> <span class="title">int</span></span>   &#123; <span class="keyword">return</span> s.data[<span class="built_in">len</span>(s.data)<span class="number">-1</span>] &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span></span>       &#123; s.data = s.data[:<span class="built_in">len</span>(s.data)<span class="number">-1</span>] &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">clear</span><span class="params">()</span></span>     &#123; s.data = s.data[:<span class="number">0</span>] &#125;</div></pre></td></tr></table></figure>
<p>正确性</p>
<ul>
<li>不重：右下角不同的子矩阵肯定不是同一个子矩阵。</li>
<li>不漏：每一个点都作为右下角遍历了一次，每次把以该点为右下角的子矩阵都计算在内。</li>
</ul>
<p>复杂度</p>
<ul>
<li><p>时间复杂度：最外层每行遍历一次，内层同时做两件事：</p>
<ul>
<li>每个点作为右下角计算一次，计算过程为常数；</li>
<li><p>每个列下标都进栈一次，最多出栈一次。（如果一直单调递增就不出栈）；</p>
<p>整体的复杂度为 O(RC)。</p>
</li>
</ul>
</li>
<li><p>空间复杂度：常数组辅助变量，每组变量大小为 C；单调栈也最多进栈 C 个列下标，复杂度为 O(C)。</p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周末试着参加了一下 LeetCode 的周赛。&lt;/p&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://jaycechant.info/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="https://jaycechant.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>聊聊儿童安全座椅</title>
    <link href="https://jaycechant.info/2020/about-child-restraint-system/"/>
    <id>https://jaycechant.info/2020/about-child-restraint-system/</id>
    <published>2020-06-20T05:06:31.000Z</published>
    <updated>2020-06-21T15:53:35.827Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，我们这批人都到了养娃的年纪。进度快的，孩子都上小学了；稍慢的，也在这几年开始集中报喜。我也是一个父亲。</p>
<a id="more"></a>
<p>在等待孩子到来的时间里，我们跟所有家庭一样，紧张、忙碌、又期待，做了大量准备功课。现在作为过来人，看到身边正在迎接新生命的朋友，总忍不住提醒几句：这个必须买，那个智商税，这样做有危险，疫苗规划了吗……</p>
<p>这两天突然想起提醒他们买安全座椅。为了避免重复费口舌，写下来吧。</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我只是一个普通的父亲，并非汽车或者安全座椅的专业人士。以下内容仅来自我的亲身经历和有限的了解，希望给身边的朋友一个参考。</p>
<p>这篇文章希望引起大家对安全座椅的重视，让不知道安全座椅的家长知道，让不打算买的去买，让本来想随便买的认真考虑再买，但它不是：</p>
<ul>
<li>专业的科普；</li>
<li>购买指南；</li>
<li>型号推荐。</li>
</ul>
<p>我不打算查一堆案例，劝无论如何不想买的人买，毕竟那是你家人的安全；也不认为你看完跟着买就万无一失。如果有时间，你应该自己做功课，根据自己的经济条件和需求选择，这里只是开一个头。当然，如果你实在觉得无从下手，跟着流程走一遍，大概会比抓瞎乱买强。</p>
<h2 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h2><p>开头先强调一些基本常识。</p>
<h3 id="必须得买"><a href="#必须得买" class="headerlink" title="必须得买"></a>必须得买</h3><p><strong>只要孩子坐车，必须得有安全座椅</strong>。要不就别坐。</p>
<p>跟大人要系安全带一个道理，包括后排。如果觉得不系安全带没什么大不了，请关掉这篇文章，先去看安全带的教育宣传片，看看系与不系伤亡率差距有多大。</p>
<p>然后你说『我系好安全带，然后牢牢地抱住孩子』。</p>
<p>很遗憾，抱不住。试验表明，时速 50km 下的急刹就足以让孩子从大人怀里飞出去。遇到紧急情况急刹，煞停时间非常短，会造成极大的反向加速度，惯性力会变成体重的好几倍（最大时约 30 倍）。<strong>这是自然规律，抱不住就是抱不住，很爱孩子也抱不住。</strong> 爱又不能修改物理定律。</p>
<p>时速 30km 下的碰撞，也足以让孩子受伤。婴幼儿最大的特点之一，就是脑袋占身体的比例特别大（约 1/4），同时颈椎特别脆弱。30km 下，爱的抱抱可能抱住了，但是脑袋的惯性大，有可能造成颈椎的致命伤，也有可能头撞到车内的硬物。</p>
<p>凭记忆复述，数据未必非常精确，但结论是靠谱的。要不信自己搜试验和案例去。</p>
<p>所以也别说什么『刚出生还不用，等后面再买』。从医院回家不坐车？还是觉得新生儿有新手免疫头比较铁？要实在经济困难，别开车别打车，坐不会急刹的地铁，和低速的公共交通。</p>
<p>就这一段内容，大家要是听进去了，很大一部分目的就达到了。</p>
<h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>安全座椅 <strong>存在有效期</strong> （一般是出厂之后 6 年）。</p>
<p>时间长了，里面的工程塑料和缓冲装置会老化失效。如果发生过碰撞，部分缓冲装置也会失效。所以一般 <strong>不推荐使用二手产品</strong> 。除非知根知底，是没有发生过碰撞的，比较新的产品，剩余的有效期还能覆盖使用时间。</p>
<h3 id="拒绝前排"><a href="#拒绝前排" class="headerlink" title="拒绝前排"></a>拒绝前排</h3><p>首先儿童就是不能坐汽车前排座椅的，哪怕他已经可以不用安全座椅。因为安全气囊是基于成年人设计的。爆破的安全气囊在提供保护的同时，也有一定的危险性，对于成年人而言还是保护大于伤害，但对于儿童则可能变成致命武器。基于同样的理由，即使加上了安全座椅，也不应该坐前排。</p>
<p>如果没有安全气囊，则更不能坐了，难道前挡风玻璃和副驾台能提供更好的保护？</p>
<h3 id="不穿厚衣服"><a href="#不穿厚衣服" class="headerlink" title="不穿厚衣服"></a>不穿厚衣服</h3><p>使用安全座椅时，不要给孩子穿太厚的衣服，因为这样安全座椅很难把孩子固定好。安全座椅倒是把厚衣服固定住了，意外发生时，孩子却从弹性良好的厚衣服里飞出来，一切都白费了。如果温度实在低，开暖气。</p>
<h3 id="车内不堆放杂物"><a href="#车内不堆放杂物" class="headerlink" title="车内不堆放杂物"></a>车内不堆放杂物</h3><p>这条其实就算没有孩子，也是应该做到的。各种香水瓶、挂饰、串儿、摆件，木头的、玻璃的、水晶的、金银的，一旦发生意外，这些又重又硬的物件在车内横飞，造成二次伤害。只是有了孩子，这受伤的阈值一下子往下降。给大人砸个包的物件，换孩子身上就不是一回事了。</p>
<p>花大价钱把孩子固定好了不去撞别的东西，结果东西自己飞过来砸，又是白费力气。</p>
<h2 id="怎么挑"><a href="#怎么挑" class="headerlink" title="怎么挑"></a>怎么挑</h2><p>儿童安全座椅，术语叫 儿童约束系统（Child Restraint System，CRS）。顾名思义，就是一整套，将婴幼儿固定在车上，避免行车过程中受到伤害的装置。座椅是最常见的形式，但也有可能是提篮（婴儿）、床（婴儿）、增高垫（学童）等形式。中文用『儿童安全座椅』做关键词基本上都能搜到，外文可能要尝试不同的术语，而比较正式的统称，就是 CRS。</p>
<p>接下来看看都要做哪些选择题，每个答案代表什么。</p>
<h3 id="年龄段"><a href="#年龄段" class="headerlink" title="年龄段"></a>年龄段</h3><p>安全座椅对标的是成人的安全带。只是婴幼儿达不到使用安全带 140cm 以上的身高标准，而且婴幼儿有头重占比大、颈椎脆弱的特点，所以需要额外的固定和保护。更进一步地说，不仅婴幼儿跟成人要区别对待，不同年龄段的婴幼儿，也有各自的特点，需要分别对待。</p>
<p>最简便的划分，分 <strong>婴儿、幼儿、学童</strong> 三个阶段。这也是C-NCAP（中国新车评价规程）所使用的分组。</p>
<blockquote>
<p>在 <a href="http://www.c-ncap.org/cms/picture/215964820359352320.pdf" target="_blank" rel="external">C-NCAP 19 年版 CRS  评价规则</a> 中，三个分组分别对应：</p>
<ul>
<li>婴儿组：适用体重 13kg 以下，参考年龄 15 个月以下；</li>
<li>幼儿组：适用体重 9~18kg，参考年龄 9 个月至 4 岁；</li>
<li>学童组：适用体重 15~36kg，参考年龄 3 岁 ~ 12 岁。</li>
</ul>
</blockquote>
<p>ADAC （全德汽车协会）的分类则更细一些，分为 <strong>新生儿、1 岁前、1 岁半前、4 岁前、7 岁前、12 岁前</strong> 。</p>
<p>需要注意的是，这些分类主要为了方便分组测试和整理结果，并不指导具体的产品开发。列出来，也只是为了让大家对年龄分段有一个直观的感受。实际的产品设计有自己的考量，除了考虑年龄，还更多地考虑 <strong>体重和身高</strong> 。一些比较精细的产品，可能连一个年龄段都不能覆盖，而通用可调节的产品则可以覆盖多个阶段的使用。</p>
<p>对于年龄段这块，个人总结如下：</p>
<ul>
<li>从孩子出生到 12 岁（身高大于 140cm），<strong>买安全座椅不是一劳永逸的</strong> 。因为覆盖 新生儿 到 12 岁的产品很少，又存在有效期。至于究竟要换多少次，具体看你选的产品怎么划分。</li>
<li>越是精细化的产品，相对而言保护会更有针对性，乘坐更舒适，使用上也更简易（并非绝对），但适用时间也越短，性价比比较低。可以调节，能满足多个阶段的产品，保护的针对性也没那么强，使用上需要调节还会更复杂一些，但可以避免频繁更换造成的麻烦，也节约支出。</li>
<li>多数产品会同时给出 年龄、体重、身高 的参考，其中年龄会标得比较明显，也是测试和销售时的主要分类依据，但实际使用中，参考意义 <strong>体重 &gt; 身高 &gt; 年龄</strong> 。现在孩子生活环境好，营养充足，有可能发育得比较快。如果体重超出了对应年龄段产品的上限，缓冲能力可能不够，则要考虑换下一阶段的产品。身高超标，则影响舒适性，产生脚放不下、安全带压迫等问题。</li>
<li>但也不建议为了延长使用时间，特意买超出当前身高范围的产品，有可能导致限制装置太松，使孩子从安全座椅中滑出。</li>
</ul>
<h3 id="产品类型"><a href="#产品类型" class="headerlink" title="产品类型"></a>产品类型</h3><p>座椅是最常见的产品形态，根据特定年龄段，也会有特殊的产品。</p>
<ul>
<li><strong>提篮 / 睡篮</strong> 。主要供新生儿使用，特点有二：<ul>
<li>考虑新生儿脊椎还没发育好，无法坐起来，需要平躺，提篮把里面的座位放平，形成带安全带的躺椅形式。</li>
<li>考虑新生儿多数时间在睡觉，为了避免上下车把孩子弄醒，提篮做成可以通过底座（硬连接）或者安全带整体固定和分离，分离后可以直接提走。</li>
</ul>
</li>
<li><strong>增高垫</strong> 。主要给接近 12 岁的学童使用，通过增高座位，使儿童达到 140 cm 使用安全带的标准。这类产品提供的保护效果有限，但胜在小巧便携，安装方便，可以作为备选方案，在比较大的孩子乘坐其他汽车时使用。</li>
<li><strong>安全背心  / 其他安全带限位装置</strong> 。作用跟 增高垫 类似，都是针对接近 12 岁的学童。但作用原理刚好相反，通过给孩子穿上安全背心，或者安装别的限位器，引导安全带的走向，让安全带适合保护孩子的需要。优缺点也基本跟增高垫一致。</li>
</ul>
<p>主流还是座椅。增高垫和安全背心是给大孩子用的，而且坐自家车有条件安装安全座椅的情况下，还是推荐安全座椅，提一下就算了。</p>
<p>重点在于新生儿要不要选提篮。提篮有上述的两个优点，缺点也很明显，就是适用时间非常短。因为提篮（接近）平躺，适用身高非常有限，一般 9 个月到 15 个月就不能用。这么贵的安全用品却只能用一年左右，对于普通家庭压力还是不小。</p>
<p>相应地，也可以选适用范围 新生儿 ~ 4 岁的可调节产品。一般通过调节座位的角度和高度，适应不同阶段的孩子，范围最大的可以从平躺一直到坐直，有分档调节和无级调节，后者比较灵活也比较贵。</p>
<h3 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h3><p>这个比较简单，只有两种，（孩子脸）朝后（反向）和朝前（正向）。</p>
<p>原则也只有两条：</p>
<ul>
<li><strong>新生儿只能反向</strong> ！因为新生儿头比重大和颈椎脆弱，正向座椅光固定身体，遇到意外时还是容易把颈椎拉伤。我们又不能把脑袋也捆住。而反向座椅发生急停时，作用力通过椅背作用在整个身体上，不容易对单个部位造成伤害。</li>
<li>只要体重和身高允许，<strong>尽量延长使用反向座椅的时间</strong> 。由于上面提到的原因，在设计提供和身高允许的情况下，延长反向使用的时间比较好。</li>
</ul>
<p>一般情况下，先买给新生儿用的反向座椅。等到反向座椅坐不下时（因为安全座椅面向车上原来的座椅，长到一定程度脚会放不下），顺便换下一阶段的正向座椅。</p>
<p>也可以买双向安装（前后均有安装接口），或者可以旋转方向的产品，延长使用寿命。</p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>一共三种连接方式，要根据车子的情况选择：</p>
<ul>
<li><strong>ISOFIX</strong> ：欧标接口，有两个连接点。支持的车型会在后排座位靠背和坐垫中间有左右两个连接件（跟安全带扣差不多高度，但在缝隙里面，需要用力伸进去才能摸到），将座椅上的连接杆插到底变成绿色就可以固定。市面上的 ISOFIX 产品往往还会多一个支撑脚架伸到过道上，形成三点固定。</li>
<li><strong>LATCH</strong> ：美标接口，在 ISOFIX 的基础上多出一个头部连接点。多出的连接点在头枕后方，后挡风玻璃下面，一般从安全座椅的头部位置伸出钩子固定，加上底下的两个连接点，形成三点固定。</li>
</ul>
<p>这两种都是硬连接，正确安装的情况下，可以将安全座椅视作车辆的一部分。只是需要车子本身支持。<strong>其中支持 LATCH 的车型可以安装 ISOFIX 的座椅，反之则不行</strong> 。在车子支持的情况下，推荐 <strong>优先选择这两种连接方式</strong> 。</p>
<p>如果车子实在不支持，或者有别的考量，就只能选安全带固定的方式：</p>
<ul>
<li>安全带固定：安全座椅上有供汽车安全带穿过的限位器。按照指引，将安全带按顺序穿过多个限位器之后，再将安全带扣上，也就是把安全座椅+孩子作为整体，系上汽车的安全带。由于汽车安全带可以伸缩，安全座椅一定程度上是可以移动的，并非刚性连接。另外，这种安装方式要求按指引，正确给座椅穿好安全带。</li>
</ul>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p>还有一些零散的功能特性，放在这里过一下。</p>
<ul>
<li>侧向保护：大多数情况下，考虑的都是汽车急刹和正向碰撞。但其实侧向碰撞和翻侧的事故也并不少见。所以有些安全座椅会做成包围型，在遭受侧向的作用力时，也能起到一定程度的保护。平时也能作为孩子睡觉时头部的依靠。更进一步的产品，则会在座椅上伸出侧向的支撑杆，固定在靠近一侧的门上，提供进一步的支撑。</li>
<li>五点式安全带：源自赛车安全带的概念，通过双肩、双髋和裆部 五个点将孩子固定住。貌似现在已经成为标配，不怎么提起。倒是如果发现固定点连 5 个都不到，可能要考虑一下。</li>
<li>前置护体：在孩子前方设置一个缓冲块，发生意外时，缓冲块以整个面的方式缓冲受到的作用力。</li>
</ul>
<p>五点式安全带 和 前置护体 貌似不能同时设置，所以成为了互斥的选项。不同产品都宣扬自己选择方式好，指出另一种方式的缺点。</p>
<p>例如 五点式 虽然比老式的安全带增加了固定点，毕竟还是通过 5 个点受力，特别是头部缺少防护。（所以才要推迟正向安装。）而前置护体虽然以一个面承受冲击，但毕竟固定点少，极端情况下有从座椅脱出的风险，而且缓冲块比较碍事，孩子四肢活动相对不自由。</p>
<p>其实两种方式既然同时存在，就说明各有优缺点。哪种好还是看自己的实际情况 和 具体型号的测试结果。</p>
<p>可能还有其他的一些功能点，但我想不起来了，估计也不怎么重要。</p>
<h2 id="强制认证"><a href="#强制认证" class="headerlink" title="强制认证"></a>强制认证</h2><p>先说认证，这是上市的及格线。拿到了不代表什么，没有就问题很大。</p>
<ul>
<li>中国市场：3C 认证，全称是 <strong>中国强制性产品认证（China Compulsory Certification）</strong>。无论是国产还是进口，只要是国内销售的产品，都要拿到这个认证。</li>
<li>欧洲市场：ECE R44/04 认证，全称 <strong>欧洲经济委员会（Economic Commission of Europe）</strong> 认证，其中 R44/04 是针对儿童安全座椅的 44 号法令第 4 版标准。跟 3C 认证类似，这是欧洲执行的强制认证。从欧洲海淘的产品必须有这个认证。据称是目前全世界最严格的认证。</li>
<li>美国市场：ASTM 认证，全称 <strong>美国材料与实验协会（American Society for Testing and Materials）</strong> 认证。跟上面两个不一样，这是自愿认证。没有不代表有问题，有的话最好。</li>
</ul>
<p>很简单，在哪销售的产品，最低限度要拿到当地的强制认证。</p>
<p>国内销售的，可以到 全国认证认可信息公共服务平台查询 3C 认证号： <a href="http://cx.cnca.cn/" target="_blank" rel="external">http://cx.cnca.cn/</a> 。ECE 和 ASTM 貌似没有公开查询的平台（如果有，请在评论补充），但大牌子估计不敢拿品牌信誉开玩笑。</p>
<p>一个产品型号如果在多地上市，则最好每个市场都拿到了对应的认证。</p>
<p>需要特别指出的是，由于欧洲（准确说是欧经会成员国）是多个国家，ECE 还有在哪个国家通过的区别。其中发达国家的测试相对严谨和不容易被收买，网上一般认 <strong>E1德国、E4 荷兰、E11英国</strong> 这三个国家为主。</p>
<h2 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h2><p>认证是准入门槛，只有过和不过。如果想进一步了解不同产品之间的优劣，就要看进一步的安全测试了。</p>
<p>你可不要觉得是多此一举，今天为了给大家找测试网站的地址，进入 C-NCAP 官网第一条看到的就是这个消息：<a href="http://www.c-ncap.org/crs/content/b01b33c08c644cb9a79d9ced15de14a8" target="_blank" rel="external">超20%产品不合格，汽车儿童安全座椅坑在哪儿？</a> （这篇文章也有教挑选技巧，感兴趣可以看看）</p>
<p>这些可是通过了 3C 认证的产品，抽检仍然高达 20% 不合格。文中指出：</p>
<blockquote>
<p>还有一种可能，是生产厂家在后续生产过程未按送检标准进行，因为厂家在做3C认证一般都是送样的，即使送样产品达到认证标准要求，厂家在后期批量生产中出于节省成本偷工减料或其他方面原因，也会造成产品质量。</p>
</blockquote>
<h3 id="C-NCAP-CRS-评价"><a href="#C-NCAP-CRS-评价" class="headerlink" title="C-NCAP CRS 评价"></a>C-NCAP CRS 评价</h3><p>全称 中国新车评价规程（China-New Car Assessment Program）儿童约束系统评价。C-NCAP 是由国资委下的中国汽车技术研究中心建立的试验评价方法。</p>
<p>19 年版 CRS  评价规则：<a href="http://www.c-ncap.org/cms/picture/215964820359352320.pdf" target="_blank" rel="external">http://www.c-ncap.org/cms/picture/215964820359352320.pdf</a></p>
<p>CRS 成绩查询：<a href="http://www.c-ncap.org/crs/main" target="_blank" rel="external">http://www.c-ncap.org/crs/main</a></p>
<p>选择厂商和品牌之后，就可以查到对应的成绩，列表里有 产品商标及名称、组别、固定方式、总体评价 等信息，点击进入详情还能看到各个项目的具体评分。</p>
<p>当然，也可以不选品牌，选择孩子对应的组别和支持的固定方式，在结果里挑选成绩靠前的产品。</p>
<p>CRS 测试的产品是在不告知厂商的情况下，由市场随机购买的，结果比较可靠。目前来看，貌似主要测试国内生成的产品。</p>
<h3 id="ADAC-测试"><a href="#ADAC-测试" class="headerlink" title="ADAC 测试"></a>ADAC 测试</h3><p>全称是 全德汽车协会（Allgemeiner Deutscher Automobil-Club）测试。堪称全世界最严格的儿童安全座椅测试。</p>
<p>测试结果地址：<a href="https://www.adac.de/rund-ums-fahrzeug/tests/kindersicherheit/kindersitztest/" target="_blank" rel="external">https://www.adac.de/rund-ums-fahrzeug/tests/kindersicherheit/kindersitztest/</a></p>
<p>分组、测试项、评分都很精细，还定期曝光不合格的产品信息。</p>
<p>难点是，只有德语。你可能需要找会德语的朋友，或者翻译软件帮忙。更麻烦的是，偶尔网站还会改版，官网地址倒是不会变，具体的查询页变了（现在给出的地址就跟我买的时候不一样），要从主页找到对应的查询页，还真的不容易。</p>
<p>由于距离上次查完已经过了很久，我也不会德语，偏偏浏览器的翻译工具还罢工了，原谅我不打算详细介绍查询技巧。不过大致也是上面的两种思路，要么挑好型号看成绩，要么给定筛选条件挑高分。</p>
<p>ADAC 貌似欧洲常见型号都会测，适合在海淘时参考，或者买国产产品时参考相同型号。不过需要注意的是，国外型号国产化之后，产品未必能保持一致。一部分修改是为了符合国内的认证，一部分也可能存在降低成本的情况。除非在国产的产品信息上，也强调了 ADAC 的测试成绩，表示国内外的产品一致。否则只能用来参考，国产还是以 C-NCAP 为准。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>中国已经是儿童安全座椅产量最大的国家，包括很多外国品牌也交给中国厂商代工。只不过由于国人这方面意识比较欠缺，大多数产品（特别是高端型号）销往了海外。国内是有设计生产高质量产品的实力的。购买时也完全可以考虑国内头部品牌。</p>
<p>但正是因为消费者的认知程度不高，国内市场还是比较混乱，所以购买时要留意各种认证和测试。</p>
<p>在这里，我不打算推荐品牌和型号（厂家没给广告费，你也没给我推荐费）。每个家庭考量不同，取舍不同，而且离我购买也已经过去了一段时间。大家还是跟着这篇文章，自己做一些功课吧。</p>
<p>匆匆写就，挂一漏万，可能有认知盲区，也可能存在过时的信息和观点，如有更新的成果，欢迎留言打脸。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉，我们这批人都到了养娃的年纪。进度快的，孩子都上小学了；稍慢的，也在这几年开始集中报喜。我也是一个父亲。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 解题： 合并 K 个有序链表</title>
    <link href="https://jaycechant.info/2020/leetcode-23-merge-k-sorted-lists/"/>
    <id>https://jaycechant.info/2020/leetcode-23-merge-k-sorted-lists/</id>
    <published>2020-06-18T06:52:25.000Z</published>
    <updated>2020-06-30T14:39:30.760Z</updated>
    
    <content type="html"><![CDATA[<p>下一题 Hard。23 号，合并 K 个有序链表。</p>
<a id="more"></a>
<p>英文：<a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">https://leetcode.com/problems/merge-k-sorted-lists/</a></p>
<p>中文：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="external">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p>
<p>不同解法涉及多个知识点，要优化也有很多细节可以调。只求 accept 的话，比较水，最好把不同做法都试试。</p>
<p>之前已经讲过链表基本操作，这次又遇到链表，就只讲算法部分，数据结构细节略过。</p>
<h2 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h2><h3 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h3><p>给定 k 个 <strong>有序</strong> 链表，合并成一个。</p>
<blockquote>
<p>这个环节是强调一定要先概括题意。特别是长篇大论讲故事的题。这题原题也就一句话，但按惯例还是给一句。</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>见测试用例</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>没有给出。</p>
<p>但我们可以注意到，既然没有给约束条件，也就是要考虑各种意义的空值。</p>
<p>另外，为了后续讨论方便，假定所有链表的总节点数为 N。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>惯例先贴测试代码，通过写测试代码体现对题目的理解。</p>
<blockquote>
<p>《<a href="https://jaycechant.info/2020/rapidly-generate-unit-tests-in-vs-code/">如何快速生成单元测试</a>》</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ fmt.Stringer = (*ListNode)(<span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">// 实现 Stringer 接口方便对比结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ListNode)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	sb := strings.Builder&#123;&#125;</div><div class="line">	<span class="keyword">for</span> l != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// 为了代码简洁，不处理多余的 '-&gt;'</span></div><div class="line">		sb.WriteString(fmt.Sprintf(<span class="string">"%d-&gt;"</span>, l.Val))</div><div class="line">		l = l.Next</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sb.String()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 待测函数会修改链表，所以要每次从数组重新生成 链表</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">listsFromSlices</span><span class="params">(aa [][]<span class="keyword">int</span>)</span> []*<span class="title">ListNode</span></span> &#123;</div><div class="line">	ll := <span class="built_in">make</span>([]*ListNode, <span class="number">0</span>, <span class="built_in">len</span>(aa))</div><div class="line">	head := <span class="built_in">new</span>(ListNode)</div><div class="line">	<span class="keyword">for</span> _, a := <span class="keyword">range</span> aa &#123;</div><div class="line">		head.Next = <span class="literal">nil</span> <span class="comment">// 避免空数组没有覆盖</span></div><div class="line">		tail := head</div><div class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</div><div class="line">			tail.Next = &amp;ListNode&#123;Val: v&#125;</div><div class="line">			tail = tail.Next</div><div class="line">		&#125;</div><div class="line">		ll = <span class="built_in">append</span>(ll, head.Next)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ll</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</div><div class="line">	name  <span class="keyword">string</span></div><div class="line">	cases [][]<span class="keyword">int</span></div><div class="line">	want  <span class="keyword">string</span></div><div class="line">&#125;&#123;</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"0"</span>,</div><div class="line">		cases: [][]<span class="keyword">int</span>&#123;&#125;,</div><div class="line">		want:  <span class="string">""</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"00"</span>,</div><div class="line">		cases: [][]<span class="keyword">int</span>&#123;</div><div class="line">			&#123;&#125;,</div><div class="line">		&#125;,</div><div class="line">		want: <span class="string">""</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"1"</span>,</div><div class="line">		cases: [][]<span class="keyword">int</span>&#123;</div><div class="line">			&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">			&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</div><div class="line">			&#123;<span class="number">2</span>, <span class="number">6</span>&#125;,</div><div class="line">		&#125;,</div><div class="line">		want: <span class="string">"1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6-&gt;"</span>,</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">// 篇幅关系，省略更多测试数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_mergeKLists</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			<span class="comment">// 链表每次要重新生成</span></div><div class="line">			<span class="keyword">if</span> got := mergeKLists(listsFromSlices(tt.cases)); got.String() != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"mergeKLists() = %s, want %s"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>如果不必考虑效率，那么这道题只要会 <strong>链表的基本操作</strong> ，就可以做。</p>
<h3 id="依次合并"><a href="#依次合并" class="headerlink" title="依次合并"></a>依次合并</h3><p>举例说，我们有 8 个有序链表，分别编号 1 ~ 8。合并 8 个链表的代码不好写；何况 k 不是一个固定的值，写出了合并 8 个链表的代码，k 还可以是 9、10、100、1000。</p>
<p>但合并两个链表很容易，两两合并，总会合并到一个：</p>
<ol>
<li>取出排在前面的两个链表，一开始是 1 和 2；</li>
<li>合并这两个链表；</li>
<li>方便起见，合并后的链表还叫 1，链表 2 已经被 1 包含了，排在最前面的链表是 1 和 3，回到步骤 1)；</li>
<li>以此类推，重复步骤 1) ~ 3)，直到只剩下链表 1。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1  2  3  4  5  6  7  8</div><div class="line">│  │  │  │  │  │  │  │</div><div class="line">├──┘  │  │  │  │  │  │</div><div class="line">├─────┘  │  │  │  │  │</div><div class="line">├────────┘  │  │  │  │</div><div class="line">├───────────┘  │  │  │</div><div class="line">├──────────────┘  │  │</div><div class="line">├─────────────────┘  │</div><div class="line">├────────────────────┘</div><div class="line">1</div></pre></td></tr></table></figure>
<p>这就是分治法。<strong>分而治之（Divide and Conquer）</strong> 。</p>
<p>当我们</p>
<ul>
<li>遇到一个很难解决的问题（合并 k 个链表），</li>
<li>这个问题可以分解成 多个 / 多层 子问题，并且子问题的解可以组合成原问题的解，</li>
<li>最小的子问题很容易解决（合并两个链表），</li>
<li>子问题结构相似，解法相近（合并）。</li>
</ul>
<p>就可以考虑分治法。</p>
<p>这种写法非常简单，就不贴代码了。需要提醒的是，因为链表 1 越来越长，对链表 1 进行遍历和修改需要的操作越来越多。此时可以将 <strong>合并（merge）成新链表</strong> ，改为其中一个链表 <strong>原地插入（insert）</strong> 另一个（最好是短链表的节点插入长链表） ，减少不必要的修改操作。</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>已知链表数为 k，总节点数为 N。最坏的情况下，第一个链表的长度为 N - k + 1，后续每个链表都只有一个节点，而且该节点比前面所有节点都大（换言之，每次都要比较到最后，才能找到插入位置）。</p>
<p>第一次合并，遍历了 N - k + 2 个节点，往后每次增加一个，总共合并 k 次。易得，时间复杂度为 O（kN），空间复杂度为常数 O(1) 。</p>
<h3 id="哈夫曼合并"><a href="#哈夫曼合并" class="headerlink" title="哈夫曼合并"></a>哈夫曼合并</h3><p>前面的做法，效率不太高，原因是越来越长的链表 1 偏偏参加了最多次合并（一个不落全参与了），导致总的遍历和操作节点数很高。考虑不同情况：</p>
<ul>
<li>链表长度平均的情况下，链表 1 也会越来越长；</li>
<li>最坏情况下，链表 1 一开始就最长，效率就更糟糕；</li>
<li>仅当链表长度差距较大，而且从短到长排列时，这种做法效率比较高。</li>
</ul>
<p>我们一般考虑最坏情况（大 O 分析）；如果最坏情况概率很低和影响不大则考虑平均情况。明显两种情况表现都不佳。</p>
<p>尝试将最坏情况转化成最优情况：</p>
<ol>
<li>取出长度最短的两个链表；</li>
<li>合并这两个链表，并将合并后的链表放回；</li>
<li>重复步骤 1) 2) 直到只剩下一个链表。</li>
</ol>
<p>实际上这就是构造了一个 <strong>以链表长度为权值的哈夫曼树</strong> 。（篇幅关系，哈夫曼树不在此展开。）哈夫曼树具有带权路径最短的性质，而合并开销正是跟链表长度相关，毫无疑问，光看合并开销这样是最优的。</p>
<p>然而构造哈夫曼树，需要额外的开销：</p>
<ul>
<li><p>链表并不能直接获取长度，需要 O(N) 时间复杂度遍历所有节点；</p>
</li>
<li><p>链表之间并非按长度排列，需要排序；考虑到合并之后的链表还得重新加入排序，优先队列是最佳选择，时间复杂度 O(k log(k) ) ，空间复杂度 O(k)。</p>
</li>
</ul>
<p>通过这个 O(N + k log(k) ) 的操作之后，所有比 <strong>链表初始长度相等</strong> 坏的情况，都能通过让短的先合并来优化。换言之，长度均分成了最坏情况。这种情况下，链表两两合并，每个初始链表参与合并的次数一致，均为 log(k)；每次将 N 个节点遍历一遍（详见下一小节）。时间复杂度为 O(N log(k))。</p>
<p>总的时间复杂度为 O(N + (N+k) log(k)) ，空间复杂度 O(k)。</p>
<p>这种做法花费了额外的时间和空间开销，大大增加了代码的复杂性，优化的效果却依赖数据的特殊性：数据分布越不均匀，效果越好。在我看来，这属于典型的 <strong>过早优化</strong> 。为不确定的优化效果，破坏代码的易读性和可维护性，工程上是非常不明智的；即使在比赛里，调试这种代码也很浪费时间。因为不推荐，不贴代码。</p>
<p>当然，这种做法并非不能用。实际应用中发现大部分数据都分布非常不均匀，对性能很敏感，profile 之后发现这里确实成为了瓶颈，可以考虑。</p>
<h3 id="两两合并"><a href="#两两合并" class="headerlink" title="两两合并"></a>两两合并</h3><p>相比之下，不需要特殊的处理，直接分组两两合并，很容易就能 O(N log(k)) 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1   2   3   4   5   6   7   8</div><div class="line">│   │   │   │   │   │   │   │</div><div class="line">└─┬─┘   └─┬─┘   └─┬─┘   └─┬─┘</div><div class="line">  └───┬───┘       └───┬───┘</div><div class="line">      └───────┬───────┘</div></pre></td></tr></table></figure>
<p>每一轮两两分组，每个链表都与同组的链表合并一次，所有 N 个节点都被遍历一次。一共 log(k) 轮。所以很容易得到 O(N log(k)) 。跟前面的做法不一样的是，抹掉了不同情况的差异，都是一样的时间复杂度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	k := <span class="built_in">len</span>(lists)</div><div class="line">	<span class="keyword">if</span> k == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 空白伪头结点，避免判空处理</span></div><div class="line">	head := <span class="built_in">new</span>(ListNode)</div><div class="line">	<span class="comment">// 合并步长从 1 开始不断翻倍</span></div><div class="line">	<span class="keyword">for</span> step := <span class="number">1</span>; step &lt; k; &#123;</div><div class="line">		<span class="comment">// 分组宽度是步长的两倍</span></div><div class="line">		width := step * <span class="number">2</span></div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i+step &lt; k; i += width &#123;</div><div class="line">			<span class="comment">// func merge(list1 *ListNode, list2 *ListNode) 实际开发中这部分应该抽取子函数</span></div><div class="line">			head.Next = lists[i]</div><div class="line">			list2 := lists[i+step]</div><div class="line">			tail := head</div><div class="line">			<span class="keyword">for</span> tail.Next != <span class="literal">nil</span> &amp;&amp; list2 != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">if</span> list2.Val &lt;= tail.Next.Val &#123;</div><div class="line">					tail.Next, list2.Next, list2 = list2, tail.Next, list2.Next</div><div class="line">				&#125;</div><div class="line">				tail = tail.Next</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> list2 != <span class="literal">nil</span> &#123;</div><div class="line">				tail.Next = list2</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 第一个节点可能是来自 list2，合并结果一定要赋值回去</span></div><div class="line">			lists[i] = head.Next</div><div class="line">			<span class="comment">// func merge() end</span></div><div class="line">		&#125;</div><div class="line">		step = width</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> lists[<span class="number">0</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，即使同为分治法，不同分割子问题的策略，对效率的影响非常大。</p>
<p>一般来说，子问题分割得越均匀，效果越好。</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>通过调整合并链表的顺序，可以优化效率。但毕竟是先后合并，总有一些节点需要反复参与合并，导致反复遍历。能不能把所有节点只访问一遍就合并完呢？</p>
<p>可以的。只要 k 个链表同时合并，不断取 k 个链表头里最小的元素放到新链表，等遍历完也就合并完了。</p>
<p>不过两个节点比较一次就得出最小，k 个头节点则需要排个序:</p>
<ul>
<li><p>花费 O(k log(k)) 的时间得到 k 个头结点组成的有序序列。</p>
<p>  但这只得出一个最小节点。只有 k 个里最小节点确定是最小的，第二个节点开始就不确定的了，剩下还没加入排序的节点里，有可能存在更小的节点。</p>
</li>
<li><p>接下来，还要从最小节点所在的链表补充新的头节点加入排序。这次只需 O(log(k)) 时间找到新加入节点的位置，就能再得到一个最小节点。（<strong>有序序列里查找要用二分法</strong>）</p>
</li>
<li><p>如此重复 N - k + 1 次，就把所有节点变成新的有序链表了。</p>
</li>
</ul>
<p>时间复杂度是 O(k log(k) + (N - k) log(k)) 。也就是 O(N log(k)) 。相对应地，需要一直维护大小为 k 的有序序列，额外空间复杂度是 O(k)。</p>
<p>稍微解释一下，为什么每次只能确定 k 个节点里的最小是全局最小，接下来需要对应的链表再加入一个节点，才能再确定一个最小节点。这个问题，反应过来了很简单，但会有人一下子反应不过来。</p>
<p><img src="../../images/leetcode-23-k-heads.svg" alt=""></p>
<p>看图就非常清楚了。</p>
<p>第一轮毫无疑问。因为各个链表都是有序的，链表头就是链表内最小的，不确定的只是链表之间的情况，所以链表头里面的最小，就是最小里的最小。</p>
<p>但第二轮开始就产生疑问了：</p>
<ol>
<li><p>为什么不能继续取最小，而要加入一个新节点？</p>
<p> 例子里如果不加新节点继续取最小，就是 3，但实际上最小是 2。必须将之前最小节点的下一个节点加入排序。</p>
</li>
<li><p>为什么只需要加最小节点的下一个节点？</p>
<p> 很简单，因为其他链表的链表头（最小）都已经参与排序了，这些链表剩下的节点里，不会有比 <strong>已排序里的最小</strong> 更小的节点了。也就是说，这些节点加进来，除了让序列变长，不会改变结果。但是刚取走了最小节点的链表不一样，有可能连续几个节点比其他链表头小。</p>
</li>
</ol>
<p>其实更简单的解释就是：每一轮的最小，都要在当前的所有链表头里产生。看图就秒懂了。</p>
<h3 id="优先队列-和-二叉堆"><a href="#优先队列-和-二叉堆" class="headerlink" title="优先队列 和 二叉堆"></a>优先队列 和 二叉堆</h3><p>不过上面的过程太理想化了。落实到代码会发现，往 k 节点的有序序列里加入新节点时，确实可以通过 二分法 快速找到 插入点。但还得插入啊！如果用数组实现，最坏情况下，插入点在开头，需要花费 O(k) 时间把所有节点往后挪。</p>
<p>这时有两种办法保持 O(log(k)) 复杂度：</p>
<ul>
<li>这 k 个节点的排序也用链表。为了避免覆盖节点原来的信息，只能创建新的节点类型，Val 值指向原来的节点。换言之，这个 k 大小的链表变成了 <em>链表的链表</em> 。</li>
<li>使用优先队列。</li>
</ul>
<p>第一种比较琐碎，我选优先队列。（其实是为了 cue 知识点，哈哈哈）</p>
<p>大家可能会同时听说过 <strong>优先队列 Priority Queue</strong> 和 <strong>二叉堆 Binary Heap</strong> ，它们之间是什么关系呢？</p>
<ul>
<li><p>优先队列是抽象的数据类型。它只定义需要支持的操作，并不限定具体的实现。在多数语言里，它就是一个 Interface。一般而言，优先队列需要支持以下操作：</p>
<ul>
<li>插入：插入带优先级的元素；</li>
<li>取出队头：获得队列里优先级最高的元素（队头），并从队列中删除；</li>
<li><p>查看队头：读取队头元素，但不做修改。</p>
<p>优先队列有多种实现，二叉堆只是最经典的一种选择。如果不考虑效率，也可以用一个普通数组来实现：插入时直接追加到数组最后（O(1)），取出时花 O(n) 时间查找并移动元素。</p>
</li>
</ul>
</li>
<li><p>二叉堆则是具体的数据结构实现。</p>
<ul>
<li>二叉堆本质上是一个 <strong>完全二叉树</strong> ，只是利用 完全二叉树 『每层全满，只有最后一层最右边可能存在空缺』的特点，使用数组来 <strong>连续存储</strong> ，简化操作。</li>
<li>堆的定义，是父节点比所有子节点都要小（或大）的树，换言之堆顶则是最小（或最大）的元素。如果用优先级作为比较内容，堆就可以作为优先队列的一个实现。</li>
<li>堆只限制了 父节点 和 子节点 的大小关系，子节点之间的关系并不确定。换言之，堆处于 <strong>部分有序</strong> 的状态，从这个状态变成完全有序，或者插入新元素后重新变回堆状态，时间开销都比较低。</li>
</ul>
</li>
</ul>
<p>对 k 个元素的二叉堆，插入和取出元素（并恢复堆）的时间复杂度均为 O(log(k))。从头构建一个 k 元素的二叉堆，最直观的做法是连续 k 次插入元素，复杂度为 O(k log(k))；或者从最后一层开始调整子树，一定到堆顶，直接使大小为 k 的数组堆化，每个元素访问一次，复杂度为 O(k)。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>go 有内置的堆实现 <code>container/heap</code> ，用法见官方文档。为了演示，还是实现一个最简单的（仅仅满足做题需要的）二叉堆。需要注意的是，凡是会修改堆本身的操作，都要用指针作为 receiver。</p>
<blockquote>
<p>为了只实现必要的操作，以及避免函数调用开销干扰效率的比较，以下堆的实现尽量只实现了必要部分，并且没有抽取公共函数。在实际开发中，这是不可取的。不是效率瓶颈的代码，应该以 可读性 和 DRY 优先。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> myHeap []*ListNode</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *myHeap)</span> <span class="title">push</span><span class="params">(node *ListNode)</span></span> &#123;</div><div class="line">	child := <span class="built_in">len</span>(*hp)</div><div class="line">	*hp = <span class="built_in">append</span>(*hp, node)</div><div class="line">	h := *hp</div><div class="line">	<span class="comment">// bubble up</span></div><div class="line">	<span class="keyword">for</span> child &gt; <span class="number">0</span> &#123;</div><div class="line">		parent := (child - <span class="number">1</span>) / <span class="number">2</span></div><div class="line">		<span class="keyword">if</span> h[parent].Val &lt;= h[child].Val &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		h[parent], h[child] = h[child], h[parent]</div><div class="line">		child = parent</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *myHeap)</span> <span class="title">pop</span><span class="params">()</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	h := *hp</div><div class="line">	top := h[<span class="number">0</span>]</div><div class="line">	k := <span class="built_in">len</span>(h)</div><div class="line">	h[<span class="number">0</span>] = h[k<span class="number">-1</span>]</div><div class="line">	<span class="comment">// bubble down</span></div><div class="line">	parent := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		child := parent*<span class="number">2</span> + <span class="number">1</span></div><div class="line">		<span class="keyword">if</span> child &gt;= k &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; k &amp;&amp; h[child].Val &gt; h[child+<span class="number">1</span>].Val &#123;</div><div class="line">			child++</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> h[parent].Val &lt;= h[child].Val &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		h[parent], h[child] = h[child], h[parent]</div><div class="line">		parent = child</div><div class="line">	&#125;</div><div class="line">	h[k<span class="number">-1</span>] = <span class="literal">nil</span> <span class="comment">// 避免内存泄漏</span></div><div class="line">	*hp = h[:k<span class="number">-1</span>]</div><div class="line">	<span class="keyword">return</span> top</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	h := <span class="built_in">make</span>(myHeap, <span class="number">0</span>)</div><div class="line">	<span class="keyword">for</span> _, l := <span class="keyword">range</span> lists &#123;</div><div class="line">		<span class="keyword">if</span> l != <span class="literal">nil</span> &#123;</div><div class="line">			h.push(l)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 空白伪头结点，避免判空处理</span></div><div class="line">	head := <span class="built_in">new</span>(ListNode)</div><div class="line">	tail := head</div><div class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(h) != <span class="number">0</span> &#123;</div><div class="line">		tail.Next = h.pop()</div><div class="line">		tail = tail.Next</div><div class="line">		<span class="keyword">if</span> tail.Next != <span class="literal">nil</span> &#123;</div><div class="line">			h.push(tail.Next)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> head.Next</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果理解了堆的定义，留意下标的计算，那么 push 和 pop 的代码就不难理解。关键是 上滤（bubble-up，又叫 sift-up） 和 下滤（bubble-down，又叫 sift-down）部分。</p>
<p>特别提醒，下滤前需要先将最后一个元素挪到堆顶，然后将这个元素作为 <strong>bubble</strong> 执行下滤，而不是对着堆顶删除之后的空穴下滤。因为空穴下滤时，无法确定两个子节点哪边较小会上浮，最后很大概率空穴会下滤到最后一层的随机位置而不是最后，破坏完全二叉树的特性。多年不写凭印象直接上手，结果就犯了这个错误。</p>
<p>只实现 push 和 pop 比较方便，却不是效率最高的实现。首先初始化堆调用了 k 次 push，背后是 k 次上滤，总共花费 O(k log(k)) 时间，实际上可以将 k 个元素都添加后做一次遍历调整，虽然仍然是 O(k log(k))，但可以避免很多重复操作。然后是每次先 pop 后 push，背后是一次下滤+上滤，实际上如果直接将新元素覆盖堆顶，一次下滤即可。这样写，复杂度阶没有变化，但是操作堆的时间能大概减半。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> myHeap []*ListNode</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h myHeap)</span> <span class="title">build</span><span class="params">()</span></span> &#123;</div><div class="line">	k := <span class="built_in">len</span>(h)</div><div class="line">	<span class="keyword">for</span> parent := k/<span class="number">2</span> - <span class="number">1</span>; parent &gt;= <span class="number">0</span>; parent-- &#123;</div><div class="line">		<span class="comment">// bubble down</span></div><div class="line">		<span class="keyword">for</span> &#123;</div><div class="line">			child := parent*<span class="number">2</span> + <span class="number">1</span></div><div class="line">			<span class="keyword">if</span> child &gt;= k &#123;</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> child+<span class="number">1</span> &lt; k &amp;&amp; h[child].Val &gt; h[child+<span class="number">1</span>].Val &#123;</div><div class="line">				child++</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> h[parent].Val &lt;= h[child].Val &#123;</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">			h[parent], h[child] = h[child], h[parent]</div><div class="line">			parent = child</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h myHeap)</span> <span class="title">top</span><span class="params">()</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> h[<span class="number">0</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h myHeap)</span> <span class="title">update</span><span class="params">(i <span class="keyword">int</span>, node *ListNode)</span></span> &#123;</div><div class="line">	h[i] = node</div><div class="line">	k := <span class="built_in">len</span>(h)</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		child := i*<span class="number">2</span> + <span class="number">1</span></div><div class="line">		<span class="keyword">if</span> child &gt;= k &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; k &amp;&amp; h[child].Val &gt; h[child+<span class="number">1</span>].Val &#123;</div><div class="line">			child++</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> h[i].Val &lt;= h[child].Val &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		h[i], h[child] = h[child], h[i]</div><div class="line">		i = child</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *myHeap)</span> <span class="title">remove</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	h := *hp</div><div class="line">	k := <span class="built_in">len</span>(h)</div><div class="line">	h[i] = h[k<span class="number">-1</span>]</div><div class="line">	<span class="comment">// bubble down</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		child := i*<span class="number">2</span> + <span class="number">1</span></div><div class="line">		<span class="keyword">if</span> child &gt;= k &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> child+<span class="number">1</span> &lt; k &amp;&amp; h[child].Val &gt; h[child+<span class="number">1</span>].Val &#123;</div><div class="line">			child++</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> h[i].Val &lt;= h[child].Val &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		h[i], h[child] = h[child], h[i]</div><div class="line">		i = child</div><div class="line">	&#125;</div><div class="line">	h[k<span class="number">-1</span>] = <span class="literal">nil</span></div><div class="line">	*hp = h[:k<span class="number">-1</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	h := <span class="built_in">make</span>(myHeap, <span class="number">0</span>)</div><div class="line">	<span class="keyword">for</span> _, l := <span class="keyword">range</span> lists &#123;</div><div class="line">		<span class="keyword">if</span> l != <span class="literal">nil</span> &#123;</div><div class="line">			h = <span class="built_in">append</span>(h, l)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 先添加完 k 个元素再一次性调整</span></div><div class="line">	h.build()</div><div class="line"></div><div class="line">	head := <span class="built_in">new</span>(ListNode)</div><div class="line">	tail := head</div><div class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(h) != <span class="number">0</span> &#123;</div><div class="line">		tail.Next = h.top()</div><div class="line">		tail = tail.Next</div><div class="line">		<span class="keyword">if</span> tail.Next != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="comment">// 还有节点就更新堆顶后下滤</span></div><div class="line">			h.update(<span class="number">0</span>, tail.Next)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 否则删除堆顶然后下滤</span></div><div class="line">			h.remove(<span class="number">0</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> head.Next</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>理论上，贴出来的三份代码，时间复杂度都是 O(N log(k))，在 N 趋向无穷时，低阶的常数和系数无关紧要。然后 N 并不真的趋向无穷，这些低阶的数也有意义。</p>
<p>我们直接跑一下基准测试。</p>
<blockquote>
<p>由于合并会修改链表，所以测试输入的链表每次都要重新生成，这一定程度上增加了额外开销，模糊了对比。为此，在开头加入了只生成测试数据什么都不干的基准测试作为对比。</p>
<p>测试数据除了几组数据量很小的边界条件以外，加入了两组较大的测试数据：</p>
<ol>
<li>100 组数据，最短一组长度只有 1，最长的长度为 100，长度分布比较随机。</li>
<li>100 组数据，第一组为 100 个 1，余下 99 组长度均为 1，数字从 2 一直到 100。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 只生成数据，不做任何操作，作为对比基线</div><div class="line">Benchmark_listsFromSlices-8                        62496             16898 ns/op            8504 B/op        421 allocs/op</div><div class="line">// 逐个链表并入链表 1，文中没有贴出代码</div><div class="line">Benchmark_mergeKListsInsert-8                      19866             60610 ns/op            8504 B/op        421 allocs/op</div><div class="line">// 两两分组合并法，文中第一份代码</div><div class="line">Benchmark_mergeKListsInsertDAC-8                   56334             21267 ns/op            8504 B/op        421 allocs/op</div><div class="line">// 二叉堆（只用 push, pop），文中第二份代码</div><div class="line">Benchmark_mergeKListsWithHeapPushPop-8             38336             31147 ns/op           12640 B/op        440 allocs/op</div><div class="line">// 二叉堆（调用了更精细的 build, update, remove），文中第三份代码</div><div class="line">Benchmark_mergeKListsWithHeapUpdateRemove-8        47240             25255 ns/op           12640 B/op        440 allocs/op</div><div class="line">// 直接使用 go 内置的堆，文中没有贴出代码，调用逻辑和第三份代码一致</div><div class="line">Benchmark_mergeKListsWithBuiltinHeap-8             29774             40205 ns/op           12800 B/op        445 allocs/op</div><div class="line">PASS</div><div class="line">ok      leetcode        9.621s</div></pre></td></tr></table></figure>
<p>结果一目了然：</p>
<ul>
<li>两两分组合并最快，而且差距相当明显。而且这个实现还很清晰简单，内存使用也少。首选。</li>
<li>其次是自己实现的堆的精细版本，跟只用 push 和 pop 相比拉开了一定差距。</li>
<li>内置的堆毕竟是要做到通用的公共库，性能比较差。但实际开发中为了避免自己实现的耗时和差错，需要用到堆时，推荐优先使用内置库。确实成为性能瓶颈再考虑优化。</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下一题 Hard。23 号，合并 K 个有序链表。&lt;/p&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://jaycechant.info/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://jaycechant.info/tags/LeetCode/"/>
    
      <category term="Algorithm" scheme="https://jaycechant.info/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>粤语（广州话）的九声六调</title>
    <link href="https://jaycechant.info/2020/the-nine-tones-and-six-tunes-of-cantonese/"/>
    <id>https://jaycechant.info/2020/the-nine-tones-and-six-tunes-of-cantonese/</id>
    <published>2020-06-12T14:05:57.000Z</published>
    <updated>2020-06-14T17:53:01.625Z</updated>
    
    <content type="html"><![CDATA[<p>学汉语，其中一道坎就是声调。只会北方官话的人学声调更多的南方方言，如粤语，也面临类似的困难。</p>
<a id="more"></a>
<p>多数西方语言属于印欧语系，没有声调的概念。音调的变化影响句子的语气（所以叫语调 intonation），不影响单词的含义。汉语的北方官话只有四个声调，而多数南方方言则保留了更多声调。像广州话，有九声六调。</p>
<blockquote>
<p>如果你不想看声调背后的历史渊源，只想直接学粤语声调，可以只阅读 <strong>五度标记法</strong> 和 <strong>九声六调</strong> 两个章节。但个人认为，了解这些有助于理解和记忆。</p>
</blockquote>
<h2 id="辨音"><a href="#辨音" class="headerlink" title="辨音"></a>辨音</h2><p>语言区别意义的最小声音单位，术语叫音位。一个音位允许多种不同发音，语言使用者心理上把它们当做同一发音，甚至完全没有察觉有什么不同。母语里不区分的音，或者直接没有的音，过了学语言的关键期，甚至是成年之后再来学，就比较难区分。</p>
<p>这种例子可以举很多：</p>
<ul>
<li>接触英语晚的同胞，比较难区分 s [s] （清齿龈擦音）和 th [θ] （清齿擦音）；</li>
<li>学普通话晚的南方人，比较难区分 z [ts] （不送气清齿龈塞擦音），c [tsʰ] （送气清齿龈塞擦音），s [s] （清齿龈擦音）和 zh [ʈʂ] （不送气清卷舌塞擦音），ch [ʈʂʰ] （送气清卷舌塞擦音），sh [ʂ]（清卷舌擦音）两组音，也就是一般所说的 平舌音 和 卷舌音；</li>
<li>部分方言不区分 l [l] （齿龈边音）和 n [n] （齿龈鼻音）；</li>
<li>当然还有非声调语言的母语者，很难区分声调；声调少的母语者，难区分母语里没有的声调。</li>
</ul>
<p>母语的学习，在婴幼儿这个听力最敏锐的时期（是的，耳蜗毛细胞的数量出生即巅峰，往后一辈子只会减少不能再生，所以要好好保护听力），加上没有既有语言的干扰，光凭模仿就能学得非常好，不需要任何发音、语法的概念。非母语的学习者，过了关键期再学，用沉浸式的方法多听多说，还是可以学得很好的。只是听力可能没有那么灵敏了，大脑中也有了母语的干扰，需要更用功，花更多时间。</p>
<p>无论如何，关键在于辨别不同的音，包括听觉上区分不同的音，和区分不同音的发音位置和技巧。<strong>能辨别的音，充分练习后基本上就能发出来。</strong> 先天条件的差异，可能会让部分人更难发出特定的音，但不至于彻底无法发出。一般人遇到的困难，更多是从未发过的音，受母语相近音的路径依赖干扰，以及练习不够。这就好像身体素质差、没有经过训练、有错误的手势会影响打篮球投篮命中，但极少人生理上就无法投篮。</p>
<p>这时如果学过发音规则和技巧，我认为对辨别相近音和矫正发音是有帮助的。只是这些知识只能减轻负担，不能代替努力；多听多说，特别是听自己说然后校正，是必经之路。所以懂很多语言知识但是不努力，跟很努力但没学过相关知识相比，反倒是后者比较有可能成。</p>
<p>今天先整理粤语九声六调的内容。后续再尝试整理粤语拼音和正字的内容。</p>
<h2 id="五度标记法"><a href="#五度标记法" class="headerlink" title="五度标记法"></a>五度标记法</h2><p>声调，是指附着在音节上的 抑扬（音调、音高变化）和 顿挫（辅音韵尾的停顿变化）。</p>
<p>先说音高。</p>
<p>可能由于印欧语系很少使用声调，现在国际通用的音高调值标记的办法，是我国语言学家赵元任发明的 <strong>五度制调值标记法</strong>，已经成为国际音标标准的一部分。</p>
<p>这个方法模仿五线谱，以 1、2、3、4、5 标记说话时的相对音高，以 1 为最低，5 为最高。</p>
<p>例如用五度标记法来标记普通话的四声（阴平，阳平，上声，去声）：</p>
<p><img src="../../images/pinyin-tones-in-five-level-tone-mark.png" alt=""></p>
<p>因为普通话声调四个调型不重复，没有必要标相对音高，可以简化用 <code>¯</code> 、<code>ˊ</code> 、<code>ˇ</code> 、<code>ˋ</code> 分别表示。</p>
<p>但在别的语言 / 方言可能会出现相同调型，这时就需要竖标来标明音高，同样是水平声调，从高到低分别是： <code>˥</code>， <code>˦</code>， <code>˧</code>， <code>˨</code>， <code>˩</code> 。这样普通话四声就可以标记为： <code>˥</code>，<code>˧˥</code>，<code>˨˩˦</code>，<code>˥˩</code> 。考虑到这些非 ascii 字母不好输入，有些环境不一定能正确显示，所以更多的时候，会用音高数字标明：55，35，214，51。</p>
<p>需要注意的是，这些都是相对音高，调值的高低是跟其他音比较之后得出的。以广州话的 阴平（55）和 阴去（33）为例，可能一个男生发出的 55 跟一个女生的 33 绝对音高差不多，但是女生发出的 55 更高，对比之下就会发现女生前面发的是 33。没有比较单发出一个 <strong>周</strong> （zau55）是没办法跟 <strong>皱</strong> （zau33）区分的，需要有其他字的音高做参考。</p>
<h2 id="声调演变"><a href="#声调演变" class="headerlink" title="声调演变"></a>声调演变</h2><p>有了标记音高的办法，然后我们才能来讨论声调。</p>
<h3 id="上古汉语"><a href="#上古汉语" class="headerlink" title="上古汉语"></a>上古汉语</h3><p>大部分语言学家认为汉语的声调是后起的，战国及之前的原始汉语没有声调，而以比现在更复杂的辅音系统区分现在不同声调的字。之后漫长的岁月里，逐渐从一些复杂的辅音演变出声调，到魏晋南北朝稳定为中古四声。</p>
<p>由于汉字是表意文字，古代又没有准确的注音手段，这方面的研究仍然存在一些争议。</p>
<h3 id="中古四声"><a href="#中古四声" class="headerlink" title="中古四声"></a>中古四声</h3><p>中古汉语（南北朝至唐宋之间的汉语）有四个声调，分别为 <strong>平、上、去、入</strong>。四声可能在上古汉语已经存在，但最早由南朝士子提出。梁武帝萧衍问周捨何谓四声，周捨答：『天子圣哲』。其中 『天』『平』都是平声，『子』『上』都是上声，『圣』『去』都是去声，『哲』『入』都是入声。</p>
<p>平上去入 四个字，既是刚好发 平上去入 四声，也一定程度描述四声的特点，提出时应该有经过特意挑选。日本遣唐僧人空海《文镜秘府论》有言：『平声哀而安，上声厉而举，去声清而远，入声直而促』；明朝僧人释真空在《玉钥匙歌诀》提到：『平声平道莫低昂，上声高呼猛烈强，去声分明哀远道，入声短促急收藏』。陈寅恪推测四声可能为 中平调、高平调、低平调、促调。可惜古代没有记录调值的手段，只能从历代韵书推断同声字，无法考究具体调值。</p>
<h3 id="四声流变"><a href="#四声流变" class="headerlink" title="四声流变"></a>四声流变</h3><p>语音的演变没有停留，四声继续发生变化：</p>
<ul>
<li><p>平分阴阳</p>
<p>  四声根据开头辅音的清浊（辅音发音时声带是否震动），清为阴（高亢），浊为阳（低沉），各分为两声。分化程度在现代汉语方言中各不相同。<strong>广州话四声都分阴阳</strong> ，烟台话继续不分阴阳，北京话只有平声分阴阳。</p>
<p>  此后很多方言里阴阳逐渐代替了清浊，浊音消失或者减少（清化）。但烟台话这样不分阴阳的方言还保留浊声母。也有吴语这样既分阴阳也保留浊声的例子，以此推测平分阴阳比浊母清化要早，阴阳承担了原本清浊的区分功能之后，浊音逐渐清化。</p>
</li>
<li><p>浊上归去</p>
<p>  这是另一个浊音相关的变化，发浊音的上声变成了去声。举例说 <strong>岛</strong> 中古音 发 清上声，现代无论普通话还是广州话，都还是上声（普通话第三声， <strong>广州话是阴上</strong>）；而 <strong>道</strong> 中古音 发 浊上声，现代普通话变成了 去声（第四声），<strong>广州话还是上声（阳上）</strong> 。浊上归去最典型的例子，就是 上 字本身。</p>
<p>  换言之，因为 平分阴阳 和 浊母清化 在前，<strong>广州话没有发生浊上归去</strong> 。</p>
</li>
<li><p>入派三声</p>
<p>  就是入声消失，最终并入 平上去 三声。中古汉语的入声，有 p，t，k 三个塞音韵尾，消失的过程中，先逐渐归并到一个到两个（一部分闽南话和客家话方言），然后只剩下一个喉塞音（吴语、晋语、江淮官话），再韵尾脱落变成独立的声调（温州话、湘语、闽北语、闽中语等），再并入其他声调（绝大部分官话方言）。各方言入声消失的进程不同，停留在了不同阶段。</p>
<p>  这一过程始于唐末宋初的中原北部，到元朝官话已经没有了入声，但在南方地区特别是华南地区保留得比较完整。现代普通话没有入声，最典型的例子就是 入 字本身，被派入了去声。 <strong>广州话完整保留了入声</strong>。</p>
</li>
</ul>
<p>完整的四声跟方言声调的对照，可以参考 <a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E8%81%B2#%E6%96%B9%E9%9F%B3%E5%A3%B0%E8%B0%83%E5%AF%B9%E7%85%A7" target="_blank" rel="external">四聲#方音声调对照</a> 。</p>
<h2 id="九声六调"><a href="#九声六调" class="headerlink" title="九声六调"></a>九声六调</h2><p>看了上面的内容，我们知道粤语的声调系统比较接近中古汉语，只是发生了 平分阴阳，入声仍然保留。不过粤语内部不同小片差异还是很大，以下仅讨论广州话。</p>
<p>广州话有九声六调，即 阴平，阴上，阴去，阳平，阳上，阳去，阴入，中入，阳入 九个声调。注意不是 9 + 6 = 15 个声调，而是 6 个调（抑扬，音高）+ 3 个入声（顿挫，塞音）= 9 个声调（同时包含抑扬顿挫）。其中 阴入（上阴入） 跟 阴平 ，中入（下阴入）跟 阴去，阳入 跟 阳去 的音高调值 是一样的，只是结尾带塞音韵母。</p>
<p>如果觉得这样看很乱，整理成表就不乱了：</p>
<table>
<thead>
<tr>
<th>阴阳 \ 调型</th>
<th>平</th>
<th>上</th>
<th>去</th>
</tr>
</thead>
<tbody>
<tr>
<td>阴</td>
<td>阴平 1（加塞音 阴入）</td>
<td>阴上 2</td>
<td>阴去 3（加塞音 中入）</td>
</tr>
<tr>
<td>阳</td>
<td>阳平 4</td>
<td>阳上 5</td>
<td>阳去 6（加塞音 阳入）</td>
</tr>
</tbody>
</table>
<h3 id="六调"><a href="#六调" class="headerlink" title="六调"></a>六调</h3><p>先不管三个入声，六调的详细调值和拼写代号如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">调类</th>
<th style="text-align:center">调值标记</th>
<th style="text-align:center">调值数字</th>
<th style="text-align:center">拼写代号</th>
<th style="text-align:center">字例</th>
<th style="text-align:center">粤拼</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">阴平</td>
<td style="text-align:center">˥、˥˧</td>
<td style="text-align:center">55、53</td>
<td style="text-align:center">1</td>
<td style="text-align:center">分</td>
<td style="text-align:center">fen1</td>
</tr>
<tr>
<td style="text-align:center">阴上</td>
<td style="text-align:center">˧˥</td>
<td style="text-align:center">35</td>
<td style="text-align:center">2</td>
<td style="text-align:center">粉</td>
<td style="text-align:center">fen2</td>
</tr>
<tr>
<td style="text-align:center">阴去</td>
<td style="text-align:center">˧</td>
<td style="text-align:center">33</td>
<td style="text-align:center">3</td>
<td style="text-align:center">粪</td>
<td style="text-align:center">fen3</td>
</tr>
<tr>
<td style="text-align:center">阳平</td>
<td style="text-align:center">˩、˨˩</td>
<td style="text-align:center">11、21</td>
<td style="text-align:center">4</td>
<td style="text-align:center">焚</td>
<td style="text-align:center">fen4</td>
</tr>
<tr>
<td style="text-align:center">阳上</td>
<td style="text-align:center">˨˧</td>
<td style="text-align:center">23</td>
<td style="text-align:center">5</td>
<td style="text-align:center">奋</td>
<td style="text-align:center">fen5</td>
</tr>
<tr>
<td style="text-align:center">阳去</td>
<td style="text-align:center">˨</td>
<td style="text-align:center">22</td>
<td style="text-align:center">6</td>
<td style="text-align:center">份</td>
<td style="text-align:center">fen6</td>
</tr>
</tbody>
</table>
<p>如果不考虑 阴平、阳平 的发音变体（考虑就画不下了），五度标记图如下：</p>
<p><img src="../../images/cantonese-tones-in-five-level-tone-mark.png" alt=""></p>
<blockquote>
<p>如果你和我一样，看了 平上去 三声在不同方言的调型之后，想总结一下规律，就要失望了。平声调型不一定平，有可能升调（普通话阳平，青岛话平声），有可能降调（上海话阴平，江淮官话阴平），甚至还有转折（济南话阴平），其它声调也类似，很难总结出规律。</p>
<p>这是因为 四声 经过了长时间的演变，已经变成单纯声调的分类，只是继续沿用原来的叫法。中古汉语一个声调下的字，除了通过某些规律分成多个声调，或者并入某个声调，剩下的还是叫原来的声调。例如 古代是平声的字，现代各方言还是叫平声，最多分开了阴阳；但是 这个平声怎么发音，现代和古代，现代各方言之间，经过长时间演变，规律已经不明显。</p>
<p>这就好比火车早就不烧火了，但我们约定俗成还是叫火车。</p>
</blockquote>
<h3 id="入声"><a href="#入声" class="headerlink" title="入声"></a>入声</h3><p>入声包括入声韵和入声调，大多数情况下不作区分，通称入声。</p>
<p>入声韵，又叫促声韵，是指在音节的结尾，加入塞音韵尾，使发音快速结束，再无声除阻。例如 姑（广州话 gu1）和 谷 （广州话 guk1），前者是阴平，后者多了一个 k [k̚] （无声除阻清软腭塞音）使 u 音变得短而急促，就变成了 入声。（普通话没有了 入声，谷 被派入了 上声。）</p>
<p>广州话保留了完整的三个入声韵尾：</p>
<table>
<thead>
<tr>
<th style="text-align:center">韵尾</th>
<th style="text-align:center">拼写</th>
<th style="text-align:center">发音</th>
<th style="text-align:center">字例</th>
<th style="text-align:center">粤拼</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">清双唇塞音</td>
<td style="text-align:center">p</td>
<td style="text-align:center">[p̚]</td>
<td style="text-align:center">湿</td>
<td style="text-align:center">sap1</td>
</tr>
<tr>
<td style="text-align:center">清齿音塞音</td>
<td style="text-align:center">t</td>
<td style="text-align:center">[t̚]</td>
<td style="text-align:center">失</td>
<td style="text-align:center">sat1</td>
</tr>
<tr>
<td style="text-align:center">清软腭塞音</td>
<td style="text-align:center">k</td>
<td style="text-align:center">[k̚]</td>
<td style="text-align:center">塞</td>
<td style="text-align:center">sak1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>用作韵尾的辅音，都发无声除阻音，又叫唯闭音，指除阻时听不到爆发的塞音，以 ◌̚ 表示。</p>
</blockquote>
<p>而入声调有两种含义。在还有入声韵的时候，入声调强调发音 <strong>短而急促</strong> ，区别于其他声调。但在入声韵的韵尾消失之后，在某些方言还存在的入声调，变成了一个纯粹的声调分类，失去了促声韵的特点（温州话的入声甚至比其它声调还要长）。</p>
<p>广州话有三个入声调，音高调值跟 阴平、阴去、阳去 一致：</p>
<table>
<thead>
<tr>
<th style="text-align:center">调类</th>
<th style="text-align:center">调值标记</th>
<th style="text-align:center">调值数字</th>
<th style="text-align:center">拼写代号</th>
<th style="text-align:center">字例</th>
<th style="text-align:center">粤拼</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">阴入（上阴入）</td>
<td style="text-align:center">˥、˥˧</td>
<td style="text-align:center">55、53</td>
<td style="text-align:center">1 或 7</td>
<td style="text-align:center">忽</td>
<td style="text-align:center">fat1</td>
</tr>
<tr>
<td style="text-align:center">中入（下阴入）</td>
<td style="text-align:center">˧</td>
<td style="text-align:center">33</td>
<td style="text-align:center">3 或 8</td>
<td style="text-align:center">发</td>
<td style="text-align:center">faat3</td>
</tr>
<tr>
<td style="text-align:center">阳入</td>
<td style="text-align:center">˨</td>
<td style="text-align:center">22</td>
<td style="text-align:center">6 或 9</td>
<td style="text-align:center">佛</td>
<td style="text-align:center">fat6</td>
</tr>
</tbody>
</table>
<h3 id="助记口诀"><a href="#助记口诀" class="headerlink" title="助记口诀"></a>助记口诀</h3><p>六个不同调（音高调值），加上三个入声调，一共九个声调。为了方便看全貌，再贴一次完整的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">调类</th>
<th style="text-align:center">调值数字</th>
<th style="text-align:center">拼写代号</th>
<th style="text-align:center">字例</th>
<th style="text-align:center">粤拼</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">阴平</td>
<td style="text-align:center">55、53</td>
<td style="text-align:center">1</td>
<td style="text-align:center">分</td>
<td style="text-align:center">fen1</td>
</tr>
<tr>
<td style="text-align:center">阴上</td>
<td style="text-align:center">35</td>
<td style="text-align:center">2</td>
<td style="text-align:center">粉</td>
<td style="text-align:center">fen2</td>
</tr>
<tr>
<td style="text-align:center">阴去</td>
<td style="text-align:center">33</td>
<td style="text-align:center">3</td>
<td style="text-align:center">粪</td>
<td style="text-align:center">fen3</td>
</tr>
<tr>
<td style="text-align:center">阳平</td>
<td style="text-align:center">11、21</td>
<td style="text-align:center">4</td>
<td style="text-align:center">焚</td>
<td style="text-align:center">fen4</td>
</tr>
<tr>
<td style="text-align:center">阳上</td>
<td style="text-align:center">23</td>
<td style="text-align:center">5</td>
<td style="text-align:center">奋</td>
<td style="text-align:center">fen5</td>
</tr>
<tr>
<td style="text-align:center">阳去</td>
<td style="text-align:center">22</td>
<td style="text-align:center">6</td>
<td style="text-align:center">份</td>
<td style="text-align:center">fen6</td>
</tr>
<tr>
<td style="text-align:center">阴入（上阴入）</td>
<td style="text-align:center">55、53</td>
<td style="text-align:center">1 或 7</td>
<td style="text-align:center">忽</td>
<td style="text-align:center">fat1</td>
</tr>
<tr>
<td style="text-align:center">中入（下阴入）</td>
<td style="text-align:center">33</td>
<td style="text-align:center">3 或 8</td>
<td style="text-align:center">发</td>
<td style="text-align:center">faat3</td>
</tr>
<tr>
<td style="text-align:center">阳入</td>
<td style="text-align:center">22</td>
<td style="text-align:center">6 或 9</td>
<td style="text-align:center">佛</td>
<td style="text-align:center">fat6</td>
</tr>
</tbody>
</table>
<p>必须说，九个声调还是不少的，即使作为母语者，偶尔也会反应不过来，这时就需要助记口诀了。</p>
<ul>
<li>首先是 <strong>分粉粪焚奋份忽发佛</strong> （fen1 fen2 fen3 fen4 fen5 fen6 fat1 faat3 fat6），几乎都是一个音，可以着重感受声调的差别；</li>
<li><strong>三九四零五二七八六</strong> （saam1 gau2 sei3 ling4 ng5 ji6 cat1 baat3 luk6），可以当电话号码背下来，就是小心不要把数字本身当作发音的声调；</li>
<li><strong>周口店河姆渡得发掘</strong> （zau1 hau2 dim3 ho4 mou5 dou6 dak1 faat3 gwat6），这个纯粹是个人喜欢。</li>
</ul>
<p>更多的口诀，可以参考 <a href="https://zh.wikipedia.org/wiki/%E7%B2%B5%E8%AA%9E%E8%81%B2%E8%AA%BF#%E4%B9%9D%E8%81%B2%E5%8F%A3%E8%A8%A3" target="_blank" rel="external">粵語聲調#九聲口訣</a> 。</p>
<p>当然，初学者还是要通过听声音先模仿发音，光靠看书面内容是无法学会的。B 站搜『九声六调』应该很容易找到视频。后续我也会考虑录一些九声六调的演示。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>很早以前就想为粤语做点什么。奈何自己水平不高，不知道从哪里入手，一直拖着。等到孩子出生，周围已经没有了说粤语的环境，才意识到不能再拖。通过行动来倒逼水平提高，比不做强。</p>
<p>于是尝试录粤语的视频，现在开始整理一点资料，说是为孩子攒以后学粤语的材料。</p>
<p>着手做之后，有了不同想法。想让孩子说粤语，比起资料，还是更需要一个环境，需要我主动跟他说。就算需要学习材料，市面上、网络上的材料虽然不算多，也远远比自己做要来得快，来得专业。而我也只是比普通人多知道一点点，需要恶补的课很多。</p>
<p>但我反而没有要放弃的想法，而是更坚定地想继续下去，只是目的变了：<strong>增进自己对粤语的了解</strong> 。之前看街访视频，一个广州小朋友在有家人教的情况下，还是不会说广州话。甚至从话里听出，因为家人教学过于积极，小朋友对说广州话产生了抵触。大环境已经变了，失去沉浸的语境，在学校的普通话之外，同时保持母语方言并不容易。起码没有我们小时候顺理成章。我们只能提供环境和帮助，而不是增加压力。</p>
<p>我没有信心将来孩子一定愿意讲，但希望到时我可以展示粤语多么有趣，我有多了解粤语，还有我对这件事有多认真 。希望做一个榜样。所以，不需要担心自己水平不高，不需要跟别人比较，不用管孩子以后是不是真的用得上。 <strong>所有努力的目标都在于自己，做就完了。</strong> </p>
<p>选题方面，一开始的题目有点大，下笔才发现 hold 不住。不断收缩范围之后，今天先从『九声六调』开始，后续做些科普型的内容。如果大神路过，发现错漏，能留言告知，感激不尽；如果有粤语爱好者，能从中获得一点助益，一起进步，则不胜荣幸。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>本文不是粤语的原创研究，而是我的个人体会、理解，加上对公开信息的整理与解说。不确定的内容，参考信息主要来源于维基百科。</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/印欧语系" target="_blank" rel="external">https://zh.wikipedia.org/wiki/印欧语系</a></li>
<li><a href="https://zh.wikipedia.org/wiki/汉藏语系" target="_blank" rel="external">https://zh.wikipedia.org/wiki/汉藏语系</a></li>
<li><a href="https://zh.wikipedia.org/wiki/音位" target="_blank" rel="external">https://zh.wikipedia.org/wiki/音位</a></li>
<li><a href="https://zh.wikipedia.org/wiki/國際音標" target="_blank" rel="external">https://zh.wikipedia.org/wiki/國際音標</a></li>
<li><a href="https://zh.wikipedia.org/wiki/汉语拼音" target="_blank" rel="external">https://zh.wikipedia.org/wiki/汉语拼音</a></li>
<li><a href="https://zh.wikipedia.org/wiki/聲調" target="_blank" rel="external">https://zh.wikipedia.org/wiki/聲調</a></li>
<li><a href="https://zh.wikipedia.org/wiki/五度标记法" target="_blank" rel="external">https://zh.wikipedia.org/wiki/五度标记法</a></li>
<li><a href="https://zh.wikipedia.org/wiki/四聲" target="_blank" rel="external">https://zh.wikipedia.org/wiki/四聲</a></li>
<li><a href="https://zh.wikipedia.org/wiki/三十六字母" target="_blank" rel="external">https://zh.wikipedia.org/wiki/三十六字母</a></li>
<li><a href="https://zh.wikipedia.org/wiki/广州话" target="_blank" rel="external">https://zh.wikipedia.org/wiki/广州话</a></li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学汉语，其中一道坎就是声调。只会北方官话的人学声调更多的南方方言，如粤语，也面临类似的困难。&lt;/p&gt;
    
    </summary>
    
      <category term="粤语" scheme="https://jaycechant.info/categories/%E7%B2%A4%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 题解： Regular Expression Matching</title>
    <link href="https://jaycechant.info/2020/leetcode-10-regular-expression-matching/"/>
    <id>https://jaycechant.info/2020/leetcode-10-regular-expression-matching/</id>
    <published>2020-06-04T03:03:24.000Z</published>
    <updated>2020-06-09T07:00:20.883Z</updated>
    
    <content type="html"><![CDATA[<p>一点点找回手感，容我继续水小题号的 Hard。</p>
<a id="more"></a>
<p>这次做的是 10 号题：正则表达式匹配。</p>
<p>英文：<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="external">https://leetcode.com/problems/regular-expression-matching/</a></p>
<p>中文：<a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="external">https://leetcode-cn.com/problems/regular-expression-matching/</a></p>
<h2 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h2><h3 id="一句话题意"><a href="#一句话题意" class="headerlink" title="一句话题意"></a>一句话题意</h3><p>实现一个只有 <code>.</code> 和 <code>*</code> 的正则表达式子集，对给定的 字符串 <code>s</code> 和 模式串 <code>p</code> ，返回是否 <strong>全文匹配</strong> 。</p>
<blockquote>
<p><code>.</code> 匹配任意单个字符</p>
<p><code>*</code> 匹配零个或多个前一个元素</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>见测试用例</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>每篇题解，都会强调 <strong>准备纸笔</strong> 和 <strong>单元测试</strong> 。为此在做这道题时，还顺便写了 《<a href="../rapidly-generate-unit-tests-in-vs-code/">如何快速生成单元测试</a>》。</p>
<p>不多解释，直接贴代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	s    <span class="keyword">string</span></div><div class="line">	p    <span class="keyword">string</span></div><div class="line">	want <span class="keyword">bool</span></div><div class="line">&#125;&#123;</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"1"</span>,</div><div class="line">		s:    <span class="string">"aa"</span>,</div><div class="line">		p:    <span class="string">"a"</span>,</div><div class="line">		want: <span class="literal">false</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"2"</span>,</div><div class="line">		s:    <span class="string">"aa"</span>,</div><div class="line">		p:    <span class="string">"a*"</span>,</div><div class="line">		want: <span class="literal">true</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"3"</span>,</div><div class="line">		s:    <span class="string">"ab"</span>,</div><div class="line">		p:    <span class="string">".*"</span>,</div><div class="line">		want: <span class="literal">true</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"4"</span>,</div><div class="line">		s:    <span class="string">"aab"</span>,</div><div class="line">		p:    <span class="string">"c*a*b"</span>,</div><div class="line">		want: <span class="literal">true</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"5"</span>,</div><div class="line">		s:    <span class="string">"mississippi"</span>,</div><div class="line">		p:    <span class="string">"mis*is*p*."</span>,</div><div class="line">		want: <span class="literal">false</span>,</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">// 篇幅关系，只提供题目的例子</span></div><div class="line">	<span class="comment">// 实际开发一定要多考虑不同的测试用例</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_isMatch</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> got := isMatch(tt.s, tt.p); got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"isMatch() = %v, want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>篇幅关系，例子以外的测试用例，留给大家自己想。</p>
<p>刷题新手基础差，题目见得少，一开始没有思路是正常的。但将对题意的理解翻译成测试用例，还有根据题目约束列出边界条件，细心一点总是可以做到的。偶尔有理解盲区，也很正常，多练习就好。</p>
<p>以这道题为例，如果认真看题目给的约束，马上就能添加几个边界条件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	name: <span class="string">"0v0"</span>,</div><div class="line">	s:    <span class="string">""</span>,</div><div class="line">	p:    <span class="string">""</span>,</div><div class="line">	want: <span class="literal">true</span>,</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">	name: <span class="string">"0va"</span>,</div><div class="line">	s:    <span class="string">""</span>,</div><div class="line">	p:    <span class="string">"a"</span>,</div><div class="line">	want: <span class="literal">false</span>,</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">	name: <span class="string">"0va*"</span>,</div><div class="line">	s:    <span class="string">""</span>,</div><div class="line">	p:    <span class="string">"a*"</span>,</div><div class="line">	want: <span class="literal">true</span>,</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">	name: <span class="string">"av0"</span>,</div><div class="line">	s:    <span class="string">"a"</span>,</div><div class="line">	p:    <span class="string">""</span>,</div><div class="line">	want: <span class="literal">false</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h2 id="直接动手"><a href="#直接动手" class="headerlink" title="直接动手"></a>直接动手</h2><p>之前一直强调，先从简单粗暴的解法入手，再逐渐改进，比没有思路干耗强。如果是比赛，解决之后没有更好的思路，不妨提交看看，也许测试数据强度不高，又或者其实想多了没有更好的解法，直接就通过了。如果是面试，不能一步到位最优解，也不妨给出初步答案，重点展现改进的思路。如果是平时练习，可以逐渐打磨，积累自己的 SOP。</p>
<p>等题目见多了，找到窍门，可以一下子想几步，就没必要一步步跟着看，可以直接跳到后面部分，或者直接关闭文章走人。（我是认真的，如果你看到题目直接想到了 <strong>最优子结构</strong> 和 <strong>状态转移</strong> ，就没有必要停留。）</p>
<p>当然可能也会有人觉得，思路展开得还不够细。确实，限于篇幅，不太可能从最『耿直』的代码开始，每个小改进贴一次代码。中间跳过的部分，如果你觉得有必要，可以自己推算一下。</p>
<h3 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h3><p>我们很容易发现，难点是 <code>*</code> ，也就是那句『<strong>匹配 0 到 多个</strong>』，就是这句话让复杂度暴增。</p>
<p>如果把 <code>*</code> 去掉，只需要从头到尾逐个字符匹配，任意一个字符不匹配就可以直接返回 false。没有任何例外。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(p) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</div><div class="line">		<span class="keyword">if</span> s[i] != p[i] &amp;&amp; p[i] != <span class="string">'.'</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦加入 <code>*</code> ，事情就变复杂了。举例 <code>abbbbbbba</code> 和 <code>abb*bba</code> ：</p>
<p><img src="../../images/leetcode10-sample1.svg" alt=""></p>
<p>假定 <code>*</code> 尽量少匹配字符（简称懒汉策略），从匹配 0 个字符开始（是的，不要忘了可以匹配 0 个字符），继续往下试，直到发现不匹配。这时不能像没有 <code>*</code> 时那样直接返回不匹配，而是要回到 <code>*</code> 之前匹配的位置，尝试让 <code>*</code> 多匹配一个字符，把剩下的再来一遍。不行？再来一遍。又不行？再来一遍……</p>
<p>直到</p>
<ul>
<li>哇，剩下的都匹配上了。true</li>
<li>噢，<code>b*</code> 遇到了 <code>b</code> 以外的字符。false</li>
</ul>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>后面剩余的字符串每次都要再尝试匹配一遍，低效暂且不管。关键发现后面的不匹配，得回到 <code>b*</code> 匹配的位置。</p>
<p><code>b*</code> 的位置，还有在 s 里的匹配位置，记录的临时变量在后面继续匹配时被覆盖了？那不行，得存起来。</p>
<p>多给一套临时变量？那再来一个 <code>c*</code>  ,  <code>d*</code> , <code>e*</code> 怎么办？只能用栈！</p>
<p>这种搜索答案时遇到选择，<strong>把选择点存起来</strong> ，先选一个分支走下去，走不通时 <strong>回到选择点继续</strong> 的做法，叫 <strong>回溯法</strong> 。那个选择点，叫回溯点。以前上课，是这样帮助学员记忆的：『能进则进，不能进则换，不能换则退』。这里的 <strong>进</strong> ，指选一个分支往下走； <strong>换</strong> 指在回溯点换一个分支； <strong>退</strong> 指当前回溯点所有分支都走不通，退回上一个回溯点。</p>
<p>把理解翻译成代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 回溯法</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> isMatchBT(s, p, <span class="built_in">len</span>(s)<span class="number">-1</span>, <span class="built_in">len</span>(p)<span class="number">-1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// BT = BackTracking</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatchBT</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>, is <span class="keyword">int</span>, ip <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123; <span class="comment">// 普通匹配循环</span></div><div class="line">		<span class="keyword">if</span> ip &lt; <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> is &lt; <span class="number">0</span> &#123; <span class="comment">// 两边同时结束，没有发现不匹配</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// pattern 结束而 string 有剩余，不匹配</span></div><div class="line">			<span class="comment">// 反之 只有 is &lt; 0 需要进一步判断，因为剩余的 pattern 有可能匹配空串</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> p[ip] == <span class="string">'*'</span> &#123; <span class="comment">// '*' 进入递归回溯，为避免嵌套太深，break 后另起 for 循环</span></div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 1. pattern 不是 '*'，而 string 还有剩余，不匹配</span></div><div class="line">		<span class="comment">// 2. 字符不匹配</span></div><div class="line">		<span class="keyword">if</span> is &lt; <span class="number">0</span> || (s[is] != p[ip] &amp;&amp; p[ip] != <span class="string">'.'</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">		is--</div><div class="line">		ip--</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ip--</div><div class="line">	<span class="keyword">for</span> &#123; <span class="comment">// '*' 回溯循环</span></div><div class="line">		<span class="keyword">if</span> isMatchBT(s, p, is, ip<span class="number">-1</span>) &#123; <span class="comment">// 递归匹配剩余串</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 剩余串不匹配，'*' 尝试再匹配一个字符后递归</span></div><div class="line"></div><div class="line">		<span class="comment">// 1. string 结束，'*' 无法进一步匹配</span></div><div class="line">		<span class="comment">// 2. 字符不匹配</span></div><div class="line">		<span class="keyword">if</span> is &lt; <span class="number">0</span> || (s[is] != p[ip] &amp;&amp; p[ip] != <span class="string">'.'</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span></div><div class="line">		&#125;</div><div class="line">		is--</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回溯要用到栈，有两个选择：</p>
<ul>
<li><p>自己管理一个栈。遇到选择分支就将回溯点压栈，要回溯就弹栈。</p>
<p>  优点是避免了函数调用的开销，缺点是不直观容易绕晕。</p>
</li>
<li><p>直接递归，利用函数栈保留回溯点。调用下一层函数相当于压栈，返回一层相当于弹栈。</p>
<p>  优缺点刚好反过来。</p>
</li>
</ul>
<p>这里为了直观，选择了直接递归。注意控制局部变量的数量，调用函数的开销也没有想象中大。</p>
<p>其它要点：</p>
<ul>
<li>理论上，可以每匹配一个字符就递归一层，这样代码最简洁。但 <code>*</code> 以外的匹配并不复杂，沿用前面写的循环即可，仅仅遇到 <code>*</code> 才回溯，减少调用栈的深度。</li>
<li>从左到右匹配和从右到左，效率上没有什么差别，因为不匹配的部分在哪是随机的。但是从左到右总是要多读一个字符判断是否 <code>*</code> ，而从右到左可以在读到 <code>*</code> 时再多读一个字符组成匹配项。</li>
</ul>
<p>测试一下，通过。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>不过，如果你生成比较大、比较复杂的测试数据，会发现回溯法的用时特别多，轻易上到秒级别。</p>
<p>原因其实前面已经提到过了，那就是每次回溯，<strong>剩余的字符串都要再尝试匹配一遍</strong> 。</p>
<p>这里面有没有重复劳动？我们再来看一个例子 <code>abbbccccccca</code> 和 <code>ab*b*c*</code> ：</p>
<p><img src="../../images/leetcode10-sample2.svg" alt=""></p>
<p>前半段 <code>abbb</code> 和 <code>ab*b*</code> 有多种匹配方式。前面匹配之后，接着判断余下 <code>ccccccca</code> 和 <code>c*</code> 部分。</p>
<p>后面不匹配？可能前面匹配多了或者少了字符，换一种方式匹配后，又回到后半段。因为当前的代码没有记录，并不知道后半段的状态重复出现，又运算了一遍。这些运算量就浪费掉了。</p>
<p>如果能保存运算过的结果就好了。</p>
<h3 id="缓存子问题的解"><a href="#缓存子问题的解" class="headerlink" title="缓存子问题的解"></a>缓存子问题的解</h3><p>上次讲 <a href="../leetcode-4-median-of-two-sorted-arrays/">二分查找</a> 时，说到一个优化的思路：只获取 <strong>最小的必要信息</strong>，否则会为不需要的信息付出额外的运算。</p>
<p>那么这次是另一个很重要的思路： <strong>发现并消除重复运算</strong>。</p>
<p>具体到动态规划（Dynamic Planning，以下简称 DP），就是：</p>
<ol>
<li>定义子问题；</li>
<li>开辟额外空间，缓存子问题的最优解；</li>
<li>当引用重叠子问题（overlapping sub-problems）的解时，读取缓存，来避免重复运算。</li>
</ol>
<p>要应用 DP 有两个关键条件：</p>
<ul>
<li><p>存在重叠子问题。</p>
<p>  DP 本质上仍然是 “Brute-Force” 搜索答案，只是做了巧妙的去重。如果不存在重叠子问题，费劲缓存没有意义。</p>
</li>
<li><p>子问题有最优子结构。</p>
<p>  最优子结构（optimal substructure）是指，全局问题的最优解包含的子问题解，也是最优解。适合贪心算法的问题也有同样特性。</p>
<p>  区别在于，贪心算法能直接从局部最优推出全局最优，DP 则不一定。DP 的全局最优解，是部分子问题最优解的组合。不一定所有子问题的解都能用上，但用上的一定是最优解。</p>
<p>  这其实很好理解：缓存的就是子问题最优解， <strong>如果全局最优包含的不是最优解，缓存就没有意义</strong>。</p>
</li>
</ul>
<p>即使对同一个问题，这两个条件也不是固定不变的，是否成立有时依赖于如何定义子问题。要 <strong>恰当地定义和分割子问题</strong> ，满足这两个条件，将复杂问题逐渐分解成简单子问题，并缓存子问题的解。这需要 <strong>分治法</strong> 作为前置知识，篇幅所限，有机会再补坑。</p>
<p>回到题目，我们将子问题 $ DP_{is, ip} $ 定义为 <code>s[is:]</code> 与 <code>p[ip:]</code> 是否匹配（注：<code>s[is:]</code> 表示从下标 is 一直到结尾的子串，子串右下标缺省表示取到末尾），那么全局就是 $ DP_{0, 0} $ 。全局解和子问题解的递推关系为：</p>
<p>$$<br>\left\{<br>\begin{array}{lr}<br>DP_{is, ip} = match(s[is],p[ip]) \land DP_{is+1, ip+1} &amp; (p[ip+1]\ is\ not\ *) \\<br>DP_{is, ip} = DP_{is, ip+2} \lor (match(s[is],p[ip]) \land DP_{is+1, ip}) &amp; (p[ip+1]\ is\ *)<br>\end{array}<br>\right.<br>$$</p>
<p>翻译成大白话就是，当前子问题匹配，需要 1. 当前位置两边的字符匹配 且 2. 余下的子问题匹配。<code>*</code> 的特殊处理后面就着代码说。</p>
<p>重叠子问题上面已经给了例子。至于最优子结构，将字符串分割成不同部分进行匹配，需要每一部分都匹配，才能得出整体匹配。全局解，包含局部解。而子问题 $ DP_{is, ip} $ 匹配与否，只有唯一解，相当于最优解。</p>
<p>子问题的解称为状态，这种根据上一阶段的状态计算出当前状态的推导式，称之为 <strong>状态转移方程</strong> 。</p>
<p>有状态转移方程，就可以写代码了。这时又有两种选择：</p>
<ul>
<li><p>Top-down</p>
<p>  先尝试引用，如果发现解不存在，再去计算。计算时引用到的解如果不存在，再递归去计算。换言之， <strong>不用不算，用到再算</strong> 。</p>
<p>  优点是，<strong>没有被最终答案（直接或间接）引用的子问题，不会被计算</strong> 。缺点是，需要先自顶向下分解，然后到了最里层返回时计算，需要用到栈或者递归，有额外的内存和函数调用开销。</p>
<p>  这种方式又被称为 记忆化（Memorized）/ 备忘录（Memorization）方法。</p>
</li>
<li><p>Bottom-up</p>
<p>  或者不管用不用得上，从最小的子问题开始，构造相邻的状态，直到获得全局解为止。</p>
<p>  优缺点刚好反过来。</p>
</li>
</ul>
<h3 id="记忆化-Top-down"><a href="#记忆化-Top-down" class="headerlink" title="记忆化 Top-down"></a>记忆化 Top-down</h3><p>先看 Top-down 的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DP: Top-down</span></div><div class="line"><span class="keyword">type</span> state <span class="keyword">uint8</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ( <span class="comment">// 用到才计算，所以需要 true， false 以外的值表示 '未计算'</span></div><div class="line">	unknown state = <span class="literal">iota</span></div><div class="line">	unmatched</div><div class="line">	matched</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// memo[is][ip] 表示 s[is:] 与 p[ip:] 两个子串是否匹配</span></div><div class="line"><span class="keyword">var</span> memo [][]state</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="comment">// 为了避免特殊判断，多出一行一列，用来处理空子串</span></div><div class="line">	memo = <span class="built_in">make</span>([][]state, <span class="built_in">len</span>(s)+<span class="number">1</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> memo &#123;</div><div class="line">		memo[i] = <span class="built_in">make</span>([]state, <span class="built_in">len</span>(p)+<span class="number">1</span>)</div><div class="line">		memo[i][<span class="built_in">len</span>(p)] = unmatched <span class="comment">// pattern 为空子串一定不匹配</span></div><div class="line">	&#125;</div><div class="line">	memo[<span class="built_in">len</span>(s)][<span class="built_in">len</span>(p)] = matched <span class="comment">// 特例：两个子串都为空时匹配</span></div><div class="line">	<span class="keyword">return</span> isMatchMemo(s, p, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatchMemo</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>, is <span class="keyword">int</span>, ip <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> memo[is][ip] == unknown &#123;</div><div class="line">		preMatch := is &lt; <span class="built_in">len</span>(s) &amp;&amp; (p[ip] == <span class="string">'.'</span> || s[is] == p[ip])</div><div class="line"></div><div class="line">		<span class="keyword">if</span> ip+<span class="number">1</span> &lt; <span class="built_in">len</span>(p) &amp;&amp; p[ip+<span class="number">1</span>] == <span class="string">'*'</span> &#123;</div><div class="line">			<span class="comment">// 匹配空串（消耗 pattern）</span></div><div class="line">			<span class="keyword">if</span> isMatchMemo(s, p, is, ip+<span class="number">2</span>) ||</div><div class="line">				<span class="comment">// 匹配一个字符（不消耗 pattern）</span></div><div class="line">				(preMatch &amp;&amp; isMatchMemo(s, p, is+<span class="number">1</span>, ip)) &#123;</div><div class="line">				memo[is][ip] = matched</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				memo[is][ip] = unmatched</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span> preMatch &amp;&amp;</div><div class="line">				isMatchMemo(s, p, is+<span class="number">1</span>, ip+<span class="number">1</span>) &#123;</div><div class="line">				memo[is][ip] = matched</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				memo[is][ip] = unmatched</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> memo[is][ip] == matched</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟回溯法细节上的差异：</p>
<ul>
<li><p>回溯法为了避免不必要的递归和回溯，<code>*</code> 以外的匹配都是直接在循环内处理，没有必要调用函数。但这里每次都要 <strong>尽可能少匹配字符， 然后交给递归处理</strong> 。这样是为了子问题分割的 <strong>粒度尽可能小</strong>，让每个（被引用到的）子问题的解都有缓存。</p>
</li>
<li><p>为了达到第一点，<code>*</code> 的匹配分成两种：要么匹配 s 空串消耗 pattern，要么匹配 s 单个字符不消耗 pattern。<strong>不同时消耗 s 和 p 的字符</strong> 。这一条是主要的难点。（不消耗是指，虽然 <code>*</code> 匹配了字符，但是 p 串下标不移动，留在原地继续匹配 s 串下一个字符）</p>
<p>  以 <code>bbbb</code> 匹配 <code>b*</code> 为例，分了 5 步（不包括失败的尝试）：<code>b*</code> 匹配 4 次 <code>b</code> 都保留 <code>b*</code> ，然后第 5 次匹配 空串才消耗掉。</p>
</li>
<li><p>Top-down DP 分解和实际计算的方向是反的。从左到右递归引用子问题，计算时就是从右到左组合。实际写就会发现，从右到左引用，下标处理麻烦一些。（如果从右到左，子问题 $ DP_{is, ip} $ 就要定义成 <code>s[0:is]</code> 和 <code>s[0:ip]</code> 是否匹配。）</p>
</li>
</ul>
<h3 id="Bottom-up"><a href="#Bottom-up" class="headerlink" title="Bottom-up"></a>Bottom-up</h3><p>Bottom-up 的代码会简洁一些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Bottom-up</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</div><div class="line">		dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">	dp[<span class="built_in">len</span>(s)][<span class="built_in">len</span>(p)] = <span class="literal">true</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> is := <span class="built_in">len</span>(s); is &gt;= <span class="number">0</span>; is-- &#123;</div><div class="line">		<span class="keyword">for</span> ip := <span class="built_in">len</span>(p) - <span class="number">1</span>; ip &gt;= <span class="number">0</span>; ip-- &#123;</div><div class="line">			preMatch := is &lt; <span class="built_in">len</span>(s) &amp;&amp; (p[ip] == <span class="string">'.'</span> || s[is] == p[ip])</div><div class="line">			<span class="keyword">if</span> ip+<span class="number">1</span> &lt; <span class="built_in">len</span>(p) &amp;&amp; p[ip+<span class="number">1</span>] == <span class="string">'*'</span> &#123;</div><div class="line">				dp[is][ip] = dp[is][ip+<span class="number">2</span>] ||</div><div class="line">					(preMatch &amp;&amp; dp[is+<span class="number">1</span>][ip])</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				dp[is][ip] = preMatch &amp;&amp; dp[is+<span class="number">1</span>][ip+<span class="number">1</span>]</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了 p 子串为空时不用计算（即 ip 为 <code>len(p)</code> ，此时 <code>p[ip:]</code> 为空），Bottom-up 所有子问题都会算一遍（包括 s 子串为空也要实际判断，因为 p 有可能匹配空串）。没有必要区分是否已经计算，状态矩阵直接用 bool 值。</p>
<p>也因为这样，Bottom-up 对子问题的划分 <strong>不重不漏</strong> 的要求更严格一些。Top-down 里如果不小心一次匹配了多个字符，导致不是每个解都有缓存，出现重复计算，只是影响运行效率。而这里如果子问题分得不够细，跳过了某个子问题的计算，后续引用到的就可能是错误值。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="运行速度"><a href="#运行速度" class="headerlink" title="运行速度"></a>运行速度</h3><p>三种解法都通过了单元测试。剩下就是要比较运行速度。在复杂度分析之前，可以直观地看一下基准测试（Benchmark Test）。</p>
<p>暂时没有发现自动生成基准测试代码的工具，还好手敲很简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_isMatch1</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">			isMatch1(tt.s, tt.p)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_isMatch2</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">			isMatch2(tt.s, tt.p)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_isMatch3</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">			isMatch3(tt.s, tt.p)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把三种实现依次重命名为 <code>isMatch1</code> 、 <code>isMatch2</code> 、 <code>isMatch3</code>，对应三个基准测试。先用题目自带的用例测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Benchmark_isMatch1-8   	 5172118	       224 ns/op	       0 B/op	       0 allocs/op</div><div class="line">Benchmark_isMatch2-8   	  599966	      1882 ns/op	    1024 B/op	      39 allocs/op</div><div class="line">Benchmark_isMatch3-8   	  545421	      2325 ns/op	    1024 B/op	      39 allocs/op</div><div class="line">PASS</div><div class="line">ok  	leetcode	4.621s</div></pre></td></tr></table></figure>
<p>（每列的含义依次为：测试名、循环次数、平均耗时、平均内存分配、平均内存分配次数，默认情况下测试时间为 1 秒。）</p>
<p>可以看到，在数据量小、用例简单时，DP 完全不占优势，回溯法快 10 倍左右。毕竟光初始化内存就落后了。</p>
<p>这时，将测试用例改为这两个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">		name: <span class="string">"6"</span>,</div><div class="line">		s:    <span class="string">"a...省略197个a...ab"</span>,</div><div class="line">		p:    <span class="string">"caa*a*a*a*b*"</span>,</div><div class="line">		want: <span class="literal">false</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"7"</span>,</div><div class="line">		s:    <span class="string">"ca...省略197个a...a"</span>,</div><div class="line">		p:    <span class="string">"c*aa*a*a*a*b"</span>,</div><div class="line">		want: <span class="literal">false</span>,</div><div class="line">	&#125;,</div></pre></td></tr></table></figure>
<p>这两个特意构造的用例， s 串特别长，重复字符多，p 串 <code>*</code> 也多；最终结果是 false，让代码一直搜索到最后；不匹配的字符一个在最左一个在最右，抵消因为方向导致的优势。（最初准备的用例长度为 500，结果运行起来非常慢，才缩短为 200 。）看看结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Benchmark_isMatch1-8   	       2	 730041750 ns/op	       0 B/op	       0 allocs/op</div><div class="line">Benchmark_isMatch2-8   	   43952	     27281 ns/op	   16160 B/op	     404 allocs/op</div><div class="line">Benchmark_isMatch3-8   	   33331	     36155 ns/op	   16160 B/op	     404 allocs/op</div><div class="line">PASS</div><div class="line">ok  	leetcode	5.940s</div></pre></td></tr></table></figure>
<p>结果一下子就逆转了。DP 比回溯法快了 约 4 个数量级。而且很明显，如果继续加大测试强度，这个差距会继续放大。</p>
<p>两种 DP 的对比， Top-down 的速度又要比 Bottom-up 快了约 30% 。跳过引用不到的子问题，起了作用。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>接下来看一下复杂度。以下假设字符串 s 的大小为 S，p 的大小为 P。</p>
<h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p>DP 的复杂度很好算。$ DP_{is, ip} $ 一共有 SP 个组合，也就是有这么多个子问题。对于每个子问题，需要判断当前下标指向的字符是否匹配，然后引用相邻子问题，每个子问题需要常数时间。换言之整体的时间复杂度就是 $ O(SP) $ 。</p>
<p>相应地，额外内存主要是缓存子问题解的二维数组，空间复杂度也是 $ O(SP) $ 。</p>
<p>Top-down 记忆化根据不同数据，可能会跳过部分子问题，但没有改变复杂度阶。</p>
<h4 id="回溯法-1"><a href="#回溯法-1" class="headerlink" title="回溯法"></a>回溯法</h4><p>回溯法的复杂度计算复杂一些。如果没有 <code>*</code> ，那么时间复杂度只是 $ O(S) $。加入 <code>*</code> 是复杂度的主要来源。参考基准测试的两个例子，构建类似 <code>aaaaaaaaac</code> 和 <code>.*.*.*b</code> 这样的最坏情况，p 串里都是 <code>.*</code> ，最后一个字符总是匹配失败无法提前退出。</p>
<p>考虑 递归函数 <code>isMatchBT</code> 的调用次数。对 <code>isMatchBT(s, p, is, ip)</code>，ip 点左边一共有 $ ip / 2 $ 个 <code>.*</code> ，匹配的过程相当于把 $ is $ 个元素分成 $ ip/2 $ 组，也就是在 $ is + 1 $ 个点里选取 $ ip / 2-1 $ 个点分割，数量为 $ \mathrm{C}_{is + 1}^{ip / 2-1} $ 。</p>
<p>对于一次函数调用，调用之前在 s 串匹配一个字符，然后调用函数，不考虑进入函数之后的开销，需要常数时间。进入函数后分两种情况：一是普通字符串的匹配，二是递归调用函数。考虑最坏的情况，都是 <code>*</code> 产生的递归调用，函数内部的开销在统计其他函数调用时计算。换言之，总的递归函数调用次数就是总的复杂度。</p>
<p>$$ \sum_{is=0}^S \sum_{ip=0}^{P/2} \mathrm{C}_{is + 1}^{ip / 2-1} $$</p>
<p>太久不看数学，已经不记得怎么算这种式子了。时间关系，只好以后再计算和验证了。</p>
<p>空间开销主要在函数调用栈上，每次函数调用使用常数内存，如果不考虑内存释放，那么空间复杂度和时间复杂度一致。但实际上，函数返回栈上的空间就释放了，空间复杂度跟最大调用深度相关，也就是 $ O(P) $ 。</p>
<p><br></p>
<p>把最快的 Top-down DP 提交，时间： 0 ms，打败 100% 的提交；内存：2.4 MB，打败45.05% 。这道题的测试数据很弱，其实回溯也是可以过的，就是比较慢。</p>
<hr>
<p>更新：</p>
<p>我实际做题时用的是 Top-down，其余代码都是为了写文章额外写的，所以没有太注意优化。</p>
<p>公众号发出之后，有朋友提醒，Bottom-up 只引用到最近的两排状态，空间复杂度可以优化到 $ O(P) $ 。</p>
<p>确实如此，优化之后，综合时间和空间复杂度，Bottom-up 才是最佳解法。Top-down 快 30% 毕竟是在极端 case 测得，一般快不了这么多。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	lastDp := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>)</div><div class="line">	curDp := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>)</div><div class="line">	<span class="keyword">for</span> is := <span class="built_in">len</span>(s); is &gt;= <span class="number">0</span>; is-- &#123;</div><div class="line">		<span class="keyword">for</span> ip := <span class="built_in">len</span>(p) - <span class="number">1</span>; ip &gt;= <span class="number">0</span>; ip-- &#123;</div><div class="line">			preMatch := is &lt; <span class="built_in">len</span>(s) &amp;&amp; (p[ip] == <span class="string">'.'</span> || s[is] == p[ip])</div><div class="line">			<span class="keyword">if</span> ip+<span class="number">1</span> &lt; <span class="built_in">len</span>(p) &amp;&amp; p[ip+<span class="number">1</span>] == <span class="string">'*'</span> &#123;</div><div class="line">				curDp[ip] = curDp[ip+<span class="number">2</span>] ||</div><div class="line">					(preMatch &amp;&amp; lastDp[ip]) || </div><div class="line">					(is == <span class="built_in">len</span>(s) &amp;&amp; ip+<span class="number">2</span> == <span class="built_in">len</span>(p))</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				curDp[ip] = preMatch &amp;&amp;</div><div class="line">					(lastDp[ip+<span class="number">1</span>] ||</div><div class="line">					 (is+<span class="number">1</span> == <span class="built_in">len</span>(s) &amp;&amp; ip+<span class="number">1</span> == <span class="built_in">len</span>(p)))</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		lastDp, curDp = curDp, lastDp</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> lastDp[<span class="number">0</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用同样的数据再跑一次 Benchmark，不仅内存用少了，还比 Top-down 还要快。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Benchmark_isMatch1-8    	       2	 681538950 ns/op	       0 B/op	       0 allocs/op</div><div class="line">Benchmark_isMatch2-8       	   43952	     27259 ns/op	   16160 B/op	     404 allocs/op</div><div class="line">Benchmark_isMatch3-8    	   32874	     36262 ns/op	   16160 B/op	     404 allocs/op</div><div class="line">Benchmark_isMatch4-8   	       48579	     24745 ns/op	      64 B/op	       4 allocs/op</div><div class="line">PASS</div></pre></td></tr></table></figure>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一点点找回手感，容我继续水小题号的 Hard。&lt;/p&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://jaycechant.info/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://jaycechant.info/tags/LeetCode/"/>
    
      <category term="Algorithm" scheme="https://jaycechant.info/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>在 VS Code 快速生成单元测试</title>
    <link href="https://jaycechant.info/2020/rapidly-generate-unit-tests-in-vs-code/"/>
    <id>https://jaycechant.info/2020/rapidly-generate-unit-tests-in-vs-code/</id>
    <published>2020-06-03T03:05:16.000Z</published>
    <updated>2020-06-03T14:56:05.497Z</updated>
    
    <content type="html"><![CDATA[<p>每次写 LeetCode 解题，都会强调 准备纸笔 和 单元测试。但这是正确的废话，特别是单元测试。老手看来这是常识，新手听说了却也还是不知道具体怎么操作。</p>
<a id="more"></a>
<p>那今天就来说一说。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>下面用 VS Code 写 Go 举例。</p>
<p>VS Code 是开源 IDE 里一个不错的选择。依托强大的插件生态，啥开发都能做。我现在基本把各种开发都挪里面，甚至包括 幻灯制作 和 一些简单的制图。</p>
<p>但 VS Code 不是唯一的选项，你也不一定写 Go。很多朋友觉得 IDEA 更好用（具体到 Go 是 GoLand），也有人习惯 Eclipse，我也体会过 Vim 纯用键盘工作的效率。这无所谓，只是提供一个思路，在你习惯的 IDE 和 语言也总是可以找到工具提高效率的。就是商业软件记得买授权，要不就用免费开源的社区工具。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>VS Code 的安装，跟着官网走，不展开。Go 环境的安装配置，也不是重点。</p>
<p>打开 VS Code，在扩展商店（Extensions）搜索 <code>Go</code> ，一般排在第一位的结果就是要安装的插件。（插件描述为 Rich Go language support for Visual Studio Code。开发者就是 Microsoft。）</p>
<p><img src="../../images/vs-code-go-extension.png" alt=""></p>
<p>安装完插件，它会提示安装各种 Go 开发需要用到的工具，按提示同意安装即可。注意的是，这些工具需要用到 go get / install 命令，所以走到这一步之前，先确认 Go 的环境已经配置好了。</p>
<p>下面我们主要用到 <code>gotests</code> 。如果已经安装，这一部分就可以跳过了。</p>
<p>如果不确定，按 <code>F1</code> 或者 <code>Ctrl + Shift + P</code>唤出指令面板（Command Palette），输入 <code>Go: Generate Unit Tests</code> ，如果出现三个提示 <code>For File</code> ，<code>For Function</code>，<code>For Package</code> ，就说明安装好了。实际上，指令面板的内容不需要完整输入，只输入开头一部分，或者首字母（像 <code>GGUT</code>），都能够智能匹配。善用指令面板，可以一定程度上摆脱鼠标。</p>
<p><img src="../../images/vs-code-command-palette.png" alt=""></p>
<p>如果没有，唤出指令面板，执行 <code>Go: Install/Update Tools</code>，找到 <code>gotests</code> 安装即可。</p>
<h2 id="干活"><a href="#干活" class="headerlink" title="干活"></a>干活</h2><p>这里用 LeetCode 的题目 <a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="external">https://leetcode.com/problems/regular-expression-matching/</a> 举例。</p>
<p>实际开发稍复杂一些，原理是一样的。主要差别是，题目帮你定好了函数签名；而实际工作中，如何模块化、如何命名、传递哪些参数，恰恰是比较难的一部分。不过，如果题目比较复杂，最好也不要一个函数到底，也要考虑抽取模块梳理逻辑，还有复用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>题目要求实现一个函数，返回字符串 s 和 正则式 p 是否匹配（bool 值）。函数签名为 <code>func isMatch(s string, p string) bool</code> 。</p>
<p>VS Code 打开工作目录。我启用了 <code>go modules</code> ，需要初始化 <code>go.mod</code> ，module name 随便给一个： <code>go mod init leetcode</code> 。然后新建一个 <code>ans.go</code> 文件用来写代码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ans.go</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 先随便返回，确保能编译运行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将焦点（也就是输入光标）停留在 <code>isMatch</code> 函数上，<code>F1</code> 唤出 指令面板，执行 <code>Go: Generate Unit Tests For Function</code> ，测试代码就自动生成了。熟练之后，<code>F1</code> 接着 <code>GGUTFF</code> （不必输完），方向键选一下，回车，很快的。也可以试试 <code>For File</code> 和 <code>For Package</code> ，就是生成 文件 / 包 内所有函数的测试。只有一个函数时，其实没有差别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ans_test.go</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_isMatch</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</div><div class="line">		s <span class="keyword">string</span></div><div class="line">		p <span class="keyword">string</span></div><div class="line">	&#125;</div><div class="line">	tests := []<span class="keyword">struct</span> &#123;</div><div class="line">		name <span class="keyword">string</span></div><div class="line">		args args</div><div class="line">		want <span class="keyword">bool</span></div><div class="line">	&#125;&#123;</div><div class="line">		<span class="comment">// <span class="doctag">TODO:</span> Add test cases.</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> got := isMatch(tt.args.s, tt.args.p); got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"isMatch() = %v, want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里为止，用时不到一分钟，熟练的话，<strong>十几秒</strong> 就做完了。</p>
<h3 id="添加测试用例"><a href="#添加测试用例" class="headerlink" title="添加测试用例"></a>添加测试用例</h3><p>接着添加测试用例。这里直接用题目提供的 5 个例子。</p>
<p>实际做题和开发中，一定还要多考虑不同的边界条件，以及随机生成大数据量进行测试。当然，在比赛中，如果时间非常紧，又实在想不出其他 cases，判断一次错误提交对于得分影响不大，也可以用基本用例测试完之后，直接提交看看。一般情况下，还是要重视 Test Cases 的设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ans_test.go</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	s    <span class="keyword">string</span></div><div class="line">	p    <span class="keyword">string</span></div><div class="line">	want <span class="keyword">bool</span></div><div class="line">&#125;&#123;</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"1"</span>, <span class="comment">// 按个人习惯随便给，只要后面出错时，能够区分、定位就行</span></div><div class="line">		s:    <span class="string">"aa"</span>,</div><div class="line">		p:    <span class="string">"a"</span>,</div><div class="line">		want: <span class="literal">false</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"2"</span>,</div><div class="line">		s:    <span class="string">"aa"</span>,</div><div class="line">		p:    <span class="string">"a*"</span>,</div><div class="line">		want: <span class="literal">true</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"3"</span>,</div><div class="line">		s:    <span class="string">"ab"</span>,</div><div class="line">		p:    <span class="string">".*"</span>,</div><div class="line">		want: <span class="literal">true</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"4"</span>,</div><div class="line">		s:    <span class="string">"aab"</span>,</div><div class="line">		p:    <span class="string">"c*a*b"</span>,</div><div class="line">		want: <span class="literal">true</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"5"</span>,</div><div class="line">		s:    <span class="string">"mississippi"</span>,</div><div class="line">		p:    <span class="string">"mis*is*p*."</span>,</div><div class="line">		want: <span class="literal">false</span>,</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">// 篇幅关系，只提供题目的例子</span></div><div class="line">	<span class="comment">// 实际开发一定要多考虑不同的测试用例</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_isMatch</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> got := isMatch(tt.s, tt.p); got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"isMatch() = %v, want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了填测试数据，我还根据自己的习惯做了一些调整，仅供参考：</p>
<ul>
<li>我习惯把测试数据放在测试函数外定义，这样：<ul>
<li>测试数据和测试逻辑分离，视觉上比较清晰，分别修改也比较容易定位。</li>
<li>如果有多个测试共用测试数据，方便复用。</li>
</ul>
</li>
<li>测试数据嵌套层次太多，数据定义会又麻烦又乱，所以我把 <code>args</code> 直接展开了。</li>
</ul>
<p>完成之后，直接执行一次测试。（可以鼠标点击 <code>Test_isMatch</code> 上面的 <code>run test</code>。如果不想动鼠标，也可以将焦点停留在测试函数，指令面板执行 <code>Go: Test Function At Cursor</code>。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Running tool: go.exe <span class="built_in">test</span> -timeout 30s leetcode -run ^(Test_isMatch)$</div><div class="line"></div><div class="line">--- FAIL: Test_isMatch (0.00s)</div><div class="line">    --- FAIL: Test_isMatch/1 (0.00s)</div><div class="line">        ans_test.go:51: isMatch() = <span class="literal">true</span>, want <span class="literal">false</span></div><div class="line">    --- FAIL: Test_isMatch/5 (0.00s)</div><div class="line">        ans_test.go:51: isMatch() = <span class="literal">true</span>, want <span class="literal">false</span></div><div class="line">FAIL</div><div class="line">FAIL	leetcode	0.309s</div><div class="line">FAIL</div></pre></td></tr></table></figure>
<p>FAIL 是肯定的，因为待测函数根本没有实现。如果 PASS 反而有问题，说明测试用例太弱。明知道是 FAIL ，也要执行一次，首先是确保没有编译错误，能正常运行；其次就是确认一下，测试用例没有弱到直接可以 PASS。</p>
<p>到这里为止， <strong>用时不到两分钟</strong> 。当然这没有包括生成更多测试用例的时间。这个时间根据要解决的问题、开发者、测试要求的不同，差别很大。</p>
<p>之后就是实现函数，然后回来测试，直到所有 cases 都 PASS 为止。</p>
<h2 id="一点展开"><a href="#一点展开" class="headerlink" title="一点展开"></a>一点展开</h2><p>看到这里，你可能会问，你要说的就这？是的，本文说的不是什么很复杂的内容。</p>
<p>然而就是这么简单的东西，很多人要么不知道，要么知道却觉得没必要、懒得写。 <strong>你在刷题和实际项目中有坚持写单元测试吗</strong> ？你能说出你的常用语言至少一个测试工具和框架吗？我猜读者朋友里，除了部分关注 Go，写  Java 的比较多。这些朋友有好好写 JUnit 或者别的测试框架代码吗？</p>
<p>如果你的答案都是肯定的，必须说你有很好的开发习惯。</p>
<p>根据我以前做算法内训讲师时的观察，大多数学员在做题时的习惯是这样的：</p>
<p><img src="../../images/manual_test.svg" alt=""></p>
<p>想到哪写到哪，凭感觉写出差不多的代码，然后 <strong>手敲输入数据</strong> 进行验证。这样测试既低效，又没有足够的测试强度。换言之，手动测试时间和精力花掉了，没有达到效果。而且因为实现、测试、修改 都依赖注意力集中，这样会很累很慢，测试和调试不知不觉就变成了 <strong>时间黑洞</strong> 。总感觉差一点就可以了，但是不断还是有错，不断消磨你的耐心。</p>
<p>为什么图里说通过是『侥幸正确』？因为手敲几个输入的测试，输入数据复杂一点的题，甚至连题目提供的例子都很难敲完，这种测试强度下居然一两次通过，要么题太水，要么人思维极其清晰，要么运气好。</p>
<h3 id="UTDD"><a href="#UTDD" class="headerlink" title="UTDD"></a>UTDD</h3><p>你不能指望遇到水题，不能指望自己不犯错和运气好。唯一可靠的，是<strong>可重复的、自动完成的</strong> 测试，帮你 <strong>低成本覆盖</strong> 所有能想到的边界条件。这其实就是 TDD （测试驱动开发）中的 UTDD（Unit Test Driven Development 单元测试驱动开发）。（篇幅关系，这里不讨论 TDD 的实施细节和优劣。）</p>
<p><img src="../../images/UTDD.svg" alt=""></p>
<p>看着好像步骤多了很多，变复杂了。但如果你看了本文前面的部分，你就会明白，大多数步骤是不怎么消耗注意力的机械操作，甚至可以借助工具自动完成：</p>
<ul>
<li>伪实现：写空白函数，返回默认值，能编译就行。</li>
<li>编写测试代码：根据实现自动生成测试代码，花时间列测试用例。</li>
<li>自动测试：辛苦鼠标点一下。</li>
</ul>
<p>费点脑细胞的，就是改进代码实现（第一次因为从空白实现开始，其实是从头实现）。另外，列出测试用例，特别是提交之后有错，考虑遗漏了什么边界用例，需要比较细心。</p>
<p>刷题如此，实际开发比这复杂（需要自己模块化，测试用例变更更频繁），但道理相通。</p>
<p>关键在于：</p>
<ul>
<li>每个步骤责任分割得足够细，只需要关注一个焦点。这样有助于聚焦思维，也方便借助工具，乃至自动化。</li>
<li>实现目标以测试用例的形式存在，每次测试都可以复用。强化用例并不会增加自动测试的负担，反而有助于引导实现。</li>
<li>测试代码告诉调用方、同事或者以后的自己，如何调用代码，哪些用法是对的哪些会引起错误。这甚至比不能运行的文档效果更好。</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>必须承认，我很长一段时间里面也是不写测试的（包括但不限于 单元测试）。一方面是学校里教测试局限于理论；另一方面工作后多数企业对此没有规范要求，反而 deadline 逼得很紧；最后，不还有测试部门在后面守着吗。说来惭愧，近些年才开始意识到测试的重要性，逐渐要求自己，并摸索到一点点技巧。</p>
<p>多数人不写 单元测试 的理由，无外乎 没有必要 和 没有时间。</p>
<p>如果代码非常简单，一眼看清做了什么，当然没有必要。但究竟有多少代码能简单到这种程度？何况最初简单的代码，在不断变更需求和改进实现之后，还能保持简单吗？写过测试用例，认真考虑过边界条件，就会发现根本不简单。</p>
<p>至于时间，被 毫无头绪的调试 和 痛苦的重构 折磨过就明白，与之相比，熟练之后写单元测试的时间简直不值一提。以此为理由就好像说磨刀耽误砍柴一般。多数人（包括我）的问题是出在 <strong>根本没有了解过怎样能写好测试</strong>，更不要提有为此练习过。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次写 LeetCode 解题，都会强调 准备纸笔 和 单元测试。但这是正确的废话，特别是单元测试。老手看来这是常识，新手听说了却也还是不知道具体怎么操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TDD" scheme="https://jaycechant.info/tags/TDD/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 4: Median of Two Sorted Arrays</title>
    <link href="https://jaycechant.info/2020/leetcode-4-median-of-two-sorted-arrays/"/>
    <id>https://jaycechant.info/2020/leetcode-4-median-of-two-sorted-arrays/</id>
    <published>2020-05-26T07:27:12.000Z</published>
    <updated>2020-06-09T07:00:02.919Z</updated>
    
    <content type="html"><![CDATA[<p>继续刷题。</p>
<a id="more"></a>
<p>依然不愿意在挑题目上花太多时间，就挑了序号最小的 Hard。</p>
<p>传送门（考虑到有人就是不想看英文，也给出中文社区。推荐刷英文版。）</p>
<p>英文：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="external">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p>
<p>中文：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="external">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="一句话题意"><a href="#一句话题意" class="headerlink" title="一句话题意"></a>一句话题意</h3><p>给定两个有序数组 nums1 和 nums2，找出（他们合并后）的中位数。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例子1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nums1 = [1, 3]</div><div class="line">nums2 = [2]</div><div class="line"></div><div class="line">中位数 2.0</div></pre></td></tr></table></figure>
<p>例子2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nums1 = [1, 2]</div><div class="line">nums2 = [3, 4]</div><div class="line"></div><div class="line">中位数是 (2 + 3)/2 = 2.5</div></pre></td></tr></table></figure>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ol>
<li><p>约定输入中，两个数组不会同时为空。</p>
</li>
<li><p>假定两个数组大小分别为 <code>m</code> 和 <code>n</code> ，时间复杂度不超过 <code>O(log (m+n))</code>。（原文是 should be，我认为 『should not exceed』更准确。）</p>
</li>
</ol>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>之前说过，准备纸笔 和 先写单元测试 是推荐的做法。测试代码看着量多，但是不费脑，还能在后续调试帮忙减轻头脑负担。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</div><div class="line">	name  <span class="keyword">string</span></div><div class="line">	nums1 []<span class="keyword">int</span></div><div class="line">	nums2 []<span class="keyword">int</span></div><div class="line">	want  <span class="keyword">float64</span></div><div class="line">&#125;&#123;</div><div class="line">	<span class="comment">// 题目有：You may assume nums1 and nums2 cannot be both empty.</span></div><div class="line">	<span class="comment">// 但是生产环境还是得把这个测试用例加上</span></div><div class="line">	<span class="comment">// &#123;</span></div><div class="line">	<span class="comment">// 	name:  "0v0",</span></div><div class="line">	<span class="comment">// 	nums1: []int&#123;&#125;,</span></div><div class="line">	<span class="comment">// 	nums2: []int&#123;&#125;,</span></div><div class="line">	<span class="comment">// 	want:  0.0,</span></div><div class="line">	<span class="comment">// &#125;,</span></div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"0v1"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;<span class="number">5</span>&#125;,</div><div class="line">		want:  <span class="number">5.0</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"2v0"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">8</span>&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;&#125;,</div><div class="line">		want:  <span class="number">4.5</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"1"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;,</div><div class="line">		want:  <span class="number">2.0</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"2"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</div><div class="line">		want:  <span class="number">2.5</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"3"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</div><div class="line">		want:  <span class="number">5.0</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"4"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;,</div><div class="line">		want:  <span class="number">5.5</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"5"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;,</div><div class="line">		want:  <span class="number">5.5</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name:  <span class="string">"6"</span>,</div><div class="line">		nums1: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</div><div class="line">		nums2: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</div><div class="line">		want:  <span class="number">9.0</span>,</div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFindMedianSortedArrays</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> got := findMedianSortedArrays(tt.nums1, tt.nums2); got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"findMedianSortedArrays() = %v, want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>篇幅所限随便放几个测试用例。实际操作中，除了能想到的边界条件，还应该随机生成一定量的测试用例，以免有没考虑到的 case。</p>
<h3 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h3><p>这里抠一下 <strong>中位数</strong> 的定义。这个问题必须写测试用例时就理解清楚，不然写出来的用例都是错的。</p>
<p>中位数是指，一个有序数组里，排在 <strong>中间的数</strong> 。这个说法比较好理解，但是不严谨：偶数个元素的数组怎么办？中间连续出现重复元素怎么办？</p>
<p>更准确的定义应该是：选定一个数（不一定包含在数组里），让数组里 大于 和 小于 这个数的元素数量，都 <strong>不超过总元素数量的一半</strong> ，这个数就是中位数。</p>
<p>举几个例子：</p>
<ul>
<li><p><code>1, 2, 3, 4, 5</code> ，中位数是 3。</p>
<p>  我们可以说因为 3 在中间；也可以说，小于 3 的数有两个，大于 3 的数也有两个，都不超过 5 的一半。<code>1, 2, 3, 4</code> 得出 2.5 ，同理可解释。</p>
</li>
<li><p><code>1, 2, 3, 3, 3</code>，中位数是 3。</p>
<p>  我们同样可以说，3 在（顺序的）中间。但容易产生一些理解上的问题，拐不过弯。像（大小的）中间不是 2 吗？ 中位数怎么区分是哪一个 3，3 同时也在 第四 和 第五 的位置，怎么会是中位数呢？</p>
<p>  我们这样看，小于 3 的数有两个，大于 3 的数有 零 个，都不超过半数。除此以外无论我们选取任何一个数（2？ 2.5 ？3.5？），都会使一边的数 大于等于 三个。</p>
</li>
</ul>
<p>需要特别说明的是，按照这个定义，2 到 3 之间的任意一个数（不包括两个端点）都是 <code>1, 2, 3, 4</code> 的中位数。但这样不利于操作。所以实际操作上是这样规定的：</p>
<ul>
<li>奇数个元素时，中位数就是有序序列下标在中间那个数。</li>
<li>偶数个元素时，中位数是中间两个数的平均值。</li>
</ul>
<h2 id="直接动手"><a href="#直接动手" class="headerlink" title="直接动手"></a>直接动手</h2><p>既然清楚了中位数的定义和一般的获取操作，那么顺利成章的做法就是：</p>
<ul>
<li>得到一个总的有序数组</li>
<li>根据数量的奇偶，取中间的数，或者中间两个数的均值。</li>
</ul>
<p>刷题老手会发现，这种做法时间复杂度是不达标的，然后直接跳到下一节。（其实真正老手直接就不会看这篇 [苦笑]）</p>
<p>但我还是把这种做法写出来。一下子看出最优解并不容易。除了新手会卡思路，有经验的人也会有不熟悉题目类型，或者纯粹脑子短路，然后卡壳。想不出更好方案的时候，按题面意思尝试模拟或者暴力解决，哪怕明知道复杂度不达标，也比干耗着强。</p>
<p>往往写着写着，就有思路了。当然，比较少有地，也有想复杂了，暴力 （可能还要一点小优化），就直接把问题解决的。</p>
<p>归并法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</div><div class="line">	m := <span class="built_in">len</span>(nums1)</div><div class="line">	n := <span class="built_in">len</span>(nums2)</div><div class="line">	size := m + n</div><div class="line"></div><div class="line">	nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</div><div class="line">	i1, i2 := <span class="number">0</span>, <span class="number">0</span></div><div class="line">	<span class="comment">// 归并排序</span></div><div class="line">	<span class="keyword">for</span> i1 &lt; m &amp;&amp; i2 &lt; n &#123;</div><div class="line">		<span class="keyword">if</span> nums1[i1] &lt; nums2[i2] &#123;</div><div class="line">			nums = <span class="built_in">append</span>(nums, nums1[i1])</div><div class="line">			i1++</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			nums = <span class="built_in">append</span>(nums, nums2[i2])</div><div class="line">			i2++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 如果其中一个数组有剩余元素，全部追加到最后</span></div><div class="line">	<span class="keyword">if</span> i1 &lt; m &#123;</div><div class="line">		nums = <span class="built_in">append</span>(nums, nums1[i1:]...)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		nums = <span class="built_in">append</span>(nums, nums2[i2:]...)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> size%<span class="number">2</span> == <span class="number">1</span> &#123;</div><div class="line">		<span class="comment">// 奇数个元素</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(nums[size/<span class="number">2</span>])</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 偶数个元素</span></div><div class="line">	half := size / <span class="number">2</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(nums[half<span class="number">-1</span>]+nums[half]) / <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个数组本来就是有序的，直接归并一次是最简单的做法了。</p>
<p>不过很容易发现，我们并不需要知道归并之后的整个有序数组，只需要知道归并后，排在中间的 一个数（奇）或两个数（偶）。只要在归并时，记录那两个数就行，没有必要真的创建一个数组放归并结果。我们甚至不用归并完，归并到中间就行了。</p>
<p>归并法改进：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</div><div class="line">	m := <span class="built_in">len</span>(nums1)</div><div class="line">	n := <span class="built_in">len</span>(nums2)</div><div class="line">	size := m + n</div><div class="line">	<span class="comment">// 相当于 floor(size/2) ，用作下标相当于第 k+1 个元素</span></div><div class="line">	<span class="comment">// 奇数个元素时是正好是中位数，偶数时是较大的那个</span></div><div class="line">	half := size / <span class="number">2</span></div><div class="line">	i1, i2 := <span class="number">0</span>, <span class="number">0</span></div><div class="line">	<span class="comment">// median left, median right，记录中间两个数</span></div><div class="line">	mleft, mright := <span class="number">0</span>, <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i1+i2 &lt;= half &#123;</div><div class="line">		<span class="comment">// 有最外层的条件限制， i1, i2 不可能同时到达尾部</span></div><div class="line">		<span class="comment">// 所以一旦其中一个数组到最后，另一个数组无需比较继续往后遍历</span></div><div class="line">		<span class="keyword">if</span> i1 &lt; m &amp;&amp; (i2 == n || nums1[i1] &lt; nums2[i2]) &#123;</div><div class="line">			mleft = mright</div><div class="line">			mright = nums1[i1]</div><div class="line">			i1++</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			mleft = mright</div><div class="line">			mright = nums2[i2]</div><div class="line">			i2++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> size%<span class="number">2</span> == <span class="number">1</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(mright)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(mleft+mright) / <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>归并需要把两个数组遍历一遍，所以时间复杂度是 <code>O(m + n)</code> ；开辟了新数组存放结果，所以额外内存空间也是 <code>O(m + n)</code> 。</p>
<p>改进后，额外内存空间变成了常数 <code>O(1)</code> ，时间减半，但是数量级还是 <code>O(m + n)</code> 。显然超出了题目 <code>O(log(m + n))</code> 的要求。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>解题熟练之后，先做复杂度分析，就能大概知道不同解法的性能，继而决定应该尝试哪种解法。</p>
<p>就这道题而言：</p>
<ul>
<li><p>取巧的做法，是留意题目给出的线索。</p>
<p>  时间复杂度中出现 <strong>对数</strong>  <code>log()</code>，往往意味着最优解是二分查找。</p>
</li>
<li><p>但不是所有题目都会给出时间复杂度提示。</p>
<p>  有些题目没有提示，直接在 运行时间 和 使用内存 上限制。我以前出题就干过这种事，给一个数据量特别大的测试用例，把 时间 和 内存 设成暴力法过不了。</p>
<p>  这时记住， <strong>获取信息是有代价的</strong> 。获取更多信息 =&gt; 消除了更多信息熵 =&gt; 做更多运算 =&gt; 更高的时间复杂度。题目只要求 <strong>中位数</strong> 一个信息，你却把整个数组排了序，也就是把其他位置的数都知道了；无论最后这些结果你要不要，计算的成本都是要付的。</p>
<p>  只把中位数查找出来，那么 <strong>在有序数组里，二分查找比顺序查找高效</strong> 。</p>
</li>
</ul>
<p><strong>查找目标是什么呢？</strong> 这时要回想 中位数 的定义：</p>
<p>找一个数，让（两个）数组里 大于 和 小于 这个数 的 元素数量，都不超过总数量的一半。</p>
<p>考虑到偶数个元素的情况，就是找相邻的两个数。又考虑到这两个数分布在两个数组里，可能一边一个，也可能都在一边，可以两边都找两个，也就是一共四个，再比较。</p>
<p>为了方便讨论，先不考虑重复元素，不会有元素跟中位数相等。那么两边都不超过总数一半，就变成了两边都刚好是总数一半。</p>
<p><img src="../../images/median-of-two-sorted-arrays-1.svg" alt=""></p>
<p>例如 <code>1, 3, 4, 5, 8</code> 和 <code>2, 6, 7</code> 两个数组。中位数是 4 和 5 之间，4.5 。</p>
<p><img src="../../images/median-of-two-sorted-arrays-2.svg" alt=""></p>
<p>再给一个例子，还是 4.5 。</p>
<p>但这是数字少，直接看出来。实际操作时，我们不确定中位数会在哪个数组里面。</p>
<p>对于第一个例子，我们从第一个数组找到 4 和 5，第二个数组找到 2 和 6，再从这四个候选里找中位数。</p>
<p>类似地，第二个例子，找到 3 和 5，还有 4 和 6，四个数里再找中位数。</p>
<p><strong>这四个数怎么得到？</strong> 试。</p>
<p>我们可以在两个数组里，分别找一个位置，切一刀，变成两段，切的地方左右的两个数，就成为了候选。</p>
<p>切的可选位置，要包括数组的最前面和最后面，也就是把整个数组都放一边。因为会有例子三这样的情况：</p>
<p><img src="../../images/median-of-two-sorted-arrays-3.svg" alt=""></p>
<p>当数组二选择在 0 这个位置划分时，候选数字就只有 6。为了清楚地表示 6 是右边的数字，我们可以记作 <code>NA, 6</code> ，表示左边没有。</p>
<p>两个数组分别有 <code>m + 1</code> 和 <code>n + 1</code> 种分法，那是有 <code>(m + 1)(n + 1)</code> 种组合吗？</p>
<p>先看确定分对地方的条件：</p>
<ol>
<li>两个数组分到左边的元素加起来，跟分到右边的元素加起来，数量一致，都是一半。</li>
<li>对于四个候选中位数，左边两个数 ≤ 右边两个数。</li>
</ol>
<p>条件 1 非常好理解，两边数量都不一致，肯定不是中位数。有这个条件，一旦一个数组的划分的位置定了，另一边也只有一个选择让两边数量一致。让我们重新回到例子一：</p>
<p><img src="../../images/median-of-two-sorted-arrays-1.svg" alt=""></p>
<p>当数组二选择位置 0 时，数组一唯一的选择是 4；1 对应 3，2 对应 2 …… 假定其中一个数组选择在位置 i 划分，那么另一边只能选择 <code>(m + n)/2 - i</code> 。然后我们发现，数组一不能选 0，因为数组二没有位置 4；也不能选 5，因为没有位置 -1。由此可得，位置只能在较小的数组选，只有 <code>n + 1</code> 种可能。</p>
<p>条件 2 看图更好理解，还是例子一：</p>
<p><img src="../../images/median-of-two-sorted-arrays-4.svg" alt=""></p>
<p>如果像图中所示，分别在两个数组的位置 2 划分，条件 1 满足，左右加起来都是四个数。但两个划分点并非同一个点。体现在数字上就是不满足条件 2。</p>
<p>为了方便讨论，我们把划分点两边的候选数字，分别称作 <code>mleft1, mright1</code> 和 <code>mleft2, mright2</code> 。当选中全局的中间点时，划分线应该对上，两个 left 都 小于等于 两个 right。由于同一个数组内是有序的，我们只需要确保 <code>mleft1 ≤ mright2</code> 和 <code>mleft2 ≤ mright1</code> 。那么这个划分里，mleft2 (6) &gt; mleft1 (4) ，就不满足条件 2。</p>
<p>把这些全部加起来，要做什么就清楚了：</p>
<ol>
<li>在元素较少的数组，选一个位置分成两部分。<strong>这一步可以用二分查找</strong> 。根据条件 1 ，这个位置定了，另一边的位置也定下来了。</li>
<li>看是否满足条件 2。不满足回到第一步。</li>
<li>两个条件都满足，在候选数字里选中位数。</li>
</ol>
<p>时间复杂度很容易可以知道，是 <code>O(log n)</code> 。</p>
<p>为了理清主要步骤，暂时忽略了一些边界条件，像 元素 是奇数怎么处理，中位数附近多个重复元素怎么处理等等。直接在代码上解决。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>二分查找：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">	intMax = <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</div><div class="line">	intMin = ^intMax</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</div><div class="line">	m := <span class="built_in">len</span>(nums1)</div><div class="line">	n := <span class="built_in">len</span>(nums2)</div><div class="line">	size := m + n</div><div class="line">	half := size / <span class="number">2</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> m &gt; n &#123;</div><div class="line">		<span class="comment">// 保持 nums1 大小 &lt;= nums2 大小</span></div><div class="line">		<span class="comment">// 避免 pos 越界判断</span></div><div class="line">		nums1, m, nums2, n = nums2, n, nums1, m</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// left bound, right bound</span></div><div class="line">	lb, rb := <span class="number">0</span>, m</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="comment">// pr = pointer right分界线右边的下标，范围[0, m]</span></div><div class="line">		<span class="comment">// 取 0 时左子集为空，取 m 时右子集为空</span></div><div class="line">		pr1 := (lb + rb) / <span class="number">2</span></div><div class="line">		<span class="comment">// left of the median in nums1</span></div><div class="line">		mleft1 := intMin</div><div class="line">		<span class="keyword">if</span> pr1 &gt; <span class="number">0</span> &#123;</div><div class="line">			mleft1 = nums1[pr1<span class="number">-1</span>]</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// right of the median in nums1</span></div><div class="line">		mright1 := intMax</div><div class="line">		<span class="keyword">if</span> pr1 &lt; m &#123;</div><div class="line">			mright1 = nums1[pr1]</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		pr2 := half - pr1</div><div class="line">		<span class="comment">// left of the median in nums2</span></div><div class="line">		mleft2 := intMin</div><div class="line">		<span class="keyword">if</span> pr2 &gt; <span class="number">0</span> &#123;</div><div class="line">			mleft2 = nums2[pr2<span class="number">-1</span>]</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// right of the median in nums2</span></div><div class="line">		mright2 := intMax</div><div class="line">		<span class="keyword">if</span> pr2 &lt; n &#123;</div><div class="line">			mright2 = nums2[pr2]</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> mright2 &lt; mleft1 &#123;</div><div class="line">			rb = pr1</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> mright1 &lt; mleft2 &#123;</div><div class="line">			lb = pr1 + <span class="number">1</span></div><div class="line">			<span class="keyword">continue</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> mleft2 &gt; mleft1 &#123;</div><div class="line">			mleft1 = mleft2</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> mright2 &lt; mright1 &#123;</div><div class="line">			mright1 = mright2</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> size%<span class="number">2</span> == <span class="number">1</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">float64</span>(mright1)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(mleft1+mright1) / <span class="number">2</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我感觉磨下标、边界条件，才是这道题最麻烦的地方。</p>
<p>几个要点：</p>
<ul>
<li>要在元素少的数组上做二分，为了保持代码简单，如果发现数组二更小，直接交换两个数组位置。</li>
<li>二分查找要小心处理下标，包括加减乘除，区间开闭。保证一定不能漏，尽量不重（有些情况是允许有重复的）。</li>
<li>划分点取最左最右时，会少了一个候选数。把左边的数初始化为负无穷（代码实现上是最小 int 值），右边初始化为正无穷（最大 int 值），可以简化判断。</li>
<li>由于下标从 0 开始，<code>size / 2</code> 作为下标，在偶数时取的是中间点右边的数，奇数时刚好是中间。代码里，以 二分值 <code>pr</code> 为右值， <code>pr - 1</code> 为左值，所以遇到奇数时，直接取右值即可。</li>
</ul>
<p>这份代码在英文版最终成绩是 时间 16ms （打败 61.59%），内存 5.8 MB（打败 25%），应该还有优化空间。不过时间关系，先到这里。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续刷题。&lt;/p&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://jaycechant.info/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://jaycechant.info/tags/LeetCode/"/>
    
      <category term="Algorithm" scheme="https://jaycechant.info/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>在静态页中使用必应搜索</title>
    <link href="https://jaycechant.info/2020/use-bing-search-in-your-static-pages/"/>
    <id>https://jaycechant.info/2020/use-bing-search-in-your-static-pages/</id>
    <published>2020-05-24T01:20:03.000Z</published>
    <updated>2020-05-24T11:49:36.371Z</updated>
    
    <content type="html"><![CDATA[<p>博客搜索框跳转搜索结果，搜索引擎从 BD 改 必应。很琐碎，且没有什么技术含量。纯粹因为平时不写前端，记一下，避免以后忘了还得查这些琐碎的内容。</p>
<a id="more"></a>
<h2 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h2><p>博客是 github pages，生成器是 hexo，模板 landscape-plus。自带的搜索框如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.baidu.com/baidu"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"word"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">tn</span> <span class="attr">type</span>=<span class="string">hidden</span> <span class="attr">value</span>=<span class="string">"bds"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">cl</span> <span class="attr">type</span>=<span class="string">hidden</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">ct</span> <span class="attr">type</span>=<span class="string">hidden</span> <span class="attr">value</span>=<span class="string">"2097152"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"si"</span> <span class="attr">value</span>=<span class="string">"&lt;%- config.url.replace(/^https?:\/\//, '') %&gt;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;%- config.url.replace(/^https?:\/\//, &#39;&#39;) %&gt;</code> 是 hexo 的模板代码，实际页面会替换成 <code>jaycechant.info</code> 。这样写是为了把域名变成变量，避免以后如果改域名还得一个一个地方修改。</p>
</blockquote>
<p>就一个 form，action 设置为 get baidu 搜索页，下面的 input 都会按 name 追加在 query string。通过这种方式，在提交时跳转到一个搜索结果。</p>
<p>例如，搜索博客的关于 Golang 的内容：<code>http://www.baidu.com/baidu?word=Golang&amp;tn=bds&amp;cl=3&amp;ct=2097152&amp;si=jaycechant.info</code></p>
<p>显示：<strong>很抱歉，没有找到与“Golang”相关的网页。</strong></p>
<p>很长一段时间，都没有注意到它。早期文章少，也用不上搜索。</p>
<p>直到有一天，发现博客还有引用 http 资源，排查的时候，才留意到这个搜索框。因为众所周知的原因，不想用 BD。何况它也没收录我的博客。</p>
<h2 id="更换"><a href="#更换" class="headerlink" title="更换"></a>更换</h2><h3 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h3><p>首选 Google。不过这不光是给我用的，读者也可能用，只能选方便访问的 Bing。</p>
<p>同样在 Bing 搜上面的内容，拿到对应的 URL ：<code>https://bing.com/search?q=site%3ajaycechant.info+Golang</code></p>
<p>这回有结果了。</p>
<p>不过 <code>site</code> 参数跟搜索关键词混在一起，需要想办法自动添加。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://global.bing.com/search"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"si"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"&lt;%- config.url.replace(/^https?:\/\//, '') %&gt;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"ensearch"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样是不行的。Bing 不识别 <code>si</code> 。类似的， <code>site</code> 也不识别。搜索，查文档，测试，Bing 貌似没有给来源站点提供独立的 query 参数。</p>
<p>也试过放两个 <code>q</code> 参数，后面那个 <code>&lt;input name=&quot;q&quot; type=&quot;hidden&quot; value=&quot;site:jaycechant.info&quot;&gt;</code> ，也不行，同名的两个 query 参数，只有最后一个会起效，相当于覆盖效果。</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>然后发现自己陷入思维定势。被从原来的搜索框改限定了思路。</p>
<p>用 js 拼接一下 q 的 value 就可以了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://global.bing.com/search"</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span> <span class="attr">onsubmit</span>=<span class="string">"document.getElementById('searchtext').value+=' &lt;%- config.url.replace(/^https?:\/\//, '') %&gt;';return true;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"searchtext"</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"ensearch"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样已经足够简单了，不过表单一提交就会跳转到搜索页，能不能留住读者，不要跳出博客？这个简单，可以用 <code>target=&quot;_blank&quot;</code> 解决。</p>
<p>不过还有一个问题：关键词被修改了，如果连续搜索，关键词会不断添加 site。要么难看，干扰真正的关键词；要么要读者手动删掉。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>还是思维定势：这个 form 一定要提交吗？</p>
<p>直接 <code>onclick=&quot;window.open(&#39;&#39;)&quot;</code> 不行吗？</p>
<p>回车不起效？拦截 keycode 就好了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span> <span class="attr">class</span>=<span class="string">"search-form"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"searchtext"</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span> <span class="attr">class</span>=<span class="string">"search-form-input"</span> <span class="attr">placeholder</span>=<span class="string">"Search"</span> <span class="attr">onkeypress</span>=<span class="string">"if(event.keyCode==13)&#123;document.getElementById('searchsub').click();return false;&#125;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"searchsub"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"search-form-submit"</span> <span class="attr">onclick</span>=<span class="string">"window.open('https://global.bing.com/search?q=site:&lt;%- config.url.replace(/^https?:\/\//, '') %&gt; '+document.getElementById('searchtext').value, '_blank')"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"ensearch"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>效果还满意，不多折腾，收工。</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>除此以外，还有一些备选方案，因为时间关系，没有折腾，先 Mark。</p>
<h3 id="第三方站内搜索"><a href="#第三方站内搜索" class="headerlink" title="第三方站内搜索"></a>第三方站内搜索</h3><p>调用第三方的服务，如 <a href="http://www.swiftype.com/" target="_blank" rel="external">Swiftype</a> ，<a href="https://www.algolia.com" target="_blank" rel="external">algolia</a>，<a href="https://www.bonsai.io/" target="_blank" rel="external">Bonsai</a>，<a href="https://www.expertrec.com/" target="_blank" rel="external">ExpertRec</a>，<a href="https://www.aliyun.com/product/opensearch" target="_blank" rel="external">阿里云开放搜索</a> 等。</p>
<p>简单说，注册帐号，提供站点地址，配置各种选项，他们就帮忙索引。然后通过 API 也好，嵌入 js 也好，提供搜索服务。</p>
<p>本质上跟传统搜索引擎没有太大区别，只是既然你注册了，就一定会收录你的站点，以及可以配置。</p>
<p>相应的，多数收费，最多提供有条件的免费（限时、限额）。</p>
<h3 id="基于-js-的站内搜索"><a href="#基于-js-的站内搜索" class="headerlink" title="基于 js 的站内搜索"></a>基于 js 的站内搜索</h3><p>静态博客如果不想依赖其它服务，那么唯一可以提供动态能力的，就只有 js 了。仍然是静态页，没有 hosted server，就把跑脚本的负担，转移到浏览器。</p>
<p>选项有 <a href="https://lunrjs.com/" target="_blank" rel="external">lunr.js</a>，基于 lunr.js 的 <a href="https://github.com/weixsong/elasticlunr.js" target="_blank" rel="external">elasticlunr.js</a> ， <a href="https://fusejs.io/" target="_blank" rel="external">Fuse.js</a> 等。</p>
<p>简单说，静态站点生成时，就把索引一起生成。搜索时，脚本在用户端运行，读取索引进行搜索。</p>
<p>看着很美好，但是有一些因素制约了使用：</p>
<ul>
<li>所有索引数据加载到用户端，并在浏览器运行，对于网速和性能有一定要求，否则影响用户体验。</li>
<li>同样的，索引数据不能太大，因此不适合大站点使用；小站点也不方便做全文索引，大多只索引 title 和 tag。</li>
<li>需要索引，也就需要分词，很多 lib 对中文支持不好，需要额外增加插件或者踩坑。</li>
</ul>
<p>纯记录，暂时没有动力折腾这两种方案。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客搜索框跳转搜索结果，搜索引擎从 BD 改 必应。很琐碎，且没有什么技术含量。纯粹因为平时不写前端，记一下，避免以后忘了还得查这些琐碎的内容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写作之难（二）：认知隧道 与 两步笔记法</title>
    <link href="https://jaycechant.info/2020/cognitive-tunnel-and-2-step-note-taking/"/>
    <id>https://jaycechant.info/2020/cognitive-tunnel-and-2-step-note-taking/</id>
    <published>2020-05-18T14:52:00.000Z</published>
    <updated>2020-05-20T18:00:47.233Z</updated>
    
    <content type="html"><![CDATA[<p>接着聊上次写作的话题，顺便记一个最近学到的，写作和资料整理方面的技巧。</p>
<a id="more"></a>
<h2 id="写作之难"><a href="#写作之难" class="headerlink" title="写作之难"></a>写作之难</h2><p>我之前写过《<a href="https://jaycechant.info/2020/difficulties-of-writing/">写作困难：你是否有类似的烦恼？</a>》，提到写文章时遇到的困难和思考。这是一个大题目，落笔时正处在困惑当中。我希望通过写的过程来让自己想清楚，结果写得很痛苦，最后删删改改，眼看成为时间黑洞，就把当时想到的先写下来结束掉。</p>
<p>那篇里面初步写了两个事情：</p>
<ul>
<li><p>结构</p>
<p>  思维 和 文本 的结构差异极大，而且想法稍纵即逝。所以我花了很长篇幅，试图通过工具和技巧，去减低难度。仿佛有了神器和窍门，文章就出来了。</p>
</li>
<li><p>内容</p>
<p>  可改进了技术，才发现，内容才是最大的困境。不会储存、运输、加工、包装，固然是浪费原材料；但空有一条生产线，没有原料也白搭。对于持续获得有价值的内容，我尚未形成自己的见解。</p>
</li>
</ul>
<h2 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h2><p>后来看到王树义老师的文章（公众号：玉树芝兰）。他在《如何高效写长文？》中，引用 史蒂芬·平克 在《风格感觉》里的话，来解释什么是写作的『非线性』：</p>
<blockquote>
<p>写作之难，在于把 <strong>网状的思考</strong>，用 <strong>树状的语法结构</strong>，转换成 <strong>线性字符串</strong>。（“The Web, the Tree, and the String”）。</p>
<footer>—史蒂芬·平克, <cite>风格感觉</cite></footer>

</blockquote>
<p>简单一句话，比我痛苦思考之后的长篇大论要清晰得多。</p>
<p>这个非线性，就是上面说到的，思维 和 文本 的鸿沟。</p>
<p>在认知上，要意识到差异的存在，并且训练自己适应这种转换；同时懂得使用工具去辅助。</p>
<h2 id="内容匮乏"><a href="#内容匮乏" class="headerlink" title="内容匮乏"></a>内容匮乏</h2><p>再看到王老师另一篇文章《如何高效实践卡片式写作？》。里面他强调，不要 <strong>自顶向下去</strong> 填写内容；要让材料 <strong>自底向上</strong> 地 <strong>生长</strong> 。</p>
<blockquote>
<p>如果此时你手头，已经有了一堆卡片。这些卡片拼在一起，已经可以勾勒出整个文章的版图。那么这篇文章，就基本上可以当做是“生长”出来，而非“生产”出来。</p>
<footer>—王树义, <cite>如何高效实践卡片式写作？</cite></footer>

</blockquote>
<p>（王老师用卡片积累素材。我从阳志平老师的文章了解过卡片写作法，之前写文章也有提过。目前还在寻找适合自己的工具，时机成熟了再给大家介绍我的实践。）</p>
<h3 id="向下分解？"><a href="#向下分解？" class="headerlink" title="向下分解？"></a>向下分解？</h3><p>得益于写代码的经验，我很轻易地意识到写作有 自顶向下 和 自底向上 这两种方式，并在之前的文章中指出。可我的理解是具体写作场景决定方向：</p>
<ul>
<li>平日对一件事积累了各种材料和想法，有一天所有思考在一个点上汇合了，整理成文，就是自底向上。</li>
<li>要是命题作文，包括作文、演讲、辩论稿，给定了题目，就只能自顶向下了。</li>
</ul>
<p>记忆里 自顶向下 的情况占多数。写文章没那么多『恍然大悟』，一方面各种命题作文，另一方面有时为了学一个技能、理解一个知识点，要通过输出特定主题内容，促进学习。</p>
<p>也就是说，多数情况下我们就是 <strong>主题 -&gt; 大纲 -&gt; 填写内容</strong> 这样的顺序在写东西。 <strong>主题 总是先于 素材</strong> 进入我们的意识。我们对一个主题有概念之前，接收不到相关的信息，也无法进行有效的思考。</p>
<p>如果从没开过车，在路上你会留意车道导向吗？调头是最左车道还是最右车道？</p>
<p>也许你是老司机，很熟。那你留意过路边的通信基站吗？自行车绿道呢？</p>
<p>这些信息你一定见过，可脑海里没有概念，相关内容只是被忽略的噪音。都能答得上的，大概是一位开车上下班、闲暇喜欢骑行的通信工程师。（不是我，不要对号入座）</p>
<p>外行人要写，只能是拿到命题之后开始留意。自顶向下很自然啊，有什么问题？</p>
<h3 id="认知隧道"><a href="#认知隧道" class="headerlink" title="认知隧道"></a>认知隧道</h3><p>《如何高效实践卡片式写作？》点出了关键：先有网再被动填充节点，会造成心理压力，继而造成 认知隧道（cognitive tunnel）。这里王老师说他是引用 采铜老师的笔记（公众号：采铜的创想世界，我没找到出处）：</p>
<blockquote>
<p>全部的注意力都聚焦在当下那件紧急的事情上，变得特别狭窄和受限，此时容易忽略全局的信息，看不到整体。</p>
</blockquote>
<p>所谓一叶障目，不见森林。这让我想起被 命题作文 支配的恐惧。眼看交卷时间一秒一秒接近，构思的内容就是写不出来；眼看明天就要上台比赛，大半夜讲稿还是挤不出来；眼看马上要出门办事了，文件就是不记得放哪了。</p>
<p>更气人的是，卷子一交，比赛一结束，手续一办完，原本想不通理不顺记不得的东西，突然一下子通了、顺了、记得了。</p>
<p>我知道 认知隧道 是怎么一回事了。</p>
<h3 id="功夫在平日"><a href="#功夫在平日" class="headerlink" title="功夫在平日"></a>功夫在平日</h3><p>可前面也说了，自顶向下分解 是情景所迫，并非主动选择。我是这样考虑的：</p>
<blockquote>
<p>先有概念，然后才能有意识地 积累素材 和 思考。</p>
<p>可你未必要等拿到命题，才能接触这个主题。</p>
</blockquote>
<p>成功的观点输出，很少是事前毫无概念、毫无准备的，更不是单凭拿到命题之后的准备时间，就能完成整张思维网络的构建。哪怕是即兴演讲，成功的输出者，也一定有自己的知识积累。</p>
<p>准备不足，以致作文命题没听过，现场辩题看不懂，来不及查资料和细想，那就只剩下瞎掰一个选项。同样的情况，哪怕准备时间换成一晚，一周，一个月，只要 准备不足 + deadline 的压力把思维逼进墙角，也不过是卡壳和拖延来回切换。（你写过毕业论文吗？）</p>
<p>就好像内存不够的电脑卡顿了，如果因为慌张一顿瞎操作，结果只会更卡。（见过太多人喜欢按刷新。）</p>
<p>你本该对命题范围早有准备，也在之前了解过相关信息，有过思考。临场不过提取之前的积累，进行二次加工。换句话说，我们是把这个现场 <strong>向下建立</strong> 的 <strong>金字塔尖</strong> ，嫁接在之前 <strong>早已准备好</strong> 的 <strong>底座</strong> 上，最后导向塔尖上的结论。</p>
<p>只是很多时候，之前的了解和积累、甚至临场的记忆调取都是下意识进行，所以才会觉得成功的命题作文是完全自顶向下写出来的。事实上，根本 <strong>不会有人纯粹地向上构建（build up）或向下分解（break down）</strong> 。思考是 <strong>网状</strong> 的，只是 <strong>下笔时为了简化</strong> ，才 <strong>裁剪成树状逻辑</strong>。向上『生长』成文，也需要向下组织内容，和主动检索补充细节；那么向下分解，当然也要用之前『培育』的材料。</p>
<p><img src="../../images/cognitive-tunnel-and-2-step-note-taking.png" alt=""></p>
<blockquote>
<p>本文的结构树</p>
</blockquote>
<p>命题作文不可避免，就要在平时准备更多用得上的材料，把『底座』准备得更坚实，这样才能把临场构造的工作量最小化，尽量限定在 <strong>结构调整</strong> 和 <strong>语言润色</strong> 的范围内。</p>
<p>试想『小学生应不应该使用智能手机』的讨论，对 小学生 和 智能手机 有概念的普通人，都能简单发表一些看法。而关注教育相关信息、少年儿童的心智特点 还有 智能手机相关知识的人，显然观点质量会更高。与之相反，一个从未用过智能手机的人，哪怕题目背景给介绍智能手机，他的观点也只能基于臆测，结论很难靠谱。</p>
<p>所以，最后还是回到平日里 做事、读书、思考。</p>
<h3 id="出坑"><a href="#出坑" class="headerlink" title="出坑"></a>出坑</h3><p>我想，如果做菜时，锅热下油后，才发现缺了主要食材，我们会杵在原地，给自己施加压力说『赶紧把食材变出来』吗？不会吧。</p>
<p>那为什么我们会认为对着 纸笔 和 键盘，就能憋出点什么？</p>
<p>有了这个认识，我想还是无法避免再次因为紧迫的任务掉进『认知隧道』里。但那时大概能意识到自己在坑里， <strong>赶紧先关火</strong> ，改出去下馆子，或者改做冰箱里有材料的菜。就算领导点名要吃这道菜，能不能商量下顿做，或者赶紧再去一趟菜市场。</p>
<p>跳出来，别在原地耗着。</p>
<h2 id="笔记做两次"><a href="#笔记做两次" class="headerlink" title="笔记做两次"></a>笔记做两次</h2><p>关于用笔记积累素材，王老师强调了一些原则，我总结如下：</p>
<blockquote>
<ul>
<li><p>集中保存、内容完整、含上下文。</p>
<p>  他举了爱在书边空白写『这个问题我已经会证明了』的费马作为反例。  </p>
<p>  不好好集中记，容易忘记含义、上下文，甚至直接把笔记弄丢。</p>
</li>
<li><p>记笔记不能干扰本来在做的事。</p>
<p>  我们先是在做事、听课、讨论。因为内容很重要，或者当时受到了启发，决定记笔记。  </p>
<p>  不赶紧记，会忘；优先级太高，容易分心扰了正事。</p>
</li>
<li><p>要用自己的话，不能光是摘录。</p>
<p>  这里面包含至少两个原因：</p>
<ul>
<li><p>只有理解清楚了，才能用自己的话讲清楚。</p>
<p>  这是用输出倒逼输入，是 <strong>费曼技巧</strong> 的核心。</p>
</li>
<li><p>版权保护表达不保护思想。</p>
<p>  笔记将来要用在自己的输出里，思想可以借鉴，表达必须是自己的话，这样才能减少侵权的风险。（题外话：相对直接的借鉴，哪怕用自己的话复述，也要署名和列出处，否则就成了洗稿了。）</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>好难。</p>
<p>做到 第一点 和 第三点 就已经非常难了。然后第二点还跟这两点冲突。</p>
<p>王老师说，那就记两次。</p>
<p>第一次，以不干扰为优先，先随便记录，确保靠这个记录短时间内能想起来详情。</p>
<p>然后，24 小时之内——我想最好可能是当天睡前——好好实施 第一点 和 第三点：集中、完整、以平时一贯的方式，用自己的话复述。</p>
<h3 id="关键词-钩子"><a href="#关键词-钩子" class="headerlink" title="关键词 + 钩子"></a>关键词 + 钩子</h3><p>这时，我突然想起 李照楠老师（公众号：L先生说）在《这套法则，治好你的信息焦虑》里讲过的『关键词 + 钩子』整理资料的办法。这是 18 年的文章，我去翻了当时的笔记。</p>
<p>面对海量的信息，他按 <strong>兴趣高低</strong> 和 <strong>是否系统</strong> ，分成了四类：</p>
<blockquote>
<ul>
<li><p>兴趣低 + 零碎 = 噪音</p>
<p>  舍弃。多数热点属于这类。对我来说短视频也算。</p>
</li>
<li><p>兴趣高 + 系统 = 方法</p>
<p>  直接操作、实践。因为系统，实践意愿又高，所以最好直接动手做。这篇文章里我学到的几个方法就是这种。</p>
</li>
</ul>
</blockquote>
<p>这两个都很明确。我认为重点在剩下两类</p>
<blockquote>
<ul>
<li><p>兴趣高 + 零碎 = 想法</p>
<p>  记笔记，思考，找材料，让它变系统。自己平时冒出来的想法属于这种。</p>
</li>
<li><p>兴趣低 + 系统 = 资料</p>
<p>  记笔记，关键词描述是什么有什么用，钩子描述用到时去哪找。现成成体系的内容，暂时用不上，弃之可惜，又没必要投入太多精力，就留下『关键词 + 钩子』，等以后感兴趣、有需要。</p>
</li>
</ul>
</blockquote>
<p>我当初看到文章时，就把这篇文章归入了 资料。有理有据有实操，算系统的内容。但当时我还没有太深的体会，也不愿意投入太多精力尝试。所以就按里面的方法，建立了一篇钩子笔记。体会浅，没坚持下来，这就成了唯一一篇钩子笔记，后面就忘了 [捂脸]。两年后，试图用关键词搜索找回文章而不得，还是凭笔记找回来的。确实有用。</p>
<h3 id="我的版本"><a href="#我的版本" class="headerlink" title="我的版本"></a>我的版本</h3><p>具体到每个人的做法，就要跟自己的工作和生活习惯，使用的工具相关。如果之前有积累，还要考虑迁移成本。</p>
<p>我笔记系统的出发点，首先是剪贴。</p>
<p>我在高中摘抄和剪贴了好几本笔记。大学后期开始用 <strong>为知笔记</strong>，到现在第十个年头，笔记 6K +，是最早一批 VIP，并打算一直续费下去。在有了 Evernote、OneNote、有道云笔记 等竞争者的今天，为知算不上多优秀。但前身是『网文快捕』的为知，剪贴线上内容一招鲜，对样式的兼容程度暂时没有看到竞争者。</p>
<p>十年里见过太多网站和服务下线，也有作者自己删文。当时只留链接的，现在很多成了死链。所以我不能真的只留『关键词 + 钩子』，而是要一份资料的 <strong>完整拷贝</strong> 。我也很早意识到，记笔记负担一定要小，不能干扰正事，要容易坚持。所以操作麻烦的，拷贝资料之后格式识别会崩的，不能跨平台同步的，都被淘汰出局。</p>
<p>就因为这点，为知的小缺点都无伤大雅。何况为知还跨平台，PC 本地全量备份（可离线），手机部分缓存（省空间）。何况它还开源，有自建私服的选项。它对 Markdown 的支持是真的弱，所以我用 Typora 当外部编辑器。</p>
<p>一旦确定原始材料的归宿，剩下的工作除非完全不兼容，都会围绕着它进行。之前资料太多，试过分目录，成效不好，改为标签 + 搜索。现在学会了 二次整理笔记，还有在拷贝基础上 关键词概括 + 钩子，就会在整理笔记时，<strong>增加一种笔记类型，专门概括和索引其他笔记</strong> 。为知支持笔记内链，虽然功能很弱。</p>
<p>大纲 和 思维导图 是没有的，需要整理思路时，只能引入 幕布。还好幕布也是跨平台同步，所以也买了 VIP。</p>
<p><img src="../../images/note-taking-workflow.svg" alt=""></p>
<blockquote>
<p>文档工作流的一部分，原始素材以及基于原始素材的链接，在为知笔记上进行。</p>
</blockquote>
<p>这是我的版本，不一定适合你的情况。</p>
<p>就好像我通过上面提到的几位在 认知 和 写作 方面的老师（他们好像都学心理学和会编程），知道了卡片式写作，知道了 Scrivener、Gingko、Devonthink、Roam research 这些工具，看着很高大上，是否适合我，如何从当前的工作流迁移，还需要尝试和磨合。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不知道这篇算不算自底向上生长的成果。我是带着问题，看了很多文章之后，加上自己的思考，在相对成熟的时机，写了这些文字。果然，比之前那篇写起来要顺利很多。</p>
<p>最终成文要组织调整这些材料时，仍然是一个向下分解的过程，但是分解到具体观点，素材已经等着我了。</p>
<p>果然人不能闭门造车，要多学习。不过没有痛苦思考的过程，可能也体会不到这句话背后的分量。子曰：『学而不思则罔，思而不学则殆』。</p>
<p>先聊到这，回头要把《风格感觉》看完，把 6 千多条历史笔记整理一下。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着聊上次写作的话题，顺便记一个最近学到的，写作和资料整理方面的技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://jaycechant.info/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>评论：为什么你应该学 Go ？</title>
    <link href="https://jaycechant.info/2020/review-why-should-you-learn-go/"/>
    <id>https://jaycechant.info/2020/review-why-should-you-learn-go/</id>
    <published>2020-05-17T04:48:48.000Z</published>
    <updated>2020-08-19T15:48:41.370Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇评论是我 ARTS 打卡中 Review 的部分，也就是阅读一篇英语（技术）文章，然后评论。</p>
<p>第一次做，也不知道做得对不对。不管，先实践，慢慢就会好的了。</p>
</blockquote>
<a id="more"></a>
<p>平时太过于依赖翻译，只有极少数觉得翻译质量不好，乃至内容存疑，才会主动去翻英语资料。</p>
<p>所以当第一次为了打卡 <strong>无目标地主动</strong> 找英文材料看，突然不知道从哪里找起。翻了半天，大多是社交网络的碎片内容。眼看时间浪费了不少，先随便找了一篇，正好我最近也想写一下学 Go 的原因。</p>
<p>《Why should you learn go?》，文章地址：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="external">https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65</a> （17 年 1 月的文章，有点旧。特别提醒，Medium 为 推家 旗下网站，访问需工具。）</p>
<p>如题，作者罗列了推荐 Go 的理由。我先简单总结作者观点（只是用引用格式区分，并非原文），再提出我的看法。</p>
<h2 id="硬件限制"><a href="#硬件限制" class="headerlink" title="硬件限制"></a>硬件限制</h2><blockquote>
<p>摩尔定律正在失效</p>
<p>过去十几年，计算机（单核）算力没有明显的变化。</p>
<p>随着在微观尺度上量子效应越发明显，堆砌晶体管数量也变得越来越难，越来越不经济。现在厂商只能增加内核数量和增大缓存。但这些办法也有其限制，很快就无法继续。</p>
</blockquote>
<p>同意。我们认为开发者的时间比较宝贵，以及我们渴望更酷炫的效果，结果就是硬件进步获得的性能，都在软件层面被挥霍掉。我们愿意花费大量的算力，只是为了提升一点点人工的效率。过去这么多年，摩尔定律虽然不精确，也基本预言了性能提升的趋势。软件的最终运行速度，不仅没有怎么提升，甚至有些还变慢了。</p>
<p>这种『挥霍』多数情况下，<strong>其实是合理</strong> 的。假定 10 年里算力提升了 50 倍，面对一个要 80 工时开发的，10 年前运行时间要 1 秒的程序，有两个选择：</p>
<ul>
<li>维持 10 年前的开发方式，开发工时和运行效率都不变。这意味着算力提升后，程序运行时间变成 1/50，也就是 20 ms。获得了 980 ms 的提升。</li>
<li>为了减轻开发负担，引入更多中间层，屏蔽更多细节。一般来说，我们不能忍受变得更慢，理想情况下，运行效率的降低大致上更好跟算力的提升打平，也就是运行时间在 10 年后还是 1s，以此换得开发时间减半。开发者省下了 40 工时。</li>
</ul>
<p>例子非常粗糙，现实世界比这个复杂得多，但勉强能说明问题：50 倍 和 2 倍，看似前者更重要。可现实中我们比较的是差值。980 ms 运行速度提升，没有人在意；而 40 工时的提速，实际上重要的多。至于这 40 工时再被不确定的需求浪费掉，就是另一个故事了。</p>
<p>摩尔定律有效时，『挥霍』是理性的选择。不过，随着大规模分布式系统的普及，以及摩尔定律逐渐失效，在处理器有基础突破之前（超导？量子？），运行效率应该被重新重视起来。</p>
<h2 id="Go-有协程"><a href="#Go-有协程" class="headerlink" title="Go 有协程"></a>Go 有协程</h2><blockquote>
<ul>
<li>轻量用户级协程，2KB 低开销，动态增长栈，MPG 调度模型 …… 轻易开到百万协程。对比之下，Java 线程开销 1MB 起。</li>
<li>CSP （Communicating Sequential Process，通信顺序进程）并发模型，可以大幅降低正确并发代码的心智负担。</li>
</ul>
<p>总的来说，就是 09 年诞生的 Go，比这些上个世纪诞生的老前辈，更原生地支持 并发 和 并行。</p>
<p>用作者话说，强大如 Java，C/C++；代码直白优雅如 Erlang。</p>
</blockquote>
<p>作者指出在摩尔定律失效的年代，靠增加 CPU 核心来提高算力。相应地，程序需要良好的并发，乃至部署分布式的系统（原文用的微服务）来更好地利用这些算力。</p>
<p>但随着了解深入，作为 Go 吹的我也必须指出两点：</p>
<ul>
<li>Java 通过第三方库也引入了协程 和 CSP。虽然使用不如原生的直接，但是结合 Java 已有的生态，还是增强了 Java 在并发方面的能力，使得 协程 + CSP 不再是 Go 的专属。</li>
<li>CSP 的底层依然是靠 锁 实现的，只是通过封装向开发者屏蔽了复杂性。在大多数场景，性能不差，同时大大降低了心智负担。但是极端情况下，还是自己控制锁的粒度才能最大限度发挥性能，这时 Go 并没有明显的优势。</li>
</ul>
<h2 id="Go-直接运行在硬件上"><a href="#Go-直接运行在硬件上" class="headerlink" title="Go 直接运行在硬件上"></a>Go 直接运行在硬件上</h2><blockquote>
<p>其实就两点</p>
<ul>
<li>Go 是编译语言</li>
<li>Go 没有虚拟机</li>
</ul>
<p>作者就是想说，Go 没有虚拟机，运行接近 C/C++ 的速度，但又不用像 C/C++ 那样自己管理内存。</p>
</blockquote>
<p>这里要提点反对意见了。早些年我也想当然地认为，Go 接近 C/C++ ，Go 肯定比 Java 快。</p>
<p>现在我要说，这是 <strong>分场合的</strong> 。Java 凭借多年深厚的积累，特别是在不同场景下的 JIT 或 AOT 优化，有些情况就是比年纪尚轻的 Go 快。当然，发生在特定场景，在 Java 可以优化，而 Go 还没有或者基于某些设计不能进行优化的时候。更多情况下，Go 比 Java 快一点，或者差不多。懒得研究和稀泥说法是，它们都在比 C/C++ 略慢的第二梯队，比多数高级语言要快。但有一点是确定的，<strong>不能闭着眼睛说 Go 没有虚拟机就一定比有虚拟机的 Java 快</strong> ！</p>
<p>编译语言、没有虚拟机真正的优势在于，无依赖地跨平台发布。实际上，通过一些技巧，还能达到单文件发布。做过运维搞过批量部署的同学，会知道这是多么宝贵的特性。</p>
<h2 id="Go-容易维护"><a href="#Go-容易维护" class="headerlink" title="Go 容易维护"></a>Go 容易维护</h2><blockquote>
<p>Go 非常克制地保持了一个简洁和清晰的语法。</p>
<p>它拒绝了很多现代高级语言会有的特性，来避免副作用：</p>
<ul>
<li>类</li>
<li>继承</li>
<li>构造函数</li>
<li>注解</li>
<li>泛型</li>
<li>异常处理</li>
</ul>
<p>它宁可让你多写两三行代码，也要保持代码的简洁明了和运行高效。</p>
<p>另外，Go 语法非常稳定，保持了很好的向后兼容。（向后指 backward，跟中文的语义理解上相反，其实指新版本兼容老版本，新环境能跑老代码）</p>
</blockquote>
<p>这确实是值得称道的点。Go 核心团队以他们多年的经验，精心挑选了核心的特性，然后努力避免不必要的特性让语言变得臃肿。</p>
<p>但是，这往往也是一个被吹捧过度的点。例如缺乏泛型 是 Go 一直被诟病的。</p>
<p>缺乏泛型，让开发者不得不在 数据结构部分 <strong>充斥复制粘贴</strong> 和 <strong>大量依赖代码生成器</strong> 之间做选择。</p>
<p>这就是语言表达力的问题。冗余代码就是会带来管理负担，代码生成器就是会引入额外依赖。</p>
<p>官方也没说过不需要泛型。只是说泛型相对不急，还没找到更好的实现方案，团队先把时间花在优化性能上。</p>
<blockquote>
<p>一旦说了 Yes，之后就必须一直 Yes。现在说 No，以后还有机会说 Yes。（大意复述）</p>
</blockquote>
<p>这才是核心团队的意思。泛型的草案已经讨论有年头了，社区的呼声也非常高。期待 Go 泛型的到来。</p>
<p>无论如何，足够精简的特性，对于 编译速度、运行速度 还有 开发者的心智负担，都很重要。也正是凭借这些方面的优势，让 Go 在各个方面都能做到接近第一梯队，然后整体下来一看，综合很强。</p>
<h2 id="背靠-Google"><a href="#背靠-Google" class="headerlink" title="背靠 Google"></a>背靠 Google</h2><p>以及很多大公司在用。</p>
<p>严格来说，这是生态角度。生态的几个指标：大厂支持，杀手案例，活跃社区，企业框架。</p>
<p>但是文章作者角度刁钻地说出了一个算技术方面的理由：</p>
<blockquote>
<p>Google 见过大场面，Google 有世界最大规模的云设施之一，由它设计的语言一定会把它遇到的问题考虑进去，做到可扩展和高效。</p>
</blockquote>
<p>呃，G 厂厉害也不是这样吹的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最后的结论还是『虽然我考试每科都是老二，但是总分高啊』。</p>
<p>运行速度不如 C/C++ ，但是开发效率和心智负担妥妥碾压。C/C++ 历史包袱重，对新手意味着学习曲线更陡、坑更多，对团队意味着管理难度高。对于离得硬件和性能稍微远一些的开发，这些代价可能不值得。</p>
<p>表达力、开发自由度不如 JavaScript 和 Python，但是静态安全性和速度又是遥遥领先。</p>
<p>所以 Go 就是很适合作为 CLI 工具、web 服务（特别是云原生的微服务）的开发语言。</p>
<p>因为优秀的类库还需要积累，又缺乏企业级的开发框架，距离 Java 还是有距离。但是发展到今天：</p>
<ul>
<li>大厂支持一开始就有，含着金钥匙诞生。</li>
<li>杀手级案例，最早是 Docker 和 K8s，后面越来越多云生态的组件加入。</li>
<li>社区人气是够的，其中中国开发者又是最捧场的。第三方库勉强够用，但是不足够好。特别是包管理转向 module 后很多包遗留了兼容问题。</li>
<li>最后只是缺足够强大全面的，可以对标 spring 的开发框架。</li>
</ul>
<p>学 Go 肯定是值得的。老手可能花一个小时就能大概上手。当前 Go 已经可以用于生产环境，用来搭建运维工具箱，或者实现一个服务。它就好像是专门为 分布式 和 云 准备的。但如果整个技术栈完全用 Go，生态还不如 Java 完善，可能还要自己踩一些坑。</p>
<p>必须承认，在强大全面的 Java 面前，Go 还是个弟弟。但奔 3 的 Java 已经开始有点油腻，才 10 岁的 Go 正年轻。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇评论是我 ARTS 打卡中 Review 的部分，也就是阅读一篇英语（技术）文章，然后评论。&lt;/p&gt;
&lt;p&gt;第一次做，也不知道做得对不对。不管，先实践，慢慢就会好的了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
      <category term="review" scheme="https://jaycechant.info/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 25: Reverse Nodes in k-Group</title>
    <link href="https://jaycechant.info/2020/leetcode-25-reverse-nodes-in-k-group/"/>
    <id>https://jaycechant.info/2020/leetcode-25-reverse-nodes-in-k-group/</id>
    <published>2020-05-16T10:25:33.000Z</published>
    <updated>2020-05-16T17:05:43.369Z</updated>
    
    <content type="html"><![CDATA[<p>好久不刷题，还得捡起来。</p>
<a id="more"></a>
<p>太久不刷，不好一来就选太难。好奇 LeetCode 中国有啥区别，逛了一下，刚好发现置顶推荐 25 号题，选择困难症表示就它了。（不过考虑到翻译和讨论质量，还是刷 LeetCode 原版，最多两边都提交一下。）</p>
<p>题目在此：<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="external">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一句话题意：给定链表 和数字 k，把链表按照每 k 个节点一组，组内原地倒序；最后不满 k 个的剩余元素保留原样。</p>
<p>例子：</p>
<p><code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>k = 2 时，返回 <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>k = 3 时，返回 <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p>约束：</p>
<ul>
<li>只能使用常数规模的额外内存</li>
<li>不能修改节点的值，而要动链表的结构</li>
</ul>
<p>题目只需要实现给定签名的 <code>reverseKGroup(head *ListNode, k int)</code> 函数，不需要写完整的程序。</p>
<hr>
<p>就是考察链表基本操作的题目，这样的题目居然也标 Hard？</p>
<p>水题一道，为了避免浪费读者时间，<strong>刷题老手可以关闭了</strong> 。新手可以参考一下我的解题流程和切入思路，毕竟没有难点可说。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="测试驱动"><a href="#测试驱动" class="headerlink" title="测试驱动"></a>测试驱动</h3><p>题目虽然简单，但链表操作还是比较违反直觉的。</p>
<p>『七加减二』法则说，人只能在短时记忆里同时处理 5 到 9 个内容。而最新的研究表明，实际上人类的平均值更低，大约只有 4。（你知道为什么一般记数字都是 4 个一组记了吧）</p>
<p>如果光凭想象，多数没有经过特殊训练的人，很快就不记得哪个节点指向哪个了。所以开始前对于新手有两个建议：</p>
<ul>
<li>拿好纸和笔，没有把握的内容，写下来推算</li>
<li>写实现之前，先写测试</li>
</ul>
<p>事实上，这两个建议对实际的软件开发也是适用的。很多时候，大家信心满满，觉得这么点事情，拿纸笔和写测试的时间是浪费。可很快就会发现，节省的时间跟陷入莫名错误时调试耗的心力和时间比，根本不算什么。正所谓『磨刀不误砍柴工』。</p>
<p>第二个建议，如果按规范执行，就是所谓的 TDD （测试驱动开发）。这里不展开，不知道的自己查一下。最近一直在用 Go，刷题也是。借助 Go 自带的测试框架，很快就可以写出这样的单元测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"strings"</span></div><div class="line">	<span class="string">"testing"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 静态类型检查</span></div><div class="line"><span class="keyword">var</span> _ fmt.Stringer = (*ListNode)(<span class="literal">nil</span>)</div><div class="line"></div><div class="line"><span class="comment">// String 方法方便调试输出</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *ListNode)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	b := strings.Builder&#123;&#125;</div><div class="line">	<span class="keyword">for</span> ; head != <span class="literal">nil</span>; head = head.Next &#123;</div><div class="line">		<span class="comment">// 为了省事，不特殊处理最后的逗号</span></div><div class="line">		b.WriteString(fmt.Sprintf(<span class="string">"%d%s"</span>, head.Val, <span class="string">","</span>))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> b.String()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从切片（Go 的动态数组）生成链表，避免声明链表的麻烦</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceToList</span><span class="params">(s []<span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	<span class="comment">// 为了不用特殊处理，头节点留空</span></div><div class="line">	head := <span class="built_in">new</span>(ListNode)</div><div class="line">	last := head</div><div class="line">	<span class="keyword">var</span> cur *ListNode</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</div><div class="line">		cur = <span class="built_in">new</span>(ListNode)</div><div class="line">		cur.Val = v</div><div class="line">		last.Next = cur</div><div class="line">		last = cur</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 跳过头节点</span></div><div class="line">	<span class="keyword">return</span> head.Next</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试用例，需要增加用例只需要添加，不需要动逻辑</span></div><div class="line"><span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	k    <span class="keyword">int</span></div><div class="line">	s    []<span class="keyword">int</span></div><div class="line">	want <span class="keyword">string</span></div><div class="line">&#125;&#123;</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"1"</span>, <span class="comment">// name 是为了并发测试时用来区分用例的，随便给，能区分就行</span></div><div class="line">		k:    <span class="number">1</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</div><div class="line">		want: <span class="string">"1,2,3,4,5,6,7,"</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"2"</span>,</div><div class="line">		k:    <span class="number">2</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</div><div class="line">		want: <span class="string">"2,1,4,3,6,5,7,"</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"3"</span>,</div><div class="line">		k:    <span class="number">3</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</div><div class="line">		want: <span class="string">"3,2,1,6,5,4,7,8,"</span>,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"39"</span>,</div><div class="line">		k:    <span class="number">3</span>,</div><div class="line">		s:    []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</div><div class="line">		want: <span class="string">"3,2,1,6,5,4,9,8,7,"</span>,</div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverseKGroup</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		<span class="comment">// 并发测试</span></div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			head := sliceToList(tt.s)</div><div class="line">			got := reverseKGroup(head, tt.k).String()</div><div class="line">			<span class="keyword">if</span> got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"reverseKGroup() = %v; want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要看着这些代码很长，写多了都是套路，部分代码还能工具生成（这里用的 VS Code + 插件），耗费的注意力是很少的。而一旦测试用例写完，我们就有了一个清晰的目标：通过修改实现，让测试通过。每次验证的成本为 0。</p>
<h3 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h3><p>解决任何问题，首先要懂得分解问题。如果问题看起来有点复杂，尝试分解成几个子问题去解决。如果还是棘手，就继续分解，直到比较容易解决为止。怎样的问题算复杂，因人而异。有些问题很难，解决多了有了固定解法，也可以直接写答案；新手生疏，就多分解细一些。</p>
<p>这里先忽略 k，先考虑整个链表原地倒序。</p>
<p>所谓倒序，对于单向链表而言，就是 前一个节点 和 后继 节点反过来。</p>
<p><code>1-&gt;2-&gt;3-&gt;4-&gt;5</code> ==&gt; <code>1&lt;-2&lt;-3&lt;-4&lt;-5</code> （为了强调修改结构而不是节点，特意不动节点位置，而修改指针指向。）</p>
<p>很容易想到，可以新建一个链表，将原链表的节点，从尾部逐个放到新链表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	<span class="comment">// 倒序后的链表，创建一个空节点避免特殊处理</span></div><div class="line">	reversed := <span class="built_in">new</span>(ListNode)</div><div class="line">	<span class="comment">// 倒序链表尾节点</span></div><div class="line">	rTail := reversed</div><div class="line">	<span class="keyword">for</span> head.Next != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// 原链表尾节点</span></div><div class="line">		<span class="keyword">var</span> tail *ListNode</div><div class="line">		cur := head</div><div class="line">		<span class="comment">// 将 cur 移向原链表最后一个节点，tail 指向倒数第二个节点</span></div><div class="line">		<span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &#123;</div><div class="line">			tail = cur</div><div class="line">			cur = cur.Next</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 将最后一个节点挂到倒序链</span></div><div class="line">		rTail.Next = cur</div><div class="line">		rTail = cur</div><div class="line">		<span class="comment">// 并从原链移除</span></div><div class="line">		tail.Next = <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	rTail.Next = head</div><div class="line">	<span class="comment">// 跳过空节点</span></div><div class="line">	<span class="keyword">return</span> reversed.Next</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用了四个指针，分别指向两条链表的头和尾。跑一下单元测试，当然是失败的，但可以看到，输出整体倒序了。</p>
<p>不过，这个实现，效率太差。链表是无法随机访问的，光访问尾节点，就得耗费 $ O(N) $ 复杂度，每次访问尾节点都从头开始查找，整体的复杂度就变成 $ O(N^2) $ 了。其实，倒序链没有必要非要从头部开始构建。原链只能从头开始读，那么倒序链就从尾部开始构建，就可以遍历一遍完成倒序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	rNext := head</div><div class="line">	reversed := rNext.Next</div><div class="line">	head = reversed.Next</div><div class="line">	rNext.Next = <span class="literal">nil</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		reversed.Next = rNext</div><div class="line">		<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> reversed</div><div class="line">		&#125;</div><div class="line">		rNext = reversed</div><div class="line">		reversed = head</div><div class="line">		head = head.Next</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种实现不仅只需要遍历一次，连指针都少用了一个。解释起来比较麻烦，直接画图反而直观：</p>
<p><img src="../../images/leetcode25-reverse.svg" alt=""></p>
<p>每次从原链表取头节点，放到倒序链表做头节点，三个额外的指针一路向后移动。遍历完成，转换也完成了。对链表稍熟练一点，应该直接想到这种做法。前面第一版实际上是写文章时临时写出来做对比的。</p>
<h3 id="分组断开与重组"><a href="#分组断开与重组" class="headerlink" title="分组断开与重组"></a>分组断开与重组</h3><p>最基本的倒序解决了。不过实际上要解决的，是把原链表分成多个 k 大小的子链表，每条子链表内部倒序。把上面实现的函数，重命名为 <code>func reverseSubGroup(head *ListNode) *ListNode</code> ，用来给每个子链表倒序时调用。参数 k 去掉，用不上。原来函数，变成解决两个问题：把原链表分割后交给倒序函数；把倒序后的链表重新拼成完整的链表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> k == <span class="number">1</span> &#123;</div><div class="line">		<span class="comment">// 及早剪枝</span></div><div class="line">		<span class="keyword">return</span> head</div><div class="line">	&#125;</div><div class="line">	cur := head</div><div class="line">	<span class="comment">// head, tail: 原链表 头节点，尾节点</span></div><div class="line">	<span class="comment">// gHead, gTail: 当前 Group 头节点 和 尾节点</span></div><div class="line">	<span class="keyword">var</span> gHead, gTail, tail *ListNode</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		gHead = cur</div><div class="line">		<span class="keyword">if</span> gHead == <span class="literal">nil</span> &#123;</div><div class="line">			<span class="comment">// 新 Group 为空，表明节点数刚好是 k 的倍数，返回</span></div><div class="line">			<span class="keyword">return</span> head</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 跳过 k 个节点，找到 Group 尾部</span></div><div class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</div><div class="line">			<span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</div><div class="line">				<span class="comment">// 当前 Group 不够 k 个节点</span></div><div class="line">				<span class="comment">// 不需倒序，接上剩余节点后返回</span></div><div class="line">				tail.Next = gHead</div><div class="line">				<span class="keyword">return</span> head</div><div class="line">			&#125;</div><div class="line">			gTail = cur</div><div class="line">			cur = cur.Next</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 倒序之前，将当前 Group 和后面断开</span></div><div class="line">		gTail.Next = <span class="literal">nil</span></div><div class="line">		<span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</div><div class="line">			head = reverseSubGroup(gHead)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			tail.Next = reverseSubGroup(gHead)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 倒序之后 gHead 实际上变成了 Group 尾</span></div><div class="line">		tail = gHead</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历逻辑跟前面很接近，差别是这里不需要倒序，只是 Group 的断开和重连。重点都用注释标注了。</p>
<p>再跑一次单元测试，OK 了。提交一下，AC，时间 4ms（打败 97.84%），内存 3.6 MB（打败 50%）。</p>
<p>外层函数也是只遍历了一遍，时间复杂度 $ O(N) $ （机械地从有多少层循环得出 $ O(N^2) $ 乃至 $ O(N^3) $ 的醒醒），空间复杂度也满足常数阶。如果不追求极限优化，特别是考虑到代码的可读性，我觉得可以接受了。</p>
<h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul>
<li><p>理解链表不能随机访问，只能从头节点开始遍历的特点，尽量用几个指针，在一次遍历里尽量多地获取稍后需要用到的节点。</p>
</li>
<li><p>多个指针一起移动时，需要小心处理赋值顺序，避免拿到错误的值。一般马上要断开的指针（修改成指向别的节点），需要先用另一个指针备份避免『失联』。</p>
</li>
<li><p>我看到讨论区里有人用栈来实现，还通过了。需要指出，这是 <strong>不符合题目要求</strong>的。</p>
<p>  题目要求额外的内存是常数。而一旦使用了栈来储存节点，栈的大小就是与 k 相关的了。k 作为一个输入，是无法控制其大小的。在实际生产环境，这会成为性能隐患。而刷题的角度说，题目既然给定了约束，这种做法直接是不符合题意。居然能通过，说明这道题的测试用例太弱了。</p>
</li>
</ul>
<p>总的来说，这道题作为新手熟悉 链表操作 的题目，值得一做。但也就这样了，我故意多写一种倒序的『初级思路』，把过程掰碎了说，也只能写到这么点内容。</p>
<p>你觉得我讲得怎样？关键点说明白了吗？有讲到你疑惑的点，还是废话连篇？欢迎留言告诉我。</p>
<h2 id="题外话：什么是-ARTS"><a href="#题外话：什么是-ARTS" class="headerlink" title="题外话：什么是 ARTS"></a>题外话：什么是 ARTS</h2><p><strong>ARTS</strong> 是由陈皓（左耳朵耗子）发起的一个活动，每周坚持做四件事，具体内容如下</p>
<ul>
<li>Algorithm：至少做一道 leetcode 的算法题</li>
<li>Review：阅读并点评至少一篇英文技术文章</li>
<li>Tip：学习至少一个技术技巧</li>
<li>Share：分享一篇有观点和思考的技术文章</li>
</ul>
<p>耗子叔说『只要坚持每天学习 1 小时，就超过了 99% 的人』（大意）。</p>
<p>我印象中很早就见过。当时不知道是忙还是别的原因，居然没有想到一起打卡。</p>
<p>儿子出生后，压力更大更忙了。可我反而意识到，需要做的事，迟早都得做，一个都逃不掉。年轻的时候会说『等 xxx 的时候』，现在越来越明白，那个时候可能永远等不到，如果现在不做，等到什么时候？</p>
<p>早年也零星刷过题，不过一般在 POJ，然后是 URAL，再后来为了方便，就泡在 Virtual Judge。在三星当算法讲师时最爽，能够带薪刷题，还自己出题构造测试用例；但是投入太多，开发业务却又落下。离开三星那个氛围，专注技术转型之后，刷题又落下了。现在重新捡起，选择了业界一致选择的 LeetCode，然后顺便开启 ARTS 的打卡。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不刷题，还得捡起来。&lt;/p&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://jaycechant.info/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="https://jaycechant.info/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="https://jaycechant.info/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>跟黄执中学观念传递：简单、意外、具体</title>
    <link href="https://jaycechant.info/2020/the-key-to-conveying/"/>
    <id>https://jaycechant.info/2020/the-key-to-conveying/</id>
    <published>2020-05-12T09:16:34.000Z</published>
    <updated>2020-05-12T10:54:48.608Z</updated>
    
    <content type="html"><![CDATA[<p>把话说清楚，本质上是要传达的内容，让受众听（看）进去。重要的首先是 <strong>内容</strong> ，然后是传达的 <strong>形式</strong> 。</p>
<a id="more"></a>
<p>明确要传达的内容，想清楚。然后考虑场景和受众，<strong>调整内容的形式</strong> 。三分钟内口头传达一个观念，跟官方声明、法律文件，不是一回事。</p>
<p>日常更多是前者。有限时间和注意力，先求触及。听进去了，感兴趣了，才有机会深入，把细节交给 面谈、合同、规范 …… 写文章也在传达观念，多数人不是写论文 和 公文。匆匆路过的读者，注意力有限。</p>
<p>至于市面常见的技巧训练，在特定的、强调仪式感的场合有用；不分场合强调，是舍本逐末。</p>
<p>有价值的内容，来自积累与洞见。具体跟所在领域相关。读书与实践，增加输入，似乎是唯一的通用法门。<br>至于传达形式，见过太多说法，头绪纷乱。直到看了少爷一个视频，豁然开朗。后来写文卡住，翻出来看。再遇到瓶颈，再看。 一看就懂，一做肌肉记忆打回原形 。知易行难。那就用自己的话复述一下，顺便推荐给大家。</p>
<blockquote>
<p>打（过）辩论的，没有不知道少爷（黄执中）的。通过《奇葩说》，现在更多人知道了他。</p>
</blockquote>
<p><br></p>
<hr>
<p><br></p>
<p>少爷说了啥？ <strong>周全和精准，妨碍我们传达。</strong> </p>
<p>此话一出，命中强迫症要害。太想把话说圆满，反而引入更多漏洞，话说成了缠脚布，打满补丁。<br>有限时间、内容里，让观念牢牢黏在听众脑海，就三个词：</p>
<ul>
<li>简单：给受众减负，让他在忘掉别的所有之后，只要记得一个。</li>
<li>意外：松动已有认知，调整观念，印象深刻。</li>
<li>具体：给细节，有画面感的细节。有温度的体验，强过冷冰冰的数据。</li>
</ul>
<p><img src="../../images/conveying-in-3-min.png" alt=""></p>
<p>推荐你完整看下来，<strong>用自己的话复述</strong> 。B 站地址在这里：《黄执中：你如何听懂我说的话？》<a href="https://www.bilibili.com/video/BV1Y7411V7wW" target="_blank" rel="external">https://www.bilibili.com/video/BV1Y7411V7wW</a></p>
<blockquote>
<p>视频记得是 16 年的，很早就看过，不知道为什么 B 站上日期变成最近的了。</p>
</blockquote>
<p><br></p>
<hr>
<p><br></p>
<p>是不是觉得道理『平平无奇』。不要围观，只有下场体验过求圆满时 <strong>加无可加</strong> 的无奈，才能理解 <strong>减无可减</strong> 的『简单』不简单。</p>
<p>而且他说的，有严格的上下文限定。不看上下文就质疑『怎么可能只缩减到一条』，属于抬杠。</p>
<p>我当年通过人人网（那时好像还叫校内），看剑气之争，还有价值之辩知道他。当时太年轻，还试图在师弟师妹面前挑他理论的毛病。</p>
<p>他的话当然不是权威，认真挑也可以挑出毛病。但是他在 辩论——或者说对受众进行观念传达上，投入精力之多、程度之深，多数人比不上。这种深入，让他比一般人多考虑了几层；我看到的问题，有时考虑浅了，更高层面就不存在了；有时问题确实存在，但对核心来说无关紧要。</p>
<blockquote>
<p>这一节属于 『想要周全』 ，是 <strong>简单</strong> 的反面案例。</p>
<p>这些话跟主线相关性很弱，可有可无。抬杠的人那么多，堵得了多少个人的口。</p>
<p>不删了，留在这里当 <strong>具体</strong> 的例子，意不 <strong>意外</strong>？</p>
</blockquote>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把话说清楚，本质上是要传达的内容，让受众听（看）进去。重要的首先是 &lt;strong&gt;内容&lt;/strong&gt; ，然后是传达的 &lt;strong&gt;形式&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="语言表达" scheme="https://jaycechant.info/tags/%E8%AF%AD%E8%A8%80%E8%A1%A8%E8%BE%BE/"/>
    
      <category term="写作" scheme="https://jaycechant.info/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>听说 B 站 500+ 万粉丝 up 主被病毒勒索</title>
    <link href="https://jaycechant.info/2020/buran-virus-what-happens/"/>
    <id>https://jaycechant.info/2020/buran-virus-what-happens/</id>
    <published>2020-05-03T09:16:18.000Z</published>
    <updated>2020-05-04T01:01:32.429Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷 B 站，在首页刷到一个视频：百大 up 主，B 站全站排名第 13，拥有 500+ 万粉丝的『机智的党妹』，被“黑客”攻击并勒索了。</p>
<a id="more"></a>
<p>这个视频是 up 主自己讲述事情的经过，在 B 站日排行最高达到第五名。</p>
<h2 id="这篇文章想说什么"><a href="#这篇文章想说什么" class="headerlink" title="这篇文章想说什么"></a>这篇文章想说什么</h2><blockquote>
<p>我写文章容易跑题，想到啥说啥。现在尝试开头一问，收束一下思维方向。</p>
</blockquote>
<ul>
<li>有这么个事</li>
<li>简单解释发生了什么</li>
<li>一点点原理（我尽量不写那么长）</li>
<li>对此普通人能做什么防备</li>
</ul>
<blockquote>
<p>注：</p>
<p>Hacker 是指对设计、编程和计算机科学方面具高度理解的人，一开始是中性词，只有技术高超的意思。中文大部分地区译作 黑客，台湾地区译作 骇客。</p>
<p>Cracker 是指恶意（一般是非法地）试图破解某个程序、系统或网络，进而窃盗、毁损或使其瘫痪的人。正确译法应该是 破坏者，或者 溃客。</p>
<p>Cracker没有道德标准，也没有“黑客精神”。Hacker 建设，而 Cracker 破坏。</p>
<p>但是由于翻译混乱，Cracker 也经常被翻译成 黑客 和 Cracker，现在提起 黑客，往往指的是 骇客，这个污名已经很难洗清了。</p>
</blockquote>
<h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>我们根据党妹视频的自述，还原一下事件经过</p>
<h3 id="自建-NAS"><a href="#自建-NAS" class="headerlink" title="自建 NAS"></a>自建 NAS</h3><p>简单说，党妹作为头部 up 主，视频制作精益求精。视频素材开始用 4K 高清，视频里出现各种高端的换场景、换装混剪，好像还有异地外景，这就导致素材量噌噌噌从几百 M 慢慢变成了 <strong>几百 G</strong>。（变成了 几百 G 是党妹视频中的自述，变大的原因像 4K 这些是我大致浏览之前的视频后猜的。之前没看过她的视频，也不懂剪辑，有可能说错。）</p>
<p>而且专业化之后肯定是团队作战，素材拷来拷去很不方便，所以他们团队自建了一个 NAS （Network Attached Storage，网络附加储存）。可以理解为一个自建的网盘，或者说在内网的公共硬盘。</p>
<p>这个 NAS，投入了十几万，长时间测试维护，觉得可以了，启用。</p>
<h3 id="被黑"><a href="#被黑" class="headerlink" title="被黑"></a>被黑</h3><p>然后第一天就被黑了。所有文件被加密，留下一封勒索信，只有交了赎金才能拿回密码，重新解密。等于 NAS 上的视频素材被当做了人质（感觉人质哪里不对？文（件）质？素（材）质？）。</p>
<p>第一天 ……</p>
<p><br></p>
<p>因为视频制作精良，素材要求很高，成本涉及场地、设备、服化道、人工，甚至还有外景的差旅费。收入方面，500+ 万粉丝，按最近的视频平均 300 万左右的播放量，无论是创作激励还是潜在的一些商业合作，也是非常可观。无论从成本还是收入看，损失都很大。</p>
<p>但这个领域太新了，要立案，证据认定都成了个问题。几百 G 加密的乱码，怎么证明花了多少成本？还没发出来的视频，怎么证明能有多少收入？</p>
<h3 id="buran-病毒"><a href="#buran-病毒" class="headerlink" title="buran 病毒"></a>buran 病毒</h3><p>中的病毒叫 buran 勒索病毒。</p>
<p>上网搜了一下，国内网络安全机构在 19 年下半年就发出过安全预警，像这篇：<a href="https://s.tencent.com/research/report/817.html" target="_blank" rel="external">《腾讯安全预警：Buran勒索病毒传入我国，用户宜小心处理不明邮件》</a> ，</p>
<p>还有这篇： <a href="https://www.secpulse.com/archives/118852.html" target="_blank" rel="external">《利用IQY（Excel Web Query）文件分发，Buran勒索病毒又出新变种》</a> 。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>可惜我不是吃安全这口饭的，上来就讲加壳、特征码、漏洞、注册表 这些也不是我擅长的。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>『通过加密保护信息安全』，倒是可以聊聊。</p>
<p>假定你有一些隐私信息，不想被人看到。可是不巧，手机（或硬盘）要拿去修。想想当年 GX 哥的遭遇。</p>
<p>资料还有用，不能删。不仅不能删，随时用到，随身携带。唯一的办法，就是加密。</p>
<blockquote>
<p> <code>私房钱藏在鞋柜里的New Balance</code> </p>
<p>&lt;=&gt; <code>\u79c1\u623f\u94b1\u85cf\u5728\u978b\u67dc\u91cc\u7684\u004e\u0065\u0077\u0020\u0042\u0061\u006c\u0061\u006e\u0063\u0065</code></p>
<p>这种叫编码（Encode），不叫加密。字跟编码的对应关系是唯一的，像 <code>\u79c1</code> 唯一对应 <code>私</code> ，你不认识，计算机可熟悉，解码（Decode）就能恢复。例子里用的是 Unicode 编码。</p>
</blockquote>
<p>加密本质上是一系列特别复杂的 <strong>数学运算</strong> 。有意义的明文（原文）经加密运算之后得到无意义的密文。想重新得到明文，则要执行相反的解密运算。当然，如果大家都用一样的加密算法，解密没什么难的，所以加密过程还要引入一个变量：密钥（key，为了避免跟密码混淆，下面直接称 key）。加密算法一样，但每次 key 不同，不知道 key 就无法解密。（俗称的密码，实际上是口令（password），能通过运算转换成 key。）</p>
<p><img src="../../images/encryption.svg" alt=""></p>
<p>如果使用经过理论和实践证明过的强加密算法，例如 AES 和 RSA，加密后 <strong>只有知道 key</strong> 才能读取有效信息，否则只能读到一堆加密后无意义的乱码。</p>
<p>如果不知道 key，只能暴力穷举。2 bit 的 key （实际上不允许），只有 00, 01, 10, 11 四种，一下子就全部试完。可如果是常见的 256 bit 长的 key，总共有 $ 2^{256} \approx 1.1579209\times10^{77} $ 种。这是一个非常大的数，科学家推断整个宇宙中的原子数也不过在 $ 10^{78} \sim 10^{82}$ 之间。</p>
<p>假定计算机运算特别快，一秒能试 $ 10^{8} $ 个 key，也得 $ 3.6717431\times10^{61} $ 年才能试完，仍然是个天文数字。即使调动整个比特币网络 18 年时的算力（$ 3.5\times10^{19}  $ FLOPS），依然没有进入可以接受的范围。目前破解只有通过对硬件缺陷和人的疏漏（社会工程学）下手。</p>
<p>RSA 还要特殊一些，属于 <strong>非对称加密</strong> ，简单说，它加密解密不同同一个 key，而是使用成对的 公钥 和 私钥。密钥对虽然关联，但是拿着其中一个算不出另一个。所以 公钥 可以公开，这也是它为什么叫公钥。作为代价，生成密钥对很慢，不像 AES 随机一串就可以了。另外，RSA 加密运算也比 AES 慢。非对称加密还有更多用途，感兴趣可以自己了解一下。</p>
<p><img src="../../images/asym-encryption.svg" alt=""></p>
<h3 id="商业机密"><a href="#商业机密" class="headerlink" title="商业机密"></a>商业机密</h3><p>其实你手里的是一系列非常值钱的商业机密，是谈判的重要筹码。竞争对手偷走了电脑，一边尝试解密，一边跟你谈判。你早就预料到这么一天，文件很多，有可能在电脑还在执行加密时，对方就出现把电脑带走，停掉加密。该怎么设计加密方案呢？</p>
<ol>
<li><p>加密、解密 <strong>尽量快</strong> 。文件太多，别还没加密完就被发现了；要用的时候，也能尽快拿回来。</p>
</li>
<li><p>没有 key 时，<strong>暴力破解难度高</strong> 。</p>
</li>
<li><p>每个文件 <strong>独立 key</strong> 。就算暴力破解了一个，还有好多个。而且谈判时能解密一个作为筹码：不骗你，我真有密钥。</p>
</li>
<li><p><strong>只保管一个 key</strong> ，多了不好管。</p>
</li>
<li>就算 <strong>中途打断</strong> ，已经完成加密的文件也不会受影响。</li>
</ol>
<p>这里面 1 和 2，3 和 4 其实是矛盾的。但通过巧妙的设计，是可以鱼与熊掌兼得的。</p>
<ul>
<li>一开始，生成一对 512 bit 的 RSA 密钥对，把私钥送到安全的地方。RSA 生成密钥对很慢，但只生成一次。</li>
<li>文件用 AES 256 bit 的 key 加密，key 每次都重新生成。</li>
<li>每个 AES key 都用 RSA 公钥加密一下，跟对应的文件放在一起。RSA 加密相对较慢，但是 AES key 只有 256 bit，只能放下 32 个字母或者约 16 个汉字，还没这句话长，快慢几乎没有差别。</li>
</ul>
<p>看看效果：</p>
<ul>
<li>AES 生成 key 和 加密都很快，满足 1。慢操作只有生成 RSA 密钥对，只执行一次，影响不大，干脆设长一点。</li>
<li>每个文件独立的 AES key，满足 3。</li>
<li>AES key 加密之后跟文件放一起，不用记，只需要保管 RSA 私钥。满足 4。</li>
<li>无论是文件数那么多个 256 bit AES key，还是一个 512 bit RSA 私钥，破解难度都是天文数字。满足 2。</li>
<li>正在加密时被打断，拿到了 RSA 公钥，完全不影响前面完成加密的文件，满足 5。</li>
</ul>
<h3 id="Cracker-帮你加密"><a href="#Cracker-帮你加密" class="headerlink" title="Cracker 帮你加密"></a>Cracker 帮你加密</h3><p>以上加密方案真是兼顾了不同情况，考虑周到。可要不是你自己主动加密呢？</p>
<p>要是 Cracker 侵入你的电脑，帮你加密，密码在他手里呢？</p>
<p>外边有坏人寻仇，你把家人藏起来，防盗门锁起来，这叫『保护』；如果坏人把你家人藏起来锁起来，就变成什么了？</p>
<p>变成了绑架。</p>
<p><br></p>
<p>可是 Cracker 是怎么『帮你加密』的呢？</p>
<p>两种可能：远程控制你的电脑后运行病毒，或者诱导你运行病毒。</p>
<p>前者往往扫描 <strong>远程控制端口</strong> ，发现端口开着就开始暴力枚举密码。如果密码不长，没有混进特殊字符，或者干脆就是网上常见的弱口令，很快就被猜中了。也有可能系统有某些提权漏洞，没打对应的补丁。总之，现在 Cracker 就像用自己电脑一样，远程控制了你的电脑。</p>
<p>后者就是把病毒混在邮件、视频、文档、软件里，诱导你打开。你在打开 <strong>来路不明</strong> 的 邮件附件、小电影、文档、破解软件 时，病毒也悄悄运行起来了。</p>
<p>然后这个 buran 病毒就开始执行上面的加密操作。除此之外，它还做了一些额外工作（不一定全）：</p>
<ul>
<li>它加密所有文件，除了一些重要的系统目录、系统文件，避免系统崩溃。加密完把原来的文件彻底删除。</li>
<li>禁用系统自动修复功能、删除系统备份、删除RDP连接历史记录、删除系统日志，并且关闭系统日志开机启动。</li>
<li>生成勒索信。</li>
<li>事情完成之后，把各种痕迹删掉，把病毒程序删掉。</li>
</ul>
<h2 id="两难境地"><a href="#两难境地" class="headerlink" title="两难境地"></a>两难境地</h2><p>前面花了较长篇幅讲加密。看到那些天文数字，我想你能大致理解，不乖乖交赎金，文件可能回不来。除非安全研究员发现 Cracker 留下了什么漏洞，可以推算出 key。我觉得这希望不大。</p>
<p>但是另一方面，也没有办法确定，Cracker 收了钱一定会办事。如果对方得寸进尺怎么办？</p>
<p>所以，明明都是现成的技术，并没有很高深的地方，但是顶尖的网络安全机构，都束手无策。</p>
<p>最好的方法，其实是事前防备。由于最近打算限制文章字数，多写短文，这篇先写到这里。防备部分后续再发一篇接着聊。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刷 B 站，在首页刷到一个视频：百大 up 主，B 站全站排名第 13，拥有 500+ 万粉丝的『机智的党妹』，被“黑客”攻击并勒索了。&lt;/p&gt;
    
    </summary>
    
      <category term="科普" scheme="https://jaycechant.info/categories/%E7%A7%91%E6%99%AE/"/>
    
    
      <category term="安全" scheme="https://jaycechant.info/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>写作困难：你是否有类似的烦恼？</title>
    <link href="https://jaycechant.info/2020/difficulties-of-writing/"/>
    <id>https://jaycechant.info/2020/difficulties-of-writing/</id>
    <published>2020-04-29T09:03:15.000Z</published>
    <updated>2020-05-01T16:39:04.060Z</updated>
    
    <content type="html"><![CDATA[<p>从小到大，我在身边人眼里，大概算 能说会写。作文偶有评优，被当做范文；初中到大学一直当学生干部，大学打辩论；工作后每次培训都拿优秀，再到当企业内训讲师，和后面带技术团队。同学和同事，对我的表达能力评价不低。</p>
<a id="more"></a>
<p>可这样的我，经常憋不出文章。</p>
<h2 id="忠实记录"><a href="#忠实记录" class="headerlink" title="忠实记录"></a>忠实记录</h2><p>我知道自己在书面表达上不得要领。不擅修辞，行文口癖频现，不够准确精炼；内容组织上，也全凭运气。</p>
<p>我所一直依仗的，仅仅是忠实记录而已。刚好对一个主题有自己观点，落笔顺理成章，还显真诚——那本来就是真实想法；可如果没想法，或者命题方向不是真实观点，就很痛苦，拧巴地挤牙膏。实际上，上高中以后我作文发挥就非常不稳定，对命题议论文尤其抵触。</p>
<p>还好选的理工科，好赖把书念完，找了个工程师的工作，平时除了代码，再写写文档，写作的问题好像也没那么重要。</p>
<p>偶尔做培训准备材料，做技术介绍，写学习笔记，内容专业性强，有明确对错和优劣，带入的个人观点依据也非常清晰。这些课纲和文章，成文有一些口癖，大致上是通顺易懂的。这走的还是忠实记录路线，没了高考作文的压力，觉得这样也没什么不对。</p>
<h2 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h2><p>可我不光写技术，也不能光写技术。</p>
<p>『宝藏男孩』、『行走的百科全书』….. 恭维话听多了，心里清楚大家过誉了，还是会窃喜，觉得可以总结一些经验想法和大家分享。另一方面，希望以输出带动思考和学习，让自己进步。就有了博客和公众号的记录，当下姑且叫做『存档计划』，开始增加非技术的内容。</p>
<p>写着写着，老问题还在，不能说彻底写不出，但输出效率显然太低，之前绕开的石头，再次挡在路上。</p>
<p>以前只是没想法或者观点冲突时卡壳，现在哪怕写亲身的体会，明明洗澡、躺床上、排队时想得好好的，等坐下面对键盘或纸笔，就写不出来了。同样的内容，有人来问，不管是面对面、语音、还是 打字，能很流畅讲给对方听；换做写成文章分享给更多人，又卡了。感觉自己是 <strong>装饺子的茶壶</strong> ，非常难受。</p>
<p>继续写技术科普，很顺畅，不缺技术主题，可以一直写下去。但这样写技术类的成就感，会掩盖掉非技术类存在的问题。最近要求自己每写几篇技术文章，中间来一篇非技术内容，如果写不出，技术内容也跟着暂停。要直面这个问题。</p>
<h2 id="技术原因"><a href="#技术原因" class="headerlink" title="技术原因"></a>技术原因</h2><blockquote>
<p>这个技术不是 Technology 的意思，而是 Cause in Technique，也就是战术操作上的原因。</p>
</blockquote>
<p>这些年断断续续在思考，和尝试不同的工具。但一天不整理输出，思考始终还处于混沌的状态。现在逼着自己整理这个话题，变成了一个 <strong>元叙述</strong>。亦即，整理的内容本身，就是关于整理的过程；整理过程本身，恰恰就是对整理成果的 尝试 和 验证。这是一个痛苦并有趣的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%% 下面这个图，不是画出来的，而是用键盘直接敲出来的。如果你感兴趣，留言告诉我。如果大家都感兴趣，我就找机会介绍一下。</div><div class="line">graph TD</div><div class="line">  st(开始)--&gt;thk[/之前的思考/]--&gt;idea[(想法的集合)]--&gt;arr[整理成文]--&gt;diff&#123;&quot;有困难吗？&quot;&#125;</div><div class="line">  diff--&gt;|&quot;很顺利&quot;|ed(输出)</div><div class="line">  diff--&gt;|&quot;又卡了&quot;|whyhow[&quot;思考为什么/怎么办？&quot;]--&gt;add[加入想法集合]--&gt;idea</div></pre></td></tr></table></figure>
<p><img src="../../images/difficulties-of-writing.svg" alt=""></p>
<h3 id="1-口头和文本的差异"><a href="#1-口头和文本的差异" class="headerlink" title="1. 口头和文本的差异"></a>1. 口头和文本的差异</h3><p>能聊不能写，是因为口头交流和文本，是两套体系。即时通讯虽然打字，内容节奏仍然是口头交流。</p>
<ol>
<li><p>交流有明确 <strong>上下文</strong> ，参与者都知晓，无需赘述。</p>
<p> 一旦面向更多读者，背景突然需要解释，三言两语未必解释得清。</p>
</li>
<li><p>交流有 <strong>时效性</strong> 。</p>
<p> 随着对话的推进，你不会也不可能太在意发言的严谨性；不会每说一句话都斟词酌句，大家在等着；也不会动不动挑别人话里的刺，除非影响理解了。随着对话推进，错误要么被忽略，要么被补充。</p>
<p> 一旦落实成公开文本，到处是漏洞，（我怕）在缺乏上下文的语境里，会被读者误解和放大。</p>
</li>
<li><p>交流有 <strong>实时反馈</strong> 。</p>
<p> 参与者的理解程度和评价，都是实时响应。不解和负面评价，可以马上做出反应；正面反馈，则给了继续交流的信心。单向文本输出失去了这些，作者只能想象读者的接受度。强迫症如我，陷入说不清和太罗嗦的两难。</p>
</li>
</ol>
<p>把一个还算满意的交流过程录音，原样转成文本，尝试直接发表，就会发现两者之间的鸿沟。</p>
<h3 id="2-想法稍纵即逝"><a href="#2-想法稍纵即逝" class="headerlink" title="2. 想法稍纵即逝"></a>2. 想法稍纵即逝</h3><p>一个想法的诞生，除了对问题持续的实践与思考，还需要松弛的精神状态，和特定情景触发。那么这个短时记忆，产生时的状态、触发的情景没有了，离开最初的时间地点越远，面容越模糊。</p>
<p>记录不方便，或者自信『这么印象深刻的想法一定不会忘』，那么大概率到有空整理时，已经丢失了大量的细节。偏偏某些细节才是关键，一旦忘记，余下部分就重归混沌与平庸。</p>
<p>更糟糕的是一下子冒出多个想法，互相干扰，大大缩短遗忘时间。</p>
<h3 id="3-思维与文本的差异"><a href="#3-思维与文本的差异" class="headerlink" title="3. 思维与文本的差异"></a>3. 思维与文本的差异</h3><p>思维的特点，和文本记录，差别很大。</p>
<p>大脑思考和记忆，是通过一系列离散信息的关联来完成的。对某个复杂的主题，大脑不像硬盘，并没有一个地方储存着这个主题的文本，一字一字线性地读或者写。而是大量零散信息，储存在不同神经元的关联里；这些信息的进一步兴奋关联，构成了更复杂的主题，以此类推。它是金字塔或者说树的结构——考虑到存在跨子树和叶子的关联，有环，其实是网状结构。</p>
<p>大脑思考时，会尝试调取已有的记忆，去解释、解决当前问题。就好像在 <strong>拼拼图或者立体模型</strong> ，去翻找用得上的零件（想象大量的、好多套零件混在一起，不是每个都用得上，需要的也不一定都有）。思维的跳跃因人而异，不同人的知识结构差异很大（怎么找，依赖零件怎么放，平时有没有整理）。</p>
<p>如果严格按照拼图从左上到右下的刻板顺序，只能盯着当前拼接位置，一块块试，接得上留下，接不上丢回去。海量候选零件，等于在蒙，全凭运气。这就是文本线性记录的特点：<strong>在没想好的地方卡住，先想到的却暂时找不到安置之处</strong> 。碰到『易碎』零件，没用上丢回去，碎了，下次要用也找不到了。</p>
<p>思维本身不受顺序限制，要有一个框架，把思维丢过来的有用零件，都先接住。</p>
<h2 id="改善办法"><a href="#改善办法" class="headerlink" title="改善办法"></a>改善办法</h2><p>能清楚界定问题，对症下药改善，反而简单。</p>
<h3 id="1-找一个倾诉对象"><a href="#1-找一个倾诉对象" class="headerlink" title="1. 找一个倾诉对象"></a>1. 找一个倾诉对象</h3><p>找一个听众。能懂相关话题，积极反馈，很好。</p>
<p>对方不懂，愿意听，也很好（参考费曼技巧）。</p>
<p>一时找不到人，一个玩偶，或任意拟人的东西，对着它说，提供的心理暗示也很有用（参考小黄鸭调试法）。</p>
<p>重要的，是有人倾听的交流感。一个人时，可以想象一个目标听众，（当作）录音给 TA 听，来增强感觉。</p>
<h3 id="2-实时记录"><a href="#2-实时记录" class="headerlink" title="2. 实时记录"></a>2. 实时记录</h3><p>实时捕获想法，不要相信当时『茅塞顿开』或『印象深刻』的感觉。</p>
<p>这句话的意思是，不要相信以后会记得，要马上记录；也不要高估这个想法起的作用，需要长时间坚持记录，才有可能从大量想法里，筛选出一些有用的。记录时尽量不要前置甄别，幼稚的念头也有启发意义，而且删除很容易；等发现那个想法确实很关键，可能就想不起来了。</p>
<p>随时记录包括两个方面： </p>
<h4 id="a-用工具降低记录成本"><a href="#a-用工具降低记录成本" class="headerlink" title="a) 用工具降低记录成本"></a>a) 用工具降低记录成本</h4><p>纸笔党可以随身携带小型记事本和笔，参考类似 Moleskine 的绑带记事本，绑一支笔。要不要 Moleskine<br>这个意大利牌子，见仁见智。个人觉得不必要，洇墨的无酸纸对不起招牌和价格。</p>
<p>再学习一些视觉笔记的符号，了解一点思维导图，尽量做到快速勾勒想法，而不是一字一句抠字眼。</p>
<p>不拘泥于纸笔，或者像我这样写字画画手残的，要感谢智能手机，提供了很多方便的工具：</p>
<ul>
<li><p>录音</p>
<p>  适合特别复杂又稍纵即逝的想法，快速而忠实地记录。</p>
<p>  缺点是，录得多了整理麻烦，一般的内容没有动力整理就堆积了。能找到带识别的录音就更好了，可以作为整理时的参考。</p>
</li>
<li><p>记事本 + 语音输入法</p>
<p>  如果不录音，以输入法识别结果作为唯一记录，语音识别的正确率一定要高。谁都不想说了一堆话之后，还要对着识别结果一个一个修改错误。适合篇幅长的内容，避免后续人工转换成文本的负担。</p>
<p>  缺点是，如果记录时识别错误没有发现，有一定概率事后会想不起原本的意图。</p>
<p>  免费的中文语音识别这块，暂时没有发现比讯飞做得好的。（如果有更新更好的选择，欢迎留言告诉我。讯飞打钱！）</p>
<p>  输入法只是转换，内容还需要一个载体，你需要一个能秒开的记事本。这里记事本是泛指，跟每个人用的手机、使用软件的习惯有关，需要亲自试用体验。</p>
</li>
</ul>
<h4 id="b-培养随时记录习惯"><a href="#b-培养随时记录习惯" class="headerlink" title="b) 培养随时记录习惯"></a>b) 培养随时记录习惯</h4><p>将记录内化成一个下意识动作。尽量地有想法就记录，不假思索，不经筛选，肌肉记忆，快速完成。</p>
<p>然后每隔一段时间，找一个集中的时间段，整理记录。</p>
<p><br></p>
<p>一定是 a) 先做出改善，再尝试做 b)，顺序不能颠倒。在觉得一个事情执行起来非常不便时，就强迫自己养成习惯，会浪费注意力，难以坚持，还损害自我评价。这是长期跟『劣根性』斗争后的体会，一定要顺应人性。</p>
<h3 id="3-结构化记录"><a href="#3-结构化记录" class="headerlink" title="3. 结构化记录"></a>3. 结构化记录</h3><p>既然大脑不习惯像打字机那样线性思考，就让记录过程迁就大脑，像思考过程那样 跳跃、发散、立体。这种记录的方式需要：</p>
<ul>
<li>能快速建立『框架』</li>
<li>能快速定位框架上的『节点』</li>
<li>方便修改，无论是节点内容，还是框架结构</li>
</ul>
<p>有些笔记达人理解原理之后，靠自己定义的符号就清晰记录。但手残党及纠结怪如我，频繁改结构，笔记很快会变得面目全非无法维护，需要引入工具协助。</p>
<h4 id="卡片笔记法"><a href="#卡片笔记法" class="headerlink" title="卡片笔记法"></a>卡片笔记法</h4><p>纸笔党可以考虑这个方法。本质上，就是拆散的、原子化的、方便索引和重新组织的笔记本。</p>
<p>很多大师都用这个方法，能马上想到的，就有 钱钟书 和 博纳科夫。钱钟书一生积累的卡片，据说近十万张。</p>
<p>做法非常简单，准备索引卡 + 铅笔，开头的一到两张卡片写下概括性的内容和大纲，然后索引到每张卡片写具体内容。内容较多条目，可以再嵌套一层，先写概括和大纲，索引到一张新卡片展开，写不完索引到下一张。互联网时代这种形式很好理解，就是一个纸质的网站，每页大约一条微博大小，带着指向其他页面的『链接』。</p>
<p>上面是 『自顶向下分解』(top break down) 的写法，有了大纲再丰富细节。有时是先想到某些具体的点，再逐渐拼凑出全貌，叫『自底向上构建』(bottom build up)，就是先写内容卡片，再概括和索引。</p>
<p><img src="../../images/card-note.svg" alt=""></p>
<p>每张卡片不大，很容易写满，给到 <strong>阶段性完成的反馈</strong> 。微博时代相比博客时代，创作量突然大增，就是因为字数越少，创作门槛越低。随手写 20 条 140 字的微博，远远比 2800 字文章容易的多 —— 前者只需 140 字内的自洽，后者需要 2800 字的思路。</p>
<p>但一个内容也不至于分很多张写，频繁换卡片 <strong>提醒我们</strong> 考虑再分一节。通过恰到好处的容量设置，同时达到这两个目的。</p>
<p>需要强调的是，不要心疼卡片，你的思考比卡片宝贵。铅笔 和 橡皮，是为了不浪费只需要小改的内容，而不是省卡片。</p>
<p>（类似 <code>$0IWc1NrJyw3$</code> 这种索引卡片，十块左右 210 张，哑光耐擦写，大小至少写得下 50 字，但又不会太大，推荐横线款而不是格子或者纯色款；铅笔是为了可修改。）</p>
<p><br></p>
<p>索引卡接近纸笔的终极解决方案。相关的卡片放一个盒子，或者打个孔穿起来，除了量大时 保存 和 人工索引 费点劲，找不到更多缺点。</p>
<p>但手残 + 习惯了软件解决方案的我，还是会寻求软件工具。当然，索引卡方案如此优秀，软件方案不同程度上是它的信息化版本。</p>
<h4 id="a-wiki-工具"><a href="#a-wiki-工具" class="headerlink" title="a) wiki 工具"></a>a) wiki 工具</h4><p>可以理解为个人版的维基百科。wiki 是项目管理中标配的知识管理工具。</p>
<p>一页相当于一张卡片，里面可以写正文，也可以添加到其他页的链接。除了单页字数不限，所有特性跟卡片笔记一一对应。</p>
<p>用过两款 wiki 软件，monowiki 和 zim wiki，其中zim wiki 使用了很长时间。基于以下原因，最近已经很少使用：</p>
<ol>
<li><p>页面的概念太重</p>
<p> 我的意思是，wiki 的使用，总是倾向于写详细的页面内容，而不是写大量小片段然后链接。</p>
<p> 一方面是由于 wiki 页面最初的设计，就是主题的详细介绍（参考维基百科，以及各种软件的 wiki 页）；另一方面是由于第 2 点，频繁的链接实际上不方便查看。</p>
</li>
<li><p>难以获得全局视角</p>
<p> 卡片获得全局视角，只需要在桌子上摊开摆放。wiki 聚焦于一页，同时查看很多页非常麻烦（受限于同时打开网页的操作和屏幕大小），甚至不可能。</p>
</li>
<li><p>移动体验</p>
<p> 这是放弃 wiki 的最后一根稻草。智能手机时代，没有找到比较合适的多段同步的 wiki 工具。将个人 wiki 服务搭建在公网，维护成本太高。最后，小屏幕让跨页面浏览编辑变得更难。</p>
</li>
</ol>
<h4 id="b-思维导图"><a href="#b-思维导图" class="headerlink" title="b) 思维导图"></a>b) 思维导图</h4><p>思维导图很好地解决了 单节点过大 和 全局视角 的问题。在 PC 上，我长时间地交替使用 XMind 和 FreeMind 两款软件。只要稍微熟悉快捷键，就能获得非常流畅的编辑体验。但同样因为一些原因，思维导图也变成了后备方案：</p>
<ol>
<li><p>重图轻文</p>
<p> 导图强调图的概念，编辑然后导出图片倒是方便。可整理思路最终是要成文的。</p>
<p> FreeMind 好一点，可以全选，复制粘贴到文本后，还保留层次结构，导出选项里也有 odt，可以用别的工具（pandoc）再转到目标格式。XMind 复制粘贴后只有缩进，丢失了层次结构，稍特殊的导出格式都要收费。</p>
</li>
<li><p>移动体验</p>
<p> 移动体验同样是让我放弃的最后一根稻草。手机上思维导图软件并不少，也有个别趁手，但跟 PC 不是同一个软件，使用体验割裂，增加同步和转换成本。稍好一点的全平台同步方案，并不便宜。而且无论哪一个，小屏幕让强调图属性的编辑更为不便。</p>
</li>
</ol>
<h4 id="c-大纲工具"><a href="#c-大纲工具" class="headerlink" title="c) 大纲工具"></a>c) 大纲工具</h4><p>新的选择是大纲编辑工具 Workflowy。考虑到速度，本地化等问题，推荐国内的模仿者 <strong>幕布</strong> 。</p>
<p>幕布在宣传时，有强调 随时转思维导图。这确实是一个杀手级特性，让轻度用户又少一个打开思维导图软件的理由。但并不是我选择幕布的主要原因，幕布也 <strong>不是一个思维导图软件</strong> 。</p>
<p>幕布编辑的是大纲。所谓大纲，是类似目录的东西，是『显示层级关系和树状结构型态的一种清单』。它的逻辑含义跟最基本的思维导图一样，是一棵树。</p>
<p><img src="../../images/outline.png" alt=""></p>
<p>幕布称大纲上的节点为『主题』，主题下可以挂正文。主题之间并列或从属，构成整个大纲。我们很容易联想到，主题=卡片。</p>
<p>把幕布当作首选解决方案的理由有：</p>
<ul>
<li>Enter=新增主题，Tab=缩进主题，Shift+Tab=提升主题，<strong>三个操作</strong> ，轻易构建大纲。</li>
<li>拖动主题前的小圆点可以把主题 <strong>拖到任意位置</strong> ，从属的子主题会跟着移动！这个操作，把主题真正变成了任意调整关系的卡片。也可以选中多个主题剪切粘贴，层次结构同样保持不变。</li>
<li>点击小圆点可以『 <strong>下钻</strong> 』，就是把选中主题变成根主题，专注于局部的内容。也可以 <strong>折叠</strong> 任意主题，隐去细节，只关注上层的结构。这是比图片缩放更精确的层次缩放功能。</li>
<li>跨平台使用体验一致，打开和同步速度尚可。基本功能免费版够用，如果需要无限主题（免费限 200 每篇）和 高级导出，9 元 / 月 或 90 / 年 的会员可以接受。</li>
</ul>
<p>还有 多条件搜索，标签分类 等功能，试用一下就知道了。多数功能思维导图也有，但在文本大纲上实现，并且随时可以转换成思维导图，比较少见（也有人说 Workflowy 模仿的 Emacs 的 org-mode）。</p>
<p><img src="../../images/export-mind-map.png" alt=""></p>
<p>更极致的用法，是只建一个文档，在文档中为所有冒出的想法找到位置，把幕布变成大脑知识的映射。幕布的 Slogan 正是『管理你的大脑』。</p>
<p>如果说还有什么不满意，编辑和导出不支持 Markdown，正文不支持和子主题混排。但这些实现起来跟底层的 OPML 格式有冲突，所以不抱期望。我只用幕布写大纲，想法成型后导出到 Typora 完成细节编辑，格式自己通过 pandoc 解决。</p>
<p>如果你也想试一下，微信扫邀请码注册，可以在原有关注官方公众号送 15 天会员的基础上，多送 15 天。 4 月 26 之前注册本来有一个周年庆抽奖，最差也得 3 个月。但那时没空写文章，只在朋友圈和知识星球提醒了一下。</p>
<p><img src="../../images/mubu-invite.png" alt=""></p>
<p><br></p>
<p>这节本质上还是引入工具，降低认知负担。但不是简单的加快速度，重点在顺应思考的习惯，帮助梳理思维。</p>
<h2 id="问题的根本"><a href="#问题的根本" class="headerlink" title="问题的根本"></a>问题的根本</h2><p>上述问题都解决掉，是不是就写出文章了？</p>
<p>很遗憾，不是。</p>
<p>战术的勤奋，不能解决战略的无力；技巧的熟练，不能填充思想的空白。</p>
<p>散乱的拼图固然可能隐藏了精美的思想蓝图，也可能美化了一团乱麻。把思路理清楚了，可能会揭露一个残酷的事实：想不明白，苦苦思索整理的成果 <strong>没有价值</strong> ——用力越猛越意味着，<strong>我没有这方面才能</strong>。</p>
<p>技巧可以把 50 分变成 60，不及格变及格；从 70 到 80，一般变优秀；但不可能把 10 变成 60，50 变成 100。</p>
<p><br></p>
<p>结论很伤人，却恐怕道出了大部分的真相。</p>
<p>这些技巧仍然是有用的，这个结论也是有启发性的。</p>
<p>过去很长的时间里，我根本不知道问题出在哪里。写作技巧 很容易成为替罪羊，毕竟比起承认自己的无知，缺乏技巧更好接受。可一旦下决心解决技巧问题，去掉干扰因素，结论很容易就水落石出：</p>
<ul>
<li><p>如果是整理和表达问题，梳理之后文章就出来了。</p>
</li>
<li><p>如果整理的成果显得浅薄，高估了自己的见解，承认就好。才能除了天赋，还有大量的投入时间。技术类的文章顺利的根本原因，是因为在提笔之前，我就投入了大量的实践时间。</p>
<p>  问自己要达到期望的水平，还要继续投入多少时间？值不值？</p>
<ul>
<li>其实不那么感兴趣，没那么重要，投入太高，完全可以放弃掉不写，回归擅长的内容。再遇到同类问题，求助专业人士。</li>
<li>很感兴趣，很重要，绕不过去。只能多花时间，多实践，多读书， <strong>求教</strong> 专业人士。</li>
</ul>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Last but not least.</p>
<ul>
<li><p>警惕宏大-叙述的冲动，多做小而局部（local）的叙述。</p>
<p>  宏大指的是，构建严密的、无所不包的自洽观点的尝试。有时输出显得浅薄，除了水平问题，还有可能是选择了过于宏大的框架（俗称 hold 不住）。一些见解，放在特定的上下文，是可以新颖且自洽的；可一旦放到更大的框架里，突然就会显得自相矛盾。就像编程多用 局部作用域（local scope），少用不用 全局作用域。</p>
<p>  本文就因为 <strong>自我指涉</strong> ，而构成了艰难的元叙述。在发现这是一个无底洞之后，赶紧收尾。</p>
</li>
<li><p>本文写得很混乱，删改的字数比能看到的多得多。我愿意把它看做认真看待 『如何思考、整理、写作』的开始，而不是想清楚之后的总结。</p>
</li>
<li><p>有独特见解，善于整理表达，只是第一步。借用严复的译事三难，仅仅是信（准确）。还要锤炼遣词造句，让表达更简练精准，是为达（流畅）。更进一步，考虑文章节奏、音韵 乃至 意象 的美感，是为雅（优雅）。后面境界，感觉离我有点远，感叹一句，读书太少。</p>
</li>
<li><p>文中提及脑神经科学和心理学的内容尚无很确切的结论，以后有可能被更新的理论代替。</p>
</li>
<li><p>文中不多的推荐，没有收钱。</p>
</li>
</ul>
<p>篇幅所限，未尽话题，以后接着聊。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从小到大，我在身边人眼里，大概算 能说会写。作文偶有评优，被当做范文；初中到大学一直当学生干部，大学打辩论；工作后每次培训都拿优秀，再到当企业内训讲师，和后面带技术团队。同学和同事，对我的表达能力评价不低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://jaycechant.info/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>域名解析从 DNSPod 到 Cloudflare</title>
    <link href="https://jaycechant.info/2020/name-server-from-dnspod-to-cloudflare/"/>
    <id>https://jaycechant.info/2020/name-server-from-dnspod-to-cloudflare/</id>
    <published>2020-04-10T15:11:52.000Z</published>
    <updated>2020-04-12T05:22:10.791Z</updated>
    
    <content type="html"><![CDATA[<p>个人博客托管在 Github pages，居然也快 8 年了。省事，不花钱。<br>前几年我又给它配了域名，解析用的免费 DNSPod 。（被腾讯收购是后来的事）</p>
<p>近期折腾技术上的事，了解到 Cloudflare 也有免费域名解析，而且居然带免费 CDN 和 DDOS 保护，有点动心。</p>
<a id="more"></a>
<h2 id="换-Cloudflare-的念头"><a href="#换-Cloudflare-的念头" class="headerlink" title="换 Cloudflare 的念头"></a>换 Cloudflare 的念头</h2><p>必须说，CDN 可有可无。虽然 github.io 服务器在国外，有时访问确实有点卡，CDN 可能改善一下，但也没到非缓存不可。而且 CDN 的缓存，会让修改和发布时，生效有延迟，不能马上看到。</p>
<p>至于 DDOS，谁有空攻击我呢。</p>
<p>这多出来的功能，属于 <strong>鸡肋</strong>。为什么我还是动心，折腾了呢？</p>
<ol>
<li><p>Cloudflare （以下简称 CF）作为盛名在外的服务商，它的解析服务不至于太烂。</p>
<p> 我只用过 DNSPod （以下简称 DP）的服务，如果以后需要用别家的，容易抓瞎。花点时间换个差不多的免费服务，可以了解一下各家的差别。</p>
</li>
<li><p>CDN 和 DDOS 保护，暂时鸡肋，但是开了也不至于有害（搞不好真香）。那么体验一下，日后需要这些功能时，值不值得弄、要怎么操作心里也有底。</p>
</li>
</ol>
<p>说白了，这是我做事的习惯：在不紧迫时，多折腾不同方案，建立起判断的基线。最坏也不过得出一个『CF 真烂，DP 真香』的结论，然后迁回去。</p>
<h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><p>注册 CF 帐号，选择免费方案，输入域名，很快就导入了当前的 DNS 记录（但是不全）。</p>
<p>然后会提醒 Name-server 不是他们家，给出他们的两个 Name-server 地址。每个人拿到的地址可能不一样，以 CF 给的为准。据说不用他们家的解析，也能用 CDN，我没研究。</p>
<p>去到域名注册商，把 Name-server 改过来。等了一下，刷新，注册商那边显示生效了。</p>
<p>回到 CF ，因为注册时刚检测过 DNS，下一次自动检测还要好久，可以手动点一下检测，然后就开始排队。过了不久，检测之后发现 Name-server 记录已经指过来了，就显示域名已经在 CF 的保护下。</p>
<p>上面一排功能按钮，起码看起来是比 DP 厉害的样子（当然不排除 DP 也有类似功能，只是它没摆出来，我也没探索过）。</p>
<p>首先把 DNS 记录缺的照抄过来（已经忘了缺哪几条了），DP 那边的记录有这些</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>域名</th>
<th>目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNAME</td>
<td>@</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>*</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>www</td>
<td>jaycechant.github.io</td>
</tr>
<tr>
<td>CNAME</td>
<td>qqmailxxxxx （这串码每个人不同）</td>
<td>mail.qq.com</td>
</tr>
<tr>
<td>MX</td>
<td>@</td>
<td>mxdomain.qq.com (priority:5)</td>
</tr>
<tr>
<td>MX</td>
<td>@</td>
<td>mxdomain.qq.com (priority:10)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>@</code> 代表根域名。同时注册 <code>@</code> , <code>*</code> , <code>www</code> ，是因为这个地址暂时只有博客，当时希望访客就算自动补上 www，或者输了随便哪个子域名，也能访问到（当然这个配置也是当年不求甚解抄网上的）。</li>
<li>也注册了域名邮箱。不要问我为什么一样的内容，要添加不同优先级的两条记录，QQ 邮箱教程这样写，照做而已。（现在 QQ 域名邮箱已经停止注册和新增邮箱了，已经注册的还能用，但新注册或者新增只能注册一个企业微信用企业邮箱。）</li>
</ul>
<p>把记录都抄过来之后，看起来差别只有两个地方：</p>
<ul>
<li>CF 有一项功能叫 CNAME flatterning，会自动把 <code>@</code> 替换成实际的根域名（<code>jaycechant.info</code> ，记录 Name 栏显示的就是完整域名），然后把指向的域名解析成实际的地址（但记录 target 栏显示的还是域名）。声称加快 30% 解析速度。只有根域名会这样做，相当于帮你生成了 根域名的 A 记录。</li>
<li>右边多了一列图标，点击在两种状态切换：箭头穿过黄色的云（Proxied）表示开启了 CDN 缓存，箭头绕过灰色的云（DNS only）表示关闭。MX 记录不能打开缓存。想体验一下，就把 CDN 打开了。</li>
</ul>
<p>配置完等了一会，博客还能访问。不确定是缓存还在起效，还是新的设置已经生效（其实也没差别）。于是去 DP 把原来的域名解析删掉。</p>
<h2 id="redirect-loop-和-1016"><a href="#redirect-loop-和-1016" class="headerlink" title="redirect loop 和 1016"></a>redirect loop 和 1016</h2><p>再等了一会，终于能看到差别：博客访问不了。错误是 ERR_TOO_MANY_REDIRECTS。</p>
<p>（参考 <a href="https://kinsta.com/blog/err_too_many_redirects/）" target="_blank" rel="external">https://kinsta.com/blog/err_too_many_redirects/）</a></p>
<p>按照 Chrome 提示和找到的建议，清浏览器缓存，清 CF 缓存，都没有用。可能是有 redirect loop。</p>
<p>于是我先关掉了 CDN，删了根记录（我也不知道当时为什么想到删根记录，可能当时还没理解好），好了，报新的错误了 Error 1016 ……</p>
<p>在好好学习，终于理解 1016 是什么意思之后，终于也知道根记录的重要性，加回去，继续 ERR_TOO_MANY_REDIRECTS……</p>
<p>问题似乎出在 通配符（wildcard）记录。根据查到的说法，每个服务商对 wildcard 的支持会不一样。我想，好像也没必要支持除了 www 以外的二级域名，就把这条记录删了（鬼知道当年跟哪里抄的做法），好了。</p>
<blockquote>
<p>注：敲下这些文字已经是第二天，我尝试找到背后的原因。重新按照之前的配置，加上 wildcard record，关掉 CDN ，清掉各种缓存，甚至尝试换个浏览器，用 curl 跟踪，都没能重现 ERR_TOO_MANY_REDIRECTS。</p>
<p>有可能这是两个 DNS 服务部分失效部分生效时产生的 edge case。可惜当时没想到跟踪 redirect ，了解具体是哪几个地址形成了 loop。</p>
<p>不过即使 wildcard record 不会引起错误，随便输一个子域名跳转到 <code>jaycechant.github.io</code> 还是 404，这条记录没有实际意义，最后还是删掉了。</p>
</blockquote>
<h2 id="Page-Rules"><a href="#Page-Rules" class="headerlink" title="Page Rules"></a>Page Rules</h2><p>然后测试 <code>www</code> 记录。（由于是默认主机名，有些人会习惯加，这条记录还是有用的）</p>
<p>结果是能访问，但会报安全提醒。这是因为证书是颁发给 <code>jaycechant.info</code> 而不是通配符域名 <code>*.jaycechant.info</code> ，<code>www.jaycechant.info</code> 不在范围内。</p>
<p>为什么不直接签一个通配符证书呢？因为证书不是自己申请的，而是在 Github pages 配置时，输入域名，Github 代为申请的。Github 官方的文档看这里：<a href="https://help.github.com/en/github/working-with-github-pages/about-custom-domains-and-github-pages。" target="_blank" rel="external">https://help.github.com/en/github/working-with-github-pages/about-custom-domains-and-github-pages。</a></p>
<p>这时发现了 CF 提供的 <strong>Page Rules</strong> 功能，可以编写规则，对满足特定条件的地址，应用某些功能，包括 Always Online （通过缓存实现）、Always use HTTPS （估计通过 301 实现）、Auto Minify 等等 20+ 个功能。</p>
<p>这里用到 Forwarding URL，可选 301（Permanent）和 302（Temporary）：</p>
<p><code>www.jaycechant.info/*</code>  -&gt;  <code>https://jaycechant.info/$1</code>，支持通配符，而且可以通过 <code>$1</code> , <code>$2</code> 这样的变量按顺序引用。</p>
<p>免费版仅提供 3 条规则，目前来看，不搞复杂的规则，够了。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>说回 CDN。</p>
<p>从我有限的尝试看，结果基本如我所料，开启 CDN 会让页面加载变快，同时修改应用有延迟。但必须说，这两个效果起码在这两天，差距都不算很大。</p>
<p>据官方说，国内他们是和百度 CDN 合作的，确实也是秒加载，不明显只能说原来直连 Github 还不够卡。</p>
<p>延迟方面，从上传完毕开始计时，一直刷新，到刷出更新的内容停止，大约 45 s。这个数字看着很大。但是要知道，上传完到 Github 发现变更，然后部署生效，也是有延迟的。而且 CF 还提供 Development Mode 开关，临时绕过缓存。（这个开关是 3小时自动关闭的，不用自己手动关。非要说麻烦的地方，就是还得登录 CF。）</p>
<p>总结下来，开没开 CDN 最明显的差异就是……证书不一样：没有 CDN 时，证书是颁发给 <code>jaycechant.info</code> 本身的，开了之后证书是颁发给 <code>sni.cloudflaressl.com</code> 。（那为什么证书地址和博客地址不一样居然能通过名称验证呢？这就要提到 SNI 了 ：<a href="https://zh.wikipedia.org/wiki/服务器名称指示" target="_blank" rel="external">服务器名称指示</a>）</p>
<p>综合下来最后还是没开 CDN。如果有一天直连 Github 卡得不行了，我再回来。</p>
<h2 id="Cloudflare-workers"><a href="#Cloudflare-workers" class="headerlink" title="Cloudflare workers"></a>Cloudflare workers</h2><p>最后提一个意外发现，Cloudflare 支持 edge computing workers，从一开始只有 js，到现在支持 js, Rust, C, C++，相当于一个 FaaS。提供了两种方案。</p>
<p>免费方案：</p>
<ul>
<li>Includes <strong>100,000 requests per day</strong> (UTC+0)</li>
<li>Up to 10ms CPU time per request</li>
<li>Lowest latency after the first request</li>
<li>Up to 30 Workers</li>
</ul>
<p>每个月花 5刀：</p>
<ul>
<li>Includes <strong>10 million requests per month</strong></li>
<li>Up to 50ms CPU time per request</li>
<li>Always lowest latency</li>
<li>Up to 30 Workers</li>
<li><strong>Key-value storage:</strong><ul>
<li>Up to 100 namespaces</li>
<li>1 GB of storage</li>
<li>10 million read operations, 1 million write, 1 million delete, and 1 million list operations</li>
</ul>
</li>
</ul>
<p>这能用来干嘛呢？要知道 Github pages 是静态托管，有限动态部分只能是浏览器端的 js，像评论这种功能就要引入额外的服务器和储存。所以第一反应就是可以运行一个评论服务，然后作为插件加入博客中。</p>
<p>它不限流量，限请求次数和每次请求的 CPU 时间。免费版每天 10 W requests ，完全够用了。</p>
<p>等等，带储存的吧，好像有 workers KV 服务。哦，KV 只有收费版才有啊，那打扰了，等我想到新的应用场景再回来……</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>最后列一下用到的工具和命令，备忘（如无备注，均是 Windows 下）</p>
<ul>
<li>清除 DNS 缓存 <code>ipconfig /flushdns</code></li>
<li>查找当前 dns 指向 <code>nslookup &lt;domain&gt;</code></li>
<li>输出详细解析和重定向过程 <code>curl -v -L &lt;domain&gt;</code> （Windows 不带，需要额外安装）</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人博客托管在 Github pages，居然也快 8 年了。省事，不花钱。&lt;br&gt;前几年我又给它配了域名，解析用的免费 DNSPod 。（被腾讯收购是后来的事）&lt;/p&gt;
&lt;p&gt;近期折腾技术上的事，了解到 Cloudflare 也有免费域名解析，而且居然带免费 CDN 和 DDOS 保护，有点动心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DNS" scheme="https://jaycechant.info/tags/DNS/"/>
    
  </entry>
  
</feed>
