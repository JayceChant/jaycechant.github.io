<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>存档Save&amp;Load</title>
  <subtitle>存档意味着放下包袱，搞砸了不过回来读档</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jaycechant.info/"/>
  <updated>2021-03-24T04:48:06.266Z</updated>
  <id>https://jaycechant.info/</id>
  
  <author>
    <name>Jayce Sigit Chant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 语言格式化动词</title>
    <link href="https://jaycechant.info/2021/golang-format-verbs/"/>
    <id>https://jaycechant.info/2021/golang-format-verbs/</id>
    <published>2021-03-14T16:43:36.000Z</published>
    <updated>2021-03-24T04:48:06.266Z</updated>
    
    <content type="html"><![CDATA[<p>这期算是 《<a href="../../categories/Go-语言实战/">Go 语言实战</a> 》的番外，内容以翻译整理为主。</p>
<a id="more"></a>
<p>它不在原本的规划之内。</p>
<p>但随着内容的深入，程序变得越来越复杂，我们将不可避免地会遇到 bug，需要调试，需要（往 console 或 日志）输出调试信息。这时数据的格式化输出变得尤为重要。</p>
<p>实际上，前面已经多次用到了格式化。与其每次用到零碎地介绍，不如集中一期整理好。</p>
<p>介绍、翻译、注释、举例，内容有点多，不必全篇记忆。记住常用部分，剩下的留个印象，需要时回来翻阅就好。</p>
<p>[TOC]</p>
<h2 id="fmt-包"><a href="#fmt-包" class="headerlink" title="fmt 包"></a>fmt 包</h2><p>格式化的功能，主要在 <code>fmt</code> 包内，<code>fmt</code> 是 <strong>format</strong> 的略写。</p>
<p>当然，除了临时的简单调试，直接用 <code>fmt</code> 输出到终端（terminal）来调试不太规范。标准输出的内容非常容易丢失，还是写入日志文件方便事后对比分析。</p>
<p>更多的时候，我们会用各种日志库来输出。但这些日志库，要么底层还是调用了 <code>fmt</code> ，要么自己实现的格式化也会尽量和 <code>fmt</code> 兼容。所以学习格式化仍然是必要的。下面主要的内容均来自 <code>fmt</code> 包。</p>
<h3 id="输出-Printing"><a href="#输出-Printing" class="headerlink" title="输出 Printing"></a>输出 Printing</h3><blockquote>
<p>注：print 对应的中文翻译应为 印刷、打印。</p>
<p>但在当前上下文中，print 并非指将内容打印到纸张等介质。而是指的是将各种数据，按照某种格式，转换为字符序列（并输出到抽象文件）的过程。</p>
<p>所以为了方便理解，我将其替换成了『输出』，请读者知悉。</p>
</blockquote>
<p><code>fmt</code> 包中名字里带 <code>Print</code> 的函数很多，但无非是两个选项的排列组合。理解了每个部分的含义，一眼就能明白函数的用途。</p>
<p>前缀代表输出目标：</p>
<ol>
<li><p><code>Fprint</code> 中前缀 <code>F</code> 代表 <strong>file</strong> ，表示内容 <strong>输出到文件</strong>。</p>
<p> 当然这里的文件是抽象的概念，实际对应的是 <code>io.Writer</code> 接口。<code>Fprint</code> 开头的函数，第一个参数总是 <code>io.Writer</code>。通过传递不同的文件给函数，可以把内容输出到不同的地方。</p>
<p> 常见的用法，是打开一个文件，将文件对象作为第一个参数，将内容输出到该文件。当然，不要被 <strong>文件</strong> 这个词误导了，抽象的文件可以是任意的字节流（stream）。具体到这里，只要是可写入的对象（带 <code>Write([]byte)(int, error)</code> 方法），都满足 <code>io.Writer</code> 接口。</p>
</li>
<li><p><code>Print</code> （没有前缀）表示内容 <strong>输出到标准输出</strong>，也就是 控制台（console）或者叫终端（terminal）。</p>
<p> 实际上调用的是 <code>Fprint(os.Stdout, a...)</code> ，换言之背后指定输出的文件为标准输出。</p>
</li>
<li><p><code>Sprint</code> 中前缀 <code>S</code> 表示 <strong>string</strong> ，表示内容 <strong>输出到字符串</strong> ，然后将字符串返回。</p>
</li>
</ol>
<p>后缀表示格式：</p>
<ol>
<li><p><code>Print</code> （没有后缀），表示输出时格式不进行额外的处理。</p>
<p> 也就是按参数的 <strong>默认格式</strong> ，顺序输出。</p>
</li>
<li><p><code>Println</code> 的后缀 <code>ln</code> 代表 <strong>line</strong> ，表示按行输出。</p>
<p> 实际上它只是比 <code>Print</code> 的多做两件事：所有参数之间增加一个空格；输出的最后会追加一个换行符。</p>
</li>
<li><p><code>Printf</code> 的后缀 <code>f</code> 代表 <strong>format</strong> ，表示格式化输出。</p>
<p> 第一个参数是 <strong>格式化字符串</strong> ，通过里面的 <strong>格式化动词（verb）</strong> 来控制后续参数值的输出格式。</p>
</li>
</ol>
<p>直接看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fmt.Print(<span class="string">"Print:"</span>, <span class="number">1</span>, <span class="string">"two"</span>, <span class="number">3.0</span>, <span class="string">"over."</span>)</div><div class="line">fmt.Println(<span class="string">"Println:"</span>, <span class="number">1</span>, <span class="string">"two"</span>, <span class="number">3.0</span>, <span class="string">"over."</span>)</div><div class="line">fmt.Printf(<span class="string">"Printf: %d, %s, %f, %s"</span>, <span class="number">1</span>, <span class="string">"two"</span>, <span class="number">3.0</span>, <span class="string">"over."</span>)</div><div class="line">fmt.Print(<span class="string">"======"</span>) <span class="comment">// 增加一行观察 Printf 的换行行为</span></div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Print:1two3over.Println: 1 two 3 over.</div><div class="line">Printf: 1, two, 3.000000, over.======</div></pre></td></tr></table></figure>
<p>给三个函数都输入 5 个参数</p>
<ul>
<li><code>Print</code> 将 5 个参数的值以默认格式依次输出，每个值中间没有加分隔符，末尾也没有换行。（因为没有换行，这里特意加了一个句点 <code>.</code> 方便区分不同函数的输出）</li>
<li><code>Println</code> 同样以默认格式输出，只是增加了空格分隔不同的值，并且末尾增加了换行。</li>
<li><code>Printf</code> 的第一个参数跟其它参数有所区别，必须是格式化字符串（format specifier）。后续参数跟字符串里的格式化动词一一对应，按照动词指定的方式，格式化后填入对应的位置，再一起输出。</li>
</ul>
<p>接下来，重点就是这些结尾带 <code>f</code> 的函数里面，格式化动词的使用。为了跟格式化字符串里一般的内容区分开来，格式化动词以百分号 <code>%</code> 开头，后面接一个字母表示。有时候为了更精确地控制格式，在百分号和字母之间还会可能会有标志选项（如整型数填充前导零，浮点数控制小数点的位数）。</p>
<p>在不是特别严谨的语境，<strong>动词</strong> 可以是指由 百分号（%）、标志选项（可选）、字母 这三者组合的整体。但更严谨地说，动词特指后面的字母。理解这一点有助于读懂下面的文档。</p>
<p>下面直接 选译/注释 文档中关于格式化动词的部分：</p>
<p>（部分格式与 Go 的版本有关，这里选译的是当下最新的 1.16 版本）</p>
<hr>
<p><code>fmt</code> 包实现了格式化输入输出（I/O），其功能类似于 C 语言的 <code>printf</code> 和 <code>scanf</code> 。格式化 <strong>动词（verbs）</strong> 是从 C 语言的动词中衍生出来的，但更简单。</p>
<p><strong>动词</strong>：</p>
<h4 id="一般动词"><a href="#一般动词" class="headerlink" title="一般动词"></a>一般动词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%v	以默认格式输出值 （v 代表 Value，不同类型的默认格式参见下方内容）</div><div class="line">	当打印结构体 （struct） 时，加号 (%+v) 会添加字段名</div><div class="line">%#v	输出值的 Go 语法表示</div><div class="line">%T	输出值类型的 Go 语法表示 （T 代表 Type）</div><div class="line">%%	输出一个百分号 (%)；不消耗任何值 （因为 % 用作了动词开头，为了区分，输出 % 需要转义）</div></pre></td></tr></table></figure>
<blockquote>
<p>注：只看介绍，所谓输出 “ Go 的语法表示” 并不直观。实际上这是指一个值在代码里的字面量形式。</p>
<p>对于输出值和字面量一样的类型（布尔类型、数字类型），没有差别；对于字符串，“语法表示意味着带上引号；对于剩下的派生类型，意味着语法表示需要包含类型信息。</p>
<p>看几个例子：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">i := <span class="number">1</span></div><div class="line">fmt.Printf(<span class="string">"%v\n"</span>, i)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, i)</div><div class="line">fmt.Printf(<span class="string">"%T\n"</span>, i)</div><div class="line"></div><div class="line">fmt.Println()</div><div class="line"></div><div class="line">a := <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	age  <span class="keyword">int</span></div><div class="line">&#125;&#123;name: <span class="string">"alice"</span>, age: <span class="number">24</span>&#125;</div><div class="line">fmt.Printf(<span class="string">"%v\n"</span>, a)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, a)</div><div class="line">fmt.Printf(<span class="string">"%T\n"</span>, a)</div><div class="line"></div><div class="line">fmt.Println()</div><div class="line"></div><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line">p := Person&#123;name: <span class="string">"bob"</span>, age: <span class="number">26</span>&#125;</div><div class="line">fmt.Printf(<span class="string">"%v\n"</span>, p)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p)</div><div class="line">fmt.Printf(<span class="string">"%T\n"</span>, p)</div><div class="line"></div><div class="line">fmt.Println()</div><div class="line"></div><div class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div><div class="line">fmt.Printf(<span class="string">"%v\n"</span>, s)</div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, s)</div><div class="line">fmt.Printf(<span class="string">"%T\n"</span>, s)</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">1</div><div class="line">int</div><div class="line"></div><div class="line">&#123;alice 24&#125;</div><div class="line">struct &#123; name string; age int &#125;&#123;name:<span class="string">"alice"</span>, age:24&#125;</div><div class="line">struct &#123; name string; age int &#125;</div><div class="line"></div><div class="line">&#123;bob 26&#125;</div><div class="line">main.Person&#123;name:<span class="string">"bob"</span>, age:26&#125;</div><div class="line">main.Person</div><div class="line"></div><div class="line">[1 2 3]</div><div class="line">[]int&#123;1, 2, 3&#125;</div><div class="line">[]int</div></pre></td></tr></table></figure>
<h4 id="布尔类型（Boolean）"><a href="#布尔类型（Boolean）" class="headerlink" title="布尔类型（Boolean）"></a>布尔类型（Boolean）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%t	单词 true 或者 false （t 代表 True value，真值）</div></pre></td></tr></table></figure>
<h4 id="整型数（Integer）"><a href="#整型数（Integer）" class="headerlink" title="整型数（Integer）"></a>整型数（Integer）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">%b	以 2 为基数输出 （b 代表 Binary，二进制）</div><div class="line">%c	输出对应 Unicode 码点所代表的字符 （c 代表 Character，字符）</div><div class="line">%d	以 10 为基数输出 （d 代表 Decimal，十进制）</div><div class="line">%o	以 8 为基数输出 （o 代表 Octal，八进制）</div><div class="line">%O	以 8 为基数输出，以 0o 为前缀 （同上，大写表示增加前缀）</div><div class="line">%q	一个单引号字符，按 Go 语法安全转义。 （q 代表 quote，引号）</div><div class="line">%x	以 16 为基数输出，a-f 为小写字母 （x 代表 heXadecimal）</div><div class="line">%X	以 16 为基数输出，A-F 为大写字母 （同上，大写表示字母大写）</div><div class="line">%U	Unicode 格式：如 U+1234；与 &quot;U+%04X&quot; 效果一样 （U 代表 Unicode）</div></pre></td></tr></table></figure>
<blockquote>
<p>注：特别说明一下 <code>%c</code> 和 <code>%q</code>。</p>
<p>首先需要注意到，自 1.9 以后，<code>byte</code> 类型实际上是 <code>uint8</code> 的别名（alias），<code>rune</code> 则是 <code>int32</code> 的别名。</p>
<p>这意味着如果以 <code>%v</code> 输出，这两个类型都会被当做数字输出。</p>
<p>想要输出对应的字符，就要考虑使用 <code>%c</code> 。</p>
<p><code>%q</code> 也是输出字符，只是有两点区别：</p>
<ol>
<li>带单引号</li>
<li>对于不可打印字符（non-printable characters，不过叫『不可见字符』更容易理解），会按 Go 语法进行转义。</li>
</ol>
<p>举例说，对于字母 A，<code>%c</code> 输出 <code>A</code>，<code>%q</code> 输出 <code>&#39;A&#39;</code> ；中文也是类似效果。而对于换行符，对应一个换行的动作，而不是一个可以看得见的字符，用 <code>%c</code> 输出会得到一个换行，用 <code>%q</code> 输出则得到 <code>&#39;\n&#39;</code> （得到一个转义）。</p>
<p>两者的区别跟 <code>%v</code> 与 <code>%#v</code> 的区别比较类似。</p>
</blockquote>
<h4 id="浮点数和复数的（浮点数）成分"><a href="#浮点数和复数的（浮点数）成分" class="headerlink" title="浮点数和复数的（浮点数）成分"></a>浮点数和复数的（浮点数）成分</h4><p>（Floating-point and complex constituents）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">%b	无小数科学记数法，指数以 2 为底数（但整数部分和指数部分均为十进制数），</div><div class="line">	相当于以 strconv.FormatFloat 函数的 &apos;b&apos; 格式，</div><div class="line">	如：-123456p-78 （分隔的 p 代表 power (of 2)， 2 的幂）</div><div class="line">%e	科学记数法，如：-1.234456e+78 （e 代表 Exponent，指数）</div><div class="line">%E	科学记数法，如：-1.234456E+78</div><div class="line">%f	无指数的小数，如：123.456 （f 代表 floating-point，浮点数）</div><div class="line">%F	%f 的同义词</div><div class="line">%g	指数较大时等同于 %e ，否则为 %f 。精度在下面讨论。</div><div class="line">	（换言之，%g 取 %e 和 %f 中较短的格式表示）</div><div class="line">%G	指数较大时等同于 %E ，否则为 %F</div><div class="line">%x	十六进制记数法(指数为十进制，底数为 2 )，如：-0x1.23abcp+20</div><div class="line">	（与 %b 的区别是，左边的实数为十六进制，而且可以有小数）</div><div class="line">%X	十六进制符号大写，如：-0X1.23ABCP+20</div></pre></td></tr></table></figure>
<blockquote>
<p>注：这部分的个别动词，在输出时可能同时混用 二进制、十进制和十六进制，记忆起来会比较混乱。如 <code>%x</code>，实数（又叫尾数）为十六进制，底数为 2，指数却又是十进制。建议大家自己在代码里实际尝试，加深印象。</p>
<p>还好如果不是涉及特殊数值的运算和表示，特殊的动词一般用得不多。日常表示浮点数，掌握 <code>%f</code>, <code>%e</code> 和 <code>%g</code> 就够了。关于浮点数的多种字面量表示方法，可以参考往期的内容 <a href="../../2020/golang-in-action-day-2/">Go 语言实战（2）： 常量与变量</a> 中，浮点数字面量部分。</p>
</blockquote>
<h4 id="字符串与字节切片"><a href="#字符串与字节切片" class="headerlink" title="字符串与字节切片"></a>字符串与字节切片</h4><p>（对以下动词而言两者等价）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">%s	字符串或字节切片未经解释的字节（uninterpreted bytes） （s 代表 String，字符串）</div><div class="line">%q	一个双引号字符串，按 Go 语法安全转义</div><div class="line">%x	以十六进制数输出，小写，每个字节对应两个字符</div><div class="line">%X	以十六进制数输出，大写，每个字节对应两个字符</div></pre></td></tr></table></figure>
<blockquote>
<p>注：想理解何为 uninterpreted，先要理解何为 interpreted。</p>
<p>对于脚本语言，解释器就叫 interpreter；分析或执行读入的内容，得到结果的过程，就是解释 interpret。如解释 <code>1 + 2</code> ，得到 <code>3</code> 。</p>
<p>在这里，对于字符串（字符序列）而言，解释主要是指字符转义。<code>%s</code> 动词不会对字符序列的内容进行转义。</p>
<p>但这里有一个非常容易让人迷惑的点，看下面例子：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">str1 := <span class="string">"1\t2\n3"</span></div><div class="line">fmt.Printf(<span class="string">"%s\n-----\n"</span>, str1)</div><div class="line"></div><div class="line">str2 := <span class="string">`1\t2\n3`</span></div><div class="line">fmt.Printf(<span class="string">"%s\n-----\n"</span>, str2)</div><div class="line"></div><div class="line">str3 := []<span class="keyword">byte</span>&#123;<span class="string">'1'</span>, <span class="string">'\\', '</span>t<span class="string">', '</span><span class="number">2</span><span class="string">', '</span>\\<span class="string">', '</span>n<span class="string">', '</span><span class="number">3</span><span class="string">'&#125;</span></div><div class="line">fmt.Printf("%s\n-----\n", str3)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1	2</div><div class="line">3</div><div class="line">-----</div><div class="line">1\t2\n3</div><div class="line">-----</div><div class="line">1\t2\n3</div><div class="line">-----</div></pre></td></tr></table></figure>
<blockquote>
<p>第一个例子很容易让人以为 <code>%s</code> 还是发生了转义。</p>
<p>实际上转义发生在源码编译阶段，而不是输出阶段。也就是对于双引号字符串，编译器已经对其完成了转义。<code>str1</code> 储存在内存里的内容，是 [‘1’, 9, ‘2’, 13, ‘3’] ，其中 9 就是制表符的 ascii 码，13 是 换行符的 ascii 码。这里已经找不到 反斜杠、字母 t 和 n 了。</p>
<p>再看接下来的两个例子就很好理解了。反引号字符串告诉编译器不要转义，字节切片则直接逐个指定每个字节的内容，所以 <code>str2</code> 和 <code>str3</code> 的字节序列里，储存的就是字面意义的 “\t” 和 “\n” 。</p>
<p>当然还有更直观的方式，可以看出字节序列的不同：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">str1 := <span class="string">"1\t2\n3"</span></div><div class="line">fmt.Printf(<span class="string">"% x\n"</span>, str1)</div><div class="line"></div><div class="line">str2 := <span class="string">`1\t2\n3`</span></div><div class="line">fmt.Printf(<span class="string">"% x\n"</span>, str2)</div><div class="line"></div><div class="line">str3 := []<span class="keyword">byte</span>&#123;<span class="string">'1'</span>, <span class="string">'\\', '</span>t<span class="string">', '</span><span class="number">2</span><span class="string">', '</span>\\<span class="string">', '</span>n<span class="string">', '</span><span class="number">3</span><span class="string">'&#125;</span></div><div class="line">fmt.Printf("% x\n", str3)</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>（具体每个十六进制数对应的字符，这里就不再解释了，反正不同是非常直观的）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">31 09 32 0a 33</div><div class="line">31 5c 74 32 5c 6e 33</div><div class="line">31 5c 74 32 5c 6e 33</div></pre></td></tr></table></figure>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%p	以十六进制数表示的第 1 个元素（下标 0）的地址，以 0x 开头</div><div class="line">	（p 代表 Pointer，指针，也就是以指针形式输出地址）</div></pre></td></tr></table></figure>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%p	十六进制数地址，以 0x 开头</div><div class="line">	%b, %d, %o, %x 和 %X 动词也可以用于指针，</div><div class="line">	实际上就是把指针的值当作整型数一样格式化。</div></pre></td></tr></table></figure>
<h4 id="v-的默认格式"><a href="#v-的默认格式" class="headerlink" title="%v 的默认格式"></a>%v 的默认格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bool:						%t</div><div class="line">int, int8 等有符号整数:		%d</div><div class="line">uint, uint8 等无符号整数:		%d, 如果以 %#v 输出则是 %#x</div><div class="line">float32, complex64 等:		%g</div><div class="line">string:						%s</div><div class="line">chan:						%p</div><div class="line">指针:							%p</div></pre></td></tr></table></figure>
<h4 id="复合对象"><a href="#复合对象" class="headerlink" title="复合对象"></a>复合对象</h4><p>对于复合对象，将根据这些规则，递归地打印出元素，像下面这样展开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct:				&#123;field0 field1 ...&#125;</div><div class="line">array, slice:		[elem0 elem1 ...]</div><div class="line">maps:				map[key1:value1 key2:value2 ...]</div><div class="line">上述类型的指针:		&amp;&#123;&#125;, &amp;[], &amp;map[]</div></pre></td></tr></table></figure>
<h4 id="宽度与精度"><a href="#宽度与精度" class="headerlink" title="宽度与精度"></a>宽度与精度</h4><p>宽度由紧接在动词前的一个可选的十进制数指定。如果没有指定，则宽度为表示数值所需的任何值。</p>
<p>精度是在（可选的）宽度之后，由一个句点（<code>.</code> ，也就是小数点）和一个十进制数指定。如果没有句点，则表示使用默认精度。如果有句点，句点后面却没有数字，则表示精度为零。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%f		默认宽度，默认精度</div><div class="line">%9f		宽度 9，默认精度</div><div class="line">%.2f	默认宽度，精度 2</div><div class="line">%9.2f	宽度 9, 精度 2</div><div class="line">%9.f	宽度 9, 精度 0</div></pre></td></tr></table></figure>
<p>宽度和精度以 Unicode 码点为单位，也就是 runes。（这与 C 语言的 <code>printf</code> 不同，后者总是以字节为单位。）标志中的任意一个或两个都可以用字符 <code>*</code> 代替，从而使它们的值从下一个操作数获得（在要格式化的操作数之前），这个操作数的类型必须是 <code>int</code> 。</p>
<blockquote>
<p>注：<code>*</code> 的用法并不直观，举个例子就很好理解。</p>
<p><code>fmt.Printf(&quot;%*.*f&quot;, 6, 3, 4.5)</code></p>
<p>输出 <code>4.500</code> （注意 4 前面有一个并不明显的空格，加上数字和小数点，宽度正好为 6 ）</p>
</blockquote>
<p>对于大多数的值来说，宽度是要输出的最小符号（rune）数，必要时用空格填充。</p>
<p>然而，对于 字符串、字节切片 和 字节数组 来说，精度限制了要格式化的输入长度（而不是输出的大小），必要时会进行截断。通常它是以符号（rune） 为单位的，但当这些类型以 <code>%x</code> 或 <code>%X</code> 格式进行格式化时，以字节（byte）为单位。</p>
<p>对于浮点值，宽度设置字段的最小宽度，精度设置小数点后的位数；但对于 <code>%g</code> / <code>%G</code>，精度设置最大的有意义数字（去掉尾部的零）。例如，给定 <code>12.345</code>，格式 <code>%6.3f</code> 打印 <code>12.345</code>，而 <code>%.3g</code> 打印 <code>12.3</code>。<code>%e</code>、<code>%f</code> 和 <code>%#g</code> 的默认精度是 6 ；对于 <code>%g</code>，默认精度是唯一识别数值所需的最少数字个数。</p>
<blockquote>
<p>注：关于如何精确控制浮点值的宽度和精度，这段说明看似说清楚了，实际执行中却常常让人迷惑。看网上的讨论，已经有很多人在诟病这一点。跟更早的文档相比，现在的版本好像已经调整过表述，但是帮助有限。</p>
<p>如果你需要精确控制以达到排版对齐一类的目的，可以参考这个讨论 <a href="https://stackoverflow.com/questions/36464068/fmt-printf-with-width-and-precision-fields-in-g-behaves-unexpectedly" target="_blank" rel="external">https://stackoverflow.com/questions/36464068/fmt-printf-with-width-and-precision-fields-in-g-behaves-unexpectedly</a></p>
<p>讨论篇幅过长且拗口，不再翻译。总的来说，精度控制有效数字，但因为有效数字不包括小数点和前导零，带前导零和小数点的数会更长；宽度控制最小宽度，在长度不足时会填充到指定宽度，但超出时并不会截断，总位数仍然可能超出。最后你可能需要制表符 <code>\t</code> 来帮助对齐。</p>
</blockquote>
<p>对于复数，宽度和精度分别应用于两个分量（均为浮点数），结果用小括号包围。所以 <code>%f</code> 应用于 <code>1.2+3.4i</code> 输出 <code>(1.200000+3.400000i)</code> 。</p>
<h4 id="其它标志"><a href="#其它标志" class="headerlink" title="其它标志"></a>其它标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+	始终输出数字值的符号（正负号）；</div><div class="line">	对 %q(%+q) 保证只输出 ASCII 码 （ASCII 码以外的内容转义）</div><div class="line">-	空格填充在右边，而不是左边</div><div class="line">#	备选格式：二进制(%#b)加前导 0b ，八进制(%#o)加前导 0 ；</div><div class="line">	十六进制(%#x 或 %#X)加前导 0x 或 0X ；%p (%#p) 取消前导 0x ；</div><div class="line">	对于 %q ，如果 strconv.CanBackquote 返回true，则输出一个原始（反引号）字符串；</div><div class="line">	总是输出 %e, %E, %f, %F, %g 和 %G 的小数点；</div><div class="line">	不删除 %g 和 %G 的尾部的零；</div><div class="line">	对于 %U (%#U)，如果该字符可打印（printable，即可见字符），则在 Unicode 码后面输出字符，</div><div class="line">	例如 U+0078 &apos;x&apos;。</div><div class="line">&apos; &apos;	(空格) 为数字中的省略的正号留一个空格 (%d)；</div><div class="line">	以十六进制输出字符串或切片时，在字节之间插入空格 (%x, %X)</div><div class="line">0	用前导零而不是空格来填充；</div><div class="line">	对于数字来说，这会将填充位置移到符号后面</div></pre></td></tr></table></figure>
<p>动词会忽略它不需要的标志。例如十进制没有备选格式，所以 <code>%#d</code> 和 <code>%d</code> 的行为是一样的。</p>
<p>对于每个类似 <code>Printf</code> 的函数，都有一个对应的 <code>Print</code> 函数，它不接受格式，相当于对每个操作数都应用 <code>%v</code> 。另一个变体 <code>Println</code> 在操作数之间插入空格，并在结尾追加一个换行。（注：这个我们在开头就已经讨论过）</p>
<p>无论用什么动词，如果操作数是一个接口值，则使用内部的具体值，而不是接口本身。因此：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">23</span></div><div class="line">fmt.Printf(<span class="string">"%v\n"</span>, i)</div></pre></td></tr></table></figure>
<p>会输出 <code>23</code> 。</p>
<p>除了使用动词 <code>%T</code> 和 <code>%p</code> 输出时，对于实现特定接口的操作数，需要考虑特殊格式化。以下规则按应用顺序排列：</p>
<ol>
<li><p>如果操作数是 <code>reflect.Value</code>，则操作数被它所持有的具体值所代替，然后继续按下一条规则输出。</p>
</li>
<li><p>如果操作数实现了 <code>Formatter</code> 接口，则会被调用。在这种情况下，动词和标志的解释由该实现控制。</p>
</li>
<li><p>如果 <code>%v</code> 动词与 <code>#</code> 标志 (<code>%#v</code>) 一起使用，并且操作数实现了 <code>GoStringer</code> 接口，则该接口将被调用。</p>
</li>
</ol>
<p>如果格式 （注意 <code>Println</code> 等函数隐含 <code>%v</code> 动词）对字符串有效 (<code>%s</code>, <code>%q</code>, <code>%v</code>, <code>%x</code>, <code>%X</code>)，则适用以下两条规则：</p>
<ol>
<li>如果操作数实现了 <code>error</code> 接口，将调用 <code>Error</code> 方法将对象转换为字符串，然后按照动词（如果有的话）的要求进行格式化。</li>
<li>如果操作数实现了 <code>String() string</code> 方法，则调用该方法将对象转换为字符串，然后按照动词（如果有的话）的要求进行格式化。</li>
</ol>
<p>对于复合操作数，如 切片 和 结构体，格式递归地应用于每个操作数的元素，而不是把操作数当作一个整体。因此，<code>%q</code> 将引用字符串切片中的每个元素，而 <code>%6.2f</code> 将控制浮点数组中每个元素的格式。</p>
<p>然而，当以适用于字符串的动词(<code>%s</code>, <code>%q</code>, <code>%x</code>, <code>%X</code>)，输出一个字节切片时，它将被视为一个字符串，作为一个单独的个体。</p>
<p>为了避免在以下情况出现递归死循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> X <span class="keyword">string</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x X)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> Sprintf(<span class="string">"&lt;%s&gt;"</span>, x) &#125;</div></pre></td></tr></table></figure>
<p>在触发递归之前先转换类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x X)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> Sprintf(<span class="string">"&lt;%s&gt;"</span>, <span class="keyword">string</span>(x)) &#125;</div></pre></td></tr></table></figure>
<p>无限递归也可以由自引用的数据结构触发，例如一个包含自己作为元素的切片，然后该类型还要有一个 <code>String</code> 方法。然而，这种异常的情况是非常罕见的，所以 <code>fmt</code> 包并没有对这种情况进行保护。</p>
<p>在输出一个结构体时，<code>fmt</code> 不能，也不会，对未导出字段调用 <code>Error</code> 或 <code>String</code> 等格式化方法。</p>
<h4 id="显式参数索引"><a href="#显式参数索引" class="headerlink" title="显式参数索引"></a>显式参数索引</h4><p>在 <code>Printf</code>, <code>Sprintf</code> 和 <code>Fprintf</code> 中，默认的行为是，每个格式化动词对调用中传递的连续参数进行格式化。然而，紧接在动词前的符号 <code>[n]</code> 表示第 n 个单一索引参数将被格式化。在宽度或精度的 <code>*</code> 前同样的记号，表示选择对应参数索引的值。在处理完括号内的表达式 <code>[n]</code> 后，除非另有指示，否则后续的动词将依次使用 n+1、n+2等参数。</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Sprintf(<span class="string">"%[2]d %[1]d\n"</span>, <span class="number">11</span>, <span class="number">22</span>)</div></pre></td></tr></table></figure>
<p>将输出 <code>22 11</code> 。 而</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Sprintf(<span class="string">"%[3]*.[2]*[1]f"</span>, <span class="number">12.0</span>, <span class="number">2</span>, <span class="number">6</span>)</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Sprintf(<span class="string">"%6.2f"</span>, <span class="number">12.0</span>)</div></pre></td></tr></table></figure>
<p>将输出 <code>12.00</code> （注意 12 前有一个空格）。</p>
<p>因为显式索引会影响后续的动词，所以这个记号可以通过重置索引为第一个参数，达到重复的目的，来多次打印相同的数值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Sprintf(<span class="string">"%d %d %#[1]x %#x"</span>, <span class="number">16</span>, <span class="number">17</span>)</div></pre></td></tr></table></figure>
<p>将输出 <code>16 17 0x10 0x11</code> 。</p>
<h4 id="格式错误"><a href="#格式错误" class="headerlink" title="格式错误"></a>格式错误</h4><p>如果给一个动词提供了无效的参数，比如给 <code>%d</code> 提供了一个字符串，生成的字符串将包含对问题的描述，像以下这些例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Wrong type or unknown verb: %!verb(type=value)</div><div class="line">	Printf(&quot;%d&quot;, &quot;hi&quot;):        %!d(string=hi)</div><div class="line">Too many arguments: %!(EXTRA type=value)</div><div class="line">	Printf(&quot;hi&quot;, &quot;guys&quot;):      hi%!(EXTRA string=guys)</div><div class="line">Too few arguments: %!verb(MISSING)</div><div class="line">	Printf(&quot;hi%d&quot;):            hi%!d(MISSING)</div><div class="line">Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)</div><div class="line">	Printf(&quot;%*s&quot;, 4.5, &quot;hi&quot;):  %!(BADWIDTH)hi</div><div class="line">	Printf(&quot;%.*s&quot;, 4.5, &quot;hi&quot;): %!(BADPREC)hi</div><div class="line">Invalid or invalid use of argument index: %!(BADINDEX)</div><div class="line">	Printf(&quot;%*[2]d&quot;, 7):       %!d(BADINDEX)</div><div class="line">	Printf(&quot;%.[2]d&quot;, 7):       %!d(BADINDEX)</div></pre></td></tr></table></figure>
<p>所有的错误都以字符串 <code>%!</code> 开头，有时后面跟着一个字符（动词），最后以括号内的描述结尾。</p>
<p>如果一个 <code>Error</code> 或 <code>String</code> 方法在被输出例程调用时触发了 panic ，那么 <code>fmt</code> 包会重新格式化来自 panic 的错误消息，并在其上注明它是通过 <code>fmt</code> 包发出的。例如，如果一个 <code>String</code> 方法调用 <code>panic(&quot;bad&quot;)</code> ，则产生的格式化消息看起来会是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%!s(PANIC=bad)</div></pre></td></tr></table></figure>
<p><code>%!s</code> 只是显示失败发生时使用的打印动词。然而，如果 panic 是由 <code>Error</code> 或 <code>String</code> 方法的 nil 接收者（receiver）引起的，则输出的是未修饰的字符串 <code>&lt;nil&gt;</code>。</p>
<hr>
<p>实际上，这一套函数的命名规则和格式化动词，基本继承自 C 语言，只是做了少量的调整和改进。有 C/C++ 经验的朋友应该非常熟悉。没有写过 C 的朋友，经过整理，也会有助于记忆和理解。</p>
<p>上述内容涉及到类型方面的知识，如果有朋友还不熟悉，可以参考往期的内容：<a href="../../2020/golang-in-action-day-3/">Go 语言实战（3）： 类型</a></p>
<h4 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf()"></a>Errorf()</h4><p>Go 在 1.13 中专门为 <code>fmt.Errorf()</code> 新增了一个动词 <code>%w</code> 。文档是这样介绍的：</p>
<blockquote>
<p>如果格式化字符串包含一个 <code>%w</code> 动词，并且该动词对应一个 <code>error</code> 操作数，<code>Errorf</code> 返回的 <code>error</code> 将实现一个 <code>Unwrap</code> 方法，会返回前面传入的 <code>error</code> 。包含一个以上的 <code>%w</code> 动词 或 提供一个没有实现 <code>error</code> 接口的操作数是无效的。无效的 <code>%w</code> 动词是 <code>%v</code> 的同义词。</p>
</blockquote>
<p>文档的说明严谨但拗口。好在这部分代码不长，直接贴出来看看：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go/src/fmt/errors.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	p := newPrinter()</div><div class="line">	p.wrapErrs = <span class="literal">true</span></div><div class="line">	p.doPrintf(format, a)</div><div class="line">	s := <span class="keyword">string</span>(p.buf)</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">if</span> p.wrappedErr == <span class="literal">nil</span> &#123;</div><div class="line">		err = errors.New(s)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		err = &amp;wrapError&#123;s, p.wrappedErr&#125;</div><div class="line">	&#125;</div><div class="line">	p.free()</div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</div><div class="line">	msg <span class="keyword">string</span></div><div class="line">	err error</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> e.msg</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> e.err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入的参数，实际上通过 <code>p.doPrintf</code> （一系列 <code>Printf</code> 函数的内部实现） 变成了字符串 <code>s</code>。此时 <code>%w</code> 是 <code>%v</code> 的同义词，参数里即使有 <code>error</code> ，也是取 <code>Error()</code> 方法返回的字符串。</p>
<p>然后再看是否有需要包裹（wrap）的 <code>error</code> 。这需要一个 <code>%w</code> 动词并对应的操作数满足 <code>error</code> 接口，仅有其中之一，或者参数顺序不对应，都不算。如无，则通过 <code>errors.New(s)</code> 返回一个只有字符串的最基本的 <code>error</code> ；否则返回一个同时包含 格式化字符串 和 内部错误的 <code>wrapError</code> 。跟基本的 <code>error</code> 相比，它多了一个获取内部错误的 <code>Unwrap</code> 方法。</p>
<h3 id="输入-Scanning"><a href="#输入-Scanning" class="headerlink" title="输入 Scanning"></a>输入 Scanning</h3><p>除了输出（Printing），<code>fmt</code> 包还提供了一系列类似的函数负责输入，将特定格式的文本（formated text）解析为对应的值。</p>
<p>与 Printing 类似，通过前后缀的组合来区分读取的来源和格式化方式：</p>
<ul>
<li>前缀：<code>Fscan</code> 表示从文件（<code>io.Reader</code>）读取；<code>Scan</code> （无前缀）表示从标准输入 <code>os.Stdin</code> 读取；<code>Sscan</code> 表示从字符串读取；</li>
<li>后缀：<code>Scan</code> （无后缀）表示把换行当成普通空白字符，遇到换行不停止；<code>Scanln</code> 表示遇到换行或者 <code>EOF</code> 停止；<code>Scanf</code> 表示根据格式化字符串里的动词控制读取。</li>
</ul>
<p>Scanning 使用几乎一样的一系列动词（除了没有 <code>%p</code>, <code>%T</code> 动词，没有 <code>#</code> 和 <code>+</code> 标志），这里不再重复介绍这些动词。动词的含义也基本一致，只是在非常细微的地方，为方便输入做了变通：</p>
<ul>
<li>对于浮点数和复数，所有有效动词都是等价的；进制以文本内容、而不是动词为准。（因为尾数和指数可能是不同的进制，无法单靠动词指定）</li>
<li>对于整型数，则以动词指定的进制为准；仅在 <code>%v</code> 时依靠前缀判断进制。</li>
<li>宽度仍然有效，用来限制读取的最大符号数（去掉前导空格）；如 <code>123456</code> ，如果用 <code>%3d%d</code> 来解析，会被理解为 <code>123</code> 和 <code>456</code> 两个数；精度不再有意义。</li>
<li>对于数字类型，数字之间可以添加下划线提高可读性，读取时会忽略下划线，不影响解析。</li>
</ul>
<p>其它更细致的差别（包括与 C 语言的差别），像符号的消耗，空白字符串的匹配，就不再展开。建议大家自己尝试，遇到问题直接去看文档。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://pkg.go.dev/fmt" target="_blank" rel="external">https://pkg.go.dev/fmt</a> ：<code>fmt</code> 官方文档，翻译整理难免有理解偏差，以文档为准</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这期算是 《&lt;a href=&quot;../../categories/Go-语言实战/&quot;&gt;Go 语言实战&lt;/a&gt; 》的番外，内容以翻译整理为主。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>现在写，可能都来不及了...</title>
    <link href="https://jaycechant.info/2021/time-is-up/"/>
    <id>https://jaycechant.info/2021/time-is-up/</id>
    <published>2021-01-31T12:28:20.000Z</published>
    <updated>2021-01-31T14:47:43.222Z</updated>
    
    <content type="html"><![CDATA[<p>之前答读者提问，整理了《<a href="../../2021/insurance-for-kids/">为什么不要先给小孩子买保险？</a>》。</p>
<p>我本来也比较关心保险话题，顺着读者的提问和讨论，计划接着聊聊穗岁康和重疾新规相关的话题。</p>
<p>如果你留意了我的推送，就会发现，最终还是没能好好聊。眼下这个时间点，可能已经不及了。</p>
<p>随便敲两个字，算是交代一下这个话题。</p>
<a id="more"></a>
<h2 id="穗岁康"><a href="#穗岁康" class="headerlink" title="穗岁康"></a>穗岁康</h2><p>作为一个外行，虽然都是个人看法，强调仅供参考，也想好好查查资料好好写，也是给自己做调研。</p>
<p>结果一忙，拖到去年年底。眼看穗岁康第一批就要截止，差一天，同样的保费却少了一个月的保障期。仓促写了一下<a href="../../suisuikang/">穗岁康</a>，并提醒有需要的朋友赶紧投保。</p>
<p>作为一个文笔不行的强迫症，写完排完版都到了 12 月 31 日晚上，如果当晚大家没有看到，推送的意义就大打折扣了，所以用了一个比较抢眼球的标题：《还剩不到两小时，错过这批白白损失一个月》。</p>
<p>到这里为止，只能说抢眼球，还不能说标题党——如果大家看完文章，确实能买到穗岁康的话。结果推送完我自己试了一下，发现医保系统调整，早在下午就关闭了购买入口。换言之，文章还没发出，第一批就买不到了。<strong>标题党实锤了</strong>。</p>
<p>朋友调侃我标题党，我也无从辩解，只好苦笑着认了。</p>
<p>心里计划着，后面好好写一下重疾新规。到时顺便提醒大家，对穗岁康有需求的人群，少一个月保障期也还是可以考虑买的。</p>
<p>然后到今天，一个月又过去了。</p>
<p>我去试了一下，穗岁康居然没有像上次那样提前关闭，不知道文章推送时还有没有。感兴趣的读者朋友，可以点进去<a href="../../suisuikang/">穗岁康</a>的文章看看，决定要不要买。就是要赶紧。</p>
<h2 id="重疾新规-与-择优理赔"><a href="#重疾新规-与-择优理赔" class="headerlink" title="重疾新规 与 择优理赔"></a>重疾新规 与 择优理赔</h2><p>然后是<strong>重疾新规</strong>。</p>
<p>时间关系，不展开说，反正这些内容，给定了关键词，文章一搜一大把。</p>
<p>简单说，2020 年 11 月 5 日，保险行业协会发布了新的重疾险规范。新规范在 2021 年 2 月 1 日实施，不影响在这之前已经成立的保单。旧定义的保险最晚要在 1 月 31 日下架。已经有很多旧定义产品提前下架了。所以说，这个醒，本来早该提。</p>
<p>新规范完善了很多细节定义，变得更细致也更科学了。多数调整是对投保人有利的，例如增加了 3 种重疾，例如明确了很多疾病的定义，减少了保险公司自行解释的余地。但也有『不利』的，最明显的就是原本直接按重疾赔付的甲状腺癌，现在按照分期，可能按轻症赔付。</p>
<p>长远来说，这是好事，会促进重疾险的健康发展。哪怕是看起来『不利』的调整，也是在平衡保险公司和投保人的关系。要知道，现在甲状腺癌甚至被称作喜癌：早期发现的甲状腺癌可能花不了多少钱就能治愈，还能按重疾赔一大笔钱。</p>
<p>按照旧定义，保司当然只能赔。为了减少理赔，很多产品只好用更严的健康告知，阻挡那些有潜在甲状腺癌风险的人投保。于是，有甲状腺结节的人群，可能因此而失去其它重疾的保障。要知道，随着超声技术的发展，普通人群里甲状腺结节的发现率已经在 4% 以上，近年可能还一直在攀升。</p>
<p>但是，视角转换到个人。我们不去考虑整个行业和整个社会，单从个人的利益最大化出发，旧定义和新定义，怎么选？</p>
<p>这时不得不提<strong>择优理赔</strong>。</p>
<p>如果光比较新旧定义，可以说孰优孰劣，没有定论，要具体案例具体分析。尤其新定义的产品，上市得还不多，特别是未来究竟是降价还是涨价，也说不定，带来了很多的不确定性。</p>
<p>保险公司可能看出了大家的犹豫，于是纷纷提出『择优理赔』，促销了一波。</p>
<p>简单说，如果买了旧定义的保险，同时支持择优理赔，将来理赔时，投保人可以在新旧定义中，选择对自己有利的定义进行理赔。</p>
<p>在未来新产品尚不明确的时候，先把保单确定下来，同时可以择优理赔，确实是对投保人的福利。</p>
<p>何况还有犹豫期。如果先买了旧定义产品，将来在犹豫期内看到更好的新定义产品，完全可以退保。而如果将来发现新产品都不如旧产品，就没有后悔药可以吃了。</p>
<hr>
<p>可是这文章写得太晚了。这个点，又是最后两小时，不知道还有多少产品还没下架？还没下架的产品，不知道业务员还扛不扛得住涌进的保单，能够赶在下架前投保？</p>
<p>何况还有健康告知的问题。择优理赔看的是重疾定义，但是健康告知是不会择优的。如果不符合投保时的健康告知，无论如何都不会理赔的。如果早半个月，发现有健康告知的疑点，还能去医院做个检查，给结节分个级。</p>
<p>所以现在这个时间点，如果你<strong>非常明确自己需要重疾险</strong>，而且也<strong>认同旧定义+择优理赔是个保底的选择</strong>，并且身体<strong>没有不符健康告知</strong>的毛病，如果还<strong>有合适的产品</strong>没有下架，买吧。然后犹豫期内再好好考虑考虑。</p>
<p>但这么多个如果，估计很难都符合，那就不要赶这趟车了。便宜总不能都让你占了，等后续新产品出来慢慢看吧。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>我们家在 16 年底买的预售房，本应 18 年底收楼。按计划应该简单收拾精装的房子，置点家具电器，通风个半年，在 19 年下半年入住。</p>
<p>可因为房子的质量问题，我们拒收了房子，跟开发商扯皮了一年多。直到 20 年的 315 晚会（你懂的），开发商才作出了部分让步。期间为了保留证据，房子一直空置。直到19 年下半年，实在觉得不能等下去了，才妥协签字收楼，并开始装修，决定自行修复房子的问题。</p>
<p>这中间经历生娃、经历了疫情，装修进程不得不多次中断。</p>
<p>不得不说，装修真是这世界上少有的同时费脑、费钱、费时间、还得出体力的活动。特别是我们这样带『精装修』的，想省钱，不得不小心翼翼保护原有装修的。特别是没有经验，一开始师傅说啥就是啥的。</p>
<p>到最后收尾时回顾，发现投入了那么多心血，却换来处处遗憾。</p>
<p>孩子逐渐长大，租住的房子越来越捉襟见肘。我现在连一张书桌都无处安放，只能在厅的一堆杂物旁，就着落地支架用笔记本。眼看马上就要入住新房，无论花时间换租，还是花钱买新家具改善租住环境，都显得不再划算。</p>
<p>一堆事情环环相扣，变成了时间和空间上的大型华容道与九连环。</p>
<p>眼下最快速能够腾出时间和空间的，显然就是赶紧了结这已经拖了太久的装修。</p>
<p>所以过去的一个月里，我疯狂地缺啥买啥，不断地约各种安装师傅，尽量在新年放假前赶进度。简单的安装我甚至都自己上阵。</p>
<p>去年过年前，原本说不回家过年的工头有事回了老家。等到小区重新对外开放，工头做完别处的单回来继续，已经是 20 年下半年。</p>
<p>现在仿佛又在重现。所以我一有空就跑新房，一直忙到晚饭时间。躺下之前要看着孩子睡着，然后躺在床上继续下单需要的东西，直到睏到睁不开眼。</p>
<hr>
<p>一不小心发了这么长的牢骚。其实就是想狡辩一下，我为什么这么长时间不发文章。</p>
<p>装修真是一个不断地接受不完美的过程，特别是市面上有那么多二把刀的师傅。而那些手艺好的师傅，审美却又迷一般守旧顽固。</p>
<p>有机会也许能聊聊装修。给不了什么好的建议，起码可以躲开我们踩过的坑。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前答读者提问，整理了《&lt;a href=&quot;../../2021/insurance-for-kids/&quot;&gt;为什么不要先给小孩子买保险？&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;我本来也比较关心保险话题，顺着读者的提问和讨论，计划接着聊聊穗岁康和重疾新规相关的话题。&lt;/p&gt;
&lt;p&gt;如果你留意了我的推送，就会发现，最终还是没能好好聊。眼下这个时间点，可能已经不及了。&lt;/p&gt;
&lt;p&gt;随便敲两个字，算是交代一下这个话题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go 语言实战（8）：命令行（3）CLI 框架</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-8/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-8/</id>
    <published>2020-12-30T15:55:36.000Z</published>
    <updated>2021-02-21T16:29:38.013Z</updated>
    
    <content type="html"><![CDATA[<p>经过前面两期的介绍，相信大家已经可以写简单的命令行程序，并且能够使用命令行参数。</p>
<p>即使遇到一些困难，建立直观认识和了解关键词之后，在网络上搜索答案也变得相对容易。</p>
<p>接下来介绍 CLI 框架。</p>
<a id="more"></a>
<p>命令行程序的前两期：</p>
<ul>
<li><a href="../golang-in-action-day-6/">命令行程序（1）</a> </li>
<li><a href="../golang-in-action-day-7/">命令行程序（2）</a> </li>
</ul>
<p>本系列完整目录：</p>
<p><a href="../../categories/Go-语言实战/">Go 语言实战系列</a></p>
<h2 id="命令行框架"><a href="#命令行框架" class="headerlink" title="命令行框架"></a>命令行框架</h2><p>对于简单的功能，单个 go 文件，几个函数，完全是足够的。没有必要为了像那么回事，硬要分很多个包，每个文件就两行代码。为了框架而框架，属于过早优化。</p>
<p>但反过来说，随着往项目里不断添加特性，代码越来越多，如何更好地组织代码，达到解耦和复用，就成了必须要考虑的问题。</p>
<p>我们当然可以把自己的思考，体现在项目的代码组织上，乃至从中抽取一套框架。但一个深思熟虑，适应各种场景变化的框架，还是有门槛、需要技术和经验积累的。</p>
<p>更便捷的做法，是引入社区热门的框架，利用里面提供的脚手架减少重复劳动，并从中学习它的设计。</p>
<p>对于 CLI 程序而言，我知道的最流行的框架有两个，分别是：</p>
<ul>
<li>urfave/cli：<a href="https://github.com/urfave/cli" target="_blank" rel="external">https://github.com/urfave/cli</a></li>
<li>cobra：<a href="https://github.com/spf13/cobra" target="_blank" rel="external">https://github.com/spf13/cobra</a></li>
</ul>
<p>cobra 的功能会更强大完善。它的作者 Steve Francia（spf13）是 Google 里面 go 语言的 product lead，同时也是 gohugo、viper 等知名项目的作者。</p>
<p>但强大的同时，也意味着框架更大更复杂，在实现一些小规模的工具时，反而会觉得杀鸡牛刀。所以这里只介绍 cli 这个框架，有兴趣的朋友可以自行了解 cobra ，原理大同小异。</p>
<h2 id="urfave-cli-框架"><a href="#urfave-cli-框架" class="headerlink" title="urfave/cli 框架"></a>urfave/cli 框架</h2><p>cli 目前已经开发到了 v2.0+。推荐使用最新的稳定版本。</p>
<p>这里使用 go module 模式，那么引入 <code>cli</code> 包只需要在代码开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/urfave/cli/v2"</span></div></pre></td></tr></table></figure>
<p>如果还不熟悉 go module，或者不知道最后面的 <code>v2</code> 代表什么，请看这篇文章：《<a href="https://jaycechant.info/2020/golang-1-13-module-VS-package/">golang 1.13 - module VS package</a>》。</p>
<p>简单说，go module 使用语义化版本（semver），认为主版本号变更是『不兼容变更（breaking changes）』，需要体现在导入路径上。 <code>v0.x</code> （不稳定版本，可以不兼容）和 <code>v1.x</code> （默认）不需要标，<code>v2.0</code> 及以上的版本，都需要把主版本号标在 module 路径的最后。</p>
<p>但是注意，这个 <code>v2</code> 既不对应实际的文件目录，也不影响包名。在这里，包名仍然是 <code>cli</code>。</p>
<p>根据作者提供的例子，实现一个最小的 CLI 程序看看：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为了编译后不用改名，module name 直接就叫 boom</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/urfave/cli/v2"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    app := &amp;cli.App&#123;</div><div class="line">        Name: <span class="string">"boom"</span>,</div><div class="line">        Usage: <span class="string">"make an explosive entrance"</span>,</div><div class="line">        Action: <span class="function"><span class="keyword">func</span><span class="params">(c *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">            fmt.Println(<span class="string">"boom! I say!"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    err := app.Run(os.Args)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码实现了一个叫 <code>boom</code> 的程序，执行的时候会输出 “boom! I say!”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;go build</div><div class="line">&gt;boom</div><div class="line">boom! I say!</div></pre></td></tr></table></figure>
<p>另外，框架已经自动生成了默认的帮助信息。在调用 <code>help</code> 子命令，或者发生错误时，会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;boom <span class="built_in">help</span></div><div class="line">NAME:</div><div class="line">   boom - make an explosive entrance</div><div class="line"></div><div class="line">USAGE:</div><div class="line">   boom.exe [global options] <span class="built_in">command</span> [<span class="built_in">command</span> options] [arguments...]</div><div class="line"></div><div class="line">COMMANDS:</div><div class="line">   <span class="built_in">help</span>, h  Shows a list of commands or <span class="built_in">help</span> <span class="keyword">for</span> one <span class="built_in">command</span></div><div class="line"></div><div class="line">GLOBAL OPTIONS:</div><div class="line">   --help, -h  show <span class="built_in">help</span> (default: <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>这段代码做的事情很简单。初始化一个 <code>cli.App</code> ，设置三个字段：</p>
<ul>
<li>名字，就是 “boom”。</li>
<li>用途，也是一个字符串，会在 help 信息用到。</li>
<li>动作，也就是执行程序时具体执行什么内容。这里是输出一个字符串。</li>
</ul>
<p>运行部分，将命令行参数 <code>os.Args</code> 作为参数传递给 <code>cli.App</code> 的 <code>Run()</code> 方法，框架就会接管参数的解析和后续的命令执行。</p>
<p>如果是跟着教程一路过来，那么很可能这里是第一次引入第三方包。IDE 可以会同时提示好几个关于 “github.com/urfave/cli/v2” 的错误，例如：”github.com/urfave/cli/v2 is not in your go.mod file” 。</p>
<p>可以根据 IDE 的提示修复，或者执行 <code>go mod tidy</code> ，或者直接等 <code>go build</code> 时自动解决依赖。无论选择哪一种，最终都会往 <code>go.mod</code> 里添加一行 <code>require github.com/urfave/cli/v2</code> 。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>当然，实现这么简单的功能，除了帮忙生成帮助信息，框架也没什么用武之地。</p>
<p>接下来我们用框架把 <code>gosrot</code> 改造一下，在基本不改变功能的前提下，把 <code>cli</code> 包用上。</p>
<p>因为有了 <code>cli</code> 包处理参数，我们就不用 <code>flag</code> 包了。（其实 <code>cli</code> 里面用到了 <code>flag</code> 包。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    app := &amp;cli.App&#123;</div><div class="line">        Name:   <span class="string">"gosort"</span>,</div><div class="line">        Usage:  <span class="string">"a simple command line sort tool"</span>,</div><div class="line">        Action: sortCmd,</div><div class="line">        Flags: []cli.Flag&#123;</div><div class="line">            &amp;cli.BoolFlag&#123;</div><div class="line">                Name:        <span class="string">"lex"</span>,</div><div class="line">                Aliases:     []<span class="keyword">string</span>&#123;<span class="string">"l"</span>&#125;,</div><div class="line">                Usage:       <span class="string">"sort lexically"</span>,</div><div class="line">                Destination: &amp;lex,</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">// unique 同为 BoolFlag，省略，请自行补完</span></div><div class="line">            <span class="comment">// ...</span></div><div class="line">            &amp;cli.StringFlag&#123;</div><div class="line">                Name:        <span class="string">"from"</span>,</div><div class="line">                Aliases:     []<span class="keyword">string</span>&#123;<span class="string">"f"</span>&#125;,</div><div class="line">                <span class="comment">// `FILE` 是占位符，在帮助信息中会输出 -f FILE    input from FILE</span></div><div class="line">                <span class="comment">// 用户能更容易理解 FILE 的用途</span></div><div class="line">                Usage:       <span class="string">"input from `FILE`"</span>,</div><div class="line">                Destination: &amp;from,</div><div class="line">            &#125;,</div><div class="line">            <span class="comment">// 省略剩余的 StringFlag...</span></div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    err := app.Run(os.Args)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>cli</code> 的 <code>Flag</code> 跟 <code>flag</code> 包类似，有两种设置方法。既可以设置以后通过 <code>cli.Context</code> 的方法读取值：<code>ctx.Bool(&quot;lex&quot;)</code> （<code>string</code> 等其它类型以此类推）。也可以直接把变量地址设置到 <code>Destination</code> 字段，解析后直接访问对应的变量。</p>
<p>这里为减少函数传参，用了后者，把参数值存储到全局（包级）变量。</p>
<p>程序入口改为 <code>cli.App</code> 之后，原来的 <code>main()</code> 函数就改为 <code>sortCmd</code> ，作为 <code>app</code> 的 <code>Action</code> 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 增加 Context 参数 和返回 error，以满足 cli.ActionFunc （Action 字段的类型）签名</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortCmd</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// 不再需要设置 flag 包</span></div><div class="line">    <span class="keyword">var</span> strs []<span class="keyword">string</span></div><div class="line">    <span class="keyword">if</span> from != <span class="string">""</span> &#123;</div><div class="line">        <span class="keyword">if</span> !isFile(from) &#123;</div><div class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s is not a file"</span>, from)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buf, err := ioutil.ReadFile(from)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"read %s fail, caused by\n\t%w"</span>, from, err)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 篇幅关系，省略... 参考之前两期的内容</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 省略...</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> output == <span class="string">""</span> &#123;</div><div class="line">        fmt.Println(res)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        err := ioutil.WriteFile(output, []<span class="keyword">byte</span>(res), <span class="number">0666</span>)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"write result to %s fail, caused by\n\t%w"</span>, output, err)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于程序被封装成了 <code>cli.App</code> ，程序的执行交给框架处理， <code>sortCmd</code> 内部不再自行调用 <code>os.Exit(1)</code> 退出，而是通过返回 <code>error</code> 类型，将错误信息传递给上层处理。</p>
<p>这里主要使用 <code>fmt.Errorf()</code> 格式化错误信息然后返回。从 <code>1.13</code> 开始，<code>fmt.Errorf()</code> 提供了一个新的格式化动词 <code>%w</code> ，允许将底层的错误信息，包装在新的错误信息里面，形成错误信息链。后续可以通过 <code>errors</code> 包的三个函数 <code>Is()</code> , <code>As()</code> 和 <code>Unwrap()</code> ，对错误信息进行进一步分析处理。</p>
<p>接下来编译执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;go build</div><div class="line"><span class="comment"># 不同参数的含义参考上一期内容</span></div><div class="line">&gt;gosort -h</div><div class="line">NAME:</div><div class="line">   gosort - a simple <span class="built_in">command</span> line sort tool</div><div class="line"></div><div class="line">USAGE:</div><div class="line">   gosort [global options] <span class="built_in">command</span> [<span class="built_in">command</span> options] [arguments...]</div><div class="line"></div><div class="line">COMMANDS:</div><div class="line">   <span class="built_in">help</span>, h  Shows a list of commands or <span class="built_in">help</span> <span class="keyword">for</span> one <span class="built_in">command</span></div><div class="line"></div><div class="line">GLOBAL OPTIONS:</div><div class="line">   --lex, <span class="_">-l</span>                 sort lexically (default: <span class="literal">false</span>)</div><div class="line">   --unique, -u              remove duplicates (default: <span class="literal">false</span>)</div><div class="line">   --from FILE, <span class="_">-f</span> FILE      input from FILE</div><div class="line">   --output FILE, -o FILE    output to FILE</div><div class="line">   --insep value, -i value   input seperator</div><div class="line">   --outSep value, <span class="_">-s</span> value  output seperator (default: <span class="string">","</span>)</div><div class="line">   --help, -h                show <span class="built_in">help</span> (default: <span class="literal">false</span>)</div><div class="line">&gt;gosort -u -i=, <span class="_">-s</span>=- 111,111,555,678,333,567,678</div><div class="line">111-333-555-567-678</div></pre></td></tr></table></figure>
<p><em>如果完全照着教程的思路重构，到这一步，你可能会发现，代码可以编译和运行，却没有输出。这是因为有一个地方很容易忘记修改。</em> 请尝试自行找到问题所在，并解决。</p>
<h2 id="另起炉灶"><a href="#另起炉灶" class="headerlink" title="另起炉灶"></a>另起炉灶</h2><p>框架除了解析参数，自动生成规范的帮助信息，还有一个主要的作用，是子命令（subcommand）的组织和管理。</p>
<p><code>gosort</code> 主要围绕一个目的（提交号的排序去重）展开，各项功能是组合而不是并列的关系，更适合作为参数，而不是拆分成多个子命令。而且之前的开发容易形成思维定势，下面我们另举一例，不在 <code>gosort</code> 基础上修改。</p>
<p>为了容易理解，接下来用大家比较熟悉的 <code>git</code> 做例子。篇幅关系，只展示项目可能的结构，不（可能）涉及具体的代码实现。</p>
<p>首先，我们看一下 <code>git</code> 有哪些命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;git <span class="built_in">help</span></div><div class="line">usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]</div><div class="line">           [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</div><div class="line">           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]</div><div class="line">           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</div><div class="line">           &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</div><div class="line"></div><div class="line">These are common Git commands used <span class="keyword">in</span> various situations:</div><div class="line"></div><div class="line">start a working area (see also: git <span class="built_in">help</span> tutorial)</div><div class="line">   <span class="built_in">clone</span>      Clone a repository into a new directory</div><div class="line">   init       Create an empty Git repository or reinitialize an existing one</div><div class="line"></div><div class="line">work on the current change (see also: git <span class="built_in">help</span> everyday)</div><div class="line">   add        Add file contents to the index</div><div class="line">   mv         Move or rename a file, a directory, or a symlink</div><div class="line">// 篇幅关系，省略余下内容，你可以自己尝试执行 git <span class="built_in">help</span> 查看</div></pre></td></tr></table></figure>
<p>总的来说，就是有一系列的全局选项（global options，跟在 git 后面，command 之前），一系列子命令（subcommand），每个命令下面还有一些专属的参数。</p>
<p>这样的工具，有几个特点：</p>
<ul>
<li>功能强大，子功能很多，无法用一个命令 + 若干参数完成，一般实现为多个子命令。</li>
<li>既有影响多数子命令的全局选项，也有某些子命令专属的选项。</li>
<li>子命令之间，既相互独立，又共享一部分底层实现。</li>
</ul>
<p>为了更好地组织程序，项目结构可以是这样子的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">│   go.mod</div><div class="line">│   go.sum</div><div class="line">│   main.go</div><div class="line">│</div><div class="line">├───cmd</div><div class="line">│       add.go</div><div class="line">│       clone.go</div><div class="line">│       common.go</div><div class="line">│       init.go</div><div class="line">│       mv.go</div><div class="line">|       ......</div><div class="line">│</div><div class="line">└───pkg</div><div class="line">    ├───<span class="built_in">hash</span></div><div class="line">    │       hash.go</div><div class="line">    │</div><div class="line">    ├───zip</div><div class="line">    |       zip.go</div><div class="line">    │</div><div class="line">    ├───......</div></pre></td></tr></table></figure>
<p><code>main.go</code> 是程序入口，为了保持结构清晰，这里只是初始化并运行 <code>cli.App</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"mygit/cmd"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/urfave/cli/v2"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    app := &amp;cli.App&#123;</div><div class="line">        Name:                   <span class="string">"mygit"</span>,</div><div class="line">        Usage:                  <span class="string">"a free and open source distributed version control system"</span>,</div><div class="line">        Version:                <span class="string">"v0.0.1"</span>,</div><div class="line">        UseShortOptionHandling: <span class="literal">true</span>,</div><div class="line">        Flags:                  cmd.GlobalOptions,</div><div class="line">        <span class="comment">// Before 在任意命令执行前执行，这里用来处理全局选项</span></div><div class="line">        Before: cmd.LoadGlobalOptions,</div><div class="line">        <span class="comment">// 同理，也可以定义 After 来执行收尾操作</span></div><div class="line">           <span class="comment">// After: xxx</span></div><div class="line">        Commands: cmd.Commands,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    err := app.Run(os.Args)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != cmd.ErrPrintAndExit &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的代码实现放到 <code>cmd</code> 包，基本上一个子命令对应一个源文件，代码查找起来非常清晰。</p>
<p><code>common.go</code> 存放 <code>cmd</code> 包的公共内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cmd</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"errors"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/urfave/cli/v2"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// Commands 将子命令统一暴露给 main 包</span></div><div class="line"><span class="keyword">var</span> Commands = []*cli.Command&#123;</div><div class="line">    cloneCmd,</div><div class="line">    initCmd,</div><div class="line">    addCmd,</div><div class="line">    mvCmd,</div><div class="line">    <span class="comment">// more subcommands ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GlobalOptions 将全局选项暴露给 main 包</span></div><div class="line"><span class="keyword">var</span> GlobalOptions = []cli.Flag&#123;</div><div class="line">    &amp;cli.PathFlag&#123;</div><div class="line">        Name:  <span class="string">"C"</span>,</div><div class="line">        Usage: <span class="string">"Run as if git was started in `path` instead of the current working directory"</span>,</div><div class="line">    &#125;,</div><div class="line">    &amp;cli.PathFlag&#123;</div><div class="line">        Name:  <span class="string">"exec-path"</span>,</div><div class="line">        Usage: <span class="string">"`path` to wherever your core Git programs are installed"</span>,</div><div class="line">    &#125;,</div><div class="line">    &amp;cli.BoolFlag&#123;</div><div class="line">        Name:  <span class="string">"html-path"</span>,</div><div class="line">        Usage: <span class="string">"Print the path, without trailing slash, where Git’s HTML documentation is installed and exit"</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 省略 man-path, info-path, paginate, no-pager...</span></div><div class="line">    <span class="comment">// more ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ErrPrintAndExit 表示遇到需要打印信息并提前退出的情形，不需要打印错误信息</span></div><div class="line"><span class="keyword">var</span> ErrPrintAndExit = errors.New(<span class="string">"print and exit"</span>)</div><div class="line"></div><div class="line"><span class="comment">// LoadGlobalOptions 加载全局选项</span></div><div class="line"><span class="keyword">var</span> LoadGlobalOptions = <span class="function"><span class="keyword">func</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="comment">// 并非实际实现，所以遇到对应的参数只是输出信息，方便观察</span></div><div class="line">    <span class="comment">// 全局选项既可以在这里读取并设置全局状态（如有）</span></div><div class="line">    <span class="comment">// 也可以在具体实现处再通过 ctx 读取（参考 add）</span></div><div class="line">    <span class="keyword">if</span> ctx.IsSet(<span class="string">"C"</span>) &#123;</div><div class="line">        fmt.Println(<span class="string">"started path changed to"</span>, ctx.Path(<span class="string">"C"</span>))</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 省略 exec-path ...</span></div><div class="line">    <span class="keyword">if</span> ctx.Bool(<span class="string">"html-path"</span>) &#123;</div><div class="line">        fmt.Println(<span class="string">"html-path is xxx"</span>)</div><div class="line">        <span class="keyword">return</span> ErrPrintAndExit</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 省略 man-path, info-path ...</span></div><div class="line">    <span class="keyword">if</span> ctx.Bool(<span class="string">"paginate"</span>) || !ctx.Bool(<span class="string">"no-pager"</span>) &#123;</div><div class="line">        fmt.Println(<span class="string">"pipe output into pager like less"</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fmt.Println(<span class="string">"no pager"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 子命令分组</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    cmdGroupStart = <span class="string">"start a working area"</span></div><div class="line">    cmdGroupWork  = <span class="string">"work on current change"</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>除了业务相关的公共逻辑放在 <code>common.go</code>，还有一些业务中立的底层公共类库，就可以放在 <code>pkg</code> 下面，例如 <code>hash.go</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hash</div><div class="line"></div><div class="line"><span class="comment">// MyHash 返回 source 的 hash 结果</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHash</span><span class="params">(source <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="comment">// 这是一个假的实现</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"hash of "</span> + source</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下其中一个子命令 <code>add</code> 的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cmd</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"mygit/pkg/hash"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/urfave/cli/v2"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> addCmd = &amp;cli.Command&#123;</div><div class="line">    Name:     <span class="string">"add"</span>,</div><div class="line">    Usage:    <span class="string">"Add file contents to the index"</span>,</div><div class="line">    Category: cmdGroupWork, <span class="comment">// 子命令分组</span></div><div class="line">    Flags: []cli.Flag&#123;</div><div class="line">        &amp;cli.BoolFlag&#123;</div><div class="line">            Name:    <span class="string">"verbose"</span>,</div><div class="line">            Aliases: []<span class="keyword">string</span>&#123;<span class="string">"v"</span>&#125;,</div><div class="line">            Usage:   <span class="string">"Be verbose"</span>,</div><div class="line">        &#125;,</div><div class="line">        &amp;cli.BoolFlag&#123;</div><div class="line">            Name:    <span class="string">"force"</span>,</div><div class="line">            Aliases: []<span class="keyword">string</span>&#123;<span class="string">"f"</span>&#125;,</div><div class="line">            Usage:   <span class="string">"Allow adding otherwise ignored files"</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// more options ...</span></div><div class="line">    &#125;,</div><div class="line">    Action: <span class="function"><span class="keyword">func</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</div><div class="line">        <span class="comment">// 仅输出信息，查看效果，不是真实实现</span></div><div class="line"></div><div class="line">        <span class="comment">// 这里也能读取全局选项</span></div><div class="line">        <span class="keyword">if</span> ctx.IsSet(<span class="string">"C"</span>) &#123;</div><div class="line">            <span class="comment">// do something</span></div><div class="line">        &#125;</div><div class="line">        items := ctx.Args().Slice()</div><div class="line">        <span class="keyword">if</span> ctx.Bool(<span class="string">"verbose"</span>) &#123;</div><div class="line">            <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</div><div class="line">                fmt.Println(<span class="string">"add"</span>, item, <span class="string">", hash is ["</span>, hash.MyHash(item), <span class="string">"]"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fmt.Println(<span class="string">"add"</span>, items, <span class="string">"successfully."</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拥有相同 <code>Category</code> 字段的命令会自动分组。这里在 <code>common.go</code> 预定义了一系列的分组，然后直接引用。之所以不是直接用字面量，是因为在多处引用字面量，非常容易出错，也不利于后续修改。</p>
<p>举例说，如果不小心在组名里输入多了一个 “s” ，就会变成下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">COMMANDS:</div><div class="line">   <span class="built_in">help</span>, h  Shows a list of commands or <span class="built_in">help</span> <span class="keyword">for</span> one <span class="built_in">command</span></div><div class="line">   start a working area:</div><div class="line">     <span class="built_in">clone</span>  Clone a repository into a new directory</div><div class="line">     init   Create an empty Git repository or reinitialize an existing one</div><div class="line">   work on current change:</div><div class="line">     add  Add file contents to the index</div><div class="line">   work on current changes:</div><div class="line">     mv  Move or rename a file, a directory, or a symlink</div></pre></td></tr></table></figure>
<p>好了，一个连低仿都不算的 <code>git</code> 算是搭出一个空架子，编译执行看看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&gt;go build</div><div class="line"><span class="comment"># help 命令和 --help, --version 框架会自动添加，如果不需要可以通过特定的字段关闭</span></div><div class="line">&gt;mygit <span class="built_in">help</span></div><div class="line">pipe output into pager like less</div><div class="line">NAME:</div><div class="line">   mygit - a free and open <span class="built_in">source</span> distributed version control system</div><div class="line"></div><div class="line">USAGE:</div><div class="line">   mygit [global options] <span class="built_in">command</span> [<span class="built_in">command</span> options] [arguments...]</div><div class="line"></div><div class="line">VERSION:</div><div class="line">   v0.0.1</div><div class="line"></div><div class="line">COMMANDS:</div><div class="line">   <span class="built_in">help</span>, h  Shows a list of commands or <span class="built_in">help</span> <span class="keyword">for</span> one <span class="built_in">command</span></div><div class="line">   start a working area:</div><div class="line">     <span class="built_in">clone</span>  Clone a repository into a new directory</div><div class="line">     init   Create an empty Git repository or reinitialize an existing one</div><div class="line">   work on current change:</div><div class="line">     add  Add file contents to the index</div><div class="line">     mv   Move or rename a file, a directory, or a symlink</div><div class="line"></div><div class="line">GLOBAL OPTIONS:</div><div class="line">   -C path           Run as <span class="keyword">if</span> git was started <span class="keyword">in</span> path instead of the current working directory</div><div class="line">   --exec-path path  path to wherever your core Git programs are installed</div><div class="line">   --html-path       Print the path, without trailing slash, <span class="built_in">where</span> Git’s HTML documentation is installed and <span class="built_in">exit</span> (default: <span class="literal">false</span>)</div><div class="line">   --man-path        Print the manpath (see man(1)) <span class="keyword">for</span> the man pages <span class="keyword">for</span> this version of Git and <span class="built_in">exit</span> (default: <span class="literal">false</span>)</div><div class="line">   --info-path       Print the path <span class="built_in">where</span> the Info files documenting this version of Git are installed and <span class="built_in">exit</span> (default: <span class="literal">false</span>)</div><div class="line">   --paginate, -p    Pipe all output into less (or <span class="keyword">if</span> <span class="built_in">set</span>, <span class="variable">$PAGER</span>) <span class="keyword">if</span> standard output is a terminal (default: <span class="literal">false</span>)</div><div class="line">   --no-pager        Do not pipe Git output into a pager (default: <span class="literal">false</span>)</div><div class="line">   --help, -h        show <span class="built_in">help</span> (default: <span class="literal">false</span>)</div><div class="line">   --version, -v     <span class="built_in">print</span> the version (default: <span class="literal">false</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># help 命令连子命令的帮助信息也自动生成了</span></div><div class="line">&gt;mygit <span class="built_in">help</span> add</div><div class="line">pipe output into pager like less</div><div class="line">NAME:</div><div class="line">   mygit add - Add file contents to the index</div><div class="line"></div><div class="line">USAGE:</div><div class="line">   mygit add [<span class="built_in">command</span> options] [arguments...]</div><div class="line"></div><div class="line">CATEGORY:</div><div class="line">   work on current change</div><div class="line"></div><div class="line">OPTIONS:</div><div class="line">   --verbose, -v  Be verbose (default: <span class="literal">false</span>)</div><div class="line">   --force, <span class="_">-f</span>    Allow adding otherwise ignored files (default: <span class="literal">false</span>)</div><div class="line"></div><div class="line"></div><div class="line">&gt;mygit -C here add a b c</div><div class="line">started path changed to here</div><div class="line">pipe output into pager like less</div><div class="line">started path changed to here</div><div class="line">add [a b c] successfully.</div><div class="line"></div><div class="line"></div><div class="line">&gt;mygit add -v a b c</div><div class="line">pipe output into pager like less</div><div class="line">add a , <span class="built_in">hash</span> is [ <span class="built_in">hash</span> of a ]</div><div class="line">add b , <span class="built_in">hash</span> is [ <span class="built_in">hash</span> of b ]</div><div class="line">add c , <span class="built_in">hash</span> is [ <span class="built_in">hash</span> of c ]</div><div class="line">add [a b c] successfully.</div></pre></td></tr></table></figure>
<p>光看帮助信息是不是感觉还挺像回事。</p>
<p>希望通过这个粗糙的例子，能让大家对 <code>urfave/cli</code> 这个框架建立一点直观的印象。</p>
<p>更多的例子、更详细的字段用法，可以参考</p>
<ul>
<li>项目主页：<a href="https://github.com/urfave/cli" target="_blank" rel="external">https://github.com/urfave/cli</a></li>
<li>文档：<a href="https://pkg.go.dev/github.com/urfave/cli/v2" target="_blank" rel="external">https://pkg.go.dev/github.com/urfave/cli/v2</a></li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>到这里，鸽了很久的 CLI （命令行程序）部分暂告一段落。</p>
<p>在实际写过几个 go 程序之后，相信大家对于 go 已经有一些直观的认识。与此同时，前面只介绍了很少一部分语言特性，在实际编程中可能会产生各种疑惑。后面几期回归基础知识讲解，希望能解开其中一部分疑惑。</p>
<p>最后的最后，关于 CLI 程序，推荐一篇文章：《<a href="https://mp.weixin.qq.com/s/Bs44U4ejmJazSnOUWAhaRg" target="_blank" rel="external">做一个命令行工具，是一件挺酷的事儿</a>》</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过前面两期的介绍，相信大家已经可以写简单的命令行程序，并且能够使用命令行参数。&lt;/p&gt;
&lt;p&gt;即使遇到一些困难，建立直观认识和了解关键词之后，在网络上搜索答案也变得相对容易。&lt;/p&gt;
&lt;p&gt;接下来介绍 CLI 框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>关于保险的两个追加话题之一：穗岁康</title>
    <link href="https://jaycechant.info/2020/suisuikang/"/>
    <id>https://jaycechant.info/2020/suisuikang/</id>
    <published>2020-12-28T08:26:42.000Z</published>
    <updated>2021-01-11T16:34:30.624Z</updated>
    
    <content type="html"><![CDATA[<p>前些天写《<a href="https://jaycechant.info/2020/insurance-for-kids/">为什么不要先给小孩子买保险？</a>》回应读者提问。</p>
<p>一开始先把初步的回答发在知识星球上。整理成文章发出来之前，有朋友问了新的问题，加上我写东西总想写全面的老毛病，追加了两个相关话题。</p>
<a id="more"></a>
<p>不过最近忙于装修，文章已经拖了一段时间，最后就没要追加的部分直接发了。追加的话题也就搁置了。</p>
<p>突然发现，2020 年马上就要过去了，话题就要失去时效性了，赶紧整理一下也发出来。</p>
<p>时间仓促，先简单提一下惠民保。不追求严谨，能引起大家注意有这么一件事就好。</p>
<p>[TOC]</p>
<h2 id="惠民保"><a href="#惠民保" class="headerlink" title="惠民保"></a>惠民保</h2><p>除了上一篇文章里提到的常见的保险，关注保险的朋友最近一两年大概会注意到一个新品种：惠民保。</p>
<p>惠民保并不是某一个保险的名称，而是一类保险的泛称。在不同地方、不同上下文，可能还会被称为全民保、市民保。</p>
<p>它本质上是一类由地方政府<strong>主导设计</strong>，经<strong>公开竞价招标</strong>后由商业保险公司承保的<strong>普惠型商业补充医疗险</strong>。</p>
<p>5 年前，深圳最早试水『惠民保』，但很快又陷入沉寂。最近一两年，以城市为单位，各种惠民保遍地开花，以『低保费、低门槛、高保障』的姿态回归。像北京的『京惠保』、重庆的『渝惠保』、东莞的『市民保』，其它还有类似『八闽保』、『蚌惠保』、『浙丽保』、『皖惠保』、『佛医保』，从名字就能看出是哪个地方的。</p>
<p>而这个话题进入我朋友圈的讨论范围，是因为今年广州一下子推出了『广州惠民保』和『穗岁康』两款保险。</p>
<p>总的来说，惠民保主打的就是：价格便宜、投保门槛低、适用人群广泛。</p>
<h2 id="值得买吗"><a href="#值得买吗" class="headerlink" title="值得买吗"></a>值得买吗</h2><p>不绕弯，直接回答核心问题：</p>
<ul>
<li>已有大病医疗保单的人群，以及身体健康、很容易买到大病医疗险的年轻人，<strong>不值得</strong>。</li>
<li>因为各种原因，被大病医疗拒保的人群，以及因为年纪太大，为高额保费犹豫的人群，基本算<strong>买到就是赚到</strong>。</li>
</ul>
<p>简单说，只要你买得到、买得起市面上主流的大病医疗险，惠民保对你来说就比较鸡肋。</p>
<p>而如果你因为各种原因被拦在了商业大病医疗的门外，那么惠民保就是你的救星。</p>
<p>下面给一个快速自查列表：</p>
<ul>
<li>已有大病医疗保单：<strong>不必考虑</strong>。</li>
<li>暂无大病医疗保单，身体健康，无拒保因素：尽快买一份商业大病医疗，<strong>不考虑穗岁康</strong>。优先买定期，保证续保的一年期也不错。</li>
<li>年纪较大，商业医疗险保费较高：尽量买商业医疗险，资金紧张可以先考虑穗岁康。</li>
<li>暂无保单，有拒保因素：优先考虑约保险顾问制定合适的方案。如果时间上、资金上有困难，先买穗岁康。</li>
</ul>
<p>需要注意的是，穗岁康虽然没有等待期，但分批次限时购买。</p>
<p>2020 年 <strong>12 月 1 日至 31 日</strong> 第一批购买的，保障期为 <strong>2021 年 1 月 1 日至 12 月 31 日</strong>。</p>
<p>而 2021 年 <strong>1 月 1 日 至 31 日</strong> 第二批购买的，保障期为 <strong>2021 年 2 月 1 日至 12 月 31 日</strong>。</p>
<p>换言之，如果你是需要购买的，最好快一点购买。同样的价格，<strong>第二批的保障期少了一个月</strong>。</p>
<p><img src="../../images/insurance/suisuikang.jpg" alt=""></p>
<p>这里以广州的保险考虑，并没有去研究其它城市的情况。其它惠民保未必符合同样的结论。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>惠民保根据其保障范围来看，仍然是一款大病医疗险。</p>
<p>既然是大病医疗，我们拿<strong>穗岁康</strong>跟最容易买到的微信<strong>微医保</strong>对比一下。（注意，不是推荐微医保。每个人都有微信，容易购买，方便拿出来比较。）</p>
<p>穗岁康：</p>
<p>穗岁康不限年龄、户籍、职业，没有等待期，也不限制既往病史。保费与年龄无关，均为 180 一年，可以用医保个人账户支付。</p>
<p>唯一的限制，是被保险人必须是广州市医保的参保人。</p>
<table>
<thead>
<tr>
<th></th>
<th>年度支付限额</th>
<th>免赔额</th>
<th>赔付比例</th>
</tr>
</thead>
<tbody>
<tr>
<td>住院门特医疗费用</td>
<td>100 万</td>
<td>1.8 万</td>
<td>80%</td>
</tr>
<tr>
<td>住院合规药品和检验检查费用</td>
<td>100 万</td>
<td>1.8 万</td>
<td>70%</td>
</tr>
<tr>
<td>门诊合规药品费用</td>
<td>30 万</td>
<td>国谈、创新药 1.8 万 / 其它 5 万</td>
<td>60% / 50%</td>
</tr>
<tr>
<td>特殊医用耗材</td>
<td>胰岛素 4.2 万 三年限报一泵</td>
<td>无</td>
<td>70%</td>
</tr>
<tr>
<td>18 岁以下 I 型糖尿病</td>
<td>1.3 万/年，3250 元/季</td>
<td>无</td>
<td>70%</td>
</tr>
<tr>
<td>指定病种筛查费用</td>
<td>100 元</td>
<td>无</td>
<td>低于 100 元按 80%</td>
</tr>
</tbody>
</table>
<p>宣传时，保额一般写 235 万。这个 235 万并非通用的保额，而是分成上面几个部分。单项超出了，另一项没动过，也不能拿过来用。所以分项当然不如直接通用的保额来得好。</p>
<p>微医保（2020版）：</p>
<p>微医保刚好相反，跟绝大多数的商业医疗险一样，对年龄（30天到65岁）、职业（排除高危职业）有限制，有等待期，需要健康告知（所以对既往病史限制比较严格）。保费跟年龄直接相关，下面给出费率表（有医保，按年缴费）：</p>
<p><img src="../../images/insurance/weiyibao_feilv.jpg" alt=""></p>
<table>
<thead>
<tr>
<th></th>
<th>年度支付限额</th>
<th>免赔额</th>
<th>赔付比例</th>
</tr>
</thead>
<tbody>
<tr>
<td>100种重大疾病医疗</td>
<td>600 万</td>
<td>无</td>
<td>质子、重离子放疗 60%，其他100%</td>
</tr>
<tr>
<td>一般疾病及意外医疗</td>
<td>300 万</td>
<td>1 万</td>
<td>100%</td>
</tr>
<tr>
<td>恶性肿瘤院外特定药物费用</td>
<td>600 万</td>
<td>无</td>
<td>100%</td>
</tr>
<tr>
<td>重大疾病住院津贴</td>
<td>100 元/天，不超过 180天/年</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>新冠肺炎保障</td>
<td>5 万危重，10 万身故</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>可以看到，除了 4 周岁以前的婴幼儿，和年龄较大的中老年人，穗岁康的<strong>价格并无优势</strong>。</p>
<p>青少年就不用说了。即使对于 30 岁上下的人群（读者主要集中在这个年龄段），虽然保费翻倍了，但是<strong>保障更足</strong>。</p>
<p>一般而言，即使得了重大疾病，一年内花掉几百万也很少见，所以姑且认为穗岁康的 100 万保额够用。即使如此，光靠免赔额和赔付比例，两者还是拉开了很大差距。</p>
<p>假设患 100 种重大疾病以外的病，但是还是比较严重（如意外重伤需要手术），花掉了 30 万的医疗费，微医保可以赔付 29 万 （30 - 1），而穗岁康只能赔付 22.56 万（(30 - 1.8) x 0.8）。两者差距 6 万多。</p>
<p>如果是门诊（穗岁康限 30 万），或者目录内疾病（微医保 0 免赔），或者花费更多的医疗费，两者差距更大。</p>
<p>即使是老年人，如果已有大病医疗保单（保证续保的一年期，或者定期保单），只要不是穷到交不起保费，也建议继续续费保障更足的商业医疗险。</p>
<p>但对于因为各种原因被拒保的朋友，没有任何门槛的穗岁康当然香。<strong>打折扣的保障也是保障</strong>，总比裸奔强。何况保费一共才 180 元，还可以用医保个人账户支付。</p>
<p>像我这样比较少看病的，个账里钱本来就剩得比较多。</p>
<h2 id="可以都买吗"><a href="#可以都买吗" class="headerlink" title="可以都买吗"></a>可以都买吗</h2><p>既然这么便宜，我医保个账剩的钱也多，在原有商业大病医疗的基础上，把穗岁康也买了行不行？</p>
<p><strong>不建议。</strong></p>
<p>医疗保险是报销险，花出去的钱可以分割后在多张保单理赔，但不会重复理赔。由于一般都允许将其它地方的报销纳入免赔额，所以搭配保单需要搭配不同的免赔额和保额。</p>
<p>一般情况是低免赔+低保额的保单，搭配高免赔+高保额的保单。</p>
<p>举例说，一个补充医疗险，免赔 1 千，保额 2 万；搭配大病医疗，免赔 1 万，保额 300 万。然后产生了两个保险理赔范围内的医疗费 10 万，就可以先找第一张保单理赔，免赔 1 千后赔付 2 万；这 2 万 1 千可以算入第二张保单的免赔额，剩余的 7 万 9 千全赔。</p>
<p>最终的效果就是，两张保单加起来赔付了 9 万 9 千，只有 1 千免赔。</p>
<p>我们可以看到，穗岁康相对市面的大病医疗来说，免赔高、保额低，赔付范围是大病医疗的子集，完全重叠，所以基本上没有用得上的情况。那如果没有用，180 的钱也是钱，用来干点啥不好。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>同样的保险，为什么对不同人群会得出截然相反的结论呢？</p>
<p>惠民保跟一般商业医疗险相比，多了政府引导的政策性，有普惠性质。类似药品的批量采购，企业在这里更多是保本微利，甚至是赔本赚吆喝。当作一次品牌宣传、新客开发，或者当搞好政府关系，或者通过走量获取用户数据，等等。</p>
<p>既然保险公司都没钱赚了，那得到好处的肯定是消费者。别急，不一定。</p>
<p>保险公司可以不赚钱。甚至可以微亏当做营销，却不可能长期赔钱。</p>
<p>羊毛出在羊身上，长远来说，保费和理赔一定是基本打平。理赔的钱，就是从你交的钱里面出。</p>
<p>我们看商业保险的条款特别严格，往往觉得它在针对我们。如果我们被拒保了，（对我们而言）这款产品可能太严格了。但反过来说，如果你满足条件投保了，<strong>这些严格的条款就是在保护你的钱</strong>。</p>
<p>只有理赔少，保费才可能便宜。不同人群的身体状况不同，理赔概率不同，就理应收取不同的保费。</p>
<p>如果不区分年龄和身体状况，均一收费，实际上就是<strong>年轻人在补贴老年人、健康人群在补贴亚健康人群</strong>。</p>
<p>从民生工程的角度来说，这种转移支付不一定是错的。所以如果你手里资金充裕，也不妨投保，当成做公益。</p>
<p>但从经济理性来说，身体健康的人不建议买。而且长远来说，当大家都意识到这个问题，会造成逆向选择，来投保的都是身体状况有瑕疵的人群。这会导致理赔率进一步上升，最后有可能会无法维持。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我家里人都配置了大病医疗险。在对比过条款之后，首先我们年轻这一代不考虑穗岁康。</p>
<p>而即使考虑到父母的保费很贵，在已有保单的情况下也不考虑切换。何况我的父母没有在广州参加医保。</p>
<p>最后我给孩子买了一份。孩子因为早产，尽管后来发育得很好，2 岁之前还是被多数大病医疗险拒保。给孩子买一份，正好填补他 2 岁之前的空档。刚好他的医保也是在广州。</p>
<p>因为篇幅的关系，<strong>没有提及『广州惠民保』</strong>。你可以简单地认为它是更低配的穗岁康。保费更低只需要 49 一年，但是理赔的限制更多，包括更高的免赔额，更低的保额，更多的除外（既往症不影响投保，但重要既往症除外）。穗岁康已经是被拒保后的备选，『广州惠民保』就更加不考虑了。相信大家不会连一年 131 元的差价都掏不出。</p>
<p>最后的最后，必须强调我不是保险专业人士。我只是自己有需求，做了对比之后把我不靠谱的结论分享出来。如果有专业人士的意见，请优先以他们的结论为准。</p>
<p>因为是第一年推出，无法预估未来的政策走向。考虑到逆向选择的问题，未来是否会增加新投保的限制呢？为此是否需要先投保呢（因为一般对续保不作限制）。所以以上的结论，局限性非常大，请谨慎参考。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天写《&lt;a href=&quot;https://jaycechant.info/2020/insurance-for-kids/&quot;&gt;为什么不要先给小孩子买保险？&lt;/a&gt;》回应读者提问。&lt;/p&gt;
&lt;p&gt;一开始先把初步的回答发在知识星球上。整理成文章发出来之前，有朋友问了新的问题，加上我写东西总想写全面的老毛病，追加了两个相关话题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>答读者问：为什么 Go 里面不能把任意切片转换为 []interface{} ？</title>
    <link href="https://jaycechant.info/2020/why-element-type-of-slice-cannot-be-converted-in-go/"/>
    <id>https://jaycechant.info/2020/why-element-type-of-slice-cannot-be-converted-in-go/</id>
    <published>2020-12-14T19:04:10.000Z</published>
    <updated>2020-12-19T16:52:43.553Z</updated>
    
    <content type="html"><![CDATA[<p>本文来源于一个朋友的提问。</p>
<blockquote>
<p>数组怎么样展开？</p>
</blockquote>
<a id="more"></a>
<p>问题描述比较模糊，进一步沟通之后得知，他需要的是将一个数组（其实是切片）展开，来作为函数的可变参数。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>关于可变参数，之前在<a href="../golang-in-action-day-6/">这里</a>（函数签名部分）介绍过。考虑到那篇文章内容比较多，这里再介绍一下。</p>
<p>简单来说，可变参数就是函数里以 <code>x ...T</code> 这种形式声明的参数。举例说 <code>f(s ...int)</code>，参数 <code>s</code> 接受零到多个 <code>int</code> 型的参数，可以像这样调用 <code>f(a, b, c)</code> （<code>a</code>，<code>b</code>，<code>c</code> 都是 <code>int</code> 型的值）。逐个传入的参数（实参）会装包成一个切片 <code>s</code>，传递给函数。</p>
<p><img src="../../images/golang-variadic-argument/golang-variadic-argument.png" alt=""></p>
<p>从函数内部的角度，这跟 <code>f(s []int)</code> 是等价的。而从调用方的角度看则有差别：可变参数接受多个 <code>int</code> 型参数，而后者只能接受一个 <code>[]int</code> 类型参数。</p>
<p>如果有多个同类型参数，遇到第二种函数定义（参数类型是切片），就只能自己先创建一个切片，再直接传递切片。不过相信你也明白了，可变参数不过是把创建切片过程省略的<strong>语法糖</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数签名：f(s []int)</span></div><div class="line">a := []<span class="keyword">int</span>&#123;x, y, z&#125;</div><div class="line">f(a)</div></pre></td></tr></table></figure>
<p>反过来，有一个 <code>[]int</code> 变量 <code>b</code> ，需要传递给可变参数怎么办？难道要 <code>f(b[0], b[1], b[2])</code> 这样一个个用下标访问？如果切片很长，又或者直接不确定长度怎么办？</p>
<p>在其它语言，例如 Python 里，对于可迭代类型对象（Iterator Types），可以用装包和拆包（解包）解决这个问题，使用上非常灵活。</p>
<p>Go （看起来）也可以解包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数签名：f(s ...int)</span></div><div class="line">f(b...)</div></pre></td></tr></table></figure>
<p>注意 <code>...</code> 的位置，声明时在前，调用时在后。</p>
<p>但，这是一个假的解包。这只是<strong>又一个语法糖</strong>，背后把 <code>b</code> 直接赋值给 <code>s</code> 。把 <code>b</code> 拆分成逐个参数传递，然后重新打包成切片 <code>s</code> 这件事，根本<strong>没有发生</strong>。</p>
<p>你以为的解包：</p>
<p><em>（图中的细箭头表示指针，粗箭头表示拷贝）</em></p>
<p><img src="../../images/golang-variadic-argument/golang-variadic-argument-unpack-expected.png" alt=""></p>
<p>或者至少是这样的：</p>
<p><img src="../../images/golang-variadic-argument/golang-variadic-argument-unpack-expected2.png" alt=""></p>
<p>其实是这样的：</p>
<p><img src="../../images/golang-variadic-argument/golang-variadic-argument-unpack-indeed.png" alt=""></p>
<p>切片是引用类型，变量本身保存的是头信息（元数据），里面有一个指向底层数组的指针，元素数据保存在数组里。在赋值和传参时，拷贝的只是切片头（slice header），底层数组并不会递归拷贝。新旧切片共享同一个底层数组。</p>
<p><code>...</code> 只是表示 <code>b</code> 是一组参数，而不是一个参数。如果缺少 <code>...</code> ，直接 <code>f(b)</code> ，会把 <code>b</code> 直接当成一个参数（也就是 <code>s</code> 切片的一个元素），参数的 <code>[]int</code> 类型和元素的 <code>int</code> 不匹配。</p>
<p>好消息是，没有额外开销。坏消息是，因此使用上多了很多限制。</p>
<ul>
<li><code>b</code> 必须是相同类型的切片。<code>[]string</code> 传递给 <code>[]int</code> 固然不行；因为没有经过解包后重新装包，数组传递给切片也不行。</li>
<li><code>...</code> （姑且还是叫解包）不能跟其它参数或者其它解包参数一起使用。<code>f(x, b...)</code> 或者 <code>f(b..., c...)</code> 都会报错。因为没有经过解包后重新装包，元素 <code>x</code> 和切片 <code>b</code> ，或者<code>b</code> 和 <code>c</code> 两个切片，都不会组成一个新切片。</li>
<li>修改 <code>s</code> 的元素，会影响到 <code>b</code> 。（因为它们共享一个底层数组）</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于没有看到具体代码，根据对方的描述，猜测问题出在没有理解『伪解包』上。所以我对这部分进行了解释。</p>
<p>然而问题并没有解决，第二天提问者又来了。</p>
<p>这次提问者给了更详细的信息。</p>
<p>他需要调用 <code>gorm</code> 包的 <code>Having</code> 方法，方法签名是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DB)</span> <span class="title">Having</span><span class="params">(query <span class="keyword">interface</span>&#123;&#125;, values ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">DB</span></span></div></pre></td></tr></table></figure>
<p>看起来跟我的猜测差不多。还有什么该注意的我忘了说？</p>
<p>我正想要代码和具体的报错信息，对方说了一句：</p>
<blockquote>
<p>为什么 []string 不能转为 []interface{}？</p>
</blockquote>
<p>我一下子明白了问题所在：解包的实参是一个 <code>[]string</code> 而不是 <code>[]interface{}</code> 。</p>
<p>如果是多个 <code>string</code> 变量作为 <code>values</code> 参数，反而没有问题。但是把 <code>[]string</code> 解包，就报错了。</p>
<p>当然，提问者自己也意识到问题出在这里了，只是不明白原因。而我过分关注可变参数，忘了留意类型。</p>
<p>这个现象很容易重现，完全没必要用到 <code>gorm</code> 包。下面的代码就报同样的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Print(<span class="string">"this"</span>, <span class="number">1</span>, <span class="string">"is"</span>, <span class="string">"fine"</span>)</div><div class="line"></div><div class="line">    ifaces := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>, <span class="string">"good"</span>, <span class="string">"case"</span>, <span class="string">"here"</span>&#125;</div><div class="line">    <span class="comment">// OK</span></div><div class="line">    fmt.Print(ifaces...)</div><div class="line"></div><div class="line">    strs := []<span class="keyword">string</span>&#123;<span class="string">"bad"</span>, <span class="string">"case"</span>, <span class="string">"here"</span>&#125;</div><div class="line">    <span class="comment">// cannot use strs (variable of type []string) as []interface&#123;&#125; value in argument to fmt.Print</span></div><div class="line">    fmt.Print(strs...)</div><div class="line"></div><div class="line">    ifaces2 := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</div><div class="line">        ifaces2 = <span class="built_in">append</span>(ifaces2, str)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// OK now</span></div><div class="line">    fmt.Print(ifaces2...)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意是 <code>fmt.Print(...interface{})</code> ，内置函数 <code>print(...Type)</code>  的原理不在今天的讨论范围。</p>
<hr>
<p>当然理解可变参数也很必要。我们还是需要先理解（伪）解包，知道解包的背后是直接传递切片。如果是语言做了真实的解包和重新装包，这个问题也就不存在了（见 <code>ifaces2</code> 部分代码）。</p>
<p>一旦了解这些，提问者很自然地发现问题变成了：既然任意类型都<strong>可以转换为空接口</strong> <code>interface{}</code>，为什么 <code>[]string</code> （或者任意别的类型的切片）<strong>不能转为空接口切片</strong> <code>[]interface{}</code>？</p>
<p><strong>是的，不可以。其它强类型语言也不可以。其它容器也不可以。</strong></p>
<p>简单粗暴的结论就是：</p>
<ul>
<li><p>子类型变量可以向父类型变量转换；但存放子类型的容器跟存放父类型的容器<strong>没有关系</strong>，不能转换。（为了方便理解，父子类型借用的 Java 的概念，Go 没有继承机制。）</p>
</li>
<li><p>Go 里面没有继承，只有接口和实现；同时（暂时）没有泛型，只有内置派生类型（slice, map, chan 等）可以指定元素的类型。Go 版本的表述是，即使类型 <code>T</code> 满足接口 <code>I</code>，各自的派生类型也没有任何关系（例如 <code>[]T</code> 和 <code>[]I</code>）。</p>
</li>
</ul>
<p>在 Java 里，<code>Integer</code> 是 <code>Number</code> 的子类，<code>ArrayList&lt;Integer&gt;</code> 是 <code>List&lt;Integer&gt;</code> 的子类。但是，<code>List&lt;Integer&gt;</code> 跟 <code>List&lt;Number&gt;</code> 没有继承关系，不能转换，只能创建新容器，然后拷贝元素。</p>
<p>对应到 Go 里，<code>string</code> 满足 <code>interface{}</code> ，<code>string</code> 变量可以转换为 <code>interface{}</code> 变量；但对应的切片 <code>[]string</code> 却不能转换为 <code>[]interface{}</code> 。<code>map</code> 和 <code>chan</code> 同理。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>设计成这样的理由，稍微解释就很容易理解。</p>
<p>无论 Java 的类继承和接口实现，还是 Go 的鸭子类型接口，都是为了实现多态。</p>
<p>关于多态（特别是不同语言下的多态）这里不展开。一句话来形容的话，Java 的多态是『代父从军』，『龙生九子，各有不同』；Go 的多态则是『如果它跑起来像鸭子，叫起来像鸭子，那它就是一只鸭子』，但是每一只『鸭子』可以有自己不同的行为。</p>
<p>具体的实现只要满足相同的约束，就可以赋值给上层抽象类型（父类型或者接口），当作该类型使用；与此同时，不同的实现有不同的行为。调用代码只需要认准上层类型的约束，不必关心具体实现的行为，达到调用和实现的<strong>松耦合</strong>。这样可以做到在不修改调用的情况下，替换掉具体实现。</p>
<p><code>Integer</code> 完全可以当作 <code>Number</code> 使用，因为 <code>Number</code> 有的行为 <code>Integer</code> 都有；日后也可以根据需要替换成 <code>Float</code> 或者 <code>Double</code>。<code>ArrayList&lt;T&gt;</code> 和 <code>List&lt;T&gt;</code> 也类似（注意，<code>T</code> 是同一个类型）。Go 的空接口 <code>interface{}</code> 对类型没有任何约束，可以接受任何类型。</p>
<p>可一旦涉及容器，情况就变了。如果一个 <code>ArrayList&lt;Integer&gt;</code> 可以当作 <code>ArrayList&lt;Number&gt;</code> ，意味着调用方可以往里面添加任何 <code>Number</code> 类型（及子类型），有可能是 <code>Integer</code> ，也可能是 <code>Float</code> 或者 <code>Double</code> 。</p>
<p>背后的具体实现 <code>ArrayList&lt;Integer&gt;</code> 可以放别的 <code>Number</code> 类型吗？不行。</p>
<p>同样的，<code>[]string</code> 不能存放 <code>string</code> 以外的元素。如果允许 <code>[]string</code> 转换成 <code>[]interface{}</code> 变量，<strong>意味着需要接受任意类型的元素</strong>。</p>
<p>总结：</p>
<p>父类或者接口作为上层抽象类型，在运行时可能会被替换为任意子类型，其<strong>可接受的行为应该是子类型的子集</strong> 。（父亲会的技能，孩子们都要会。父亲不能接孩子们不会的活，否则这个活就无法在运行时分派给孩子们干。）</p>
<p><code>[]interface{}</code> 可以接受的元素类型，比任意具体类型的切片都要多，显然不满足上述条件。从『空接口是任意类型的抽象』，得出空接口切片（或者其它容器）也是上层抽象，就属于想当然了。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来源于一个朋友的提问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组怎么样展开？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>为什么不要先给小孩子买保险？</title>
    <link href="https://jaycechant.info/2020/insurance-for-kids/"/>
    <id>https://jaycechant.info/2020/insurance-for-kids/</id>
    <published>2020-11-16T17:38:01.000Z</published>
    <updated>2020-12-28T08:32:44.217Z</updated>
    
    <content type="html"><![CDATA[<p>知识星球读者提问：</p>
<blockquote>
<p>如果是帮小朋友买保险，需要买哪些保险？教育基金之类的有没有必要？</p>
</blockquote>
<a id="more"></a>
<p>这个提问非常典型。典型就典型在，这个问题的提法，本身就有问题。</p>
<p>小朋友是家人的心头肉，特别关注，人之常情。但是，有必要<strong>优先为小朋友买保险</strong>吗？  要<strong>优先考虑教育基金</strong>吗？</p>
<p><strong>目录</strong></p>
<p>[TOC]</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>问题很大，展开说够写几篇文章。</p>
<p>我尽量挑重点说。能问到我这个外行这里来，说明起码比我外行，尽量一篇文章先建立基本的认识。更具体的分析公众号和知乎里多的是专业人士。我这个外行可能会说错，不要当作最终答案。重要的是读者先有了基本概念，后续进一步了解时知道搜索关键词。</p>
<p>有些重要的话放到了最后，希望你能看完。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>问的是帮小孩子买。对于婴幼儿，我个人推荐的购买优先级是，<strong>医保 &gt; 意外 &gt; 大病医疗 &gt; 重疾</strong>。小额医疗、寿险和教育基金可能不是普遍的需求。</p>
<h3 id="1-医保、意外险"><a href="#1-医保、意外险" class="headerlink" title="1. 医保、意外险"></a>1. 医保、意外险</h3><p><strong>全家必买，基础保障</strong>。</p>
<p>医保（社会医疗保险）的保障有些高不成低不就，却仍然是非常重要的基础保障。不要指望医保解决全部问题，『高不成』的部分可以由商业保险来补足。</p>
<p>由于意外险只赔意外引起的后果，除特殊职业，不同人发生意外的概率差别有限。所以便宜，规则不复杂。</p>
<p>成人约 300 保费可以保一百万（一年，下同）。小孩限保额，10 岁以下限 20 万，18 岁以下限 50 万（儿童大保额有道德风险），根据不同年龄不同的附加项，百元左右一年。</p>
<hr>
<p>这两项<strong>越早买越好</strong>，一天没买上，孩子就暴露在无保障的风险中。孩子<strong>出生后应该尽快办完出生证、户口，然后马上买</strong>。</p>
<p>医保正常情况是前一年年底扣费，所以出生的第一年算补办，是有时间限制的，一般是出生后 90 天内。各地规定有不同。</p>
<p>意外险产品都比较接近，很少有特殊规定，不值得太费心，挑热销产品，保障足保费低的，怎么方便怎么买。像直接微信买『护身福』就挺好。（可以扫码直接购买）</p>
<p><img src="../../images/hushenfu.png" alt=""></p>
<p>注意，这里<strong>并非特别推荐</strong>护身福。只是对于多数人，研究、比较、管理保单都太麻烦了，门槛一高容易忘了买（或者买完忘了保单在哪）。这点上说，因为每个人都有微信，腾讯旗下产品会便捷一些。如果你愿意去花时间了解，可能会找到更好的选择。</p>
<p>对于一年一买的必买险种，多做功课货比三家固然好，看着差不多直接买问题也不大。<strong>直接买热销比纠结没买强</strong>。</p>
<h3 id="2-医疗险（报销型）"><a href="#2-医疗险（报销型）" class="headerlink" title="2. 医疗险（报销型）"></a>2. 医疗险（报销型）</h3><p><strong>直接买大病医疗</strong>，保障大风险。</p>
<p>医疗可以分小额（门诊）医疗和大病医疗（俗称百万医疗）。</p>
<p>区别是前者保额和免赔低，小病也能用。后者保额和免赔高，像几百万保额、免赔一万，绝大多数病用不上。赔付概率低了，明明保额那么高，价格可能反而还更低。一年期的大病医疗，年轻人大约几百块就能保几百万，老人也不过一千多点。定期险再贵一点。</p>
<p>小额医疗有点鸡肋。保额低，保费不低，导致杠杆很小（一般只有 10+，也就是花一百的保费，大约只能得一千多的保额）。身体健康的人，一年下来看几次感冒的钱，医保报销之后就没多少了，看病的钱不一定有保费多。关键小病费用太琐碎，很多人未必愿意走报销流程。这就导致<strong>逆向选择</strong>，体质好的不会买，买的都经常看病。</p>
<p>这反过来让理赔率变高，保险公司也需要发工资需要盈利，自然会把保费调高，这又进一步降低了性价比，强化了逆向选择。保险是用来对冲风险的，把不确定的大风险转换成确定的小支出。<strong>不要指望回避所有风险，更不要指望占保险公司便宜</strong>。除非是医院常客，不建议考虑小额医疗。</p>
<p>大病就不同，概率很低，但是一旦出现就能把家庭财务击穿。这种反而很适合用保险兜底。高免赔额挡住了大多数小毛病，理赔概率非常低。理赔的人少，保费才能便宜。</p>
<p>医疗险是报销险，保额内报销超出免赔的部分。以 200 万保额免赔一万为例，如果癌症花了 61 万，能报销 60 万。它的存在，是保证『有钱治』。但既然是报销，总报销额一定小于等于总开销，不会让你有钱赚的。有多张保单时，可以把医疗费用拆分成几个部分在不同保单理赔，但不会对同一块支出重复理赔。</p>
<p>不过在其它保单报销过的费用，一般可以算在免赔额度里。据此搭配不同保额和免赔额的保单来实现更好的保障，已经属于高阶操作，读者可以自行搜索了解。</p>
<hr>
<p>作为一个外行，从医疗险开始往下的保险，都不敢推荐了。因为不同人的需求不同，需要的保额不同，健康状况不同，预算不同。</p>
<p>只能说：尽量以小保费买大保额（高杠杆），核保一定要符合健康告知（否则将来保险公司可以拒赔），实在有小毛病无法通过核保，就要线下找保险公司制定方案，要么除外要么加钱。</p>
<p><strong>尽量买定期</strong>，一份保单保障多少年，或者保障到多少岁。选尽量长的缴费年限，降低每年保费负担。在中国，只要有保单在，即使保险公司破产这种低概率事件发生，保监会也会指定其它保险公司接收保单继续承保，必要时会启动保险保障基金。</p>
<p>一年期产品，每年都是新保单，即使保险公司承诺可以续保，也未必有法律效力。一旦老产品下线，买新产品就得重新核保，可能会因为小毛病被拒保。<strong>这条建议基本对任何与健康状况相关的保险都有效</strong>。</p>
<p>如果太头疼，<strong>腾讯微医保</strong>或<strong>阿里好医保</strong>两个一年期闭着眼买比不买强（健康告知必须符合，这点不允许闭眼）。可以先买，继续找更好的产品，以后有更好的换。换保险需要重新核保（健康告知）和计算等待期，记得把这两点考虑进去。<strong>这条建议对其它定期险也有效。</strong></p>
<h3 id="3-重疾险（给付型）"><a href="#3-重疾险（给付型）" class="headerlink" title="3. 重疾险（给付型）"></a>3. 重疾险（给付型）</h3><p>优先级靠后。对于收入低，保费预算紧张的家庭，先配齐其它保障。</p>
<p>重疾险（重大疾病保险）是给付型，是对『可能患重疾』做对赌。保险公司押你没事，你押会中招。没事，保险公司赚保费。中招，保险公司直接赔全额。注意，不管你治不治，花了多少钱，保险公司不过问，只要确诊目录上的病，直接赔全额。</p>
<p>大病医疗哪怕动不动几百万保费，但其实很多病没那么严重，就算癌症也很少会一年内把保额报销完。还有太严重的情况，没怎么治就挂了没怎么花钱。所以平均下来，实际的赔付额可能就几万。</p>
<p>但是重疾看着保额低，直接全额赔。所以 30 万的保额，（重症）理赔必赔 30 万，这就导致重疾健康告知很严，还比较贵。</p>
<p>重疾的最大作用，是患病后的经济补偿。治病花钱，找大病医疗报销；病人不能上班断了收入，重疾的赔付可支撑一段时间的家庭开支。</p>
<hr>
<p>小孩和老人，没有劳动收入，必要性就低一些。对于经济紧张的家庭，重疾保费也是一笔不小的支出。保费预算不多的话，建议优先配置大病医疗险。</p>
<p>当然保费宽裕的话，还是建议尽量买，特别是家里劳动力非常有限，孩子患病需要主要劳动力停工照顾的情况。</p>
<p>买重疾除了注意保额，还要留意包含的疾病目录，确诊标准，还有赔付次数等。</p>
<h3 id="4-寿险"><a href="#4-寿险" class="headerlink" title="4. 寿险"></a>4. 寿险</h3><p>代替离开的家庭支柱照顾家人。我认为这要买，但不是给孩子买。</p>
<p>寿险跟重疾险类似，只是押的不是患病，而是死亡。也就是被保险人死亡即赔付，是一个被保险人自己永远看不见理赔的保险。作用就像第一句说的，是为了在家庭支柱离世后，获得一笔钱，避免因为失去收入导致生活质量断崖式下降。</p>
<p>小孩子没有收入，他的离开给家庭带来的主要是精神上的痛苦，此时赔一笔钱对家庭的改善意义有限。</p>
<p>对于收入来源单一，特别背负债务的家庭（如房贷），建议<strong>给收入主力买寿险</strong>。</p>
<h3 id="5-养老险、教育基金"><a href="#5-养老险、教育基金" class="headerlink" title="5. 养老险、教育基金"></a>5. 养老险、教育基金</h3><p>以养老和教育之名的储蓄。看具体情况。</p>
<p>前面介绍的，都是消费型保险。钱花出去买了保险，就跟其它消费一样，钱花了就花了。只不过一般消费买商品，保险买保障。</p>
<p>买保险的一个原则是，消费型和储蓄型尽量分开买：</p>
<ul>
<li><p>消费型就消费型，直接算得出来杠杆率，用多少保费换了多少保额。各种条件差不多，选杠杆高的。</p>
</li>
<li><p>投资（包括储蓄）的就是投资的，看回报率，而且要看内部回报率买（IRR，可以用工具或者excel算，不展开）。</p>
</li>
</ul>
<p>极少数情况下，某些公司的好产品，不卖给一般人，一定要你买了理财才能买。如果保险确实好，理财收益也过得去，可以考虑套餐。</p>
<p>但大多数的组合产品，都是为了让你算不清上面两笔账，你说保额低时他谈有回报，你说回报率低时他又说有保障。其实你分别买两个产品还更便宜。</p>
<p>回到要不要买养老险和教育险：看你的投资能力和自制力。</p>
<ul>
<li>投资能力很强，能稳定战胜保险的收益率，不买。（稳定划重点，过山车的收益就接近投机了。）</li>
<li>自制力强，理财条理清晰，不同钱的用途分得清做得到。不买。</li>
</ul>
<p>如果这些条件达不到，手里又有余钱，可以给老人或孩子存点钱。认真对比过 IRR 再买。如果送各种天花乱坠的权益，把对你有用的折算成钱一起对比，用不上的忽略。</p>
<p>这种保险不是对冲风险，只是存钱给未来花，优先级最低。最怕买保险不认真看条款，买了组合的保险，等到需要赔付时才发现很贵的保费只换来很低的保额根本不够用，剩下的保费都拿去储蓄了，又还没到取出时间，那就非常尴尬了。</p>
<p>（你回去家里问问，很可能家里老人禁不住亲戚的推荐，已经买了这些鸡肋的产品。别问我怎么知道的。）</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><h3 id="人员配置顺序"><a href="#人员配置顺序" class="headerlink" title="人员配置顺序"></a>人员配置顺序</h3><p>你会发现上面顺便把成人和老人也提到了。</p>
<p>提问者跳过了其它家庭成员，直接问孩子，<strong>这个顺序本来就是不对的</strong>！应该把家庭看作抵抗外来风险的一个整体，优先给家庭的收入主力配置保障。</p>
<p>家庭支柱不给自己配置保障，光给老人小孩买一堆保险，看着孝顺慈爱，但没有用。你倒了他们可以靠着（他们的）保单很好地活下去吗？保费都没人帮他们交好吧。</p>
<p>极端地假设，如果家里的钱只够为一个人配置保险，那就<strong>给賺钱最多的人配</strong>。小孩病了没有保险，起码还有人照顾和筹钱。只给小孩买保险，大人却病倒了，断了收入，连每年续交保费也无法保证，小孩的保单也失去意义。</p>
<p>当然最好的办法，还是趁全家都健康时，把必要的保障都配齐。</p>
<h3 id="一年期-与-定期"><a href="#一年期-与-定期" class="headerlink" title="一年期 与 定期"></a>一年期 与 定期</h3><p>健康相关的保险尽量买长期（定期）险，避免以后健康恶化被拒保。</p>
<p>前面在聊到医疗险的后面提到了，这里再啰嗦一遍：</p>
<ul>
<li><p>如果预算紧张，<strong>买一年期比不买强</strong>。一年期里，又尽量选官方有续保保证的（虽然这个保证视乎公布方式，不一定有法律效力）。一年期的风险在于未来产品下架，或者大幅调高保费。这时想买新产品，需要重新核保，有可能因为小毛病被拒保。</p>
</li>
<li><p>如果预算够，<strong>尽量买定期</strong>！一份保单保障多少年，或者保障到多少岁。选尽量长的缴费年限，降低每年保费负担。只要有保单在，即使保险公司破产这种低概率事件发生，保监会也会指定其它保险公司接收保单继续承保，必要时会启动保险保障基金。</p>
</li>
</ul>
<p>当然还有一种办法，先买一年期的产品，等到预算充裕或者遇到好的产品，再改买定期产品。<strong>记得换保险需要重新核保和计算等待期</strong>，要留意当前的身体状况，以及要提前买避免等待期没有保障。</p>
<h3 id="是否保终身"><a href="#是否保终身" class="headerlink" title="是否保终身"></a>是否保终身</h3><p>如果觉得长期险保费太贵，也许是因为保终身，可以考虑保固定年限（如30年）或到固定岁数（如70岁），把保费降下来。只要是人就一定会死，保终身意味着患病概率大增（医疗/重疾）或者一定会赔（寿险），保险公司为了不亏只能多收钱。</p>
<p>记住羊毛出在羊身上，千万不要指望薅保险公司的羊毛。也不要心疼钱花了，觉得没事钱就白费了，为此特意去买保终身和返还型保险。要知道返还的保费本质上就你多交的保费存下来的，不用等到死了才领回来，一开始就少交不好吗。</p>
<p>当然，如果你是现在不差钱，但是花钱大手大脚，担心年老（70 岁以后）患病会没钱，或者不能留一笔钱给家人，保终身也许是个不错的选择。</p>
<h3 id="规划服务"><a href="#规划服务" class="headerlink" title="规划服务"></a>规划服务</h3><p>买保险是个技术活，需要根据家庭的财务状况以及家庭成员的身体状况规划。所以除了意外险可以随便一点选，全文下来几乎没有推荐具体的保险。</p>
<p>除了努力一点自己学习保险知识，也可以寻求专业的保险规划服务。但这个以我的半桶水，也不敢推荐。只能说要么挑有名的大平台，要么挑背景过硬的保险人出来单干创业的。无论哪种，都必须中立，不受雇于某个保险公司。</p>
<p>理论上收费的咨询更好，这种服务更专业细致，一次过的咨询费用能买到更合理的配置，还是值得的。有咨询费收入也可以让顾问更关注口碑，不受销售佣金左右。但还是无法排除有败类两头吃。</p>
<p>免费的咨询除了是推广期搞促销，更多的是以销售佣金作为主要收入。理论上这也算中立，赚哪家佣金不是赚，长远的客户口碑更重要。但禁不住某些产品的佣金特别高，可能会撬动『中立』。个别产品新推出时为了冲销量，佣金达到首年保费的一半，可能有大几千块钱，很难不让人心动。</p>
<p>所以可能真的没有一劳永逸的解决办法，哪怕找了顾问，自己也要多上心，多问几个问题，自己也考虑一下对方的建议是否合理。</p>
<p>那些突击培训上岗、一知半解的保险代理人，即使是自家亲戚也不要信——<strong>大概率他们自己本身就是韭菜</strong>。为了完成业绩，他们自己会买，会动员身边所有亲戚朋友买。但多数半路出家的代理，销售能力也就那样，都卖一圈之后开始卖不动，也就只能改行，然后保险公司又开始高薪招下一批代理……</p>
<hr>
<p>最后的最后，这只是一个消费者的视角。非专业人士，不能作为购买建议。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知识星球读者提问：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果是帮小朋友买保险，需要买哪些保险？教育基金之类的有没有必要？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迎接一个新生命的到来：备孕篇</title>
    <link href="https://jaycechant.info/2020/get-ready-for-a-new-life/"/>
    <id>https://jaycechant.info/2020/get-ready-for-a-new-life/</id>
    <published>2020-11-09T10:03:35.000Z</published>
    <updated>2020-11-29T06:34:31.924Z</updated>
    
    <content type="html"><![CDATA[<p>没有想到有一天我会聊这个话题。</p>
<a id="more"></a>
<p>像之前在<a href="../about-child-restraint-system/">安全座椅</a>的文章里说的，同龄人大多到了婚育阶段，进度有快有慢：有孩子已经上学的，有还在相亲的。我在向前辈们取经的同时，居然也有人向我取经。</p>
<p>让我们从备孕聊起。</p>
<blockquote>
<p>年轻读者如果不想泄漏你们的计划，建议收藏，不用转发。</p>
<p>已为人父母的读者没这个顾忌，可以分享给身边需要的朋友。</p>
</blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>对没了解过的话题，我们很难提出有价值的问题。<strong>没有概念</strong>，自然也不知道『该问什么』。互联网发达的今天，只要是公开的知识，知道自己『不知道什么』，很容易获得答案。提正确的问题，比答案重要；建立概念，先于详尽的内容。</p>
<p>我只是一个孩子的父亲，不是<strong>医学工作者</strong>，本来没有我的事。只是被问多了，发现问题常常没问到点上，需要反复介绍一些基础概念，翻查并转发一系列文章，顺带补充解释。这非常琐碎，琐碎到让我决定写概括性的文章，来避免重复劳动。</p>
<p>本文<strong>不能作为医学建议</strong>。主要目的，是希望引起对相关话题的关注，并提供部分参考。只能尽量保证，内容要么是亲身经历和体会，要么是经过资料查证。</p>
<p>只是我和身边人的经历，<strong>样本量很小</strong>；<strong>非生物医学相关专业、没有科研经历</strong>，很多内容超出我的知识储备。可想而知，本文一定会出现错漏，欢迎指正。</p>
<p>大家知道有这些关键词，后续会主动了解相关内容，目的就达到了。</p>
<hr>
<p>本文假设读者相信现代医学、遗传学和营养学，这是后续讨论的基础。</p>
<p>今天在系统分类学、解剖学、生物地理学、古生物学、分子生物学、遗传学等学科压倒性的证据支持下，学术界普遍认为进化是事实（fact），而不仅仅是理论（theory）。只是细节上尚存争议，还需更多研究。我国现代推崇唯物主义，又没有宗教观念的阻碍，大家对进化论和遗传学的接受度应该比较高。</p>
<p><br></p>
<p><strong>目录</strong></p>
<p>[TOC]</p>
<h2 id="一、-赛前状态"><a href="#一、-赛前状态" class="headerlink" title="一、 赛前状态"></a>一、 赛前状态</h2><p>接下来是要讲鼓掌的事吗？并不是。鼓掌远远不是故事的开始。</p>
<p>最早提出进化学说的拉马克，提出了『用进废退』和『获得性遗传』两个法则。这两个法则后来被达尔文提出的『自然选择』所推翻和代替。孟德尔的经典遗传学为此提供了理论基础。</p>
<p>简而言之，后天获得的性状没有改变生殖细胞的 DNA 序列，无法遗传。如果说母亲的身体素质关系到胎儿的生长环境，那父亲只是纯粹的 DNA 提供者。他的身体状况只影响小蝌蚪数量和活力，进而影响命中率；他的身体和精神状态，不影响胎儿。</p>
<p><strong>真的是这样吗</strong>？</p>
<p>经典遗传学会回答『是的』。30 年前遗传学家或许都这样认为，讨论父亲后天状态与胎儿关系的论文很大可能会被当成胡闹。</p>
<p>但最近几十年发展起来的表观遗传学发现，还存在很多 DNA 序列以外的机制会影响遗传，像 DNA甲基化、RNA干扰、组蛋白修饰等，能在不改变 DNA 序列的前提下，调节基因的表达。尽管相关的研究还不够充分，越来越多的证据显示，生殖细胞（小蝌蚪和卵子）里不仅仅保存了 DNA，还有别的信息，记录着细胞主人的状态。</p>
<p>大白话就是：<strong>受孕前父母的状态，会影响到胎儿</strong>。所以，<strong>男女双方都需要备孕</strong>，而且是<strong>从身体状况到精神状态</strong>全面的准备。父母有熬夜、不运动、抽烟喝酒、暴饮暴食、精神压力大、长期处于污染环境 等状况，可能会通过现在尚未明确的途径，影响到孩子。</p>
<p>这些因素短则影响胎儿发育，长的甚至会影响孩子一辈子。例如，长期暴露在橙剂中的美国越战老兵，他们的后代患有脊柱裂的概率就比普通人更高。</p>
<blockquote>
<p>橙剂是一种除草剂，曾用在越战中实施落叶计划，使丛林中的越南游击队无处藏身。橙剂的生产过程会产生有毒的二噁英，可能致癌。</p>
</blockquote>
<p>如果做不到一直远离污染并保持良好的生活习惯，起码要在准备要宝宝前的一段时间内做到。至于『一段时间』究竟是多长，我也不知道生活习惯影响到表观遗传需要多长时间，只能说『越长越好』。</p>
<p>戒掉所有不良习惯，远离污染源，规律作息，坚持锻炼，保持营养均衡，注意调节精神状态。里面随便一条都是一个专业领域，够写一堆文章，不详细展开。有这个概念，目的就达到了。</p>
<p>嗯，还是忍不住强调几点。</p>
<h3 id="一类致癌物"><a href="#一类致癌物" class="headerlink" title="一类致癌物"></a>一类致癌物</h3><p>不良习惯和环境污染里面，<strong>特别点名强调</strong>一类致癌物。这个清单大家可以在网上搜到。日常最容易接触到的是这几样：</p>
<ul>
<li>香烟，包括二手烟和三手烟（香烟成分残留）。香烟不存在安全暴露水平。</li>
<li>酒精饮料，包括低度酒。酒精的摄入同样不存在安全水平。</li>
<li>槟榔，即使不含任何添加也会致癌。</li>
<li>马兜铃酸，主要存在于马兜铃科的植物，以及包含这些植物成分的药物。</li>
<li>黄曲霉毒素，主要存在于各种霉变食物里。</li>
<li>中式咸鱼。</li>
</ul>
<h3 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h3><p>你应该去请教专业人士。但我猜大多数人不会去健身房也不会请教练。只提醒一点：有氧和无氧结合（或者说心肺训练和抗阻训练结合），不要一味只做一种你喜欢的运动。</p>
<h3 id="营养"><a href="#营养" class="headerlink" title="营养"></a>营养</h3><p>营养学也是非常专业的学科，且部分理论还存在争议。如果不能咨询专业的营养师，可以参考最新版《中国居民膳食指南》。这个基础上，根据个人身体状况和口味习惯，再做一些调整。身体有特殊问题的，还是得以医生和专业营养师意见为准。</p>
<p>具体到备孕期和孕期，一些营养素被认为作用比较关键，挑部分有代表性的说：</p>
<ul>
<li><p>钙和维生素D：</p>
<p>  钙是骨骼和牙齿的主要元素，在人的整个生命周期都起着很重要的作用。少年儿童需要长个子，成年人需要防止骨质流失，老年人则直接面临骨质疏松的威胁，都需要持续摄入钙。</p>
<p>  女性由于生理特点，又比男性更容易缺钙。尤其是怀孕和哺乳期间，母体的钙大量供应给孩子。要知道孩子从一颗受精卵一直长到戒奶为止，身上的钙都是从母亲身上『夺取』的。在备孕时，一定要提高『钙储备』。</p>
<p>  维生素 D 则是可以促进钙元素的吸收、重吸收和沉积。儿童缺乏维生素 D 会引起佝偻病（软骨症）。所以光补钙没有效果，还得保证有足够的维生素 D。</p>
</li>
<li><p>维生素 E：</p>
<p>  一类脂溶性维生素，包括四种生育酚和四种生育三烯酚。从名字（生育酚）就能看出来，维生素 E 可以促进生殖系统的活性，使男子小蝌蚪活力和数量增加；使女子雌性激素浓度增高，提高生育能力，预防流产。</p>
<p>  新生儿维生素 E 不足会使血球容易破裂而发生溶血性贫血。</p>
</li>
<li><p>维生素 B 族：</p>
<p>  一系列水溶性维生素，在细胞代谢中有着重要的作用。虽然有着相似的编号，但在化学上是差别较大的不同化合物。</p>
<p>  孕妇缺乏叶酸（B9）会引起婴儿先天缺陷，这点得到了<strong>世界卫生组织和国家卫健委</strong>的认可。世卫建议围孕期（从孕前到哺乳期结束）应该补充叶酸，特别是孕前到孕 12 周。而在我国很多地方，满足一定条件能在社区免费领取叶酸。这两点可见对叶酸<strong>重视程度之高</strong>。有研究指出，男性补充叶酸也有助于提高小蝌蚪质量。</p>
<p>  除此以外，烟酸（B3）和 钴胺素（B12）也比较重要。</p>
</li>
<li><p>微量元素：</p>
<p>  镁、锌、铁、硒、碘等。</p>
</li>
<li><p>必需脂肪酸：</p>
<p>  二十二碳六烯酸（DHA）、α-次亚麻油酸（ALA）等。</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>就举几例，再列就太长了。具体摄入量大家自己查或咨询医生，不敢推荐。</p>
<p>总的来说，不挑食，荤素搭配，食物来源尽量种类多而杂，大部分营养成分可以从食物中获得。必需的营养素较多地存在于蔬菜水果、未经精加工的谷物、动物肝脏、牛奶、鱼肉等食物里。</p>
<p><strong>民间传说的饮食禁忌大多不靠谱</strong>，反而容易造成营养不均衡。</p>
<p>真正需要警惕的是上述提到的有毒物质：烟酒、咸鱼、某些药物。不要吃未彻底煮熟的食物，特别是生肉，有可能得寄生虫，影响胎儿的发育。</p>
<p>还要警惕所谓的大补，像老火汤，溶解的营养有限，维生素被高温破坏，摄入的主要是脂肪和嘌呤，除了长胖和升高尿酸，没有别的作用；孕期发胖会<strong>增加妊娠糖尿病和妊娠高血压的风险</strong>。各种补药也是风险大于好处。</p>
<h4 id="补充剂"><a href="#补充剂" class="headerlink" title="补充剂"></a>补充剂</h4><p>饮食均衡的情况下，<strong>不建议依赖营养补充剂</strong>，性价比低，个别营养素容易过量摄入。</p>
<p>不过有些营养素来源单一，一旦偏食就容易缺乏。</p>
<p>像维生素 D ，除了吃蛋黄和动物肝脏，主要靠日光（特别是 UVB）照射皮肤时合成。如果少吃相应的食物，加上接触日光的时间太短，就需要考虑服用维生素 D 补剂。</p>
<p>叶酸倒是广泛存在于叶菜、水果、肝脏和肉类当中，但叶酸非常容易在烹饪中被破坏，食物中的摄入量不足以满足需要，所以围孕期补充叶酸补剂是相当必要的。</p>
<p>除了这两样，考虑到现代人的饮食特点（吃得过于精细、单一，容易挑食，不爱吃素、内脏或者鱼），很多营养素还是可能摄入不足。起码在围孕期，要考虑服用补充剂——叶酸只是最低限度。因为逐样购买服用不仅麻烦，还非常难根据不同阶段调节用量，我们直接购买了专门围孕期配方的产品。</p>
<p>当时综合网上的评价，选择了英国 Vitabiotics 旗下的 Pregnacare 系列。这个系列做得很全很细，从备孕到孕中再到哺乳期恢复期，都有针对的产品。甚至还有给男性备孕的产品（不单卖，跟女性备孕产品组合出售）。除了孕中会加一颗 DHA 鱼肝油，所有产品都是一天一颗，省心省事。</p>
<p>懒得写到孕中和产后再列一次，干脆列出来全系列。附带 TB 海外旗舰店的口令，这样跳过去就知道是哪一款。</p>
<ul>
<li>孕前（before conception）：有女性款和男女款。上面说了，备孕是双方的事，推荐男女款（<strong>him&amp;her</strong>）（￥bbAqcOmwwGN￥）。</li>
<li>孕中（during pregnancy）：有基础版 <strong>original</strong>，和区分孕早期和孕晚期（以孕 5 月为分界线）并强化 DHA 的 plus 和 max。推荐按阶段选用 <strong>plus</strong>（￥8DFWcONb2nd￥）和 <strong>max</strong>（￥PrzdcONYQde￥）。跟孕前不确定吃多久不好多买不同，后面需要屯多少是比较确定的，建议买套装尽量划算一些。</li>
<li>产后：哺乳期选 <strong>breast-feeding</strong>（￥kiuWcON1NuK￥），如果断奶早就选产后修复 <strong>new mum</strong>（￥0297cONYQ67￥）。</li>
</ul>
<p>比较遗憾这个系列还是出现了个别玄学成分，像男士备孕的产品里出现了秘鲁玛卡、西伯利亚人参提取物这种<strong>缺乏医学证据</strong>支持的成分，介意慎选。我们权衡了风险和便利之后还是选用了。还好这只是其中一个比较方便的选择，大家也可以了解其它同类产品。海外销售的产品，尽量选<strong>正规海淘渠道</strong>，或者<strong>托国外亲友带</strong>。现在物流信息和各种单据都可以伪造，小商家和私人代购有信用风险。</p>
<h2 id="二、提高成功率"><a href="#二、提高成功率" class="headerlink" title="二、提高成功率"></a>二、提高成功率</h2><p>有了好身体，就该考虑上场比赛了。</p>
<p>开头先问大家一个问题：小蝌蚪和卵细胞，哪个存活时间长？</p>
<p>或者换个问法，谁等谁？</p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p>先别下拉考虑一下。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p>小范围调查的结果，要么回答不知道，要么认为卵细胞的存活时间比较长。毕竟卵细胞比较大，而且自带营养；公主待字闺中，等天下英雄擂台竞逐，比较符合想象。</p>
<p>但事实上，精子存活时间比卵子长。</p>
<p>自排卵算起，卵细胞会在输卵管存活 1 到 2 天时间，其中前 <strong>14~18 小时</strong>受精能力最强。如果没能受精，卵细胞的受精能力会逐渐减弱直至死亡。</p>
<p>而<strong>进入子宫的小蝌蚪</strong>，最多能存活<strong>大约 3 天</strong>！</p>
<p>小蝌蚪看着很脆弱，也确实很脆弱，在体外只能存活几分钟。但是，生殖道分泌液会为小蝌蚪提供能量，使小蝌蚪成熟，这个过程称为『获能』。小蝌蚪在阴道中能存活约 8 个小时，通过子宫颈之后则最多可以存活 3 天。</p>
<p>小蝌蚪还有一个优势，量大。一次出击以亿为单位。小蝌蚪看不见瞎游，一路上各种艰难险阻，还要在其中一根输卵管上浪费一半兵力，但是量足够大，就总有一部分能活到最后。</p>
<h3 id="宁早勿晚"><a href="#宁早勿晚" class="headerlink" title="宁早勿晚"></a>宁早勿晚</h3><p>结合两个时间，可以得到什么结论？怎样才能使相遇的可能性最大化？</p>
<p>假设排卵的时间点为 T ，排卵后一天为 T + 1，之前一天为 T - 1，以此类推。</p>
<p>很容易推导出，最佳出击时间点很可能就是 T。此时双方细胞活力最强，一边沿输卵管往外移动，另一边一群往里游，汇合时间最充足。但人又不是机器，这个时间点很难掌控。如果时间偏差一点会怎样？</p>
<p>T + 1 应该也有机会，T + 2 就渺茫了。反过来说，T - 1 和 T - 2 完全没有问题。T - 3 也不是没可能（小蝌蚪苦等三天，见到刚刚出门的公主）。实际上，最佳时间点还要往前移差不多一天。从查到的数据看，从 T - 5 到 T 都有机会受孕，其中概率最高是 T - 2 到 T 的三天；T - 1 概率最高有 35%，T - 2 也有 30%，而排卵日当天才只有 25%，T + 1 则可能性非常低了。</p>
<p>结论就是，尽量预测 T 的时间，并在那之前完成鼓掌比赛。如果误差比较大，<strong>宁早勿晚</strong>，让小蝌蚪们提前等着。</p>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>怎么预测？</p>
<p>月经周期规律的女生相对好办。现在有很多记录周期的软件，坚持记录，就可以<strong>根据周期推算排卵期</strong>。记录的时间越长，周期越规律，预测越准确。前面说了，需要一段时间的赛前准备，正好先记录一段时间。</p>
<p>有些女生的周期不太规律，周期规律的也希望得到比推算更准确的结果。这时可以用<strong>排卵试纸</strong>。</p>
<p>排卵试纸本质上是检测尿液中的促黄体生成素（缩写 LH），检测时将试纸一端浸入尿液，等候一会看检测线即可，很方便。（现在新出的测试棒，比尿杯更方便使用。具体产品用法，以说明书为准。）因为是比较成熟的技术，结果比较准确，也不贵。我们当时直接用的网上销售量最大的套装，包括两个月用量的排卵试纸和 5 条早孕试纸，平均到每次检测才几毛钱。（￥FQJccNRNO7p￥）</p>
<p>试纸的灵敏度是固定的，而每个人的 LH 水平有差异（还有尿液浓度的问题），不要看少数几次检测的值，而是要看 LH 水平的变化趋势。一般推荐从月经结束后三天左右开始测，测得疏一些（每天或者隔天），发现增强就增加检测频率，从每天到每半天再到每 4 小时。如果发现到了最强突然开始转弱，意味着会在最强时间点的 24 ~ 48 小时内排卵，未来的 24 小时内是比较好的时机，赶早不赶晚。</p>
<p>需要注意的是，LH 试纸对部分人群不适用。多囊卵巢综合征、卵巢早衰等患者，LH 水平不具参考意义。</p>
<h3 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h3><p>即使挑中最佳的日期，成功率也不过比 1/3 略强。心急要孩子的人很容易想到一个办法：在可能受孕的 5~6 天里，天天运动，甚至每天多次运动。</p>
<p>这未必不是一个办法。但是过高的频率，会影响精子的质和量，过度疲劳也会影响双方的状态。另外，女生过于频繁接触外来细胞，有可能会激发抗体，引起免疫性不孕。我找到的说法是，最频繁至少也要隔一天一次。没有找到依据，仅供参考。</p>
<p>另一方面，也有人会考虑到精子质量，每个月只在最佳时间上场比赛，其它时间都通过禁欲来养精蓄锐。这同样是不可取的，因为过长时间的禁欲，会导致精子老化，质量反而下降。</p>
<h3 id="赛后休息"><a href="#赛后休息" class="headerlink" title="赛后休息"></a>赛后休息</h3><p>都努力到这里了，还有一个小技巧提高成功率。</p>
<p>不知道大家有没有观察过，刚发射出来的弹药，是半固体的凝胶状；然后过 10~30 分钟，会重新液化。这里面是一系列的凝固因子和液化因子在调节，前者包括纤维蛋白和凝固蛋白等，后者则包括一系列的酶。</p>
<p>身体不会平白无故制造纤维蛋白再造个酶分解掉，费这工夫当然有用。</p>
<p>比赛进行当中，双方剧烈运动，小蝌蚪们很难在目标上停留。这时纤维蛋白组成的带黏性的凝胶，有助于把小蝌蚪作为整体送达，并留在目标赛道上。等比赛结束，运动员休息，凝胶才液化，小蝌蚪们的比赛才正式开始。可以简单理解为 先打包运送，到达后再拆包裹。</p>
<p>知道这一点有什么用？</p>
<p>首先重申身体素质的重要性，如果身体有毛病，或者缺少某些营养素，导致这个凝固-液化的过程出了问题，小蝌蚪的活性会大打折扣（这个过程涉及多种锌蛋白，锌很重要）。</p>
<p>然后就是女生要注意赛后休息，不要乱动。参考液化需要的时间，比赛结束后应该仰卧平躺休息一段时间，可以垫个枕头让入口抬高，尽量给小蝌蚪液化和游动的时间，减少小蝌蚪的流失。这个姿势据说还能让小蝌蚪聚集在宫颈口，提高通过的数量。</p>
<p>上亿的数量看着很多，对看不见瞎游的蝌蚪来说，路上多的是陷阱。损兵折将之后，终于来到宫殿之内，生存环境变好，输卵管左还是右的抉择又少了一半。即使到了终点，透明带还是需要大量的小蝌蚪用自己的顶体去溶解。</p>
<p>珍惜小蝌蚪，提高成功率。</p>
<h3 id="别太紧张"><a href="#别太紧张" class="headerlink" title="别太紧张"></a>别太紧张</h3><p>前面给了这么多建议，都做到了是不是就一定能成？</p>
<p>当然不是。即使一切就绪，挑到最好的时间点，受孕的概率也只有 35%。</p>
<p>成功受孕，实在是太多因素共同作用的结果，我们只能干预其中的一（小）部分。各种看似玄学的因素里，就包括了压力水平，或者说情绪。</p>
<p>2015 年荷兰一个综述性研究回顾了 1992 年到 2014 年之间的多个研究的数据，试图找出<strong>预测排卵期后定时同房</strong>与妊娠率之间的关系。在排除掉无效数据和过小的样本之后发现：</p>
<ul>
<li>只有两项研究报告了临床妊娠率（经超声确认），<strong>没有发现妊娠率差异的证据</strong>；证据表明，如果假设没有排卵预测下的妊娠率为 16%，定时同房的妊娠率为 9%~33%。</li>
<li>有两项研究仅分析了自我报告的妊娠（基于妊娠试验阳性，无超声确认）；如果将自述怀孕包括在内，则<strong>定时同房的妊娠率略高</strong>。证据表明如果没有排卵预测的妊娠率为 13%，则定时同房的妊娠率在 14% 到 23%之间。</li>
<li>只有一项研究报告了定时同房可能存在的不利影响。该研究表明，使用尿液检测和没有使用额外措施的女性之间，<strong>压力水平没有差异</strong>。其它不良影响的数据不足。</li>
<li>一项试验报告了受孕时间数据。试图受孕时间少于12个月与12个月以上的夫妇之间，没有证据表明有效果差异。</li>
</ul>
<p>有兴趣的可以自行阅读论文：<a href="https://www.cochranelibrary.com/cdsr/doi/10.1002/14651858.CD011345.pub2" target="_blank" rel="external">https://www.cochranelibrary.com/cdsr/doi/10.1002/14651858.CD011345.pub2</a></p>
<p>总的来说，预测排卵期然后定时同房在<strong>逻辑上无懈可击</strong>，但在研究中的效果却显得<strong>优势微弱</strong>，完全没有看上去那么美好。毕竟影响的因素太多，而预测并不能确保准确。为了养精蓄锐，仅在特定日期比赛，竞技水平容易受影响，还会导致精子老化。上场时过分关注受孕，双方带着任务和压力，也会影响比赛质量。</p>
<p>所以虽然上面给了这么多技术建议，并不需要像规范那样小心遵守。如果因此造成压力，反而得不偿失。享受过程，夫妻之间琴瑟和鸣，孩子是水到渠成的事。如果长时间的尝试都没有成功，或者发现了其它问题，则要尽快求助于正规三甲医院的生殖科。千万不要病急乱投医，中了野鸡医院的套路，特别要小心正规医院里的外包科室。</p>
<h2 id="三、中奖之后"><a href="#三、中奖之后" class="headerlink" title="三、中奖之后"></a>三、中奖之后</h2><p>这篇写的是备孕，本来到这里就该结束了。剩下的话题，如果读者感兴趣，再接着写。</p>
<p>不过，可能会有读者在看完本文后马上行动，然后足够幸运，一个月内中奖。以我写字的速度，搞不好推送下一篇时，孩子都打酱油了。那再说两句。</p>
<p>如果买了上面提到试纸套装，里面一般会包含早孕试纸，没有就另外买一些备着。亲戚该来的时候不见来，验一下，两道杠就是中奖了（一条对照线，一条检测线，也有产品两条线组成十字形）。</p>
<h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>然而早孕试纸阳性，并不能确切地说就是怀孕了。</p>
<p>试纸（或者验孕棒）只是检测人绒毛膜促性腺激素（缩写 hCG），正常情况下由胎盘分泌，怀孕是最大的可能，但一些疾病也会引起 hCG 升高。另外，即使成功受精，hCG 来自胎盘，也可能存在葡萄胎和宫外孕的情况。不正常发育的胚胎不仅不会带来一个新生命，还会<strong>危害准妈妈的健康，最严重时甚至致命</strong>。</p>
<p>此时，首要任务是去<strong>正规医院</strong>的产科，做一个确认，一般包括验血和超声检查。</p>
<h3 id="建档"><a href="#建档" class="headerlink" title="建档"></a>建档</h3><p>如果胎儿正常发育，先恭喜你。接下来才是忙碌的开始。</p>
<p>在国内，大城市有大量适育青年，大型公立医院的<strong>产科床位常常紧缺</strong>。</p>
<p>这点我们在广州是亲身经历。条件好实力强的公立医院，产科护士站往往放着一个时间表，上面写着哪些月份（对应预产期）还有床位，一般未来几个月都已经排满。产科里前面的人刚出院，马上就会有临盆的准妈妈住进来；如果没有并发症，不需要特别的照顾，或者仅仅是产后的护理，有些人甚至住走廊用帘子围起来的临时床位。</p>
<p>为了确保床位，确认怀孕之后的第一件事，就是<strong>选择将来生产的医院</strong>，然后<strong>在该医院建档</strong>（有些地方叫建卡），尽量一直在这家医院产检。</p>
<p>理论上，建档是完全自愿的，医院也不会拒绝没有建档的产妇。但实际操作上，医院肯定优先接收有建档的产妇，在床位不足时，会劝未建档的产妇转院。而即使紧急情况不便转院，医院缺乏之前的产检记录，也会增加判断和救治失误的风险。</p>
<p>所以不仅要建档，还要早建档，按时产检，尽量不要转院。</p>
<p>医院的选择，要综合考虑医院情况、经济实力、距离远近。举几个需要考虑的问题例子：</p>
<ul>
<li>首先是医院的医疗条件和产科的实力。包括但不限于医生队伍的水平，设备设施是否齐全，做检查是否方便等等。</li>
<li>身体条件允许的话，建议尽量选无痛分娩。医院是否有实施无痛分娩的条件？</li>
<li>经济允许的话，尽量选择丈夫陪产，一方面对产妇是很重要的精神支持，另一方面让丈夫参与到分娩中去，能更好地体谅妻子。医院是否提供陪产选项？</li>
<li>孕晚期以前，一般孕妇还是在上班，那么医院的位置最好同时兼顾家里和单位。如果不能兼顾，则应该优先考虑孕晚期（靠近家里）。</li>
</ul>
<p>这只是其中的一部分问题。每个家庭还会有自己的考量。</p>
<p>我们当时迁就上班地点，建档医院离家里稍远（半个多小时车程）。结果在家里破水，第一时间打 120，被告知只能就近派车，不能指定医院。权衡风险之后，产妇平躺在后排，我自己开车送到建档医院。那是开过最煎熬的 30 分钟。后来才知道，可以请求 110 帮助，即使不能派车开道，一般也可以报备车牌，安全范围内允许交通违规，像走应急道，确认对向没车时闯红灯等等。</p>
<p>至于建档的具体流程，每个地方每个医院有不同，一段时间之后政策也会更新，需要去医院和社区确认。</p>
<p>建档之后，医生和护士就会告诉你接下去该做什么，可能下一篇都没有必要写了（如果没人问我的话）。</p>
<h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>国内提倡优生优育，除了备孕时会给发叶酸，对于部分产检和产后恢复项目是有补贴的。我们当时遇到的形式，是社区会发放服务券，在做相应项目时把券交给医院，会有部分抵扣，抵扣部分记账由政府买单。</p>
<p>这点需要及早了解和办理。很多年轻夫妻不知道有这些福利，根本没办；或者后面知道再去办时，可能一些福利已经错过了使用时间。</p>
<p>同样地，这些福利因地而异，请自行到社区了解。</p>
<h3 id="低调发育，别浪"><a href="#低调发育，别浪" class="headerlink" title="低调发育，别浪"></a>低调发育，别浪</h3><p>很多地方都有一个风俗，怀孕前三个月只告知最亲密的人，对其他人秘而不宣。理由是前三个月胎儿不稳，有一定机会流产。</p>
<p>这是有道理的。</p>
<p>前三个月对应孕早期，胎儿还是非常脆弱。太多人知道，引起关注，有可能会变成打扰和压力。而一旦真的失去这一胎，所有的关注和祝福，都会变成更大的压力。</p>
<p>考虑到篇幅已经太长，而且这部分已经超纲，请自行搜索孕早期的注意事项。该注意的都差不多，只是比其它时间更娇气一些。</p>
<h3 id="谨慎保胎"><a href="#谨慎保胎" class="headerlink" title="谨慎保胎"></a>谨慎保胎</h3><p>最后强调一点：<strong>谨慎保胎</strong>。</p>
<p>常见的情况是，抽血做早孕检测，发现某个指标低了，直接就要保胎，打针或吃药。甚至医生还没说什么，孕妇和家人这边先主动要求保胎。毕竟诊断上写着『先兆流产』四个字，非常吓人。（我被吓到过）</p>
<p>我说的就是这里要谨慎。</p>
<p>首先，很多时候<strong>指标不好是胚胎发育有问题的『果』，而不是『因』</strong>。hCG 来自胎盘分泌，刺激黄体产生孕酮。有染色体缺陷的胚胎，发育不好，孕早期就会体现在指标上。这本身是生命进化出来的筛选机制，在伤害最小的时候放手。用老一辈的话说，是缘分未到。强行挽留，将孕妇置于生命危险之中，还可能生出缺陷宝宝。</p>
<p>其次，各种激素之间的关系比较复杂，数值跨度非常大，检测本身也存在一定的波动和误差，<strong>不能看单次检测的高低</strong>。像 hCG 主要看翻倍情况，而孕酮则要结合 hCG 一起判断。一两次的指标偏差，不一定是有问题。</p>
<p>由于这些原因，国外主流的医学意见，<strong>不鼓励在孕早期进行干预</strong>。</p>
<p>国内医生难道不知道这些吗？我想当然知道，至少比我懂。我也相信大多数医生是在为病人考虑。</p>
<p>奈何医生拗不过国人『用药求心安』的心理，以及越来越被激化的医患矛盾。用药了，看起来尽力了，将来坏结局不容易怨到医生头上；反过来，哪怕不用药才是为患者着想，将来出事，难免会被患者和家属怀疑没有尽力。人有一个名为『如果当初』的心魔，而普通患者并不能区分有效治疗和安慰剂。</p>
<p>为了防杠，必须说这只是个人的有限观察，以及基于观察的推测，不是所有医生都这样。虽然我们只经历了一次生育历程，外加身边朋友的少数例子，但在看其它的大小毛病时，开惯例药、开安慰性质的药物和治疗，不在少数。（当然医生可能并不觉得这是安慰剂。）有时不方便详细沟通，药没什么害处也不贵，也就算了。特别不合适的，礼貌地跟医生商量，一般都会取消掉。有一次开的特别离谱，我指出里面的副作用，医生居然不知道药里有某种成分。这个话题很大，有机会另文讨论。</p>
<p><strong>但是，但是！只是要谨慎，不是说一定不能保胎。</strong> 有些情况确实需要保胎，大龄孕妇需要干预的情况多一些。 <strong>也不是鼓动大家去质疑医生。而是要有主动了解的意识，要和医生沟通具体情况，了解前因后果和各种风险，参与到决策中去。</strong> 而不是觉得听不懂就放弃交流，当个工具人，让做啥就做啥，哪个指标低就补哪个。</p>
<p>孕妇和家人有权利了解不同选择背后的风险，也只能自己去承担选择的后果。</p>
<p>实际上只要表现出愿意了解的姿态，让医生觉得你讲道理，可以交流，医生一般都会愿意投入更多的耐心。</p>
<p>如果医生的解答无法打消疑虑，可以换一个医生甚至换一家医院确认，然后综合考虑不同医生的意见。意见一致当然最好，出现分歧，要么继续找别的医生，要么就从中间选择一个医生的意见忠实执行。千万不要在治疗进行中，因为心有疑虑而将治疗方案打折扣，更不要擅自组合不同医生的方案。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>写太长了。</p>
<p>我像个爱操心的老管家，皇帝不急那啥急，写着写着想起什么就往里面加。我在担心『他们』不知道这些的时候，他们有着一张张具体的脸。有时候是他们私聊问我。有时候他们没问，我耐不住去提醒。</p>
<p>得了，赶紧结了。</p>
<p>再次强调，外行人，仅供参考，<strong>不作为医疗建议</strong>！有啥事，拿不准的不妨勤跑医院，大不了白跑。</p>
<p>原本打算列一下资料来源的，太长太多太碎了，放弃。反正不是论文。如果有人感兴趣讨论里说吧。最近也有可能开不了讨论，那就后台留言，多人问的我另起一篇。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有想到有一天我会聊这个话题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我国省级行政区名称起源</title>
    <link href="https://jaycechant.info/2020/origin-of-names-of-provincial-administrative-regions-in-china/"/>
    <id>https://jaycechant.info/2020/origin-of-names-of-provincial-administrative-regions-in-china/</id>
    <published>2020-11-05T02:24:15.000Z</published>
    <updated>2020-12-31T04:11:21.312Z</updated>
    
    <content type="html"><![CDATA[<p>作为广东人，我专门了解过『广东』 和『粤』这两个名字的来源。也大概知道其它一些省份名字的起源。</p>
<p>印象里是以自然地理命名为主。在地名里出现东南西北还有阴阳（山南水北谓之阳）的，一般都是用来指示在某个地理标志的旁边，而这样的名字很常见。</p>
<a id="more"></a>
<p>真的是这样吗？我也不确定。300 多个地级行政区就算了，34 个省级行政区不多，那就查一下。</p>
<p>溯源时我会尽量追溯最初的源头。例如两广以及广州的『广』，很容易查到来源于广信，但查询不会就此终止，如果可能还是要查出广信的『广』哪里来。又例如甘肃的『甘』来自甘州，而甘州的『甘』，则据传来自城内的甘泉。这种追溯并非总是可行，实际上大多数古地名都无法进一步查证来源，如果追溯到山川河岳的命名，更没有什么道理可讲。</p>
<p>简称也会列出来源。由于简称往往不止一个，不再统计数量。感兴趣的读者可以自己统计分类。</p>
<blockquote>
<p>本文并非原创研究，也不是严谨学术文章，仅仅是出于个人兴趣的整理。</p>
<p>内容来自对网络公开信息的整理，主要参考维基百科（<a href="https://zh.wikipedia.org/），个别兼有参考百度百科（https://baike.baidu.com/），交叉比对的词条数量太多，不一一列举。" target="_blank" rel="external">https://zh.wikipedia.org/），个别兼有参考百度百科（https://baike.baidu.com/），交叉比对的词条数量太多，不一一列举。</a></p>
<p>对于多种说法的情况，会尽量将不同说法列出，只略去个别明显不合理的说法。同样，分类标准也并非毫无争议，存在一些模棱两可的情况，这时纯粹依据个人判断。</p>
<p>如有错漏，欢迎留言指正。</p>
</blockquote>
<p><strong>目录</strong></p>
<p>[TOC]</p>
<h2 id="自然地理"><a href="#自然地理" class="headerlink" title="自然地理"></a>自然地理</h2><p>这类命名，名字里的关键信息来源于自然的地理标志，如山脉、江河、湖泊等。两广这样『广』字来源于历史事件的不算。这类命名往往作为地区泛指先出现，在成为习惯叫法很多年以后再确认为正式的行政区。</p>
<p>这一类的数量确实最多，达到 18 个，刚好过半，但是仍然比我预期中的要少。我本以为会占压倒性的大多数。</p>
<p>自然地理的范围太广，还能进一步分类。其中山脉 2 个，江河 8 个，湖泊 3 个，海洋港口 3 个，能明显看出地理特征但不好分类的 2 个。二级分类里，以江河命名的最多，甚至有 3 个行政区，名字直接就是江河名本身（包括古称或简称）。这也很正常，毕竟人类文明就是在大河流域孕育的。</p>
<h3 id="山脉"><a href="#山脉" class="headerlink" title="山脉"></a>山脉</h3><h4 id="山西"><a href="#山西" class="headerlink" title="山西"></a>山西</h4><p><strong>太行山以西</strong>。原为地区泛指，春秋时属晋国。秦及以后各代，山西地区都属于政权的腹地，并有多个朝代在山西地区建立陪都。</p>
<p>唐宋时境内大部分属于河东道（路），取黄河以东。时至今日，黄河仍然是山西和陕西的分界线。直到元朝设河东<strong>山西</strong>道，直属中书省，『山西』开始出现在行政区名上。明朝设<strong>山西</strong>等处承宣布政使司，正式成为行省，山西彻底取代河东成为行政区名。</p>
<p>简称晋，春秋时境内为晋国之地。</p>
<h4 id="山东"><a href="#山东" class="headerlink" title="山东"></a>山东</h4><p><strong>太行山以东</strong>。『山东』的说法最早出现于战国，金代以前是一个地区泛指，先秦指崤山和华山以东，唐宋指太行山以东。</p>
<p>境内在唐时分属河北道和河南道，宋时主要属京东东路。南宋时山东全境被金占领，金设<strong>山东</strong>东路、<strong>山东</strong>西路两路，『山东』开始作为行政区名。元时为<strong>山东</strong>东西道，属中书省。明朝设<strong>山东</strong>等处承宣布政使司，正式成为行省。</p>
<p>简称鲁，有时也称齐鲁或齐，因春秋战国时境内主要为齐国和鲁国。</p>
<h3 id="江河"><a href="#江河" class="headerlink" title="江河"></a>江河</h3><h4 id="河南"><a href="#河南" class="headerlink" title="河南"></a>河南</h4><p><strong>古黄河以南</strong>。秦汉以前河专称黄河，河流称川或水，后来才逐渐变成通称。</p>
<p>楚汉之争时项羽封申阳于原韩国三川郡（黄河、洛水、伊水为三川），为<strong>河南</strong>国，后亡于汉，改<strong>河南</strong>郡，为西汉京畿地区直属七郡之一，大约相当于今洛阳及周边地区，是今河南境内最早以『河南』为地名。</p>
<p>唐改<strong>河南</strong>府，属都畿道（即东都）；同时期有<strong>河南</strong>道，约为今山东全境、河南全境（除洛阳）加上安徽和江苏北部。宋初将两京归入<strong>河南</strong>道，但很快又重新划分十五路，其中并没有河南路，河南府属京西北路。元设<strong>河南</strong>江北等处行中书省，简称河南省或江北省，辖下的<strong>河南</strong>江北道接近今河南大部加湖北北部。明设<strong>河南</strong>等处承宣布政使司，基本与今河南一致。</p>
<p>河南简称豫，境内为禹贡九州的豫州之地。《周礼》解释说『禀中和之气，性理安舒，故云豫也。』豫为安乐、安逸之意。</p>
<h4 id="河北"><a href="#河北" class="headerlink" title="河北"></a>河北</h4><p><strong>古黄河以北</strong>。</p>
<p>秦置河东郡河北县，为『河北』最早见于地名，但此时的河北只是一个县，大约在今山西南部。</p>
<p>唐设<strong>河北</strong>道，开始包括今河北全境及邻近省的部分地区。宋改河北路，金分河北为东西两路。元时因紧邻大都，分属中书省的京畿山后道和燕南<strong>河北</strong>道。明清属（北）直隶。民国被分为察哈尔、热河、河北三省。新中国成立后恢复原河北行政区。</p>
<p>河北简称冀，境内为禹贡九州的冀州之地。又因春秋战国时境内有燕赵两国，又称燕赵之地。</p>
<h4 id="江西"><a href="#江西" class="headerlink" title="江西"></a>江西</h4><p><strong>长江以南的西部</strong>。秦汉以前江专称长江，汉称『大江』，六朝开始出现『长江』的记录。</p>
<p>唐初设江南道，取<strong>长江以南</strong>之意。玄宗时分江南道为江南东道、江南西道、黔中道。<strong>江南西道</strong>即江西前身，包括今江西及湖南全境、湖北及安徽南部部分地区。肃宗时设洪吉都团练守捉观察处置使，代宗时改江南西道观察使（通称江西）。后升为节度使，懿宗时改<strong>江西</strong>节度使，管辖今江西全境，为『江西』一名的开始。</p>
<p>宋初复设江南路，真宗时又分为东西两路。元设<strong>江西</strong>等处行中书省，包括今江西大部和广东西部以外全境，正式使用『江西』作为行政区名。明设<strong>江西</strong>等处承宣布政使司，基本与今江西一致。</p>
<p>简称赣，来源于境内最大的河流赣江（又写作灨）。又因为从北往南看在长江右边，被称为江右，与之相对江东又称为江左。</p>
<h4 id="浙江"><a href="#浙江" class="headerlink" title="浙江"></a>浙江</h4><p>取自浙江，即<strong>钱塘江</strong>古称。一般认为，钱塘江古称『浙江』，见于《山海经》、《越绝书》、《史记》、《水经注》等古籍，又称『折江』、『之江』。</p>
<p>浙江境内在春秋战国时属越国，后亡于楚。秦灭楚后设会稽郡。</p>
<p>唐初设江南道，玄宗时分出江南东道，肃宗时又分江南东道为<strong>浙江</strong>东道、<strong>浙江</strong>西道以及福建道，是『浙江』二字第一次作为行政区名，浙江二道合称『两浙』，辖境大致为今天苏南、皖南、上海及浙江全境，与今天吴语区相仿。</p>
<p>宋设两浙路。元代在两浙及福建设立<strong>江浙</strong>等处行中书省，治杭州路。明设<strong>浙江</strong>等处承宣布政使司，开始和福建分开，辖区与今基本一致。</p>
<p>简称浙。因为境内为古百越中的于越的核心区域，也是春秋时越国所在，有时也称为越。</p>
<h4 id="上海"><a href="#上海" class="headerlink" title="上海"></a>上海</h4><p>取自<strong>上海浦</strong>（即黄浦江），吴淞江（今苏州河）北支流；另有下海浦，在今虹口区，已被填平。</p>
<p>上海地区早在晋朝已经有渔民聚集发展出商贸集镇，到唐天宝年间设华亭县，属苏州。南宋时华亭县属嘉兴府，于上海浦西岸设市镇，集市名<strong>上海</strong>市，镇名<strong>上海</strong>镇，为『上海』首次见于地名。</p>
<p>元朝时华亭县升格为松江府，辖华亭县。后以『华亭地大人众，难理』析华亭县东北置<strong>上海</strong>县，仍属松江府，为上海建制之始。至明嘉靖年间为抵御倭寇，上海县筑起城墙。此时松江府已较为富庶。</p>
<p>1843 年《南京条约》上海作为通商五口开埠。1845年中英《上海租地章程》开始租界历史。此后法国与美国相继在上海设立租界。租界逐渐形成不受中国管辖，拥有独立司法、行政权力的地区。之后历经数次扩张，范围基本为今上海的核心区域的大部分地区。凭借独特的政治制度和地理位置，上海开埠后逐渐发展为远东最繁荣的经济和商贸中心。新中国成立后，上海市从江苏省划出，设为直辖市。</p>
<p>简称沪，源于古时当地人创造的一种名为“扈”的捕鱼工具，东晋时松江入海口称之为沪渎（今上海市青浦区东北旧青浦镇西）。有时也称申，相传上海西部战国时曾为楚国公子春申君的封地。</p>
<h4 id="辽宁"><a href="#辽宁" class="headerlink" title="辽宁"></a>辽宁</h4><p>取<strong>辽河永远安宁</strong>之意。</p>
<p>东北地区在古代大部分时间属于渔猎民族活动范围，先秦时期有肃慎、秽貊、东胡等民族，与汉族并称东北四大族系。汉至唐期间，境内先后有高句丽、挹娄、室韦、靺鞨等民族活动。</p>
<p>战国时燕国在辽宁地区设置辽东、辽西两郡，中原对两郡的统治一直延续到唐末。西汉征服卫满朝鲜之后，一度设置乐浪、玄菟、真番、临屯四郡，合称汉四郡。但到西晋时因不堪长期与高句丽和百济作战，侨置辽西而丢失。</p>
<p>东北境内先后建立过扶余国、高句丽、渤海国等国，渤海国后成为唐的属国。唐以后先后是辽朝与金朝的统治范围。</p>
<p>元朝开始将东北纳入中央王朝管治。明朝在东北境内设置都司、卫所等军事机构，对当地民族实行招抚、羁縻政策。清初将这里作为自己的起源禁地，禁止汉人入内，并作为流放犯人之地，设东北三将军镇守。</p>
<p>南部为镇守盛京等处将军，又称奉天将军。光绪三十三年（1907 年）裁三将军，改东北三省。南京国民政府时期考虑到『奉天』取自『奉天承运』，君主思想浓厚，改今名。</p>
<p>简称辽。辽河旧称巨流河，西汉前称句骊河。</p>
<h4 id="吉林"><a href="#吉林" class="headerlink" title="吉林"></a>吉林</h4><p>满语吉林乌拉的简称，意为<strong>沿着松花江</strong>，原指今吉林市。</p>
<p>（部分内容参考『辽宁』一节）</p>
<p>清顺治时设宁古塔昂邦章京，康熙时改宁古塔将军，后移驻吉林，改称镇守吉林等处地方将军，吉林从城池名变为行政区名，包括今吉林全境、黑龙江东部、辽宁北部，以及俄罗斯滨海边疆区和哈巴罗夫斯克边疆区。沿海地区在 1860 年的 《北京条约》被全部割让。1907 年改省，1954 年省政府从吉林市迁到长春市。</p>
<p>简称吉。</p>
<h4 id="黑龙江"><a href="#黑龙江" class="headerlink" title="黑龙江"></a>黑龙江</h4><p>来自境内最大河流<strong>黑龙江</strong>，满语萨哈连乌拉，即黑水。</p>
<p>（部分内容参考『辽宁』一节）</p>
<p>康熙时设镇守<strong>黑龙江</strong>等处地方将军，辖今黑龙江西部及内蒙古自治区东北部，黑龙江开始作为行政区。1907 年改省。</p>
<p>简称黑。</p>
<h3 id="湖泊"><a href="#湖泊" class="headerlink" title="湖泊"></a>湖泊</h3><h4 id="湖南"><a href="#湖南" class="headerlink" title="湖南"></a>湖南</h4><p>取自<strong>洞庭湖以南</strong>。</p>
<p>湖南境内在唐玄宗时分属山南东道、江南西道和黔中道。</p>
<p>唐代宗从江南西道分置<strong>湖南</strong>都团练守捉观察处置使，又称湖南道，辖衡（今衡阳）潭（今长沙）在内五州，后增至七州，为『湖南』之名首次出现。</p>
<p>宋时分属荆湖南路和荆湖北路。元设湖广等处行中书省，包括今湖南、湖北、广西、海南及广东西部，先设宣慰司于衡州，后迁潭州；今湖南境内主要属于岭北<strong>湖南</strong>道。</p>
<p>明属湖广等处承宣布政使司，包括今湖南湖北（广东及广西布政使司已从湖广分出）。清初沿明制，至康熙时分湖广左、右布政使司，后改湖广右为<strong>湖南</strong>布政使司，正式成为独立行省。</p>
<p>简称湘，来自贯穿全境的河流湘江。</p>
<h4 id="湖北"><a href="#湖北" class="headerlink" title="湖北"></a>湖北</h4><p>取自<strong>洞庭湖以北</strong>。</p>
<p>唐以前湖北境内大部分时间属于荆州，唐玄宗时将江南道分置为三道，今湖北境内分属山南东道、淮南道、江南西道和黔中道。</p>
<p>宋改道为路后，湖北分属<strong>荆湖北</strong>路和京西南路。元设湖广等处行中书省，湖北主要属江南<strong>湖北</strong>道，北部则属河南江北行省河南江北道。</p>
<p>明至清初湖广等处承宣布政使司已不再包括两广地区，但两湖仍同属一省。康熙时分湖广左、右布政使司，后改湖广左为<strong>湖北</strong>布政使司，正式成为独立行省。</p>
<p>简称鄂，因武汉周边在西周属于鄂国。鄂国原在河南南阳一带，受晋国压力南迁。后境内诸侯国都被楚国吞并，春秋战国时期属于楚国，所以又称为楚。又因湖北全境属禹贡九州的荆州，又称荆、荆州、荆楚。</p>
<h4 id="青海"><a href="#青海" class="headerlink" title="青海"></a>青海</h4><p>因<strong>青海湖</strong>得名。</p>
<p>青海东部自汉朝开始纳入中央王朝控制，至隋朝控制青海全境。</p>
<p>安史之乱时被吐蕃夺取西宁，至元朝重新并入中央管治。元以前属鄯、廓二州，北宋改鄯州为西宁州，为西宁名字之始。</p>
<p>元时大部分属吐蕃等處宣慰司都元帥府。清改西宁府，属甘肃省，西宁以外的大部分地区，设钦差办理<strong>青海</strong>蒙古番子事务大臣，又称<strong>青海</strong>办事大臣，驻青海湖东，是『青海』作为行政区的开始。</p>
<p>乾隆时青海办事大臣移驻西宁，改称西宁办事大臣。民国初改西宁办事长官，仍驻甘肃西宁。1929 年设青海省，省会西宁县，西宁不再归属甘肃。</p>
<p>简称青。</p>
<h3 id="海岛港口"><a href="#海岛港口" class="headerlink" title="海岛港口"></a>海岛港口</h3><h4 id="海南"><a href="#海南" class="headerlink" title="海南"></a>海南</h4><p>即<strong>海南岛</strong>及周边南海诸岛。取南海（实际上是琼州海峡）以南之意。</p>
<p>海南岛从西汉开始纳入中央管治，属珠崖郡（今海南琼山）、儋耳郡。东汉平交趾（今越南北部），珠崖县归交趾刺史部（今广东、广西、福建漳州及越南北部）。之后海南岛及雷州半岛地区一直归属两广所在行政区。</p>
<p>明以后归属广东，至 1988 年独立建省，取岛名为行政区名。</p>
<p>唐代在岛上建琼州，简称琼和琼州海峡得名于此。</p>
<h4 id="香港"><a href="#香港" class="headerlink" title="香港"></a>香港</h4><p>地理上指<strong>香港岛</strong>、九龙半岛及周边岛屿。香字来历有多种说法，一说由于东莞香料在此转运，一说源于叫香江的溪流。而港则因为此处是天然良港。</p>
<p>香港开埠之前归属广东，历属番禺县（今广州）、宝安县（今深圳）、循州（今惠州）。</p>
<p>1810 年代，英国东印度公司勘探珠江口香港一带地形，英国人于香港岛赤柱登陆后，获原居民陈群引路到香港岛北部，行经<strong>香港</strong>村（今黄竹坑旧围）时从陈群的蜑家话回答中得知『香港』发音，后成为整座岛屿的总称。英治时期的香港旗有『阿群带路』图纪念此事。而香港村的得名，则有上述两个说法。</p>
<p>香港因两次鸦片战争签署的《南京条约》和《北京条约》被英国强租为殖民地。1997 年回归后设特别行政区。</p>
<p>简称港。雅称香江。</p>
<h4 id="澳门"><a href="#澳门" class="headerlink" title="澳门"></a>澳门</h4><p>本名<strong>蠔镜澳</strong>（后蠔改濠），指盛产蚝且水域如镜的港湾。澳指海边湾区可以停船的地方，即泊口。因澳外有名为『十字门』的水域，所以称<strong>澳门</strong>。</p>
<p>澳门被葡萄牙强租之前属广东，历属番禺县（今广州）、封乐县（今江门新会西北）、宝安县（今深圳）、东莞县（今东莞）、香山县（今中山与珠海）。</p>
<p>明代时葡萄牙人在屯门海战大败，开始转向澳门寻找地盘，先以贿赂获准在澳门暂居，后经公开将贿赂转为地租。清末葡萄牙停止向清朝交地租并占领关闸，后迫使清政府签订《中葡和好通商条约》，规定中国同意葡国永居管理澳门，再后来扩展边界，并划定澳门的界址，使澳门沦为殖民地。1999 年回归后设特别行政区。</p>
<p>简称澳。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>以下两个能看出是以自然地理命名。陕指陕塬，『陕』和『塬』都是对地貌的描述。川为平川广野，指的是四川盆地。</p>
<h4 id="陕西"><a href="#陕西" class="headerlink" title="陕西"></a>陕西</h4><p><strong>陕塬以西</strong>之意。周朝初，周公召公以陕塬（又名陕陌，今河南三门峡市陕州区内）为界，分陕而治。『自陕而东者，周公主之；自陕而西者，召公主之。』关于陕，《直隶陕州志》有『山势四围曰陕，环陕皆山故曰陕』。塬则是黄土高原上的一种地貌，周围被流水冲刷形成沟壑，边缘陡峭，顶上保持比较平坦的状态。</p>
<p>唐朝陕西地区属京畿道，直属中央。安史之乱后在今陕西、河南之间设陕虢华节度使，后改<strong>陕西</strong>节度使，兼神策军（禁军的一支），为『陕西』之名的开始。</p>
<p>宋朝设陕塬以西为<strong>陕西</strong>路，包括今甘肃部分地区而不包括秦岭以南地区，『陕西』开始成为行政区。元设<strong>陕西</strong>等处行中书省。明将甘肃划入<strong>陕西</strong>等处承宣布政使司，改奉元路为西安府，为西安之名的开始。清朝将陕西布政使司左右分治，后发展为陕西省和甘肃省（含宁夏）。</p>
<p>简称陕。又简称秦，因境内在春秋战国主要为秦国领地。</p>
<h4 id="四川"><a href="#四川" class="headerlink" title="四川"></a>四川</h4><p><strong>川峡四路</strong>的总称。</p>
<p>先秦时期，蜀地已有部落政权。秦攻占蜀地，置巴、蜀二郡，蜀地开始进入中原视野。</p>
<p>唐置剑南道（剑门关以南），肃宗时分剑南节度使为剑南西<strong>川</strong>和剑南东<strong>川</strong>两节度使（川是平川广野之意）。宋灭后蜀后置西川路（治成都府），后多次分合。先分西川路置峡路（治夔州，今重庆奉节），称<strong>川峡二路</strong>。再分西川路为西川西路（简称西川，仍治成都）和西川东路（简称东川，治利州，今广元），为<strong>川峡三路</strong>。又并东川入西川为二路。后西川路兵变，平叛后宋廷深感『西蜀辽隔，事有缓急，难以应援』，分西川路为益州、利州二路，峡路为梓州、夔州二路，均以治所命名，合称<strong>川峡四路</strong>，简称<strong>四川</strong>，设四川制置使。这是『四川』名字的起源，但其时还不是正式行政区。</p>
<p>元设<strong>四川</strong>等处行中书省，正式成为行省。此时的四川省还包括重庆路。重庆从清末《马关条约》开始成为通商口岸，抗日战争时期升为陪都，从四川分出，新中国成立后设为直辖市。</p>
<p>简称川。因先秦时期境内分属巴国和蜀国，又简称蜀或巴蜀。</p>
<h2 id="组合命名"><a href="#组合命名" class="headerlink" title="组合命名"></a>组合命名</h2><p>所谓组合命名，是指行政区在调整设置时，从辖区里最主要的州府，各取一字，组合为名。这种组合得到的名字一共有 4 个。</p>
<p>如果细究的话，来源的两个字本身又可以进一步分类。</p>
<h4 id="甘肃"><a href="#甘肃" class="headerlink" title="甘肃"></a>甘肃</h4><p><strong>甘州</strong>（今张掖） + <strong>肃州</strong>（今酒泉）。</p>
<p>其中甘州在西魏时由西凉州更名，以城内甘泉遍地，泉水清洌甘甜而得名。肃州在隋朝建立，肃字来源未见记载，推测为肃清边患之意。</p>
<p>甘肃境内是周人和秦人的发祥地。春秋时东部属秦，西部属西戎。汉时归凉州。</p>
<p>唐时甘肃一带分属关内道、陇右道和山南道，其中最大的是甘州和肃州。</p>
<p>宋时归西夏，西夏取甘州和肃州首字，置<strong>甘肃</strong>军，『甘肃』正式成为行政区。</p>
<p>元一度设西夏中兴行省，后移治甘州路，改<strong>甘肃</strong>等处行中书省。明划入陕西等处承宣布政使司。</p>
<p>清分陕西西部为巩昌省，后改<strong>甘肃</strong>省，管辖整个西域。清末新疆单独划出，民国将青海、宁夏单独建省，甘肃形成现在的区域。</p>
<p>简称甘。又简称陇，来自境内的山脉陇山，即六盘山。</p>
<h4 id="江苏"><a href="#江苏" class="headerlink" title="江苏"></a>江苏</h4><p><strong>江宁</strong>（今南京） + <strong>苏州</strong>。</p>
<p>其中江宁取<strong>江南安宁</strong>之意。苏州原名<strong>姑苏</strong>，原为姑胥，是禹舜时胥的封地，后因吴语中胥、苏音近改为苏。胥本义为小吏。</p>
<h5 id="江宁"><a href="#江宁" class="headerlink" title="江宁"></a>江宁</h5><p>西晋改东吴都城建业（今南京）为秣陵县，又分出临江县，次年改名<strong>江宁</strong>县，为『江宁』名字之始；又从秣陵县分出建业县，又改称建邺，后避司马邺讳改建康。东晋及南朝宋、齐、梁、陈均建都建康，连东吴在内为六朝，故称『六朝古都』。</p>
<p>建康城在隋灭陈后被下令『平荡耕垦』，夷为平地，合建康、秣陵等县为江宁县。唐初以江宁县置江宁郡，后置升州。五代吴改金陵府，南唐改<strong>江宁</strong>府，是南京全境（大致）最早以江宁为名。此后历代多次改置，至明朝改应天府，前期为首都，成祖北迁后为陪都。清初降格为江宁府，为江南省首府。</p>
<h5 id="苏州"><a href="#苏州" class="headerlink" title="苏州"></a>苏州</h5><p>传说舜封胥于江东，从此称江东一带为姑胥，姑为古吴语拟声词，无义。胥在江东灵岩山下建姑胥城（今苏州吴中区木渎镇）。周时泰伯奔吴，后代迁姑胥城，以胥有狱卒之意，<strong>改胥为苏</strong>。</p>
<p>吴王阖闾在灵岩山建姑苏台，灵岩山为<strong>姑苏</strong>山。春秋战国时姑苏城历属吴国、越国、楚国江东郡。秦改江东郡为会稽郡。隋灭陈后，废吴郡，以姑苏山为名改吴州为<strong>苏州</strong>，是『苏州』作为地名的开始。</p>
<p>唐时为江南东道治所。北宋末升平江府，元改平江路，明改苏州府，直隶南京。</p>
<h5 id="江苏-1"><a href="#江苏-1" class="headerlink" title="江苏"></a>江苏</h5><p>江苏境内在春秋时属吴国。明以前一直分属不同行政区。</p>
<p>唐初分属江南道、淮南道、河南道。宋代分属江南东路、两浙西路、淮南东路、京东西路。元初属江淮等处行中书省，后以长江为界，分属河南江北等处行中书省和江浙等处行中书省。</p>
<p>明建都南京（后为陪都），今江苏省、安徽省和上海市境内州府直属中央，为直隶（迁都后为南直隶）。清初改南直隶为<strong>江南</strong>省，治江宁府，设江南左、右布政使司。康熙时，江南右布政使司改<strong>江南苏松常镇太</strong>等处承宣布政使司，简称<strong>江苏</strong>布政使司，为『江苏』一名的开始。乾隆时将安徽、江苏两省列入《大清会典》，史称『江南分省』。</p>
<p>简称苏。</p>
<h4 id="安徽"><a href="#安徽" class="headerlink" title="安徽"></a>安徽</h4><p><strong>安庆</strong> + <strong>徽州</strong>（今黄山市大部、绩溪、婺源）。</p>
<p>其中安庆于南宋由舒州改置<strong>安庆</strong>军，后因宋宁宗曾任安庆军节度使升为安庆府。徽州原名歙（shè）州，南宋平定方腊之乱后改名徽州，是徽文化的发源地。</p>
<h5 id="安庆"><a href="#安庆" class="headerlink" title="安庆"></a>安庆</h5><p>隋改熙郡（今安庆）为熙州，再改为同<strong>安</strong>郡。唐改为舒州。北宋徽宗时置舒州德庆军。</p>
<p>南宋高宗升潜藩康州（今肇庆德庆县）为德庆府，后因德庆军与德庆府同名，取『同安郡』的安与『德庆军』的庆，改称<strong>安庆</strong>军，『安庆』之名始于此。宋宁宗时升安庆府。</p>
<h5 id="徽州"><a href="#徽州" class="headerlink" title="徽州"></a>徽州</h5><p>隋灭陈后，改新安郡为歙州（今安徽歙县、绩溪、黄山市部分地区、江西婺源等地）。宋徽宗宣和年间，方腊于歙州起义，次年被平定。歙州因此改<strong>徽</strong>州，以徽岭、徽水（今绩溪县西北）为名。</p>
<h5 id="安徽-1"><a href="#安徽-1" class="headerlink" title="安徽"></a>安徽</h5><p>安徽境内情况与江苏类似，明以前分属不同行政区。唐初分属江南道、淮南道。宋朝主要分属江南东路、淮南西路。元朝主要分属河南江北行省和江浙行省。</p>
<p>明朝与江苏同在南直隶，清初改江南省，设江南左、右布政使司。康熙时改江南左布政使司为<strong>江南安徽</strong>等处承宣布政使司，简称<strong>安徽</strong>布政使司，为『安徽』一名的开始。乾隆时『江南分省』，列入《大清会典》。</p>
<p>简称皖，因安庆府境内有皖山（天柱山）、皖水（皖河），先秦时曾有皖国。有时也简称徽。</p>
<h5 id="一个题外话"><a href="#一个题外话" class="headerlink" title="一个题外话"></a>一个题外话</h5><p>江南省省会一开始在江宁。清初江南省分左右布政使时，右布政使移驻苏州，负责今江苏地区；左布政使留在江宁，负责今天安徽地区。江宁虽然在右布政使的管辖下，却是左布政使的驻地；直到近一百年后，安徽布政使才正式移驻安庆。南京是安徽省会的说法，并不是毫无根据。（手动狗头）</p>
<h4 id="福建"><a href="#福建" class="headerlink" title="福建"></a>福建</h4><p><img src="../../images/china-province-names-origin/fujian_diming.png" alt=""></p>
<p><strong>福州</strong> + <strong>建州</strong>（今建瓯市周边）。</p>
<p>其中<strong>福</strong>州唐开元年间由闽州改置，得名于州西北的福山。建州为唐改<strong>建安</strong>郡所置，得名于东汉献帝的年号。</p>
<h5 id="建安四县"><a href="#建安四县" class="headerlink" title="建安四县"></a>建安四县</h5><p>福建境内在先秦时期属于百越地区，为闽越。战国时越国（今浙江境内，为于越）亡于楚，于越人一支外迁到闽中地区，与当地闽人一起建立闽越国，又叫东越。</p>
<p>秦时设闽中郡，治东治，废去闽越王王位，降为君长。汉初复封闽越国，至武帝时叛汉被灭，宫城焚毁，越人北迁江淮。东治设侯官驻守，闽地远属会稽郡管辖。汉昭帝时遗民渐多，设治县（今福州市区及闽侯县一部分），东汉初改东侯官都尉。</p>
<p>东汉献帝建安元年，会稽太守孙策攻侯官，废侯官都尉，并在侯官北面设<strong>建安</strong>（今建瓯）、南平、汉兴（今浦城）三县，取『建安年间，南方平定，汉室复兴』之意，连侯官在内，为福建境内最早四县。</p>
<h5 id="福州-与-建州"><a href="#福州-与-建州" class="headerlink" title="福州 与 建州"></a>福州 与 建州</h5><p>三国时东吴以会稽郡南部诸县设<strong>建安</strong>郡，治建安县。自晋至唐初，今福州、南平周边地区几经改置，先后改闽州、泉州（今福州，与今泉州不同）、建安郡等。</p>
<p>唐高祖武德元年置<strong>建</strong>州，初治闽县，四年移治建安县，六年以闽县复置泉州（与建州并设）。睿宗时泉州改闽州，玄宗时以闽州西北福山为名改<strong>福</strong>州。泉州（福州）先后还析出漳、汀、武荣（后升泉州，即今泉州）诸州，福建各州基本成型。</p>
<h5 id="福建-1"><a href="#福建-1" class="headerlink" title="福建"></a>福建</h5><p>唐时福建境内属江南东道，安史之乱后期，肃宗在境内设<strong>福建</strong>观察使，辖福州、建州在内的数州，为『福建』名字的开端。宋置<strong>福建</strong>路，接近今辖区。元属江浙等处行中书省。明设<strong>福建</strong>等处承宣布政使司，辖区基本维持至今。</p>
<p>简称闽，最早见于《山海经·海内南经》『闽在海中，其西北有山，一曰闽中山在海中。』汉代《说文解字》中说『闽，东南越，蛇种。』可见古闽人有蛇图腾崇拜，而这也体现在了『闽』字当中。</p>
<h2 id="特殊含义"><a href="#特殊含义" class="headerlink" title="特殊含义"></a>特殊含义</h2><p>这类命名方式，名字里的关键信息具有特殊含义。除了北京的京字代表首都以外，其它名字大多是纪念重要事件。</p>
<p>这一类命名有 6 个。</p>
<h4 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h4><p><strong>北方的首都</strong>之意。京本义为人工筑的高丘，引申为高大。因为国都大多建在高地，后泛指汉字文化圈内的国都。</p>
<p>北京地区的建城历史已有三千多年，历来是北方边防重镇。先秦时期境内先属于蓟国；蓟被燕所灭后纳入燕国。秦设蓟县（约为今北京西城区，不是天津蓟县），为广阳郡治所，属幽州。西晋时幽州移治范阳（今北京到保定之间），十六国后赵时迁回蓟县。唐代安禄山、五代时刘守光分别在此建立过割据政权，国号均为燕。</p>
<p>后晋为了打败后唐，向契丹称臣，割让燕云十六州，其中包括幽（今北京）、顺（今北京顺义）、檀（今北京密云）、儒（今北京延庆）四州。北京地区开始纳入北方民族的控制范围，为辽、金打开了进入中原的大门。</p>
<p>北宋初年意图收复十六州，辽于是在北京地区建立陪都，称<strong>南京</strong>幽都府，后改南京析津府，再改燕京，为北京地区最早被称为『京』。（南京是相对辽上京临潢府而言。上京遗址在今内蒙古赤峰市巴林左旗附近。<strong>北京比南京更早被称作南京</strong>。）金朝灭辽和北宋后，海陵王完颜亮迁都北京，称<strong>中都大兴府</strong>。</p>
<p>蒙古大军攻下中都后，进行了屠城，城池被焚毁。忽必烈即位后，决定以汉地为统治基础，重建燕京为首都，后改中都路大兴府，再改<strong>大都路</strong>。</p>
<p>明朝在应天府（今南京）建都，改元大都为<strong>北平府</strong>。明成祖取得皇位后，升为<strong>北京</strong>顺天府，为『北京』一名之始；同时完善京杭大运河，保证北京的物资供给。18 年后，迁都北京，应天府改南京。清朝承明制。</p>
<p>辛亥革命后，民国定都南京。北京兵变后，袁世凯定都北京，直至北洋政府垮台。此时北京仍依清制称顺天府，至民国三年改称京兆地方，直辖北洋政府。</p>
<p>1928 年北伐成功后，国民政府重新定都南京，北京改称北平特别市，撤销京兆地方。1930 年改河北省北平市，同年改回行政院直辖市。</p>
<p>新中国成立后改回北京市，重新成为首都。</p>
<p>简称京。在一些特殊场合也有用到古称燕或燕京（像燕京啤酒）。</p>
<h4 id="天津"><a href="#天津" class="headerlink" title="天津"></a>天津</h4><p>明成祖纪念靖难之役，改名天津，即<strong>天子津渡</strong>（天子经过的渡口）。</p>
<p>『天津』一词散见于古籍，有多个含义，所以天津最早的词源有多种说法，可能在明以前天津作为地名就已经存在（不一定是今天津地区）。</p>
<p>但天津境内在明以前多是盐场、码头、军事据点，加上海水侵蚀和战乱影响，未能一直保持较大的城市聚落；直到明成祖下诏赐名，筑城设天津卫，天津才逐渐发展起来。所以以明成祖赐名作为名字的来源。</p>
<p>天津地区位于渤海湾西部，历史上曾有多条河流从这里入海。古黄河就曾三次改道于天津入海，带来大量泥沙，形成冲积平原。直到金朝以后，黄河向南改道，海岸线才慢慢固定下来。</p>
<p>境内开发大致是自北向南、自东向西，秦汉时境内有泉州（约为今武清区）、雍奴（约为今宝坻区）、无终（今蓟州区）等县，并在泉州设置盐官。但西汉末因为海侵，海平面上升变为沼泽，汉初设置的四个县城均被废弃。</p>
<p>隋朝修建京杭运河，南北运河在天津境内交汇，称三岔河口，开始重新发展起来。唐在今芦台设盐场，今宝坻设置盐仓。唐中叶成为南方物资北运的水陆码头。</p>
<p>后晋割让燕云十六州，蓟州（今蓟州区）落入辽朝控制，直沽河（今海河）为辽与中原的界河，宋朝在南边设置许多军事据点，防备辽兵南下。金朝在三岔河口建直沽寨，天津地区从漕运枢纽变成了军事重镇。</p>
<p>天津地区在元以后重新统一，加之黄河已向南改道，海岸线稳定，海漕开通，直沽重新成为漕运枢纽。元朝改直沽寨为海津镇，属大都路（今北京）。</p>
<p>明朝靖难之役时，明成祖在此渡河，登基后下诏赐名<strong>天津</strong>，筑城设天津卫，为『天津』一名的开始。清朝改卫为州，再升州为府。</p>
<p>清末，西方列强多次攻打天津大沽口，先是与清廷签订《天津条约》；后大沽口沦陷，清廷与英国再签订《北京条约》，天津成为九国租界。此后，天津逐渐成为北方开放的前沿和洋务运动的基地，率先开启近代化建设，成为当时中国第二大工业基地和北方最大的金融商贸中心。</p>
<p>北伐时期，国民革命军占领天津后，将天津设为天津特别市，后改行政院直辖市。一度改河北省辖，后恢复直辖。</p>
<p>新中国成立后为中央直辖市，出于工业发展考虑一度并入河北成为河北省会，1967 年恢复直辖市。</p>
<p>简称津。</p>
<h4 id="广东"><a href="#广东" class="headerlink" title="广东"></a>广东</h4><p><strong>广南东路</strong>的简称。广字取自广信县（今梧州封开一带），汉武帝平定南越国，颁圣旨有『初开粤地，宜<strong>广布恩信</strong>』，取其意设广信。</p>
<p>先秦时期整个南方地区被中原称为南蛮，属于禹贡九州中的扬州百越之地。这时中原政权并没有对两广地区有实质性的控制。传说楚王曾在广州设置楚庭，今越秀山上有清代所建『古之楚庭』石牌坊记载了这个传说。但传说真实性，以及楚庭实际所指，至今存疑。</p>
<p>秦统一六国之后，继续征服百越，将岭南纳入版图，在今两广地区设置南海、桂林、象郡三郡。广东境内主要属南海郡，治番禺县（今广州）。广西境内主要属桂林郡，部分属南海郡和象郡。</p>
<p>秦末乱世，南海郡尉任嚣病重，传位龙川县令赵佗，赵佗以此建立南越国，还兼并了桂林和象郡。南越国疆域最大时包括两广大部分，福建小部分，以及越南北部和中部地区。汉朝建立后，南越国向汉朝称臣。吕后掌权期间两国一度交恶，赵佗称帝。吕后死后关系缓和。</p>
<p>到汉武帝时，南越国不愿归附，被汉朝所灭，属地分置南海、苍梧、郁林、合浦、交趾、九真、日南、琼崖、儋耳九郡，属交趾刺史部。汉朝因忌惮南越国的原有势力，不以番禺为治所，而是在苍梧郡设<strong>广信</strong>县，作为交趾刺史部驻地。交趾刺史部东汉时改交州。州治一度迁往龙编县（今越南河内东边），又迁回广信。</p>
<p>三国时属孙吴。孙权将州治迁回番禺县。后分交州合浦以北置广州（相当于今广东及广西北部），交州移治龙编，史称『交广分治』。这是『广州』这个名字第一次出现。</p>
<p>唐置岭南道，后分岭南东道和岭南西道，广东境内属岭南东道。宋初复置岭南道，后改广南道，再改路，又分置为广南东路、广南西路。</p>
<p>元朝时两广没有独立的行政区，广东大部分属江西行省，广西及雷州半岛、海南岛属湖广行省。</p>
<p>明朝设<strong>广东</strong>、<strong>广西</strong>两个承宣布政使司，『广东』、『广西』正式成为行政区名。雷州半岛和海南岛开始归属广东。之后两广辖境基本沿袭明制。</p>
<p>新中国成立后，钦州、廉州（今钦州、防城港、北海）划入广西，怀集划入广东。1988 年海南独立建省。</p>
<p>简称粤。粤，古同越。先秦时期中原称长江以南至今越南北部大部分地区为百越。秦末汉初广东境内曾建立南越国。后为了跟百越其它地区区分，逐渐固定使用粤字。</p>
<p><img src="../../images/china-province-names-origin/yue.png" alt=""></p>
<p><img src="../../images/china-province-names-origin/liangzhuyuyue.jpg" alt=""></p>
<blockquote>
<p>良渚文化双孔玉钺，1986年反山遗址发掘。良渚反山遗址位于浙江省杭州市西北。</p>
<p>图源见水印。</p>
</blockquote>
<h4 id="广西"><a href="#广西" class="headerlink" title="广西"></a>广西</h4><p><strong>广南西路</strong>的简称。</p>
<p>先秦时期，广西地区远离中原，和广东以及其它南方地区一起被称为南蛮、百越。境内主要为西瓯和雒越族群。</p>
<p>因两广历史上长期作为一个整体，广西得名历史参见『广东』条目。</p>
<p>新中国成立后，改壮族自治区。</p>
<p>简称桂，因为广西境内在秦时主要属于桂林郡。《山海经·海内南经》有『桂林八树，在贲隅西』。贲隅即番禺，指番禺县（今广州）或番禺城（今广州越秀区）。</p>
<h4 id="新疆"><a href="#新疆" class="headerlink" title="新疆"></a>新疆</h4><p>原汉朝西域，清朝收复后取<strong>故土新归</strong>之意。</p>
<p>新疆境内在汉朝时被称为<strong>西域</strong>，存在许多古国，如龟兹、楼兰、于阗、车师、焉耆、疏勒、康居、月氏等。这些古国同时处于汉朝和匈奴的影响之下。</p>
<p>公元前一世纪，匈奴冒顿单于即位后，统一漠北，歼灭月氏国，控制西域诸国。汉武帝决心联合西域各国夹击匈奴，派张骞两次出使西域，与西域之间连接起丝绸之路。到汉宣帝时，汉朝在与匈奴的争斗中胜出，在龟兹建西域都护府，西域诸国成为汉朝属国，西域首次<strong>纳入中国版图</strong>。</p>
<p>西晋因北方胡族入侵而亡，进入五胡十六国时期，西北先后多个民族的政权试图控制西域，最后北魏统一中国北方，控制西域东南部。南北朝时期，吐谷浑和柔然分别从南北入侵西域，北朝逐渐失去对西域的控制。直到隋炀帝打败吐谷浑，重新控制西域东南部。</p>
<p>唐朝太宗至高宗年间，或诸国来朝，或唐发兵征伐，唐在西域<strong>设安西、北庭两都护府</strong>。玄宗时，曾在都护府上又设碛西节度使。同时，在龟兹、于阗、疏勒、碎叶（一度是焉耆）设军事建制，史称安西四镇。安史之乱发生后，吐蕃趁机逐渐控制天山南部及河西走廊，甚至一度攻占并洗劫长安城。另一边，回纥正式改称回鹘，控制漠南漠北至中亚的广大地区，包括西域北部。</p>
<p>唐朝末年，吐蕃、回鹘衰落，中原政权无暇顾及西域，西域诸国重新陷入混战。回鹘汗国灭亡后，分三路西迁：迁河西走廊的称甘州回鹘，后与部分高昌回鹘和蒙古等其他民族融合，形成今裕固族；迁吐鲁番盆地的称高昌回鹘，除部分拒绝伊斯兰化东迁到河西外，大部分与察合台汗国人融合成为维吾尔族族源之一；迁帕米尔高原的称葱岭回鹘，建立喀喇汗王朝，和葛逻禄人融合，成为维吾尔族另一个族源。</p>
<p><strong>喀喇汗国</strong>控制西域西部，虽为首个改宗伊斯兰教的突厥语国家，但制度保持东方王朝的特色，强调与中原传统的联系。中亚的历史记录也把喀喇汗王朝当作中国的一部分。同时期西域还有高昌、于阗等国。</p>
<p>辽朝被金所灭后，辽宗室耶律大石西迁称帝，建立<strong>西辽</strong>（又称喀喇契丹）。耶律大石受过汉文化教育，在辽朝担任过翰林院编修，西辽沿袭辽制，以中国自居。随后向西域、蒙古高原、中亚乃至西亚扩张，统治西域八十余年，后被蒙古所灭。蒙古帝国时期，西域分属不同汗国。</p>
<p>明初为防范漠北蒙古，于哈密设卫所。后不敌吐鲁番汗国，卫所多次被破内迁，至明末退守嘉峪关。明中期，东察合台汗国演变成叶尔羌汗国。清朝时，蒙古准噶尔部以伊犁为根据地建立准噶尔汗国，南部的叶尔羌汗国则由和卓家族掌握了实权。</p>
<p>1755 年清朝灭准噶尔，后又平定阿睦尔撒纳反叛和大小和卓之乱，西域全境平定，乾隆命名为<strong>新疆</strong>，在伊犁设伊犁将军，新疆重新回到中国的版图。名字出自给陕甘总督的谕令『<strong>新辟疆土</strong>如伊犁一带，距内地远，一切事宜难以遥制』，为『新疆』一名之始。但此时新疆还不是专称，雍正时贵州新辟疆土也叫新疆。</p>
<p>1864 年，塔城条约向俄国割让新疆西北部巴尔喀什湖南部大片土地，苏联解体后这些地方属于中亚多个国家。同年，新疆发生叛乱，并得到英俄两国支持，清朝最后只剩下塔城、哈密等少数据点。</p>
<p>1875 年左宗棠督办新疆事务开始，陆续收复天山南北，至 1881 年收复被俄国占领的伊犁地区，新疆又一次回归中国版图。1884 年依左宗棠建议，新疆正式建省，此时的『新疆』的含义出自左宗棠的奏折『他族逼处，<strong>故土新归</strong>』。</p>
<p>新中国建立后改为维吾尔族自治区。</p>
<p>简称新或疆。</p>
<h4 id="重庆"><a href="#重庆" class="headerlink" title="重庆"></a>重庆</h4><p>南宋光宗先封恭王，后即帝位，升恭州为重庆府，取<strong>双重喜庆</strong>之意。宋朝有皇帝即位时，将潜藩升府的惯例。</p>
<p>双重喜庆最常见的说法是，赵惇于淳熙十六年（1189 年）正月被封恭王，紧接着同年二月受禅登基，故为重庆。这个说法是<strong>站不住脚</strong>的。赵惇早于 1162 年孝宗登基的时候就被封为恭王，1171 年被封为太子，然后又过了 18 年到了 42 岁才登基，受封恭王早就是 27 年前的事了。登基时已是太子，喜庆的事要么不算，要么封王和封太子一起算，为什么只是双重？而且宋朝的皇帝，基本都是先封王在登基的，为什么唯独这次是重庆？</p>
<p>另一个说法是，因为赵惇受禅登基，登基庆典时父母俱在，是为重庆。这个说法似乎更合理一些。总之，因登基升府改名是确定的，但具体是哪『双重喜庆』已不可考。</p>
<p>重庆在清末以前一直归属四川，可以参考『四川』部分。</p>
<p>秦占领蜀地后，在重庆境内设巴郡，历属荆州、益州、巴州、楚州。隋朝以渝水（嘉陵江）改渝州。</p>
<p>宋徽宗时改恭州，再因宋光宗升<strong>重庆</strong>府，为重庆名字的开始。</p>
<p>清末中英签订《烟台条约》，英国可向重庆派驻领事；《马关条约》开始，重庆正式成为内陆通商口岸。抗日战争时期，国民政府先定重庆为战时首都，后升格为直辖市，从四川省分出，后定为永久陪都。</p>
<p>新中国成立后重新并入四川省，1997 年设直辖市。</p>
<p>简称渝，因渝水及渝州。又简称巴，因先秦时期境内主要属于巴国，且巴国定都境内。</p>
<h2 id="民族"><a href="#民族" class="headerlink" title="民族"></a>民族</h2><p>这类命名有 4 个，3 个直接来自民族名，1 个来自原住民族群。（台湾对原住民的族群认定尚存争议。）</p>
<h4 id="西藏"><a href="#西藏" class="headerlink" title="西藏"></a>西藏</h4><p>来自<strong>卫藏</strong>。卫为藏语中央之意，指拉萨周边，今天所谓前藏地区；藏即日喀则地区，即后藏。卫藏在清朝先译为满文，因『卫』与满文中的西方（wargi）发音接近，且卫藏在中国西南部，被译为 wargi dzang，汉语再据此翻译成西藏。</p>
<p>藏（tsang）在藏语是本是满盈、纯净、清澈的意思，后用来指雅鲁藏布江（藏曲），再后来又引申指雅鲁藏布江的发源地——以日喀则为中心的后藏地区。也可以算因江河得名。</p>
<p>藏为其他民族对藏族的称呼，藏族对藏区自称『博』（bod）</p>
<p>简称藏。</p>
<h4 id="内蒙古"><a href="#内蒙古" class="headerlink" title="内蒙古"></a>内蒙古</h4><p>来自<strong>内札萨克蒙古</strong>，指归附清朝较早的漠南蒙古各旗。</p>
<p>蒙古高原自古是北方游牧先民的活动范围，活跃的民族先后有匈奴、东胡、鲜卑、柔然、突厥、回鹘、契丹等。（这些民族并非严格的并列关系，有些是同一民族在不同时期的称呼。像契丹是柔然的一支，而鲜卑和柔然又源自东胡。）</p>
<p>汉武帝时汉朝成功控制漠南及河西走廊，将匈奴赶到漠北。漠南成为汉人政权与北方民族的缓冲区，主要为汉人聚居。</p>
<p>五代十国时期，契丹人建立契丹国（后改辽国），成为蒙古草原上的第一个帝国，定都上京（今内蒙古赤峰市巴林左旗附近）。后来辽被金所灭，在此期间蒙兀室韦趁机摆脱辽的控制，开始在蒙古草原上扩张。</p>
<p>蒙兀室韦是一个东胡族源的部落，最早见于《旧唐书》。铁木真（即成吉思汗）曾祖合不勒汗统一尼伦各部，建立<strong>蒙兀汗国</strong>。汗位传至铁木真父亲也速该，也速该被塔塔儿部毒死，蒙兀儿亡国。</p>
<p>铁木真经过征战，带领蒙古乞颜部崛起，统一了漠北各部，建立<strong>大蒙古国</strong>，『蒙古』成为各部统一的名称。蒙古帝国打破不同部落的各自为政，将各部重新编成九十五个千户，蒙古成为军政合一的国家，『蒙古』这个名字又从部落名逐渐变成统一的民族认同。</p>
<p>在第四任蒙古大汗蒙哥去世后，领有汉地、主张汉化的忽必烈，与受漠北蒙古贵族拥护的阿里不哥争夺汗位，最后忽必烈胜出，同时控制漠南（大约相当于今内蒙古）、漠北（大约相当于今蒙古国）。</p>
<p>但忽必烈的汗位并没有得到所有蒙古贵族的承认，其它汗国时而独立，时而承认宗主自治，使蒙古帝国事实上分裂成四大汗国。忽必烈在其领地内改国号为大元，建立元朝，承袭了蒙古帝国在汉地、蒙古高原及西伯利亚的领土。</p>
<p>元被明朝所灭后，残余势力退居漠北，史称北元。北元覆灭后分出鞑靼、瓦剌、兀良哈三部。漠南则在 15 世纪末由成吉思汗十五世孙达延汗统一。漠南蒙古其中一支，达延汗的孙子俺答汗率土默特部驻牧呼和浩特，后归顺明朝，这部分后来变成了内属蒙古。</p>
<p>到后金崛起时，察哈尔部的林丹汗为蒙古大汗。察哈尔部与后金交战兵败，林丹汗逃亡，其子额哲投降，漠南蒙古被并入后金（后来的清朝）版图，为内札萨克蒙古。后来归顺的漠北蒙古被称为外札萨克蒙古。两者合称外藩蒙古，由世袭的札萨克管理；与之相对的是土默特等内属蒙古，由朝廷官员直接治理。</p>
<p>清朝后期文书开始出现<strong>内蒙古</strong>和<strong>外蒙古</strong>的概念，分别指代内札萨克二十四部 和 喀尔喀四部。</p>
<p>在清朝灭亡、民国建立之际，受沙皇俄国影响，泛蒙古主义兴起。发生辛亥革命的 1911 年，外蒙古喀尔喀四部宣布脱离清朝统治。为实现蒙古统一，还向内蒙古出兵。1915 年中、俄、外蒙三方会谈，签订《中俄蒙协约》，袁世凯政府以承认外蒙自治和俄国在外蒙的一系列特权，换取俄国承认中国为外蒙的宗主国。1921 年外蒙古在苏联的帮助下建立共和国。1946 年，民国政府承认外蒙古独立。</p>
<p>与此同时，内蒙古在民国政府治下，仍分属绥远、热河、察哈尔、宁夏、兴安等省。</p>
<p>1947 年，内蒙古举行人民代表会议，成立内蒙古自治政府，是抗战后中共领导的第一个少数民族自治政府。新中国成立后转制为内蒙古自治区政府。</p>
<p>简称内蒙、蒙。</p>
<h4 id="宁夏"><a href="#宁夏" class="headerlink" title="宁夏"></a>宁夏</h4><p>取<strong>夏地安宁</strong>之意。西夏是党项族建立的政权，国号源于发祥地夏州及家族封号夏国公。</p>
<p>宁夏境内长期作为中原与西北先民对峙的前线，处于中原和周边部落国家的交替控制下。部分参考『甘肃』条目。</p>
<p>东晋时匈奴铁弗部人赫连勃勃在关中及河套地区建立大夏，又称胡夏、赫连夏。有人认为匈奴是夏后氏之后，所以国号称夏。后被北魏所灭，置夏州，铁弗部逐渐融入汉族。</p>
<p>宋时西夏占据今甘肃、宁夏地区，以宁夏为中心建立大夏国，定都兴庆府（今银川）。后亡于蒙古。党项族人后融入各族（据传李自成为党项人）。</p>
<p>元朝于西夏故地设西夏中兴行省，又称<strong>宁夏</strong>行省，取『夏地安宁』之意，为『宁夏』地名之始。后废西夏行省，改甘肃行省，建宁夏府路辖宁夏平原地区，归属甘肃行省。之后一直归属甘肃。</p>
<p>民国时独立建省。新中国改回族自治区。</p>
<p>简称宁。</p>
<h4 id="台湾"><a href="#台湾" class="headerlink" title="台湾"></a>台湾</h4><p>即<strong>台窝湾</strong>，又叫大员，为平埔原住民的社名，在今台南市安平区大员镇。</p>
<p>台湾对原住民的认定尚存在争议。过往认为大武垅为西拉雅族的分支，原因之一是荷兰人以西拉雅语传教时，大武垅族被认为是西拉雅语使用者。后来发现大武垅语和西拉雅语之间的差异，且族人自我认同跟西拉雅族不同，开始逐渐将大武垅族独立出来。</p>
<p><strong>大武垅</strong>族自称 Taivoan 或 Taibowan，音近闽南语之『大满』、『台窝湾』、『台湾』，加之族人发源自台南，也的确曾建立台欧湾社（Taiouwang），有学者认为是台湾一名的来源。荷兰人来台时最早接触该名，并在荷兰统治时期逐渐代指岛内全境，称为大员。清朝时定名台湾。</p>
<p><em>台湾历史在两岸存在争议（即使在岛内，蓝绿阵营之间、汉族和原住民之间也有分歧）。主要分歧点在岛上原住民的来源，以及岛上与中原大陆之间早期关系上。学术上就有争议的事再加上政治因素，不讨论。</em></p>
<p>可以确定的是，随着 17 世纪闽粤沿海汉人开始大量移居，汉人逐渐成为岛上居民的主体，中华文化也成为了岛上的主流文化。即使经过半个世纪的日治时期也未曾改变。现岛上近 98% 人口为汉族，除了保留原有风俗的原住民，岛上居民大多使用繁体中文，讲国语、闽南话、客家话等汉语方言。</p>
<p>政治上，目前的台湾地区当局，是内战失败退守台湾的中华民国政府。台湾当局从未宣布独立（是的，虽然绿营小动作很多，但不敢正式宣布）。无论在共和国还是所谓民国的行政区划上，台湾都是中国的一个省。海峡两岸同属一个中国，台湾是中国不可分割的一部分。</p>
<p>简称台。</p>
<h2 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h2><p>云南县得名较早，确切由来已不存。</p>
<p>贵州地处偏远，是汉族为主的行政区中建制较晚的一个。贵州中贵字的起源，有多种说法，并不明确。</p>
<h4 id="云南"><a href="#云南" class="headerlink" title="云南"></a>云南</h4><p>汉武帝时在境内置云南县（今云南大理祥云县），为『云南』最早记录。因汉代无史籍记载，后人对『云南』的名称由来作出各种推测：有<strong>彩云之南</strong>、<strong>云山之南</strong>、少数民族地名改易等。</p>
<p>先秦时期，云南境内为多个方国，境内先民被中原称为西南夷。秦统一六国后，在云南东北部设立郡县。汉武帝时征服西南夷，设益州郡和 24 县，其中包括云南县。</p>
<p>由于远离中央，境内地方豪强势力较强，名义上为州县，时有豪强获得实际的独立。唐朝洱海地区的蒙舍诏部落首领皮罗阁兼并其他五诏，建立南诏国，被唐朝封为<strong>云南</strong>王。后历经多个政权，至白族段氏建立大理国时，辖今云南、贵州、四川西南、缅甸北部，及老挝和越南少数地区。</p>
<p>元朝征服大理国，设<strong>云南</strong>等路行中书省，云南正式成为行省。之后有过短暂的割据政权，都很快被中央政权镇压。</p>
<p>简称滇，来自滇池和古滇国。滇字来源有多种解释，可能来源于族名、少数民族语言演变等。滇原指云南及贵州地区，直至贵州建省，滇变为专指云南省。</p>
<p>又简称云。因为清代境内有迤东道、迤西道、迤南道，又称三迤，简称迤，现已很少使用。</p>
<h4 id="贵州"><a href="#贵州" class="headerlink" title="贵州"></a>贵州</h4><p>贵州境内在先秦时期主要为夜郎等方国，被中原称为西南夷，少数地区属于楚国。秦统一后，分属巴郡、蜀郡、黔中郡和象郡，汉代分属牂牁郡（初属犍为郡）和武陵郡。</p>
<p>犍为郡为汉武帝招抚夜郎侯所置，约定以其子为县令。因汉地遥远，夜郎侯暂时答应，后多次不服反叛，留下『汉孰与我大』的典故，后演变为成语『夜郎自大』。最后于汉成帝年间被灭。</p>
<p>三国时多数地区归蜀汉，南北朝时多数属南朝，隋设明阳、牂牁二郡；唐设黔州郡，属矩州。到五代十国时期，因地处偏远，多数时间隶属相邻的割据政权，与中原政权<strong>关系疏远，少有来往</strong>。</p>
<p>宋太祖时，土著首领普贵以控制的矩州归顺，被封矩州刺史，宋朝在敕书中有『惟尔贵州，远在要荒』，为『贵州』之名称此地区的最早记载，推测是指今贵阳地区。宋徽宗宣和元年，思州土著首领田佑恭加授<strong>贵州</strong>防御使衔，贵州正式成为行政区，相当于现在的贵阳。 </p>
<p>元朝时，境内大部分属于湖广行省，其它地区实行土司制度，设八番顺元宣慰司都元帅府于贵州（今贵阳）。</p>
<p>明设<strong>贵州</strong>等处承宣布政使司，贵州正式成为行省；程番府移治贵州城，并改称贵阳府，为今贵阳名字的开始。</p>
<p>简称黔，来自唐时境内属黔中道（战国时楚可能有黔中郡，尚有争议）。又简称贵。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p>江南·读城丨安徽的“徽”取自哪里：</p>
<p>  <a href="https://wenhui.whb.cn/third/yidian/201902/22/243702.html" target="_blank" rel="external">https://wenhui.whb.cn/third/yidian/201902/22/243702.html</a></p>
</li>
<li><p>你不知道的贵州 | “贵州”曾经真的等于贵阳？</p>
<p>  <a href="https://movement.gzstv.com/news/detail/127234/" target="_blank" rel="external">https://movement.gzstv.com/news/detail/127234/</a></p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为广东人，我专门了解过『广东』 和『粤』这两个名字的来源。也大概知道其它一些省份名字的起源。&lt;/p&gt;
&lt;p&gt;印象里是以自然地理命名为主。在地名里出现东南西北还有阴阳（山南水北谓之阳）的，一般都是用来指示在某个地理标志的旁边，而这样的名字很常见。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go 语言实战（7）：命令行程序（2）</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-7/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-7/</id>
    <published>2020-10-27T09:36:37.000Z</published>
    <updated>2020-10-30T01:55:45.784Z</updated>
    
    <content type="html"><![CDATA[<p><a href="../golang-in-action-day-6/">上一期</a> 我们有了一个最简单的命令行程序。从命令行参数输入一系列的编号，程序就会排好序重新输出。</p>
<p>接下来让我们继续改进程序。</p>
<a id="more"></a>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="标志（flag）参数"><a href="#标志（flag）参数" class="headerlink" title="标志（flag）参数"></a>标志（flag）参数</h3><p>我们在之前已经了解过命令行参数。在 <code>gosort</code> 程序中，就是通过命令行参数，输入需要排序的编号。</p>
<p>简单的命令行参数输入后变成了字符串切片，只有位置（下标）的差别，不方便传递复杂的参数。如果规定特定次序的参数表示特定的含义，不好记忆不说，还无法缺省（因为一旦缺省，次序就乱了）。而像 <code>gosort</code> 程序这样，普通参数（又叫位置参数）数量不确定，把特殊参数放到最后面也达不到缺省的效果。</p>
<p>我们需要 标志（flag）参数，通过在短横线（也就是减号 <code>-</code> ）后面加上参数名，构成一个标志，使得参数变得有名字，不再受限于顺序。使用效果类似这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 假定 gosort 支持标志参数 -x</span></div><div class="line"></div><div class="line"><span class="comment"># 允许缺省，此时 -x 为默认值</span></div><div class="line"><span class="comment"># 123 456 789 为三个普通参数，是需要排序的编号，下同</span></div><div class="line">gosort 123 456 789</div><div class="line"></div><div class="line"><span class="comment"># 如果 -x 是一个布尔参数，那么有 -x 表示 true</span></div><div class="line">gosort -x 123 456 789</div><div class="line"></div><div class="line"><span class="comment"># 如果 -x 不是布尔型的参数，那么还要指定 -x 的值</span></div><div class="line"><span class="comment"># 可以使用等号</span></div><div class="line">gosort -x=out.txt 123 456 789</div><div class="line"><span class="comment"># 也可以不用等号，紧接着的第一个参数被认为是指定的值</span></div><div class="line">gosort -x out.txt 123 456 789</div></pre></td></tr></table></figure>
<p>自己实现标志参数并不难，只需要检查每一个命令行参数，找出短横线开头的，然后根据类型决定要不要读下一个参数作为值；处理的同时，要把标志参数和位置参数分开，供后续使用。虽然不难，实现起来比较琐碎，一不小心会漏掉一些边界条件，需要耐心地去测试完善。</p>
<p>你可以尝试实现看看。不过这里我们偷个懒，使用标准库自带的 <code>flag</code> 包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意 xFlag 不是 bool 而是 *bool（bool指针）</span></div><div class="line"><span class="comment">// 创建时的三个参数，分别是参数名，默认值和参数说明</span></div><div class="line"><span class="keyword">var</span> xFlag = flag.Bool(<span class="string">"x"</span>, flase, <span class="string">"试用 flag 参数，默认为 false"</span>)</div><div class="line"><span class="comment">// 解析需要放在所有 flag 设置好之后</span></div><div class="line">flag.Parse()</div><div class="line"><span class="comment">// 需要解引用获取 bool 值</span></div><div class="line"><span class="keyword">if</span> *xFlag &#123;</div><div class="line">    <span class="comment">// -x 设置为 true 时的操作</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 可以通过 flag 包访问位置参数的数量和值（去掉了程序名和标志参数)</span></div><div class="line">fmt.Println(<span class="string">"位置参数一共有"</span>, flag.NArg(), <span class="string">"个，分别是："</span>, flag.Args())</div></pre></td></tr></table></figure>
<p>除了直接生成标志参数后返回储存地址（指针），也可以声明好变量之后，在设置标志参数时指定储存的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意这里的 name 直接就是 string，不是指针</span></div><div class="line"><span class="keyword">var</span> name <span class="keyword">string</span></div><div class="line"><span class="comment">// 将 name 的地址传给标志参数</span></div><div class="line">flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"无名"</span>, <span class="string">"试用 string 类型的 flag 参数"</span>)</div><div class="line"><span class="comment">// 解析时参数会储存到指定的变量</span></div><div class="line">flag.Parse()</div><div class="line"><span class="comment">// name 本身就是 string，无需解引用</span></div><div class="line">fmt.Println(name)</div></pre></td></tr></table></figure>
<p>简单总结一下：</p>
<ul>
<li><code>flag</code> 包保存着关于标志参数的全局状态， <code>flag.Parse()</code>  必须在 <strong>所有标志参数设置好之后、访问任意一个参数值之前调用</strong> 。</li>
<li><code>flag</code> 只支持基本类型 + <code>time.Duration</code> 类型的参数，每个类型有两个设置函数：不带 <code>Var</code> 结尾的直接返回储存变量的指针，带 <code>Var</code> 结尾的则需要你指定指针。</li>
<li>在使用时，标志参数必须位于所有位置参数之前，否则会被当做位置参数。例如 <code>gosort -x 123 456 -name bob</code> 无法得到 <code>name</code> 参数，反而会得到这样的位置参数： <code>[&quot;123&quot;,&quot;456&quot;,&quot;-name&quot;,&quot;bob&quot;]</code> 。</li>
<li>标志参数名尽量避开 <code>h</code> 和 <code>help</code> ，因为 <code>flag</code> 包默认实现了这两个标志，打印帮助信息。</li>
</ul>
<p>更复杂的标志参数，可以使用第三方包 <code>github.com/urfave/cli</code> 和 <code>github.com/spf13/cobra</code>，它们在 <code>flag</code> 的基础上，封装了更高级的用法。但目前为止，<code>flag</code> 已经够用了。</p>
<blockquote>
<p>记得标准库和第三方包的详细文档，可以在 pkg.go.dev 搜到。</p>
<p>在这一期里，部分函数只会做简略的介绍，详细的函数签名和用法需要大家自行看文档。</p>
</blockquote>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><blockquote>
<p>篇幅关系，只展示代码的关键部分，需要补足剩余的代码才能编译运行。</p>
</blockquote>
<p>在开始改进之前，先将之前的程序做一点小调整：把排序和拼接的代码，单独抽取成一个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 为了不修改包级变量（os.Args 以及后面的 flag.Args()）</span></div><div class="line">    <span class="comment">// 排序前先拷贝一份</span></div><div class="line">    s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(os.Args)<span class="number">-1</span>)</div><div class="line">    <span class="built_in">copy</span>(s, os.Args[<span class="number">1</span>:]))</div><div class="line">    fmt.Println(sortStrings(s))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 因为不需要供包外调用，函数名小写开头即可</span></div><div class="line"><span class="comment">// 上一期介绍过函数签名和函数原型，读者想必可以看懂这个函数的参数和返回值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortStrings</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">    sort.Strings(strs)</div><div class="line">    <span class="keyword">return</span> strings.Join(strs, <span class="string">","</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将功能相对独立的、会被复用的代码抽取成函数是一个好的编程习惯，将函数内部控制在较少的容易理解的行数，可以让程序代码行数持续膨胀的同时，保持一个较好的可读性。</p>
<h3 id="按数值排序"><a href="#按数值排序" class="headerlink" title="按数值排序"></a>按数值排序</h3><p>还记得我们的需求吗？待排序的是一组提交编号，它们是单调递增的序列号。在实际使用中，因为代码库特别庞大，到后期提交编号达到好几位数，位数要过很长时间才增长一位，给人一种编号位数一直就是这么多的错觉。实际上并不是这样，编号用完了还是要进位的，9999 之后，就是 10000 了。</p>
<p>之前的实现按文本（字符串）排序，就出问题了。例如 <code>9,80,564,1253</code> 这几个数，如果按照数值排序，现在的顺序就是升序；可如果按字符串排序，则刚好反过来，顺序是 <code>1253,564,80,9</code> 。因为字符串是头部对齐后从左到右比较的，前缀分出先后就直接结束比较。</p>
<p>我们需要先将提交编号转换为数字，再按数字的规则排序。另一方面，按照字符串排序可以保留，让 <code>gosort</code> 程序有更多的用途，这时就需要一个标志参数区分开。现在规定默认情况按数值排序，而当设置 <code>-l</code> （lexically）时按字符串排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 设置 bool 型的标志参数 -l</span></div><div class="line">    <span class="keyword">var</span> lex <span class="keyword">bool</span></div><div class="line">    flag.BoolVar(&amp;lex, <span class="string">"l"</span>, <span class="literal">false</span>, <span class="string">"sort lexically"</span>)</div><div class="line">    flag.Parse()</div><div class="line"></div><div class="line">    <span class="keyword">var</span> res <span class="keyword">string</span></div><div class="line">    <span class="keyword">if</span> lex &#123;</div><div class="line">        <span class="comment">// 如果设置了 -l，调用之前的sortStrings()</span></div><div class="line">        <span class="comment">// flag.Args() 返回的切片在 Parse() 的时候已经去掉了多余的参数</span></div><div class="line">        s := <span class="built_in">make</span>([]<span class="keyword">string</span>, flag.NArg())</div><div class="line">        <span class="built_in">copy</span>(s, flag.Args())</div><div class="line">        res = sortStrings(s)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 否则先转为整型切片再排序</span></div><div class="line">        <span class="comment">// 由于没有对返回的切片进行修改，所以无需拷贝</span></div><div class="line">        nums, err := strsToNums(flag.Args())</div><div class="line">        <span class="comment">// 命令行参数不一定都是数字，转换有可能失败，此时要打印错误信息并退出</span></div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            fmt.Println(err)</div><div class="line">            <span class="comment">// 0 以外的值表示异常退出</span></div><div class="line">            <span class="comment">// 退出后，后面的代码都不会再执行</span></div><div class="line">            os.Exit(<span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">        res = sortNums(nums)</div><div class="line">    &#125;</div><div class="line">    fmt.Println(res)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是设置标志参数并储存在变量 <code>lex</code> ，这部分内容参考前面的准备知识。然后程序根据 <code>lex</code> 的值执行不同的分支。如果是字符串排序，就是之前的函数。另外一个分支则多了几个新函数。</p>
<p><code>strsToNums()</code> 是我们自己实现的函数，用来把字符串切片转换为整型数切片。因为转换有可能失败，所以返回值列表里还带着一个 <code>error</code> 类型的返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">strsToNums</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</div><div class="line">    <span class="comment">// 创建同样大小的 int 切片，用来存放转换的结果</span></div><div class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(strs))</div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    <span class="comment">// 遍历每个字符串并转换</span></div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> strs &#123;</div><div class="line">        nums[i], err = strconv.Atoi(strs[i])</div><div class="line">        <span class="comment">// 这里的逻辑是，只要其中一个字符串转换失败，就返回空白切片和错误</span></div><div class="line">        <span class="comment">// 你也可以改为忽略不能转换的字符串，继续转换和排序</span></div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nums, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了标准库函数 <code>strconv.Atoi()</code> 。<code>strconv</code> 是 String  Convert 的缩写，这个包里是跟字符串转换相关的工具函数，其中 <code>Atoi()</code> 就是把按十进制显示的字符串，转换为 <code>int</code> 型。因为字符串储存的不一定是十进制数，就有可能转换失败。</p>
<p><code>sortNums()</code> 是另一个我们自己实现的函数，跟之前的 <code>sortStrings()</code> 类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortNums</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">    sort.Ints(nums)</div><div class="line">    <span class="keyword">return</span> numsJoin(nums)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于整型切片无法直接 <code>strings.Join()</code> ，为了让 <code>sortNums()</code> 内部跟 <code>sortStrings()</code> 保持类似，我们又自行实现了 <code>numsJoin()</code>。把整型数拼接成逗号隔开的字符串有很多种具体的做法，这里是其中一种：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现 1</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numsJoin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="comment">// 一种直观的想法就是，再逐个转换回字符串，再 strings.Join()</span></div><div class="line">    strs := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(nums))</div><div class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</div><div class="line">        <span class="comment">// 每个整型数都一定有对应的字符串表示，不存在失败，所以返回值里没有 error</span></div><div class="line">        strs[i] = strconv.Itoa(nums[i])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> strings.Join(strs, <span class="string">","</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过我嫌这里做了两次转换（先从整型到一个个字符串，再把字符串拼成长字符串），有点浪费。能不能一步到位呢，于是我又写了第二种实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现 2</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numsJoin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="comment">// 声明一个 byte 切片作为缓冲区</span></div><div class="line">    <span class="comment">// 这里无需 make，因为后续的两个 append 操作都会根据需要扩展切片，包括 nil 切片也能处理</span></div><div class="line">    <span class="keyword">var</span> buf []<span class="keyword">byte</span></div><div class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</div><div class="line">        <span class="comment">// 把转换后的字符串放进缓冲区（以字节的形式）</span></div><div class="line">        strconv.AppendInt(buf, <span class="keyword">int64</span>(n), <span class="number">10</span>)</div><div class="line">        <span class="comment">// 把逗号放进缓冲区</span></div><div class="line">        <span class="built_in">append</span>(buf, <span class="string">','</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// byte 切片转换为字符串，只转换一次</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(buf)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我还能基于 <code>bytes.Buffer</code> 和 <code>strings.Builder</code> 写出别的实现版本。</p>
<p>但第一种实现就挺好的。这里只是展示，有时同一个功能可以有多种实现方式。开发的首要任务是实现功能，并且尽可能让代码易读，不容易出错。性能有时也重要，但必须是经过分析，确认有性能差异，并且这个差异对于程序的表现有影响。第二种实现一定比第一种性能好吗？差异是否大到值得特意去优化？使用看起来性能好但是不熟悉的实现，是否会带入潜在的 bug？答案都是不确定的。</p>
<p>这里为了行文方便，每个函数分开讨论，实际上它们都放在 <code>main.go</code> 里。在 Go 里，包级成员（包括函数）的引用顺序和声明顺序无关，只要不存在循环引用即可。一般的惯例是，<code>init()</code> 和 <code>main</code> （如果有）最前面，然后是导出（exported）成员（就是首字母大写那些），然后是未导出（unexported）成员。未导出函数之间，先被引用到的就放前面。</p>
<p>现在重新编译之后执行一下程序看看效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; gosort -h</div><div class="line">Usage of gosort:</div><div class="line">  <span class="_">-l</span>    sort lexically</div><div class="line"></div><div class="line">&gt; gosort 1253 80 9 564</div><div class="line">9,80,564,1253</div><div class="line"></div><div class="line">&gt; gosort 1253 abc 80 9 564</div><div class="line">strconv.Atoi: parsing <span class="string">"abc"</span>: invalid syntax</div><div class="line"></div><div class="line">&gt; gosort <span class="_">-l</span> 1253 abc 80 9 564</div><div class="line">1253,564,80,9,abc</div></pre></td></tr></table></figure>
<h3 id="从文件输入输出"><a href="#从文件输入输出" class="headerlink" title="从文件输入输出"></a>从文件输入输出</h3><p>现在程序默认按数值排序，即使遇到长度不同的提交编号也不怕；同时按文本排序的功能也没丢掉，偶尔还能用来排一下人名之类的文本信息。程序够用了吗？</p>
<p>还是回到最初的需求。为什么不人工检查排序呢？因为编号多，最多达几十上百，这种数量，人工排序又慢又累又容易错。甚至不要说排序，就是把编号全部输入一遍，也是慢、累、易错。实际工作中都是打开记事本，把大家回复的编号整理起来，然后直接复制到命令行作为参数。有时还得追加提交编号，就把新的编号放到记事本最后面，然后 Ctrl + A（全选），Ctrl + C（复制），来到命令行，Ctrl + V（粘贴），熟练到麻木。</p>
<p>为什么要重复做这四个动作，能不能告诉程序，直接从指定的文件读编号？当然可以。不过从命令行参数输入编号还是得保留，方便数量少时使用。</p>
<p>这时可以设置标志参数 <code>-f</code> （file，不过为了跟后面的输出区分，还是理解为 from 吧），传入一个文件，让程序改为从文件读入。这里假定文本文件里只有编号，以空白字符隔开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 省略 -l 部分代码...</span></div><div class="line">    <span class="keyword">var</span> from <span class="keyword">string</span></div><div class="line">    flag.StringVar(&amp;from, <span class="string">"-f"</span>, <span class="string">""</span>, <span class="string">"input from file"</span>)</div><div class="line">    flag.Parse()</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> strs []<span class="keyword">string</span></div><div class="line">    <span class="keyword">if</span> from != <span class="string">""</span> &#123;</div><div class="line">        <span class="comment">// 如果不是文件，输出错误信息并退出</span></div><div class="line">        <span class="keyword">if</span> !isFile(from) &#123;</div><div class="line">            fmt.Println(from, <span class="string">" is not a file"</span>)</div><div class="line">            os.Exit(<span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 读取文件有多种实现方式，这里采用了最简单的 ioutil 包</span></div><div class="line">        buf, err := ioutil.ReadFile(from)</div><div class="line">        <span class="comment">// 如果读取文件有错误，也是输出错误信息并退出</span></div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            fmt.Println(<span class="string">"read "</span>, from, <span class="string">" fail: "</span>, err)</div><div class="line">            os.Exit(<span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 这里不要用 strings.Spilt(string(buf), " ")，因为间隔的空白字符可能不止一个</span></div><div class="line">        <span class="comment">// Fields() 以任意数量的空白字符作为分割</span></div><div class="line">        strs = strings.Fields(<span class="keyword">string</span>(buf))</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 无论是否从文件读入，位置参数都追加到后面</span></div><div class="line">    <span class="comment">// ... 的含义，请参考上一期可变参数部分</span></div><div class="line">    strs = <span class="built_in">append</span>(strs, flag.Args()...)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> res <span class="keyword">string</span></div><div class="line">    <span class="keyword">if</span> lex &#123;</div><div class="line">        <span class="comment">// 前面 append 时字符串追加到了新切片，这里不用再拷贝</span></div><div class="line">        res = sortStrings(strs)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        nums, err := strsToNums(strs)</div><div class="line">    <span class="comment">// 省略之后的代码...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>增加了 <code>-f</code> 参数之后，如果 <code>from</code> 有值，而且这个值确实是一个有效的文件，就会从里面读取内容。位置参数的值同时也追加到切片里。</p>
<p>这里面用到的新函数，只有 <code>isFile()</code> 是自行实现，其它像 <code>ioutil.ReadFile()</code> 和 <code>strings.Fields()</code> 可以直接查询文档。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断是否文件的固定套路</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">    info, err := os.Stat(path)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !os.IsExist(err) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> !info.IsDir()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相应地，从命令行复制大段的输出也不够方便。极端的情况下，太多的输出甚至会超出命令行的缓冲区。可以从文件输入，自然也可以从文件输出。跟 <code>-f</code> 参数类似，我使用 <code>-o</code> （output）参数指定输出文件。参数设置就不再示范了，这里看一下怎么写入文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 省略...</span></div><div class="line">    <span class="keyword">var</span> output <span class="keyword">string</span></div><div class="line">    </div><div class="line">    <span class="comment">// 省略...</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> output == <span class="string">""</span> &#123;</div><div class="line">        fmt.Println(res)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        err := ioutil.WriteFile(output, []<span class="keyword">byte</span>(res), <span class="number">0666</span>)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            fmt.Println(<span class="string">"write result to "</span>, output, <span class="string">" fail: "</span>, err)</div><div class="line">            os.Exit(<span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样地，为了偷懒，直接用 <code>ioutil.WriteFile()</code> ，三个参数分别是文件名（路径），写入的数据（<code>string</code> 需要转换为 字节切片）和 文件权限。这个函数在遇到目标文件存在且有写权限时，会直接覆盖原来的内容，但不改动权限；如果文件不存在，则以指定权限创建文件。<code>0666</code> 为八进制数，对应 Linux 的权限值（在 Windows 系统 Go 会自动转换为相应的操作）。</p>
<p>接下来试一下修改后的程序。我们首先创建一个 <code>input.txt</code> （注意前后和中间间隔有多余空格，实际操作中不小心多输入空格是非常常见的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">123 456 111      983</div></pre></td></tr></table></figure>
<p>然后执行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用 strings.Spilt(string(buf), " ") 分割文件输入的效果</span></div><div class="line"><span class="comment"># 分割结果里出现了空白字符串，无法转换为数字</span></div><div class="line">&gt; gosort <span class="_">-f</span> input.txt 256</div><div class="line">strconv.Atoi: parsing <span class="string">""</span>: invalid syntax</div><div class="line"></div><div class="line"><span class="comment"># 使用 strings.Fields(string(buf)) 的效果</span></div><div class="line">&gt; gosort <span class="_">-f</span> input.txt 256</div><div class="line">111,123,256,456,983</div><div class="line"></div><div class="line"><span class="comment"># 参数较多时，为了视觉上紧凑，可以用等号连接</span></div><div class="line">&gt; gosort <span class="_">-f</span>=input.txt -o=output.txt 256</div><div class="line"><span class="comment"># 没有错误的话没有输出，结果在 output.txt 里</span></div></pre></td></tr></table></figure>
<h3 id="其它改进"><a href="#其它改进" class="headerlink" title="其它改进"></a>其它改进</h3><p>除此之外，还能想到一些有用的功能。</p>
<h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>无论是有人不小心回复了重复的编号，还是管理员整理时多写了，编号偶尔会出现重复。重复的内容，在不同场景下，造成的影响可大可小。对于一些严格的场景，我们更希望编号里没有重复。这就要求对结果进行去重。</p>
<p>这时我们可以增加一个 <code>-u</code> （unique）的 <code>bool</code> 参数，表示开启去重。（当然也可以默认去重，设置一个反向的开关表示保留重复。）去重可以在排序之后做，因为这时重复元素相邻，更容易处理。这个功能实现起来并不难，对切片做一次遍历即可，大家可以尝试自己实现。如果一时没有概念，可以先用 Go 语言完成这道题 <a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="external">https://leetcode-cn.com/problems/remove-element/</a> ，做出这道题就知道如何高效地在切片里去除元素了。</p>
<p>需要注意的是，因为有 <code>[]string</code> 和 <code>[]int</code> 两种切片，去重的逻辑可能要实现两个版本（视乎你的代码实现）。这是 Go 目前不便的其中一个地方：没有泛型，会一定程度导致代码重复。</p>
<h4 id="自定义分隔符"><a href="#自定义分隔符" class="headerlink" title="自定义分隔符"></a>自定义分隔符</h4><p>现在的程序，根据常用的场景，默认了输入的分隔符是空白字符，输出的分隔符是半角逗号 <code>,</code> 。但这个设定不会总是好使。有可能输入文件是其他人整理的，可能是别的系统导出的，用了别的分隔符；输出内容也可能用于别的场景，需要别的格式。</p>
<p>这时我们需要针对每个场景修改代码，重新编译吗？没有必要。只要设置对应的标志参数，允许分别指定分隔符就好。而如果没有指定，还是用原本的默认符号。两个符号分别用于分割输入的内容，和拼接输出的内容，需要调整相关的代码，可能用到的函数基本都在 <code>strings</code> 包里。</p>
<p>这两个功能添加上之后，实现效果大概是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这里我定义输入分隔符的参数为 -i，输出分隔符的参数为 -s</span></div><div class="line">&gt; gosort -u -i=, <span class="_">-s</span>=- 111,111,555,678,333,567,678</div><div class="line">111-333-555-567-678</div></pre></td></tr></table></figure>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><code>numsJoin()</code> 的第二种实现有几个 bug，你发现了吗？</li>
<li>通过自行查阅文档，了解 <code>strings.Builder</code> 的用法，你可以写出 <code>numsJoin()</code> 的第三种实现吗？</li>
<li>你可以自行实现 <strong>去重</strong> 和 <strong>自定义分隔符</strong> 两个功能吗？</li>
</ol>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;../golang-in-action-day-6/&quot;&gt;上一期&lt;/a&gt; 我们有了一个最简单的命令行程序。从命令行参数输入一系列的编号，程序就会排好序重新输出。&lt;/p&gt;
&lt;p&gt;接下来让我们继续改进程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>遇到十字路口，你要做的三件事（翻译）</title>
    <link href="https://jaycechant.info/2020/three-things-to-do-when-you-hit-a-crossroads-translation/"/>
    <id>https://jaycechant.info/2020/three-things-to-do-when-you-hit-a-crossroads-translation/</id>
    <published>2020-10-26T05:51:10.000Z</published>
    <updated>2020-10-26T12:37:34.547Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<strong>Three Things To Do When You Hit A Crossroads</strong></p>
<p>地址：<a href="https://medium.com/introskeptic/three-things-to-do-when-you-hit-a-crossroads-504be4bda616" target="_blank" rel="external">https://medium.com/introskeptic/three-things-to-do-when-you-hit-a-crossroads-504be4bda616</a></p>
<p>作者：<a href="https://medium.com/@ethangreavu" target="_blank" rel="external">Ethan Greavu</a></p>
<p>翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）</p>
<p>一直撰写和翻译技术文章，有点枯燥，今天看到朋友圈有人感慨人生的选择，所以想到翻译一篇相关的文（ji）章（tang），希望能从中得到启发。</p>
<a id="more"></a>
<p>以下是译文：</p>
<hr>
<blockquote>
<p>当走到人生的十字路口，在你面前有两种选择：一种是选择放弃，那是一条糟糕的路；还有一种是选择反击，一条真正艰难的路。</p>
<p>——马修 · 佩里</p>
</blockquote>
<p>遇到十字路口最糟糕的一点是，你不可能总是知道自己什么时候会遇到岔路。十字路口让我们感到害怕，因为我们对接下来要做什么感到不确定。</p>
<p>如果我遇到一个十字路口，我应该知道该走哪条路，而且可能会试着走那条路。但这无法阻止我对曾经有过的其它选择的好奇。</p>
<p>我们之所以会把十字路口当作一个艰难的抉择，是因为我们知道，尽管很多道路前途光明，里面却可能隐藏着一两条糟糕的路。问题是，糟糕的路究竟有多糟糕；如果我们无法看清路的另一头有什么，我们又有多大可能冒险去走那些路？</p>
<p>十字路口是可怕的，却又是诱人的，因为背后充满了机遇。只有很少的路是负面的。但即使危险可能并不存在，做选择仍然让人感觉到痛苦，这种阴影在做出决定之前、期间甚至之后，都会笼罩在我们的头上。</p>
<h2 id="1-做出重大改变"><a href="#1-做出重大改变" class="headerlink" title="1. 做出重大改变"></a>1. 做出重大改变</h2><p>做出重大改变是很难的，因为你可能无法准确地找到那些会引起重大改变的决定。</p>
<p>我们所知道的是，重大的变化是一般是指类似的事：接受一个新的工作机会、离开目前的工作、结束一段关系或者从家里搬出来等等。然而，有些重大变化是看不见的，而且是在没有预期的情况下发生的。</p>
<p>与一个刚认识的人建立新的关系，这个人可能从此在你的生活中扮演着重要的角色；但如果你们是偶然相遇，这个重大的改变未必是你发起的。</p>
<p>但重大的改变主要还是掌握在我们自己手中，只要我们想，即使感觉时机不对，我们还是可以随时采取行动。做出一个改变生活方式的重大决定，会让我们保持掌控感。</p>
<p>我们当然可以选择轻松写意地走进十字路口；但拼命地直奔向前，却有可能让最好的那条道路变得更加美好。用尽全力，逼着十字路口，将最好的道路交出来。</p>
<p>如果你不是用力地撞向十字路口，强行开路，那可能是你被道路选择而不是你选择了道路，你不一定能得到对你来说最有利的结果。</p>
<h2 id="2-先行动再思考"><a href="#2-先行动再思考" class="headerlink" title="2. 先行动再思考"></a>2. 先行动再思考</h2><p>大家都知道的做事方法，是先思考再行动，做事要谨慎。</p>
<p>对于某些情况来说，这是对的。但在机会出现时——如果是决策时机稍纵即逝那种——没能采取行动，我们很可能就只能固守在当下的线性路径上。</p>
<p>仔细考虑一个机会，不能保证你还能有不受限制的时间抓住这个机会。任何事情都有可能发生，任何事情都有可能被撤回。</p>
<p>先行动再思考，让你有时间在行动过后去思考这个行动。行动之前的思考会让你产生是否要行动的焦虑。也许你本来已经决定好要走那一条路，但随着时间推移，你开始找理由和借口，说那不是当时最好的路。</p>
<p>即使这个行动利大于弊，如果当时没能抓住机会，以后就更难强迫自己行动了。</p>
<p>无论如何，先行动再思考能让你在某个地方得到立竿见影的效果；而先思考再行动则会让你原地踏步。你被留在原地想象你本来可以去的地方：如果我当时做了决定，而不是想得太多，结果会怎样。</p>
<p>我们的大脑并不总是围绕着我们的利益全面地考虑事情。我们并不总是考虑什么对我们最好。我们想保持舒适，而舒适让我们哪都去不成。</p>
<p>如果仔细考虑一个决定可能会导致过度思考，就不要给大脑思考的时间，直接做决定。</p>
<h2 id="3-回溯"><a href="#3-回溯" class="headerlink" title="3. 回溯"></a>3. 回溯</h2><p>回溯有一种坏名声，它被视为已经失败，所以才不得不回到以前的地方。但事实并非如此。</p>
<p>有益的回溯是另一条机遇之路。也许你现在所处的地方，并不是你认为必须要做的抉择，你在来时的路看到了更好的机会。那就回溯到那个地方。</p>
<p>回溯可能并不总是可行的。可如果回溯是可行的，如果回溯是必要的，那就应该把它作为一个选项。</p>
<p>抓住的机会，即使没有充分利用好，也还是从中获得了经验。</p>
<p>回溯里唯一的损失是时间。尽管如此，如果你没有走过第一条路，也许回头再去走的另一条路也不会如此清晰。回溯并非只是单纯地走回头路。</p>
<p>你总是还在进步中，即使可能感觉不到，那也是过程的一部分。</p>
<hr>
<p>遇到十字路口是令人恐惧的，我们可能看到好几条路，或者可能完全看不见路的另一头。</p>
<p>无论怎样，我们对自己想去的地方有一种直觉，困难的是迈出第一步，并下定决心走下去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;strong&gt;Three Things To Do When You Hit A Crossroads&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://medium.com/introskeptic/three-things-to-do-when-you-hit-a-crossroads-504be4bda616&quot;&gt;https://medium.com/introskeptic/three-things-to-do-when-you-hit-a-crossroads-504be4bda616&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://medium.com/@ethangreavu&quot;&gt;Ethan Greavu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）&lt;/p&gt;
&lt;p&gt;一直撰写和翻译技术文章，有点枯燥，今天看到朋友圈有人感慨人生的选择，所以想到翻译一篇相关的文（ji）章（tang），希望能从中得到启发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://jaycechant.info/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（6）：命令行程序（1）</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-6/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-6/</id>
    <published>2020-10-18T16:39:39.000Z</published>
    <updated>2020-10-25T13:37:44.978Z</updated>
    
    <content type="html"><![CDATA[<p>看到别人的好作品，像画作、模型还是代码，我们第一反应可能是感叹结构复杂、技巧精湛，然后紧接着冒出一个想法：太难了，我做不到。</p>
<a id="more"></a>
<p>这往往是因为我们对相应的领域了解不够，只看到复杂的结果，对如何通向目的地毫无概念。如果了解如何分解任务，到最简单的步骤为止，还有从最简单能看到反馈的雏形开始，逐步改善，普通人也能做出复杂的作品，最多时间比有天赋的人多花一些。</p>
<p>这一期开始，我们会花几期的时间，逐步地尝试改善一个命令行程序。</p>
<p>如果是从这篇文章才开始看的新手，建议先简单浏览前几期的内容。当然，你也可以完成第一期的环境搭建之后直接跳到这期，在实际遇到问题时再去查看具体的内容。</p>
<ol>
<li><a href="../golang-in-action-day-1/">初识</a></li>
<li><a href="../golang-in-action-day-2/">常量与变量</a></li>
<li><a href="../golang-in-action-day-3/">类型</a></li>
<li><a href="../golang-in-action-day-4/">运算符</a></li>
<li><a href="../golang-in-action-day-5/">流程控制</a></li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>我们从一个命令行程序开始。</p>
<h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>命令行界面（CLI，Command Line Interface），又叫字符用户界面 （CUI，Character User Interface），区别于图形用户界面（GUI，Graphic User Interface）。GUI 就像在国外不用学当地语言，有一份我们能看懂的、甚至有图片的菜单供选择，指一下就有结果，无需语言交流。而在 CLI 里，人和机器通过标准输入输出（可以简单理解为打字）进行交互：你必须通过命令准确地告诉系统你想干嘛，然后系统执行并把结果打在屏幕上。你必须得先知道系统接受什么命令。如果输入命令以外的东西，系统只能告诉你『我听不懂』。</p>
<p>GUI 当然要比傻傻等着你打字的黑窗友好，也是日常使用的主流。但在方便之余，你无法提出菜单以外的细致要求，执行菜单上没有显示的操作。同一个动作（如点一下菜单第二项），结果高度依赖当前的菜单显示，你必须等菜单显示完成才能接着『交互』，而不能一口气直接下达想要的一系列动作指令。这就好像你明明想好了要干什么，却不能说话，非要等下属慢慢翻到那页菜单。相比之下，CLI 可以一口气接受一系列精确的指令。所以即使在图形界面的系统中，命令行也没有被遗弃，甚至还在不断地加强。</p>
<p>从开发的角度说，图形界面开发的门槛反而比较高，命令行程序因为没有图形界面，减少了很多工作量，可以把精力集中在核心的功能上，适合练手。</p>
<h3 id="函数签名和函数类型"><a href="#函数签名和函数类型" class="headerlink" title="函数签名和函数类型"></a>函数签名和函数类型</h3><p>别误会，我没有打算详细介绍函数。</p>
<p>在实际的开发中，自然会接触函数的用法。在写出优雅强大的函数之前，我们可以先调用标准库或第三方包里别人写好的函数，并从中学习。</p>
<p>要正确使用函数，我们需要查看文档，看懂函数签名和注释，有些还会有例子，就像看说明书。如果想学习实现，则要进一步看源码。</p>
<p>以经常用的 <code>fmt.Println</code> 为例。</p>
<p>可以在 <a href="https://pkg.go.dev" target="_blank" rel="external">https://pkg.go.dev</a> 上搜索 <code>fmt</code> 包，找到 <code>Println</code> 这个函数，内容是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.</p>
</blockquote>
<p>Example Code:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">const</span> name, age = <span class="string">"Kim"</span>, <span class="number">22</span></div><div class="line">	fmt.Println(name, <span class="string">"is"</span>, age, <span class="string">"years old."</span>)</div><div class="line"></div><div class="line">	<span class="comment">// It is conventional not to worry about any</span></div><div class="line">	<span class="comment">// error returned by Println.</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Kim is 22 years old.</div></pre></td></tr></table></figure>
<blockquote>
<p>注：pkg.go.dev 从 19 年起取代了 godoc.org 成为了 Go 语言的文档网站，上面不仅可以搜索到标准库，所有被缓存了的第三方 module 也都能搜到。（go module 默认会先向 proxy 请求第三方包，proxy 发现尚未缓存就会先获取缓存再返回。换言之，几乎所有公开的有人请求的 module 都可以搜到。）</p>
</blockquote>
<hr>
<p>函数签名、注释、例子还有例子的输出，是标准的文档构成。</p>
<blockquote>
<p>注：文档里的实际上是函数原型（prototype），但要确认的主要是签名信息。</p>
</blockquote>
<p><code>Println</code> 不是讨论重点，注释和例子就不展开了。主要介绍一下函数签名。</p>
<p>函数签名（function signature）定义了函数的输入（参数列表）和输出（返回值列表）。它本质上是函数开发者和调用者之间的契约，包含函数的关键信息：参数的类型、个数和顺序，返回值的类型、个数和顺序。调用者通过它了解调用时要提供什么，以及在调用完成后会得到什么。（当然，按签名调用还是有可能出现逻辑上的错误，开发者需要在注释中进一步说明注意事项。）函数名、参数名、返回值名可以出现在签名里也可以省略，<strong>命名信息对签名来说并不重要</strong> 。</p>
<p>最简单的函数签名是这样的：<code>(参数列表) (返回值列表)</code>。签名信息前面加上 <code>func</code> 关键字就成了函数类型（type）字面量，再加上函数名就成了函数原型（prototype），再加上函数体 <code>{/*代码实现*/}</code> 就变成完整的函数。实际使用中，虽然函数签名是关键，但命名能帮助我们区分函数、参数和返回值，还能从命名中推测用途，所以很多函数签名其实是带着命名的类型字面量或函数原型的形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单纯的签名信息</span></div><div class="line">(<span class="keyword">int</span>, <span class="keyword">int</span>) (<span class="keyword">int</span>, error)</div><div class="line"><span class="comment">// 函数类型字面量，但不细究的话，也可以叫函数签名</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></div><div class="line">// 函数原型，有时这个也叫函数签名</div><div class="line"><span class="title">func</span> <span class="title">Count</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></div><div class="line">// 完整的函数</div><div class="line"><span class="title">func</span> <span class="title">Count</span><span class="params">(start <span class="keyword">int</span>, end <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span> &#123;</div><div class="line">    <span class="comment">// 有引用到的参数需要命名。一般函数没有多余的参数，所以参数都是命名的。</span></div><div class="line">    count := <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i := start; i &lt; end; i++ &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        count++</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Go 里面函数也是一种类型，签名相同的函数就被认为是同一个类型。下面的代码是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(c <span class="keyword">int</span>)</span> = <span class="title">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123; <span class="keyword">return</span> x + y &#125;</div><div class="line"><span class="keyword">var</span> f2 <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span> = <span class="title">f</span></span></div></pre></td></tr></table></figure>
<p>实际上，真正的签名信息是 <code>(int, int) int</code> ，<code>func</code> 关键字和各种命名 <code>a</code>, <code>b</code>, <code>c</code>, <code>x</code>, <code>y</code>, <code>z</code> 都可以省略，有没有命名、命名是否相同，不影响它们是同一个类型。（函数的参数名 <code>x</code> 和 <code>y</code> 在函数体没有引用时也可以省略，例如 <code>func(int, int) int {return 0}</code> 。）</p>
<p>无论是哪一种形式，关注的要点都是参数列表和返回值列表。知道以下几点规则，你就可以读懂函数签名：</p>
<ul>
<li><p>跟其它 C 家族语言返回值类型在前、没有关键字不同（C 语言：<code>int myFunc(int a)</code>），Go 以关键字开头，函数名和参数列表在返回值列表前面。</p>
<p>  （顺序：关键字 - 函数名 - 参数列表 - 返回值列表。）</p>
</li>
<li><p>因为允许多返回值，参数和返回值都是列表。其中参数列表外面的括号不能省略，即使参数列表为空；而返回值列表如果为空或者只有一个匿名返回值，可以省略括号。</p>
<p>  （区分参数还是返回值：第一个括号里的是参数，右边剩下的是返回值。Go 没有类似 <code>void</code> 的关键字，没有返回值时，返回值部分直接为空。）</p>
</li>
<li><p>连续多个相同类型的命名参数或返回值，可以一起声明，<code>(a, b, c int, s string)</code> 等价于 <code>(a int, b int, c int, s string)</code> 。（要看懂这种写法，但不推荐这样写。这样写在增减参数和调整参数顺序时，容易出错，会把类型张冠李戴。）</p>
</li>
</ul>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>Go 支持可变参数（variadic arguments）。具体声明形式是，在类型前面加上三个句点 <code>...</code> ，表示可以接受 0 到多个该类型的参数。例如 <code>Println</code> 的 <code>(a ...interface{})</code> 表示可以接受任意个空接口类型的值作为参数。</p>
<blockquote>
<p>注：空接口方法列表为空，意味着任意类型都满足空接口，任意类型都可以作为实参传递给函数。相当于 Java 里用 Object 作为参数类型。</p>
</blockquote>
<p>调用时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可以没有参数，只输出一个换行符</span></div><div class="line">fmt.Println()</div><div class="line"><span class="comment">// 可以 3 个 int 型字面量</span></div><div class="line">fmt.Println(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// 不同类型混合着来</span></div><div class="line"><span class="comment">// 允许不同类型是因为用了空接口类型，数量可以为任意个才是可变参数的关键</span></div><div class="line">fmt.Println(<span class="string">"院子里有"</span>, <span class="number">1</span>, <span class="string">"棵枣树，另"</span>, <span class="number">1</span>, <span class="string">"棵也是枣树？"</span>, <span class="literal">true</span>)</div></pre></td></tr></table></figure>
<p>函数最多只能声明一个 <strong>可变参数</strong> ，而且只能是最后一个参数（可变参数放中间，后面的参数就很难对得上号了）。</p>
<p>可变参数实际上是一个语法糖，传给可变参数的一系列值被打包成了一个对应类型的切片，供函数内部引用。<code>Println</code> 的参数在函数内部相当于 <code>(a []interface{})</code> 。不过今天不讨论函数的实现，只讨论调用。</p>
<p>既然可变参数实际上变成了一个切片，如果调用方刚好有一个同类型切片 <code>s</code>，可以直接拿来当实参吗？</p>
<p>不能。可变参数调用时要求传入的是一个一个对应类型的值，传相应的切片类型不符。难道只能 <code>(s[0], s[1], s[2])</code> 这样一个个地传参吗？如果切片有一百个元素呢……</p>
<p>这时有另外一个语法糖，在实参后面同样加上 <code>...</code> ，就会产生类似 Python 解包（unpack）的效果。当然，只是像，实际上是告诉函数这是一个切片，可以直接复制给可变参数，并没有解包再打包的操作。</p>
<p><code>...</code> 的位置很容易搞混：可变参数（形参）的声明放在前面，给实参『解包』放在后面。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>铺垫了一些背景知识，下面开始动手。</p>
<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>准备这期内容时，我在读者中间征集过日常找不到软件工具的小需求，作为实战项目的选题。最后也没找到合适选题，这期先用我曾经遇到的需求做例子。后续大家想到什么需求，还是可以留言，也许就用在下一个项目上。</p>
<p>这个需求很简单：<strong>排序</strong>。源自我第一份工作时，开发之余偶尔帮项目做版本管理。VCS 用的 P4，所有手机型号的项目，在同一个代码库的同一棵源码树上，通过分支和特性开关区分型号。优点是，跨型号共性问题，只要在源头上修改一次，随着代码定期集成到各分支，都会修复，避免重复劳动和遗漏型号。缺点是，针对某些型号的修改，如果隔离没做好，会影响无关的型号。</p>
<p>送测和正式发布的编译，为避免引入不确定的提交，采用基线（base）+ 追加提交的方式。会选择一个经过验证的提交作为 base，到 base 为止的所有修改都参与编译；base 之后的提交，往往都不太确定，遇到必须包含的提交，就要添加到追加提交里，编译时会将这些提交当作补丁按顺序应用到代码上（相当于临时 cherrypick）。但这个顺序，不是提交顺序，而是填写顺序。假如提交 A 修复问题 1 同时引起问题 2，之后提交 B 对同一个地方做修改修复问题 2。那么填写时必须按照 A 到 B 的顺序，否则 B 的修改会被 A 覆盖，问题 2 将仍然存在。</p>
<p>每次编译之前，在内网公布 base，模块负责人根据 base 回复需要追加的提交，然后管理员就得到了一堆提交号。P4 的提交号是自增序列号，所以只要将它们升序排列，就能保证先后顺序。</p>
<p>交流大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">管理员：本次编译，base 为 123456</div><div class="line">驱动组：133297 修复兼容性问题</div><div class="line">电源管理组：167834 修正功耗计算</div><div class="line">图形组：123467 调整刷新缓存</div><div class="line">系统组：145683 修改进程管理策略</div><div class="line">......</div></pre></td></tr></table></figure>
<p>管理员经过整理，得到了 <code>123467,133297,145683,167834</code> 作为编译的参数。提交少的时候，人工处理一下就完了。但如果因为某些原因无法提高 base，后续的补丁却源源不断，提交可能会积累到过百，这时人工确认就又累又容易出错了。于是我当时就写了一个命令行工具来处理这么一个简单的需求。</p>
<p>为什么不直接用 Excel 呢？首先是 Office 启动慢，特别在已经打开一系列开发工具的前提下；其次需要将提交录入，排序之后还得想办法导出，又增加了工作量。Linux 底下倒是有一个 <code>sort</code> 命令，但是当时我在用 Windows。对于这种简单的需求，自己开发不仅工作量不大，遇到需求有变化时还很容易按需调整。</p>
<p>当时还没接触 Go，用的 C 开发。现在当然要用 Go 来练习。</p>
<blockquote>
<p>注：考虑到篇幅有限，下面只展示代码的关键部分，需要补足剩余的代码成分才能编译运行。</p>
<p>关于如何初始化一个项目，以及项目的基本结构，请参考第一期的内容。如果还有问题，欢迎在留言区或者加入交流群提问。</p>
</blockquote>
<h3 id="小目标"><a href="#小目标" class="headerlink" title="小目标"></a>小目标</h3><p>一开始不要设太高的期待，先让程序可以跑起来，这样才能基于运行的反馈，一步步改善程序。为此先把需求简化到最简：从标准输入获取提交号，排好序之后，输出到标准输出，用英文逗号隔开（格式要方便后续使用，P4 要求的格式就是用逗号隔开的提交号，你也可以根据自己的需要调整）。</p>
<p>假定把这个程序叫 <code>gosort</code> ，那么用起来大概是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; gosort 133297 167834 123467 145683</div><div class="line">123467,133297,145683,167834</div></pre></td></tr></table></figure>
<p>这个程度很简单，调用标准库就可以做到。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p><code>gosort 133297 167834 123467 145683</code> 这一串，对命令行环境来说，是（带参数的）命令，会根据开头的命令，传递给名为 <code>gosort</code> 的程序；而对 <code>gosort</code> 程序来说，这一串则是命令行参数。<strong>注意，命令（程序名）也是参数的一部分</strong>。有些程序实现了多种功能，对外链接到不同文件名，会根据传进来的程序名称不同，执行不同的动作。最典型的例子是 <code>busybox</code> ，它以单一可执行文件，提供了一个包含超过两百个命令的 unix 工具集合，被称为嵌入式 Linux 的瑞士军刀。</p>
<p>不像其它 C 家族语言，Go 的命令行参数不是作为 <code>main</code> 函数的参数传递的，而是通过 <code>os</code> 包的 <code>Args</code> 变量获取。<code>os</code> 包初始化时会获取参数并储存在 <code>Args</code> 中，它是一个字符串切片 <code>[]string</code>。前面介绍过查询文档的方法，想了解更多可以自行到 pkg.go.dev 查询；标准库源码则在 Go 的安装目录的 <code>src</code> 目录下，按包名储存，另外大多数 IDE 都支持源码的跟踪跳转（一般的操作，是对着 <code>os.Args</code> 按 <code>Ctrl</code> + 鼠标左键）。</p>
<p>先读取命令行参数然后直接输出看看效果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 包声明、import 语句已省略，请自行补充</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(os.Args)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先编译</span></div><div class="line">&gt; go build</div><div class="line"><span class="comment"># 后执行。程序名请替换成你自己的 module 名。Linux 下本地执行需要加 ./</span></div><div class="line">&gt; gosort 133297 167834 123467 145683</div><div class="line"><span class="comment"># 以下是输出，我们先不要纠结方括号</span></div><div class="line">[gosort 133297 167834 123467 145683]</div><div class="line"></div><div class="line"><span class="comment"># 当然我们也可以直接 go run</span></div><div class="line">&gt; go run main.go 133297 167834 123467 145683</div><div class="line"><span class="comment"># go run 本质上是在临时目录编译后执行，所以输出的程序名里带有临时目录信息</span></div><div class="line">[C:\Users\Jayce\AppData\Local\Temp\go-build065892054\b001\exe\main.exe 133297 167834 123467 145683]</div></pre></td></tr></table></figure>
<h3 id="改善"><a href="#改善" class="headerlink" title="改善"></a>改善</h3><p>这里我们需要改善几个问题：</p>
<ul>
<li>在这个程序里，程序名用不上，留在切片里还会参与后续的排序。</li>
<li><code>os.Args</code> 是第三方包的包级变量，尽量不要直接在上面排序。虽然命令行参数在这个程序里暂时没有别的用处，但直接修改公共变量仍是一个坏习惯。</li>
<li>方括号其实是输出切片内容时的格式，最终结果不需要方括号，要想办法去掉。</li>
<li>不仅要去掉切片的方括号，还要加上英文逗号。</li>
</ul>
<p><code>main</code> 函数里的代码改进如下（这里就不再执行，请自己执行，查看改动后的输出）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// n 是除了程序名以外的参数数量</span></div><div class="line">    <span class="comment">// len() 是内置函数，获取集合（这里是切片）的大小</span></div><div class="line">    n := <span class="built_in">len</span>(os.Args) - <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="comment">// 创建一个大小为 n 的切片</span></div><div class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</div><div class="line"></div><div class="line">    <span class="comment">// copy() 也是内置函数，把除程序名以外的参数拷贝到新切片</span></div><div class="line">    <span class="comment">// [1:] 是从下标 1 开始重新切片，跳过下标 0（即程序名）</span></div><div class="line">    <span class="comment">// 重新切片返回的新切片，跟原切片指向同一个底层数组，修改会互相影响，重新切片后还是要拷贝</span></div><div class="line">    <span class="built_in">copy</span>(nums, os.Args[<span class="number">1</span>:])</div><div class="line"></div><div class="line">    <span class="comment">// 把参数逐个输出，其中前面的参数后面跟逗号，最后一个参数后面跟换行</span></div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</div><div class="line">        fmt.Print(nums[i], <span class="string">","</span>)</div><div class="line">    &#125;</div><div class="line">    fmt.Println(nums[n<span class="number">-1</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>多快好省地实现排序算法，本身也是学问。但这次我们不研究这个，直接使用 <code>sort</code> 包。</p>
<p>自定义类型想要排序，需要实现 <code>sort.Interface</code> 接口的一系列方法；基本类型则预先实现了对应的函数。对于 <code>string</code> 类型的升序排序，<code>sort</code> 包给我们提供了 <code>sort.Strings()</code> 。</p>
<p>另外，前面最后的输出代码，实现起来还是比较麻烦，而且存在一个 bug。借助字符串工具包里的 <code>strings.Join()</code>  函数，可以先拼接成目标字符串，再一口气输出，既简单又绕开了 bug：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这次不再详细注释，有疑问请习惯查文档，或者参与讨论</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    n := <span class="built_in">len</span>(os.Args) - <span class="number">1</span></div><div class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">string</span>, n)</div><div class="line">    <span class="built_in">copy</span>(nums, os.Args[<span class="number">1</span>:])</div><div class="line">    sort.Strings(nums)</div><div class="line">    fmt.Println(strings.Join(nums, <span class="string">","</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时编译之后再执行程序，效果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; gosort 133297 167834 123467 145683</div><div class="line">123467,133297,145683,167834</div></pre></td></tr></table></figure>
<p>通过调用标准库，5 行代码实现了我们阶段性的小目标。</p>
<p>下一期我们还是讨论这个程序，面对需求的变化，如何改善程序去支持更复杂的功能。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>第一次改善后的程序里，输出的代码有什么 bug？</li>
<li><code>sort.Strings(nums)</code> 为什么没有返回值？字符串切片 <code>nums</code> 只是作为实参传给了排序函数，按理说切片本身发生了拷贝，为什么排序最后对 <code>nums</code> 生效了？</li>
</ol>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到别人的好作品，像画作、模型还是代码，我们第一反应可能是感叹结构复杂、技巧精湛，然后紧接着冒出一个想法：太难了，我做不到。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（5）：流程控制</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-5/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-5/</id>
    <published>2020-10-17T07:07:07.000Z</published>
    <updated>2020-10-17T16:02:06.585Z</updated>
    
    <content type="html"><![CDATA[<p>这一期介绍 程序的流程控制，下一期开始引入实战项目：一开始不能太贪心，会先尝试做一个 CLI 工具。</p>
<a id="more"></a>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>程序有三种基本的控制结构，分别是 <strong>顺序、分支（选择） 和 循环</strong> 。其中顺序结构不需要任何特殊的语句，程序语句按顺序执行即可。需要控制语句的是剩下两种结构。</p>
<p>注意，Go 语言的代码块不能省略大括号（<code>{}</code>，又叫花括号），哪怕只有一行。这是为了保持语言的可伸缩性，使得语言在不同规模和不同的上下文都不会出现歧义。与之相反，条件表达式处于关键字和左大括号 <code>{</code> 中间，而且总是只有一行，所以不需要加括号 <code>()</code> 。</p>
<p>无论是分支结构还是循环结构，都需要引入条件表达式，来控制执行路径。由于 Go 取消掉了一些操作的值，使得它们从表达式变成了语句，导致相应的操作无法直接加入条件表达式。估计是因为这样，Go 允许在条件表达式前增加一个简单语句，中间用分号 <code>;</code> 隔开，也就是这样 <code>简单语句;条件表达式</code>。注意，只能是一句，如果是更复杂的效果，还是应该在进入控制结构之前，通过多个语句先完成操作。</p>
<p>其中简单语句可以是：</p>
<ul>
<li>空白。</li>
<li>表达式。</li>
<li>通道（<code>chan</code>）的发送语句。</li>
<li>自增自减。</li>
<li>赋值。</li>
<li>变量的短声明。</li>
</ul>
<p>变量短声明很可能是用得最多的语句，因为在这里声明变量可以限制变量的作用域，仅限于控制结构内部，但需要注意变量遮盖（shadow）的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">a := <span class="number">1</span></div><div class="line"><span class="keyword">if</span> a &lt; <span class="number">10</span> &#123;</div><div class="line">    a = <span class="number">10</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 外层 a 被修改，是 10</span></div><div class="line">fmt.Println(a)</div><div class="line"></div><div class="line">b := <span class="number">1</span></div><div class="line"><span class="keyword">if</span> b := <span class="number">2</span>; b &lt; <span class="number">10</span> &#123; <span class="comment">// 声明了一个新的变量 b，作用域为整个 if-else 控制结构</span></div><div class="line">    b = <span class="number">10</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 如果条件满足执行到这（例如 b:= 11），这里访问的也是内层 b</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 外层 b 仍然是 1</span></div><div class="line">fmt.Println(b)</div></pre></td></tr></table></figure>
<h3 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1. 分支结构"></a>1. 分支结构</h3><p>分支结构会指定一个到多个条件，通过测试哪些条件得到满足来决定执行路径。Go 里面可以实现分支结构的语句有：</p>
<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>Go 的 if 语句跟其它语言差别不大，直接上例子。</p>
<p>细节差别有：表达式不用括号，代码块不能省略大括号，<code>else if</code> 不像一些语言可以写成 <code>elif</code> （Go 很省关键字）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if 的条件表达式只能为 布尔 bool 类型</span></div><div class="line"></div><div class="line"><span class="comment">// 1. 只有 if 子句</span></div><div class="line"><span class="keyword">if</span> 布尔表达式 &#123; <span class="comment">// 不像 C 语言，布尔表达式不用加括号</span></div><div class="line">    <span class="comment">// 条件为真才执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 加上 else 子句</span></div><div class="line"><span class="keyword">if</span> 布尔表达式 &#123;</div><div class="line">    <span class="comment">// 表达式为真执行这里</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 否则执行这里</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. else 后面可以嵌套更多 if 语句</span></div><div class="line"><span class="keyword">if</span> 条件<span class="number">1</span> &#123;</div><div class="line">    <span class="comment">// 条件1 为真</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 条件<span class="number">2</span> &#123;</div><div class="line">    <span class="comment">// 条件2 为真</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 都不满足</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><p>只有一两个判断条件时， if 语句是很好的选择；但当分支多了起来，大量的 <code>else if</code> 会导致代码冗长又难以维护。这时 switch 语句是更好的选择。</p>
<p>可能是为了省关键字，switch 实际上有两个用法，分别是表达式 switch，和类型 switch。无论哪一种，switch 语句都会从上到下逐个测试 case，执行第一个满足的分支。</p>
<h5 id="表达式-switch："><a href="#表达式-switch：" class="headerlink" title="表达式 switch："></a>表达式 switch：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 表达式 switch 也有两种用法</span></div><div class="line"></div><div class="line"><span class="comment">// 1. 经典 switch-case 用法，表达式可以为任意类型，不限定布尔型</span></div><div class="line"><span class="comment">// case 后面的值类型必须跟表达式的类型是可比较的</span></div><div class="line"><span class="keyword">switch</span> 表达式 &#123;</div><div class="line"><span class="keyword">case</span> 值<span class="number">1</span>:</div><div class="line">    <span class="comment">// 表达式 == 值1 时执行</span></div><div class="line">    <span class="comment">// 可以是多行语句</span></div><div class="line"><span class="keyword">case</span> 值<span class="number">2</span>:</div><div class="line">    <span class="comment">// 表达式 == 值2 时执行</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="comment">// default 子句可选，前面所有 case 都不满足时执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 接近某些语言的 switch-cond 的用法</span></div><div class="line"><span class="comment">// 大量 if-else 的分支结构可以改写成这种形式</span></div><div class="line"><span class="keyword">switch</span> &#123; <span class="comment">// 没有表达式，但如果有需要，仍然可以保留一个简单语句，后面加分号表明省略了表达式</span></div><div class="line"><span class="keyword">case</span> 布尔表达式<span class="number">1</span>: <span class="comment">// 这里的表达式只能为 布尔型</span></div><div class="line">    <span class="comment">// 表达式1 为 true 时执行</span></div><div class="line"><span class="keyword">case</span> 布尔表达式<span class="number">2</span>:</div><div class="line">    <span class="comment">// 表达式2 为 true 时执行</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="comment">// 同样是所有 case 都不满足时执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="类型-switch："><a href="#类型-switch：" class="headerlink" title="类型 switch："></a>类型 switch：</h5><p>类型 switch 涉及类型断言。</p>
<p>Go 的接口变量允许储存任何满足接口的类型的值，举例说类型 <code>T</code> 满足接口 <code>I</code> ，那么 <code>T</code> 的值 <code>t</code> 就可以赋值给 <code>I</code> 的变量 <code>i</code> ：<code>var i I = t</code> 。</p>
<p>而将接口变量 <code>i</code> 转换为具体的类型 <code>T</code> 时，除了显式的类型转换 <code>t = T(i)</code> ，还可以用 <strong>类型断言</strong> <code>t = i.(T)</code> 。两者之间一个明显的差别是，类型转换需要开发者自行确保可以转换，否则就会产生一个运行时 panic；而类型断言有安全形式 <code>t, ok = i.(T)</code> ，如果转换失败，<code>ok</code> 的值为 <code>false</code> ，并不会产生 panic。不过这里不是讨论类型断言，不详细展开。</p>
<p>类型 switch 借用了类型断言的形式，但是括号里的不是某个具体的类型，而是关键字 <code>type</code> ，也就是 <code>i.(type)</code> ；然后 case 后面接的，就不再是值，而是具体的类型。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">switch i.(type) &#123;</div><div class="line">case 类型1:</div><div class="line">    // 如果 i 的值是 类型1 时执行</div><div class="line">case 类型2:</div><div class="line">    // i 为类型2 时执行</div><div class="line">case nil:</div><div class="line">    // 除了类型，还能判断 i 是否为 nil</div><div class="line">default:</div><div class="line">    // 上述 case 均不满足时执行</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类型 switch 还可以包含一个短声明，提供一个转换后的变量供 switch 结构体内部调用</div><div class="line">switch x := i.(type) &#123;</div><div class="line">case nil:</div><div class="line">    // i 为 nil，没有动态类型信息，x 的类型仍然是 i 的接口类型</div><div class="line">	fmt.Println("i 为 nil")</div><div class="line">case int:</div><div class="line">    // x 的类型是 int</div><div class="line">	fmt.Println(x)</div><div class="line">case func(int) float64:</div><div class="line">    // x 的类型是签名为 func(int) float64 的函数</div><div class="line">    fmt.Println(x(1))</div><div class="line">case bool, string:</div><div class="line">    // 条件类型不止一个，无法确定命中的类型，x 的类型没有做转换，仍是 i 的接口类型</div><div class="line">    fmt.Println(x)</div><div class="line">default:</div><div class="line">    // i 虽然不为 nil，但是没有命中任何类型，x 的类型仍然是 i 的接口类型</div><div class="line">	fmt.Println("意料以外的类型")</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="与-C-风格-switch-的差别"><a href="#与-C-风格-switch-的差别" class="headerlink" title="与 C 风格 switch 的差别"></a>与 C 风格 switch 的差别</h5><p>所以总结下来，switch 语句实际上包含了</p>
<ul>
<li>C 风格的 switch-case 经典用法。</li>
<li>scheme 风格的 switch-cond 用法（但是子句还是用 <code>case</code> 关键字）。</li>
<li>类型断言用法。</li>
</ul>
<p>不熟悉的话，还挺容易混淆的。</p>
<p>除此之外，虽然关键字和结构整体都是沿袭 C 风格的 switch 语句，细节上还是有几个比较重要的差异：</p>
<ul>
<li><p>默认 break：</p>
<p>  C 风格的 switch，case 之间的默认行为是 fallthrough。换言之，命中的 case 只是一个入口，如果没有遇到 break 语句，接下去的每个 case 都会执行，直到结束。</p>
<p>  但实际上，需要 fallthrough 的情况非常少，大多数情况下，我们都只是希望只执行命中的 case，这就导致 case 和 break 总是成对出现，非常啰嗦。</p>
<p>  Go 将 switch 的默认行为改为 break，需要 fallthrough 时，再在 case 的结尾显示写一个 <code>fallthrough</code>。注意类型 switch 不允许 fallthrough。</p>
</li>
<li><p>case 不限定为常量值：</p>
<p>  C 风格的 case 后面，只能接一个 常量或字面量的值。Go 无此限制。在经典用法中，值可以是常量，也可以是变量或者表达式。</p>
</li>
<li><p>case 后面允许接多个条件：</p>
<p>  因为 C 风格 switch 默认 fallthrough，当多个条件共享相同的代码时，只要将多个 case 顺序写在一起，代码放在最后一个 case，就可以共享代码逻辑。</p>
</li>
</ul>
<p>下面看一下例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C 代码</span></div><div class="line"><span class="keyword">switch</span> (x) &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:</div><div class="line"><span class="keyword">case</span> <span class="number">2</span>:</div><div class="line"><span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">    <span class="comment">// 这里的代码被 3 个case 共享</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Go 的默认行为变成了 break，不能这样写了；但是多个条件共享代码反而更容易了，因为 case 后面可以接多个条件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Go 代码</span></div><div class="line"></div><div class="line"><span class="comment">// 经典 C 风格</span></div><div class="line"><span class="keyword">switch</span> x &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>:</div><div class="line">    <span class="comment">// x 等于任意一个数都执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// cond 风格</span></div><div class="line"><span class="keyword">switch</span> &#123;</div><div class="line"><span class="keyword">case</span> x &lt; <span class="number">0</span>, x == <span class="number">0</span>, x &gt; <span class="number">0</span>:</div><div class="line">    <span class="comment">// 任意一个条件为 true 都执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span> x := i.(<span class="keyword">type</span>) &#123;</div><div class="line"><span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">int</span>, <span class="keyword">string</span>:</div><div class="line">    <span class="comment">// i 的类型是其中任意一个类型都执行</span></div><div class="line">    <span class="comment">// 但是类型不止一个时，x 不会转换类型</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中的任意一种写法，都可以；但是三种写法不能混用。</p>
<h4 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h4><p>select 语句可以说是通信版的 switch，也可以说是借鉴了 C 语言 select 函数的含义（虽然读写的对象不同），并且升格成了关键字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> &#123;</div><div class="line"><span class="keyword">case</span> a = &lt;- ch1: <span class="comment">// 从通道中接收（读）</span></div><div class="line">    <span class="comment">// 读到消息之后的操作</span></div><div class="line"><span class="keyword">case</span> ch2 &lt;- b: <span class="comment">// 发送消息（写）</span></div><div class="line">    <span class="comment">// 发送成功之后的操作</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="comment">// 以上 case 都阻塞时，执行这里</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>select 语句里的每个 case 后面都接一个通信操作，要么接收要么发送。</p>
<p>执行时，会在可以执行的 case 中 <strong>随机</strong> 执行一个（注意是随机，switch 则是从上到下测试第一个满足的），其它 case 忽略。如果没有可以执行的 case，则会执行 default 子句；没有可执行的 case 且没有 default 子句，则会阻塞直到有可以执行的 case 为止。所以如果不想阻塞，就一定要增加 default 子句。</p>
<p>select 语句常常嵌套在循环结构里，实现对通道轮询的效果。详细用法在介绍并发和通道时再展开。</p>
<h3 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2. 循环结构"></a>2. 循环结构</h3><p>在 Go 里面实现循环结构，只有一个 for 语句。看起来这又是省关键字的结果。Go 的不同写法，可以实现 C 风格里的 for、while 和 do-while ，甚至还有 Java 的 for-each 或 Python 的 for-range 效果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 经典写法</span></div><div class="line"><span class="comment">// 初始化语句和步进语句都是简单语句，循环条件必须是布尔表达式</span></div><div class="line"><span class="comment">// 3 个部分可以任意省略，但是分号要保留（这才看得出来没省略的是哪部分）</span></div><div class="line"><span class="comment">// 循环条件如果省略，等同于 true，变成死循环，需要内部有 break 语句 或 return 语句 结束循环</span></div><div class="line"><span class="keyword">for</span> 初始化语句; 循环条件（布尔表达式）; 步进语句 &#123;</div><div class="line">    <span class="comment">// 循环体</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. while 写法</span></div><div class="line"><span class="comment">// 如果只保留循环条件，用法等同于 while</span></div><div class="line"><span class="comment">// 同样的，如果省略循环条件，就会变成死循环</span></div><div class="line"><span class="keyword">for</span> 循环条件 &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3. do-while 写法</span></div><div class="line"><span class="comment">// do&#123;...&#125;while(循环条件) 和 while 相比，是把判断后置，无论如何至少执行一次</span></div><div class="line"><span class="comment">// 可以通过死循环再 break/return 跳出来模拟</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    <span class="comment">// 循环体</span></div><div class="line">    </div><div class="line">    <span class="comment">// 不满足继续循环的条件时退出</span></div><div class="line">    <span class="keyword">if</span> !循环条件 &#123;</div><div class="line">        <span class="keyword">break</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 4. for-range 写法</span></div><div class="line"><span class="keyword">for</span> i, x = <span class="keyword">range</span> 表达式 &#123;</div><div class="line">    <span class="comment">// 循环体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>range 表达式的右边，可以是 数组、数组的指针、切片（slice）、字符串（<code>string</code>）、映射（<code>map</code>）或者可接收（可读）的通道（<code>chan</code>）。换句话说，它们的成员元素可以枚举。</p>
<p>range 表达式本质上是一个语法糖，实际上底层实现还是展开成普通的 for 循环，帮你枚举对象里的成员元素。对于通道以外的类型而言，展开后的三个部分可以近似看作：取第一个元素（初始化）；没遍历到最后一个元素（循环条件）；取下一个元素（步进）。而对于通道而言，循环条件变成了通道还没关闭。</p>
<p>详细用法，具体在每个类型里介绍。这里只提醒两点：</p>
<ul>
<li><p>range 表达式获得的变量都是拷贝，对变量的修改不会影响集合中原来的值。（这个的原理会专门找一期介绍值和引用）如果想修改集合里的值，还是要老老实实地遍历下标（或者 map 的 key），然后直接修改索引值 <code>s[i] = newVal</code> 。</p>
</li>
<li><p>多数的 range 表达式可以返回不止一个值。你既可两个值都赋值给变量使用，也可以只要其中一个；丢弃第二个值可以直接忽略 <code>for i := range s {...}</code> ，而丢弃第一个值则必须显式赋值给空白标识符 <code>for _, v := range s {...}</code> 。</p>
<p>  | 类型                       | 类型定义            | 第一个值             | 第二个值                           |<br>  | ————————– | ——————- | ——————– | ———————————- |<br>  | 数组、数组指针 或 切片 <code>a</code> | <code>[n]E, *[n]E, []E</code>  | 下标 <code>i</code> ，类型<code>int</code> | 下标对应的元素 <code>a[i]</code>，类型 <code>E</code>    |<br>  | 字符串 <code>s</code>                 | <code>string</code>            | 下标 <code>i</code> ，类型<code>int</code> | 下标对应的字节 <code>s[i]</code>，类型 <code>byte</code> |<br>  | 映射 <code>m</code>                   | <code>map[K]V</code>           | 键值<code>k</code>，类型<code>K</code>     | 键值对应的元素 <code>m[k]</code>，类型<code>V</code>     |<br>  | 通道 <code>c</code>                   | <code>chan E, &lt;- chan E</code> | 元素 <code>e</code>，类型 <code>E</code>   | -                                  |</p>
</li>
</ul>
<p>无论是哪一种写法，都可以看作是经典写法的变体（省略了某些部分），所以执行流程都是相同的：</p>
<ol>
<li>执行初始化（init）语句；</li>
<li>判断循环条件（condition），满足则进入循环，否则退出（循环条件省略等同于 true）；</li>
<li>执行循环体；</li>
<li>执行步进（post）语句，并回到 2。</li>
</ol>
<h3 id="3-控制语句"><a href="#3-控制语句" class="headerlink" title="3. 控制语句"></a>3. 控制语句</h3><p>控制语句主要针对循环结构，除了按照 for 语句的规则执行，还可以加入一些控制语句，改变执行的方向。</p>
<p>分别有 <code>break</code> 、<code>continue</code> 和 <code>goto</code> 三种语句。这三种语句的用法跟 C 家族语言基本一致：</p>
<ul>
<li><p><code>break</code> 跳出当前的循环，并继续执行循环之后的语句。<code>break</code> 也可以用于跳出 switch 代码块，但由于 Go 的 switch 默认会在 case 结尾退出，所以 switch 里 <code>break</code> 用得比较少。</p>
<p>  注意有多层循环嵌套时，<code>break</code> 只会跳出当前所在的内层循环。</p>
<p>  如果想跳出在外层循环，需要在跳出的循环前面加标签（label），<code>break</code> 后面加上标签作为目标，就会跳出对应的循环。</p>
</li>
<li><p><code>continue</code> 中止当前循环的执行，改为执行步进语句，（在同一个循环结构内）开始执行下一次循环。</p>
<p>  跟 <code>break</code> 类似，有多层循环嵌套时，<code>continue</code> 只会影响当前所在的内层循环。</p>
<p>  如果想开始外层的下一次循环，同样可以用循环前的标签作为 <code>continue</code> 的目标。</p>
</li>
<li><p><code>goto</code> 必须配合标签 （label） 使用。<code>goto</code> 语句会无条件跳转到（同一个函数内部） 标签 声明的位置继续执行。<code>goto</code> 的使用不限于某种控制结构。实际上，靠 if-else + <code>goto</code> 可以实现任意的控制结构。</p>
<p>  <code>goto</code> 用好了可以用很少的代码实现复杂的逻辑控制；但是用不好的话，会导致执行流程混乱，造成理解和调试困难。结构化程序设计一般不鼓励使用 <code>goto</code> ，多数后来的高级语言也都不提供 <code>goto</code> 语句。</p>
</li>
</ul>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>标签（label）本质上就是一个 标识符，只是它指向的不是一个常量或变量，而是一个程序的位置（指向声明位置下一行代码）；有效作用域总是为同一个函数体，不受嵌套的代码块限制（标签是 Go 里面唯一一种永远都是函数级作用域的标识符）。标签不占用常量和变量的命名，允许标签跟其它标识符重名，但强烈建议不要重名。</p>
<p>标签声明时单独一行，后面接一个冒号 <code>LABEL:</code>；使用时作为 <code>break</code> 、<code>continue</code> 和 <code>goto</code> 的目标。为了区别于其它标识符，标签一般全大写。</p>
<p> <code>goto</code> 的目标标签可以声明在函数内的任意地方，跳转的限制只有两条：</p>
<ul>
<li>不能跨函数跳转，包括函数内嵌套的函数和闭包。</li>
<li>不能（向后）跳过变量声明（可以跳过常量声明）。因为跳过的变量后续引用到会报错。修改的方法是把变量声明提前到跳转区间以外。</li>
</ul>
<p>相对应地，作为 <code>break</code> 和 <code>continue</code> 目标的标签多一个限制：标签必须声明在外层某个循环前面（相当于指向该循环），用来表明要跳出或者继续的是哪个循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">LABEL1:</div><div class="line">a := <span class="number">1</span></div><div class="line">LOOP_I:</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; I; i++ &#123;</div><div class="line">LOOP_J:</div><div class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; J; j++ &#123;</div><div class="line">        <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; K; k++ &#123;</div><div class="line">	        <span class="comment">// ...</span></div><div class="line">    	    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="comment">// LOOP_J 也是合法的</span></div><div class="line">                <span class="comment">// 但使用 LABEL1 和 LABEL2 以及 LOOP2 都无法编译通过</span></div><div class="line">        	    <span class="keyword">break</span> LOOP_I</div><div class="line">	        &#125;</div><div class="line">        </div><div class="line">    	    <span class="keyword">if</span> nextj &#123;</div><div class="line">                <span class="comment">// 跟 break 类似，选择 LOOP_I 和 LOOP_J 以外的标签都无法编译通过</span></div><div class="line">        	    <span class="keyword">continue</span> LOOP_J</div><div class="line">	        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">LABEL2:</div><div class="line"><span class="comment">// ...</span></div><div class="line">LOOP2:</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>写教程可以深入细节，一直到内部的原理。也可以不多解释直接模仿着跑起来，多见几个例子再回头解释。</p>
<p>前者似乎所有人都可以看，新手打基础，老手查漏补缺。但新手可能还没建立起直观的认识，一上来就太多细节，也许就懵了。这个系列既然起了『实战』之名，按理说应该接近后者。直接来几个实例，先跑起来，再介绍里面分别是什么。有 C 家族语言经验的朋友，甚至都不需要解释，从例子里大概就能体会差异，可以用来干些简单的活。</p>
<p>写到第四期，似乎越来越理论和细节了。这并不是我的本意。</p>
<p>这样固然是满足了一部分我自己深入了解 Go 的需要；另一方面，也是希望可以迁就一部分缺少 C 家族语言经验的读者。（是否有没有编程经验的读者呢？因为缺乏来自你们的反馈，读者的面目在我这其实是模糊的。）这就需要在第一个『实战项目』之前先铺垫一些『基础知识』。虽说是基础，凡是涉及的主题，我都希望写透一些，不太愿意把一个主题拆得零碎，先笼统过一遍，下次展开一点，后面再来深入。</p>
<p>但这样下去，与其看我啰嗦，还不如直接看 Go 官方的语言规范来得简洁清晰。虽然我不断强调大家可以当参考资料跳着看；但是从详尽的资料中筛选关键信息不正是我该做的事吗。幸好写到这一期，开发一个最基本的程序所需要的知识勉强是够了，所以下一期赶紧开始进入一个实战程序吧。</p>
<p>开发中肯定还会遇到没介绍过的内容，等到毫无遗漏介绍完再开始是不现实的，这时提问答疑和群内互助就足以解决问题了。开发中遇到的问题，后面正好着重介绍。</p>
<p>这里给出 Go 语言官方的规范文档，大家也可以自行查阅。</p>
<p>官网：<a href="https://golang.org/ref/spec" target="_blank" rel="external">https://golang.org/ref/spec</a></p>
<p>官方提供给国内访问的镜像：<a href="https://golang.google.cn/ref/spec" target="_blank" rel="external">https://golang.google.cn/ref/spec</a></p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一期介绍 程序的流程控制，下一期开始引入实战项目：一开始不能太贪心，会先尝试做一个 CLI 工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（4）：运算符</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-4/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-4/</id>
    <published>2020-10-08T09:32:18.000Z</published>
    <updated>2020-10-17T07:49:35.465Z</updated>
    
    <content type="html"><![CDATA[<p>接下来的两期分别介绍 运算符 和 控制结构，然后准备引入实战项目。</p>
<a id="more"></a>
<h2 id="运算符（operator）"><a href="#运算符（operator）" class="headerlink" title="运算符（operator）"></a>运算符（operator）</h2><p>运算符将操作数（operands）连接成表达式（expression）。然后表达式根据（运算符的）规则求值。</p>
<blockquote>
<p>注意，Go 是区分 <strong>表达式</strong>（expression，整体可求值）和 <strong>语句</strong>（statement，不可求值）的语言。</p>
<p>既然运算符连接操作数会得到表达式，然后表达式一定可以求值（注意操作数可能是一个值，也可能是另一个表达式，或者返回值，总之可以求值）；那么反过来说，不能求值的就不是表达式，对应的符号也不是（Go 定义的）运算符。</p>
<p>在这里，作为对比会提及一些容易被当成表达式的语句（官方文档称之为 operators form statements，运算符形式的语句），但不展开讲语句。</p>
</blockquote>
<p>Go 是强类型语言，意味着双目运算符的两个操作数类型要一致（移位运算除外）。对于不一致的情况，要么是 <code>untyped</code> 自动转换，要么是显式转换，相应的规则请参考前面两期的内容。</p>
<h3 id="1-算术（arithmetic）运算符"><a href="#1-算术（arithmetic）运算符" class="headerlink" title="1. 算术（arithmetic）运算符"></a>1. 算术（arithmetic）运算符</h3><p>算术运算符对数字类型（numeric）的值进行运算，并得到与第一个操作数相同类型的值。</p>
<p>在 Go 里，四则运算 和 位运算 都被认为是算术运算。</p>
<p>算术运算符都是 <strong>双目运算符</strong>（意味着需要两个操作数）；三个特殊情况是用作正负号的 <code>+</code> 、<code>-</code> 和用作按位取反的 <code>^</code> ，这时它们是单目运算符。</p>
<h4 id="1-1-四则运算"><a href="#1-1-四则运算" class="headerlink" title="1.1 四则运算"></a>1.1 四则运算</h4><p>四则运算包括我们熟知的 <code>+</code>, <code>-</code>, <code>*</code>,<code>/</code> （加减乘除），以及除法衍生的运算 <code>%</code> （求余）。</p>
<p><code>+</code>, <code>-</code>, <code>*</code>,<code>/</code> 的操作数可以是 <strong>任意数字类型</strong>（包括整型数、浮点数 和 复数）；<code>%</code> 则只能是整型参与运算。</p>
<p>加减乘除的含义和规则想必不用介绍，只提一下几个特殊情况：</p>
<ul>
<li><p>我们都知道，除数不能为 0。如果整数除法里除数为 常量 0，直接编译错误；如果是 变量 0，则会引起一个运行时 panic。如果是浮点数除法，IEEE-754 没有规定，结果视具体实现而定，目前 Go 的实现是得到一个特殊浮点数『无穷』（视乎被除数的符号，得到 <code>+Inf</code> 或 <code>-Inf</code>）。</p>
</li>
<li><p>因为结果的类型与操作数一致，整数除法的结果也是整数，那就可能出现『除不尽』，这时尾数向零的方向截断（truncate）。例如 <code>7 / 4</code> 结果为 <code>1</code> （尾数 <code>0.75</code> 被截断，尽管 <code>1.75</code> 更接近 <code>2</code>），<code>-7 / 3</code> 结果为 <code>-2</code> （商 <code>-2</code> 余 <code>-1</code> 比 商 <code>-3</code> 余 <code>2</code> ，商更靠近 0）。</p>
</li>
<li><p>对于求余，假设 <code>x / y</code> ，商为 <code>q</code> 余数为 <code>r</code> ， 它们之间的关系满足 <code>x = q*y + r</code> 且 <code>|r| &lt; |y|</code> （余数的绝对值一定小于除数的绝对值，注意是除数不是商）。我们根据上一条规则求得整数除法的商之后，就可以根据这条规则得到余数了：</p>
<p>  | x    | y    | x / y | x % y |<br>  | —- | —- | —– | —– |<br>  | 5    | 3    | 1     | 2     |<br>  | -5   | 3    | -1    | -2    |<br>  | 5    | -3   | -1    | 2     |<br>  | -5   | -3   | 1     | -2    |</p>
</li>
</ul>
<ul>
<li><p><code>+</code> 和 <code>-</code> 作为单目运算符时，放在值的前面表示指定数值的符号，也就是作为正负号使用，相当于省略掉作为双目运算符时前面的 <code>0</code> ：<code>-5</code> 等价于 <code>0 - 5</code>。 （实践中 <code>+5</code> 跟 <code>5</code> 没有任何区别，所以很少会用到单目的 <code>+</code>）</p>
</li>
<li><p><code>+</code> 加号和 <code>+=</code> 也可以应用在字符串上，严格来说这不是加法，而是连接（concat）；当然你也可以理解为特殊的『字符串加法』。</p>
</li>
</ul>
<p>除此以外，还要留意类型的范围和精度，看运算结果是否有超出类型的表示范围。溢出的处理可以参考数字类型的类型转换部分。</p>
<h4 id="1-2-位运算"><a href="#1-2-位运算" class="headerlink" title="1.2 位运算"></a>1.2 位运算</h4><p>位运算只能应用于 <strong>整型数</strong> 。进一步细分，位运算又可以分为 按位逻辑运算 和 移位运算。</p>
<p>由于位运算是直接对二进制位进行运算，所以我们要了解整型数的二进制表示：</p>
<ul>
<li><p>正数 还有 零 比较好办，只要知道如何表示二进制数，做一个进制转换即可，例如 <code>21</code> 二进制位为 <code>00010101</code> （为了方便举例，用最短的 <code>int8</code>，下同）。</p>
</li>
<li><p>负数要麻烦一些，并不是直接在正数的基础上把符号位置为 1，因为这样正负数的加法很难实现。计算机使用二进制补码（简称补码）来表示负数。</p>
<p>  这里不展开补码的原理，只要记住一个口诀『取反加一』，就可以从正数得到对应的负数的补码。例如 <code>21</code> 的二进制取反是 <code>11101010</code> ，加一得到 <code>11101011</code> ，就是 <code>-21</code> 的补码；<code>-2</code> 的补码是 <code>11111110</code> （注意加一时产生了进位）。这两个数的补码，直接跟对应的正数相加，结果均为 0 （丢弃最高位的溢出）；跟别的数相加也能直接得到正确的结果。</p>
</li>
</ul>
<h5 id="按位（bitwise）逻辑运算"><a href="#按位（bitwise）逻辑运算" class="headerlink" title="按位（bitwise）逻辑运算"></a>按位（bitwise）逻辑运算</h5><p>按位逻辑运算的基本规则跟逻辑运算一致。只是逻辑运算对布尔值进行运算，而按位运算对二进制位逐位进行运算。</p>
<table>
<thead>
<tr>
<th>op （运算符）</th>
<th>11110000 op 01010101</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>01010000</td>
<td>AND 按位与，两边均为 1 时结果为 1，否则为 0。</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>11110101</td>
<td>OR 按位或，两边至少一个为 1 时结果为 1，均为 0 时才为 0。</td>
</tr>
<tr>
<td>^（双目）</td>
<td>10100101</td>
<td>XOR 异或，不同的位结果为 1 ，相同的位为 0。</td>
</tr>
<tr>
<td>^（单目）</td>
<td>-</td>
<td>NOT 非，或者叫按位取反，<code>^01010101</code> 结果为 <code>10101010</code> ，相当于省略双目运算的左操作数 <code>11111111</code> （对应位宽全 1，相当于无符号数的最大值，和有符号数的 <code>-1</code>）。</td>
</tr>
<tr>
<td>&amp;^</td>
<td>10100000</td>
<td>bit clear（AND NOT） 位清除，注意不是与非（与非是 NAND）。只有左操作数为 1 且右操作数为 0 时结果为 1，否则均为 0。可以看作将右操作数中的 1 从左操作数中清除掉。</td>
</tr>
</tbody>
</table>
<p>其它更复杂的逻辑运算，可以通过组合基本的逻辑运算构成。例如，<strong>同或</strong> （XNOR）可以在 <strong>异或</strong> 的基础上 <strong>取反</strong>  <code>^(a ^ b)</code>；<strong>与非</strong> （NAND）可以在 <strong>与</strong> 的基础上 <strong>取反</strong>  <code>^(a &amp; b)</code> 。</p>
<p>相信你会发现，位清除（bit clear，AND NOT）其实也是 <strong>与</strong> 和 <strong>取反</strong> 的组合，<code>a &amp;^ b</code> 等价于 <code>a &amp; (^b)</code> ，那为什么需要组合成一个独立的运算符呢？看下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = ^<span class="number">1</span> <span class="comment">// untyped int, -2（补码）</span></div><div class="line"><span class="keyword">const</span> b <span class="keyword">uint64</span> = ^<span class="number">1</span> <span class="comment">// ！如果不想得到负数，指定类型为无符号数，得到溢出错误</span></div><div class="line"><span class="keyword">var</span> c <span class="keyword">uint64</span> = ^<span class="number">1</span> <span class="comment">// ！同样的错误，问题出在常量（字面量）在转换类型时，不能改变值</span></div><div class="line"></div><div class="line"><span class="comment">// 正确的做法是先指定了类型再取反</span></div><div class="line"><span class="keyword">const</span> d <span class="keyword">uint64</span> = <span class="number">1</span> <span class="comment">// 关键是先指定类型，避免转换</span></div><div class="line"><span class="keyword">const</span> e = ^d <span class="comment">// 正常</span></div><div class="line"><span class="keyword">var</span> f = ^<span class="keyword">uint64</span>(<span class="number">1</span>) <span class="comment">// 也可以</span></div><div class="line"></div><div class="line"><span class="comment">// 同样道理，在清除指定位时</span></div><div class="line"><span class="keyword">var</span> x <span class="keyword">uint64</span> = <span class="number">2</span></div><div class="line"><span class="keyword">var</span> y = x &amp; (^<span class="number">1</span>) <span class="comment">// ！`^1` 试图转换为 uint64 参与运算时报错。</span></div><div class="line"><span class="comment">// 只能先指定为无符号整型吗？</span></div><div class="line"><span class="keyword">var</span> z = x &amp;^ <span class="number">1</span> <span class="comment">// 正常</span></div></pre></td></tr></table></figure>
<p>可以看到，独立的 <code>&amp;^</code> 运算符，跟两个运算符组合使用相比，规避掉了溢出错误，省略了将字面量先指定类型，还是有差别的。需要注意的是，并没有 <code>|^</code> 运算符。</p>
<h5 id="移位（shift）运算"><a href="#移位（shift）运算" class="headerlink" title="移位（shift）运算"></a>移位（shift）运算</h5><p>分为左移位 <code>&lt;&lt;</code> 和右移位 <code>&gt;&gt;</code> ，就是把左操作数的二进制位（连符号位一起），向对应方向，移动右操作数指定的位数。</p>
<p>移位时，超出范围的位丢弃，空缺的位左移补零、右移补符号位（无符号数还是补零）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int8:</div><div class="line"></div><div class="line">   7(00000111) &gt;&gt; 2</div><div class="line">   1(00000001)     // 右移超出范围的两个 1 丢弃，左边补 0（符号位为 0）</div><div class="line"></div><div class="line">   7(00000111) &lt;&lt; 5</div><div class="line"> -32(11100000)     // （低位数起）第三位的 1 一直左移，直到符号位，变成了负数，右边补 0</div><div class="line"></div><div class="line">-128(10000000) &gt;&gt; 5</div><div class="line">  -4(11111100)     // 右移过程中左边补 1 （符号位为 1）</div></pre></td></tr></table></figure>
<p>移位运算是少有的允许左右操作数不同类型的运算。两个操作数都可以是任意整型，但右操作数的值不能为负数（只能为 0 或 正数）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">2</span></div><div class="line">y = <span class="number">1</span> &lt;&lt; a <span class="comment">// a 虽然是有符号数，但值为正数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> b = <span class="number">-2</span></div><div class="line">y = <span class="number">1</span> &lt;&lt; b <span class="comment">// ！编译错误：negative shift count</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="number">-3</span></div><div class="line">y = <span class="number">1</span> &gt;&gt; c <span class="comment">// ！运行时错误：negative shift amount</span></div></pre></td></tr></table></figure>
<p>不过移位运算也可能涉及类型转换：如果移位表达式不是一个常量表达式（换言之，不可以编译期求值），而且左操作数是无类型常量（untyped const），左操作数会隐式转换为 <strong>移位表达式替换为左操作数时它要转换的类型</strong> 。</p>
<p>这句话非常拗口，需要举个例子。 <code>var y int8 = 1 &lt;&lt; x</code> 这个例子里面，如果 <code>x</code> 是常量，那么 <code>1 &lt;&lt; x</code> 就会在编译时求值，<code>1</code> 是 <code>untyped const</code>，结果的类型跟它一样，然后结果会试图转换为 <code>int8</code> 类型；如果 <code>x</code> 不是常量，<code>1</code> 需要先转换为 <code>int8</code> 再参与移位运算。之所以是 <code>int8</code> ，是因为把表达式替换为左操作数的话（ <code>var y int8 = 1</code> ），左操作数需要转换为 <code>int8</code> 。</p>
<p>换言之，运行时的移位操作，如果不知道左操作数应该转换为什么类型参与运算（这关系到溢出判断），可以先把移位拿掉，判断完类型再加回来。</p>
<h4 id="1-3-容易当成算术运算的语句"><a href="#1-3-容易当成算术运算的语句" class="headerlink" title="1.3 容易当成算术运算的语句"></a>1.3 容易当成算术运算的语句</h4><ul>
<li><p>赋值语句</p>
<p>  Go 里面，赋值语句是没有值的。所以 <code>a + b</code> 是一个加法表达式，可以求值，可以放在赋值符号 <code>=</code> 或者 <code>:=</code> 的右边；但 <code>c = a + b</code> 整体却是一个赋值语句，不能求值。</p>
<p>  与其它 C 家族语言类似，Go 提供了算术运算后赋值的语法糖 <code>a op= b</code> ，它等价于 <code>a = a op b</code> ，其中 <code>op</code> 可以为任意一个双目算术运算符（<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&amp;^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>）。有些教程把这种组合称作 『赋值运算符』，<strong>这种说法不严谨</strong>，因为这些语句整体不能求值，并不是表达式。不能把它们加入别的运算（如 <code>c + (a += b)</code>），也不能作为右值赋值（如 <code>c = (a -= b)</code>）。带 <code>=</code> 的这一系列符号不算（狭义的）运算符。</p>
</li>
<li><p>自增自减语句</p>
<p>  在 C 语言里面，<code>++</code> 和 <code>--</code> 确实是运算符，自增自减是表达式且可以求值。甚至还弄出了运算符在前和在后两种用法，分别用来表达先运算后求值和先求值后运算。</p>
<p>  Go 大概是觉得这些用法非常不直观容易出错，取消了自增自减的求值。所以在 Go 里面，它们是语句，只有写在变量后面一种用法，得单独一行先执行完，再访问变量取值。<code>b = a++</code> 这样的写法是错的，<code>a++</code> 把 <code>a</code> 的值加了 1，但 <code>a++</code> 语句本身并没有值。</p>
</li>
</ul>
<h3 id="2-比较（comparison）运算符"><a href="#2-比较（comparison）运算符" class="headerlink" title="2 比较（comparison）运算符"></a>2 比较（comparison）运算符</h3><p>比较运算又叫关系运算，应用范围比算术运算广，不在局限于数字类型。比较运算要求两个操作数的类型可以 <strong>互相赋值</strong>，以及满足两个条件：可比较（comparable） 和 有序（ordered）。其中可比较不一定有序，但有序一定是可比较的。</p>
<p>比较运算的结果是布尔值。</p>
<h4 id="可比较（comparable）"><a href="#可比较（comparable）" class="headerlink" title="可比较（comparable）"></a>可比较（comparable）</h4><p>相等运算符 <code>==</code> （相等）和 <code>!=</code> （不相等）要求操作数是可比较的。不同类型的规定如下：</p>
<ul>
<li><p>布尔（<code>bool</code>）值可比较。布尔类型只有 <code>true</code> 和 <code>false</code> 两个值，要么相同，要么不同。</p>
</li>
<li><p>数字类型都是可比较的。</p>
<ul>
<li>整型数很好理解，相等需要值完全一致。</li>
<li>浮点数涉及精度问题，详细规定需要参考 IEEE-754 规范。总的来说，因为涉及精度损失，浮点数直接比较的结果可能会出现不符合预期的情况：对于精度要求比较低的比较，可以将差值小于精度视作相等；如果精度要求超出可以表示的范围，只能考虑使用其它实现，例如 <code>math/big</code> 包。</li>
<li>复数的相等，就是实部和虚部的浮点数分别相等。</li>
</ul>
</li>
<li><p>字符串（<code>string</code>）可比较。就是逐个字节比较。</p>
</li>
<li><p>指针可比较。两个指针指向同一个变量，或者都是 <code>nil</code> 被认为相等。</p>
</li>
<li><p>通道（<code>chan</code>）可比较。两个通道变量指向同一个通道（来自同一个 <code>make</code> 调用创建），或者都是 <code>nil</code> 被认为相等。</p>
</li>
<li><p>接口（<code>interface</code>）可比较。两个接口变量拥有相同的动态类型、而且值也是相等（具体怎么比较根据动态类型决定），又或者都是 <code>nil</code> ，被认为相等。</p>
<p>  如果动态类型不同，不相等，不会报错。如果动态类型相同，但是该类型不可比较，会产生一个运行时 panic。（对不可比较的静态类型进行比较，编译时就不会通过；但是接口的实际类型需要运行时确定，所以变成了 panic 报错。）</p>
</li>
<li><p>非接口类型 <code>X</code> 的变量 <code>x</code> 与 接口类型 <code>T</code> 的变量 <code>t</code> ，满足以下条件时可比较：<code>X</code> 类型可比较，且，<code>X</code> 类型满足 <code>T</code> 接口。</p>
<p>  而 <code>x</code> 与 <code>t</code> 相等需要满足：<code>t</code> 的动态类型是 <code>X</code>，且，<code>t</code> 的值与 <code>x</code> 相等（按 <code>X</code> 类型的比较规则）。</p>
</li>
<li><p>数组类型可比较需要满足：两个数组是相同类型（同样的长度和元素类型， <code>[10]int</code> 和 <code>[10]bool</code> 是不同类型，<code>[10]int</code> 和 <code>[9]int</code> 也是不同类型），且，元素类型可比较。</p>
<p>  两个数组相等则需要满足对应的元素都相等。</p>
</li>
<li><p>结构体与数组类似，可比较需要满足：相同类型，且，所有成员字段的类型可比较。</p>
<p>  两个结构体相等需要所有成员字段都相等。</p>
</li>
</ul>
<p>注意以上规则不仅在直接比较时有效，还有这些类型作为数组或者结构体成员，被递归自动比较时也有效。</p>
<p>切片（slice）、映射（<code>map</code>）和函数（<code>func</code>）不可比较。但是可以跟 <code>nil</code> 进行比较判断是否非空。</p>
<p>顺便提一下，映射的键值类型必须是可比较类型，这在以后介绍的时候会提到，这里先做个一个知识关联。</p>
<h4 id="有序（ordered）"><a href="#有序（ordered）" class="headerlink" title="有序（ordered）"></a>有序（ordered）</h4><p>顺序（ordering）运算符 <code>&lt;</code> 小于，<code>&lt;=</code> 小于等于，<code>&gt;</code> 大于，<code>&gt;=</code> 大于等于 则要求操作数的类型是有序的。</p>
<p>有序的类型就非常少了，只有 整型、浮点型 和 字符串 三类。</p>
<p>这个比较好理解。数字直接比大小，浮点数涉及精度仍然参考 IEEE-754。字符串仍然是逐个字节比较，前缀相等时，较短的字符串较小（也就是空串最小，较短的字符串相当于同一个前缀后面接了一个空串）。</p>
<p>由于 Go 不支持运算符重载，所以除了这几个类型以外的类型都不支持顺序运算符，也没办法使它们支持。特殊的比较，就需要引入一些工具包（如 <code>reflect.Equal</code> 函数），自定义类型则需要自己实现比较方法如 <code>(a T) compareTo (b T)</code> 。另外，如想利用 <code>sort</code> 包进行排序，类型就需要满足 <code>sort.Interface</code> 接口。</p>
<h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3 逻辑运算符"></a>3 逻辑运算符</h3><p>逻辑运算符对布尔（<code>bool</code>）值进行运算，并得到一个布尔值。</p>
<p>逻辑运算符只有三个：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>短路逻辑与，操作数均为 <code>true</code> 时结果为 <code>true</code>，否则为 <code>false</code>。</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>短路逻辑或，操作数只要有一个为 <code>true</code> 结果即为  <code>true</code>，只有均为 <code>false</code> 时为 <code>false</code> 。</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非，单目运算，结果跟操作数相反。</td>
</tr>
</tbody>
</table>
<p>Go 的逻辑运算跟 C 一样是『短路逻辑』，双目运算时右操作数是『按需求值』的——意思是，如果不需要用到右操作数的值就能得到表达式的值，右操作数就不会求值。这可以用于避免一些运行时错误。</p>
<p>例如 <code>if a.val &gt; 10</code> ，如果 <code>a</code> 是 <code>nil</code>，就会产生一个 “nil pointer dereference” 的空指针 panic。这时如果改为 <code>if (a != nil) &amp;&amp; (a.val &gt; 10)</code> （括号非必要，只是方便看清左右操作数的范围），当 <code>a</code> 为 <code>nil</code> 时，<code>a != nil</code> 为 <code>false</code> ，对于逻辑与来说，无论右操作数的值是什么，整个表达式都一定是 <code>false</code> ，所以右操作数的表达式会被直接跳过不求值，也就不会触发空指针引用了。</p>
<h3 id="4-其它运算符"><a href="#4-其它运算符" class="headerlink" title="4 其它运算符"></a>4 其它运算符</h3><p>不好归类的运算符在这里统一介绍。</p>
<h4 id="地址（address）运算符"><a href="#地址（address）运算符" class="headerlink" title="地址（address）运算符"></a>地址（address）运算符</h4><p>有两个，分别是 <strong>取址运算符</strong> <code>&amp;</code> 和 <strong>解引用（dereference，又译 提取 或 取值）运算符</strong> <code>*</code> 。均为单目运算符，写在操作数前面。</p>
<p>取址运算应用在 <code>T</code> 类型的操作数 <code>x</code> 上，会得到一个 <code>*T</code> 类型的指针，指向 <code>x</code> 的地址；<code>x</code> 必须是可寻址的（addressable）。</p>
<p>相反，解引用运算应用在 <code>*T</code> 类型的操作数 <code>p</code> 上，会得到一个 <code>T</code> 类型的值；<code>p</code> 必须是一个有效的指针，不能为 <code>nil</code> ，否则会引起空指针解引用的运行时 panic。</p>
<h5 id="可寻址（addressable）"><a href="#可寻址（addressable）" class="headerlink" title="可寻址（addressable）"></a>可寻址（addressable）</h5><p>Go 中可寻址的范围比其它一些语言要广，除了变量（意味着有对应的可变内存）以外，还可以是：</p>
<ul>
<li>指针的解引用：<code>p</code> 是一个非 <code>nil</code> 指针，则 <code>*p</code> 可寻址，<code>&amp;*p</code> 其实就是对取值的结果再取址，等于 <code>p</code> 自身。</li>
<li>切片（slice）的索引操作：<code>s</code> 是一个 切片，则 <code>s[1]</code> 可寻址（即使切片本身不可寻址，当然需要 <code>s</code> 非空且索引在范围内）。</li>
<li>可寻址结构体的字段：<code>a</code> 是一个可寻址的结构体，则 <code>a.X</code> 可寻址（需要有 <code>X</code> 这个字段）。</li>
<li>可寻址数组的索引操作：<code>a</code> 是一个可寻址的数组，则 <code>a[1]</code> 可寻址（同样需要索引操作先成功）。</li>
<li>复合类型字面量：例如切片字面量 <code>[]int{1,2,3}</code> ，结构体字面量 <code>struct{X int}{1}</code> ，（使用上看起来）都是可寻址的。注意这条是一条例外，实际上是一个方便使用的语法糖，本质上 <code>&amp;T{...}</code> 等价于 <code>tmp := T{...}; &amp;tmp</code> ，表面上是对字面量取址，实际上是对自动生成的变量取址。</li>
</ul>
<p>作为对比，以下的情况均不可寻址：</p>
<ul>
<li>字符串的索引操作，即字符串中的字节。</li>
<li>映射 （<code>map</code> ）中的元素。</li>
<li>通过类型断言获得的接口变量的动态值。</li>
<li>常量。</li>
<li>字面量（复合字面量是个例外，背后其实是语法糖）。</li>
<li>包（package）级函数。</li>
<li>方法（当作函数值）。</li>
<li>各种中间值：<ul>
<li>函数调用（可能有返回值，也可能没有，都不可寻址）。</li>
<li>显式类型转换。</li>
<li>除了指针解引用（<code>*p</code>）以外的所有运算。</li>
</ul>
</li>
</ul>
<p>如果觉得上述列举过于繁琐，可以总结为一点：取址的对象必须是安全的可修改的内存。相对应地，不可寻址的情况可以总结为三点：</p>
<ul>
<li><p>不可变的。</p>
<p>  字面量、常量、字符串的字节 都是这种情况。如果取址之后可以修改，则破坏了不可变性；如果不能修改，那么对不可变的值取址没有意义。</p>
</li>
<li><p>中间结果。</p>
<p>  函数返回值、类型转换、类型断言、表达式结果 等都属于这种情况。中间结果的问题是，还没赋值给一个变量，没分配可访问的内存，没有地址可言。</p>
</li>
<li><p>不安全的。</p>
<p>  映射的元素、包级的函数 等属于这种情况。这种属于底层操作上可以取址，但是取址会引起问题，语法上规定了不可取址。</p>
</li>
</ul>
<p>映射的元素为什么不可寻址？映射（map）底层用哈希表实现，有自己的内存管理机制，当条目数量改变时可能会调整内存并重新哈希条目，将元素在内部移动，此时如果允许寻址，之前取的地址就会失效。</p>
<p>为什么哪怕是不可寻址的切片（例如函数返回的切片），它的索引也可以寻址？因为后面介绍到切片就会发现，切片是一个引用类型，切片本身只是切片的元数据，底层指向一个总是可寻址的数组。对切片的索引操作实际上是对底层数组的索引，自然是可寻址的。</p>
<p>更多关于可寻址的总结，可以参考 <a href="https://gfw.go101.org/article/unofficial-faq.html#unaddressable-values。" target="_blank" rel="external">https://gfw.go101.org/article/unofficial-faq.html#unaddressable-values。</a></p>
<h4 id="接收（receive）运算符"><a href="#接收（receive）运算符" class="headerlink" title="接收（receive）运算符"></a>接收（receive）运算符</h4><p>只有一个 <code>&lt;-</code> ，单目运算符，用在通道（<code>chan</code>）变量前面，表达式的值是从通道中接收到的值，类型则是通道的元素类型。</p>
<p>通道必须是可读的通道（读写 <code>chan</code> 或者只读 <code>&lt;-chan</code> ，不能是只写 <code>chan&lt;-</code>）。接收操作会阻塞直到有值可接收，试图从 <code>nil</code> 通道接收会一直阻塞，而试图从关闭（closed）的通道接收则会马上返回一个对应类型的零值。</p>
<p>这里其实我们只需要知道 <code>&lt;-</code> 是一个运算符，从通道接收是一个表达式即可。详细内容可以到介绍并发和通道时再深入了解。</p>
<h3 id="5-运算符优先级"><a href="#5-运算符优先级" class="headerlink" title="5 运算符优先级"></a>5 运算符优先级</h3><p>上表格，数字越大优先级越高：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>所有单目运算符：正负号<code>+</code>/<code>-</code>，按位取反<code>^</code> , 逻辑非 <code>!</code> ，取址<code>&amp;</code> ，解引用 <code>*</code> ，接收<code>&lt;-</code></td>
</tr>
<tr>
<td>5</td>
<td><code>*  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</code></td>
</tr>
<tr>
<td>4</td>
<td><code>+  -</code></td>
</tr>
<tr>
<td>3</td>
<td><code>==  !=  &lt;  &lt;=  &gt;  &gt;=</code></td>
</tr>
<tr>
<td>2</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>1</td>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td>0</td>
<td>语句</td>
</tr>
</tbody>
</table>
<p>所有单目运算符优先级都是最高，换言之其它优先级里的都是双目运算符。像优先级为 5 的 <code>*</code> 只能是乘号，而不是解引用。</p>
<p>原本没有 0，最后一行是我加的，语句并非运算符的一部分。语句的优先级最低，在所有运算符之后，像赋值 <code>=</code> 和 自增 <code>++</code> 自减 <code>--</code> 。像 <code>*p++</code> 等价于 <code>(*p)++</code> ，解引用是优先级最高的单目运算符，自增则是优先级最低的语句。</p>
<p>对于优先级，我个人的看法是，留个印象即可，不必细究。遇到优先级容易产生歧义的地方，直接加括号，清晰明了，适当增加括号没有任何副作用。</p>
<p>你愿意花时间熟悉优先级当然好。但是在实际开发中，你熟悉的不能保证其他人也熟悉，也不能保证自己未来会不会一时看错。保持程序的可读性非常重要。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>非常巧合，我在准备这一期的内容的前几天，刚好看见 Go 语言中文站的站长徐老师分享了两道练习题，正好作为运算符的练习题，那我就直接拿来主义（文中有解析，先自己尝试做，不要直接看答案）：</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/Pa_YgypVUlVaTN0ZutSyoQ" target="_blank" rel="external">题解：竟然半数以上的人做错了，基础真的很重要</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/GqdzjXuaZOmjqit32Vxuzg" target="_blank" rel="external">这么一道“简单”的题，为什么结果出乎我的意料</a></p>
</li>
</ul>
<h2 id="上期练习答案"><a href="#上期练习答案" class="headerlink" title="上期练习答案"></a>上期练习答案</h2><p>问题1：</p>
<p>一般情况下，我们用自定义类型（defined type）的常量模拟枚举。三种状态最直接的做法是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> State <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Todo State = <span class="literal">iota</span> <span class="comment">// 零值。只声明不赋值就会得到零值。如果想区分零值和有效值，可以在前面增加一个 Unknown 作为零值，并增加一个对 Unknown 的判断。</span></div><div class="line">    Ongoing</div><div class="line">    Done</div><div class="line">)</div></pre></td></tr></table></figure>
<p>如果只是个别地方使用，完全没有必要纠结底层类型（underlying type）。考虑到有内存对齐，底层使用 <code>int8</code> 也不见得可以节约多少内存，反而可能增加类型转换的麻烦。</p>
<p>不过如果要用到一个很大的 <code>[]State</code> 切片，这时底层类型就值得考虑一下了。三个（或者加上 <code>Unknown</code> 四个）状态， <code>bool</code> 无法表示，就只能选择 <code>int8</code> 或者 <code>uint8</code> 了。</p>
<p>问题2：</p>
<p><code>true</code> 。</p>
<p>这里有一个刻意的误导。<code>str1</code> 和 <code>str2</code> 指向不同的字符串；这点都不需要 <code>str2</code> 是拼接得到的，即使 <code>var str2 = &quot;hello world&quot;</code> ，甚至 <code>var str2 = str1</code>，它们都不会指向同一个字符串。这意味着，<code>&amp;str1 == &amp;str2</code> （<code>&amp;</code> 是取址操作，得到的是指针）总是 <code>false</code> 。</p>
<p>但是，比较操作符 <code>==</code> 在字符串上比较的是内容。两个字符串长度一致，对应的每个字节都相等，就会被认为相等，所以是 true。这个问题其实超出了上期的内容，对错没有关系，能引发思考和留下印象就好。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来的两期分别介绍 运算符 和 控制结构，然后准备引入实战项目。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言中价值十亿美元的错误（翻译）</title>
    <link href="https://jaycechant.info/2020/translation-billion-dollar-mistake-in-go/"/>
    <id>https://jaycechant.info/2020/translation-billion-dollar-mistake-in-go/</id>
    <published>2020-10-01T15:52:05.000Z</published>
    <updated>2020-10-26T09:45:40.960Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<strong>Billion-Dollar Mistake in Go ?</strong></p>
<p>地址：<a href="https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc" target="_blank" rel="external">https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc</a></p>
<p>作者：<strong>Harri Lainio</strong>（<a href="https://hackernoon.com/u/lainio" target="_blank" rel="external">@lainio</a>）</p>
<p>翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）</p>
<a id="more"></a>
<blockquote>
<p>十亿美元（billion dollar）的错误 / bug 貌似是美国的一个梗，大概的意思是，对于那些市值上几千亿的大企业，如果一个错误能够导致市值下跌个百分之零点几，就已经是十亿左右了。</p>
<p>在计算机领域，最著名的 BDM 大概是 图灵奖得主Tony Hoare 说他在 1965 年发明的 null 引用。</p>
<p>但我不确定这是不是最早的出处，毕竟在商业领域这样的说法也很常见。</p>
</blockquote>
<p>以下为译文：</p>
<hr>
<p><img src="../../images/billion-dollar-mistake.png" alt=""></p>
<p>以下示例代码来自 Go 的 <a href="https://golang.org/pkg/os/" target="_blank" rel="external">标准库文档</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</div><div class="line">count, err := file.Read(data)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    log.Fatal(err)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"read %d bytes: %q\n"</span>, count, data[:count])</div></pre></td></tr></table></figure>
<p>代码看起来没什么问题。出自标准库官方文档的代码，肯定不会错，对吧。</p>
<p>在阅读介绍 <code>Read</code> 函数的 <code>io.Reader</code> <a href="https://golang.org/pkg/io/#Reader" target="_blank" rel="external">文档</a> 之前，我们先花几秒钟来弄清楚这里面有什么问题。</p>
<p>例子里的 <code>if</code> 语句（至少）应该这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</div></pre></td></tr></table></figure>
<p>你也许在想，我是不是在自欺欺人：我们不是应该查看 <code>File.Read</code> 函数的 <a href="https://golang.org/pkg/os/#File.Read" target="_blank" rel="external">文档</a> 吗？那个才是正确的文档吧？是的，但那不应该是唯一正确的文档。</p>
<blockquote>
<p>译者注：读到这里的朋友可能会云里雾里，又未必愿意 / 方便（特别是公众号不能外链）看完文档再回来。我简单介绍一下。</p>
<p>在 <code>io.Reader</code> 接口的文档里，当 <code>Read</code> 遇到文件结束时，<code>io.EOF</code> 可能跟着非 0 的 n （读取的有效字节数）一起返回，也可能在下次调用跟 n = 0 一起返回。（这部分文档很长，有 1300 多个单词，还介绍了 <code>Read</code> 方法其它可能的行为，但多数是建议而不是强制的口吻。）</p>
<p><code>File.Read</code> 的文档则只有一句话，非常明确地指出遇到文件结尾时，会返回 <code>0, io.EOF</code> 。（换言之，<code>io.EOF</code> 不会跟有效字节一起返回。）</p>
</blockquote>
<p>如果我们不能真的用接口隐藏实现细节，那接口有什么用处？一个接口应该规定（set）它的语义，而不是像 <code>File.Read</code> 那样规定它的实现者。当接口的实现者是 <code>File</code> 以外的其他东西，但仍是一个 <code>io.Reader</code> 时，上面的代码会发生什么？当它把数据和 <code>io.EOF</code> 一起返回时，它退出得太早了，但这对所有的 <code>io.Reader</code> 实现者都是允许的。</p>
<h2 id="接口（Interface）-vs-实现者（Implementer）"><a href="#接口（Interface）-vs-实现者（Implementer）" class="headerlink" title="接口（Interface） vs 实现者（Implementer）"></a>接口（Interface） vs 实现者（Implementer）</h2><p>在 Go 里面，你不需要显式标记接口的实现者。这是一个强大的特性。但这是否意味着我们总是应该根据静态类型来使用接口语义呢？例如，下面的 <code>Copy</code> 函数是否应该使用 <code>io.Reader</code> 的语义？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</div><div class="line">    src.Read() <span class="comment">// 现在 read 的语义是来自 io.Reader 吗?</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那这个版本是不是应该只使用 <code>os.File</code> 的语义呢？(注意，这些只是虚构的例子)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst os.File, src os.File)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</div><div class="line">    src.Read() <span class="comment">// 那现在 read 的语义是不是来自 os.File 的 Read 函数呢 ?</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实践中认为，总是应该使用接口语义，而不是绑定到具体的实现——这就是有名的 <a href="https://zh.wikipedia.org/wiki/%E6%9D%BE%E8%80%A6%E5%90%88" target="_blank" rel="external">松耦合</a>。</p>
<h2 id="io-Reader-的问题"><a href="#io-Reader-的问题" class="headerlink" title="io.Reader 的问题"></a>io.Reader 的问题</h2><p>这个接口有以下问题：</p>
<ul>
<li>如果不学习 <code>io.Reader</code> 的文档，你就不能安全地使用任何 <code>Read</code> 函数的实现。</li>
<li>如果不仔细研究 <code>io.Reader</code> 的文档，你就无法实现 <code>Read</code> 函数。</li>
<li>由于缺少对错误（error）的分类（distinction），接口不够直观、完整和符合习惯。</li>
</ul>
<p>正因为 <code>io.Reader</code> 是一个接口，前面提到的问题才多了起来。这给 <code>io.Reader</code> 的每个实现者 和 <code>Read</code> 函数的每个调用者之间带来了跨包依赖。</p>
<p>标准库本身就有很多其它 <a href="https://golang.org/pkg/io/#Reader" target="_blank" rel="external"><code>io.Reader</code></a> 的调用者误用（misuse）该接口的例子。</p>
<p>根据这个 <a href="https://github.com/golang/go/issues/21852" target="_blank" rel="external">问题单（issue）</a>，标准库——尤其是里面的测试——都坚持使用 <code>if err != nil</code> 这个写法，这就阻止了 <code>Read</code> 实现中的优化。</p>
<p>例如，当检测到 <code>io.EOF</code> 时，如果（连同剩余的数据）立即返回 <code>io.EOF</code> ，就会让一部分调用者无法正确运行。原因是显而易见的。reader 接口文档允许两种不同类型的实现：</p>
<blockquote>
<p><code>Read</code> 在成功读取 n &gt; 0 个字节后，如果遇到错误或文件结束的情形，它会返回读取的字节数。它可能会在同一个调用中返回（非 nil）错误，也可能会在后续调用中返回错误（同时 n = 0）。</p>
</blockquote>
<p>接口应该是直观的、并且是通过编程语言本身正式地定义的，使得你无法实现或者误用它们（cannot implement or misuse them）。开发者不应该需要先阅读文档才能进行必要的错误传递。</p>
<blockquote>
<p>译者注：这里的 ‘cannot implement’ 感觉意思不对，不知道原作者是不是想表达错误实现的意思，却只在 use 上加了 mis，忘了 implement。个人猜测本意是 ‘cannot implement or use them in a wrong way’ ，不能错误地实现或者使用它们。但这只是我个人的猜测，写在这里，译文还是忠实于原文。</p>
</blockquote>
<p>允许接口函数有多个（本例中是两个）不同的显式行为是有问题的。接口的思想，是隐藏实现细节，实现松散耦合。</p>
<p>最明显的问题是，<code>io.Reader</code> 接口既不直观，也不符合 Go 典型的错误处理惯例。它还打乱了程序推导中正常和错误分离的控制路径。这个接口使用错误传递机制来处理一些实际上不是错误的东西：</p>
<blockquote>
<p><code>EOF</code> 是 <code>Read</code> 没有更多输入时返回的错误。函数应该只返回 <code>EOF</code> 来表示输入的正常（grateful）结束。如果 <code>EOF</code> 在结构化数据流中意外发生，相应的错误应该是 <code>ErrUnexpectedEOF</code> 或其他能给出更多细节的错误。</p>
</blockquote>
<h2 id="作为可辨识联合（Discriminated-Unions）的错误"><a href="#作为可辨识联合（Discriminated-Unions）的错误" class="headerlink" title="作为可辨识联合（Discriminated Unions）的错误"></a>作为可辨识联合（<a href="https://en.wikipedia.org/wiki/Disjoint_sets" target="_blank" rel="external">Discriminated Unions</a>）的错误</h2><p><code>io.Reader</code> 接口和 <code>io.EOF</code> 指出了 Go 目前的错误处理中所缺少的东西，那就是 <strong>错误的分类（the error distinction）</strong>。例如，Swift 和 Rust 不允许部分失败。函数调用要么成功，要么失败。这就是 Go 的错误返回值的问题之一。编译器无法提供任何支持。众所周知，这同样也是 C 语言的非标准错误返回的问题——当你有一个重叠的错误返回通道时就会这样。</p>
<p>Herb Shutter（译者注：C++ 程序设计专家，曾担任 ISO C++ 的秘书和会议召集人，原文有笔误，应为 Sutter）特意在他的 C++ 提案《<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf" target="_blank" rel="external">零开销的确定性异常：抛出值（Zero-overhead deterministic exceptions: Throwing values）</a>》中提到：</p>
<blockquote>
<p>『正常』与 『错误』（控制流）是一个非常基础的语义区分，而且可能在任何编程语言中都是最重要的区分，尽管这一点总是被低估。</p>
</blockquote>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>Go 当前 <code>io.Reader</code> 接口存在问题，是因为违反了语义的区分。</p>
<h3 id="增加语义上的区别"><a href="#增加语义上的区别" class="headerlink" title="增加语义上的区别"></a>增加语义上的区别</h3><p>首先，我们通过声明一个新的接口函数，停止使用返回错误来处理不是错误的东西。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, left <span class="keyword">bool</span>, err error)</div></pre></td></tr></table></figure>
<h3 id="只允许明显的行为"><a href="#只允许明显的行为" class="headerlink" title="只允许明显的行为"></a>只允许明显的行为</h3><p>其次，为了 避免混淆 以及 阻止明确的错误，我们引导使用下面的助手包装器（helper wrapper）来处理这两种允许的 <code>EOF</code> 行为。包装器只提供了一个显式行为来处理数据的结束。因为文档中说，必须允许在没有任何错误（包括 <code>EOF</code>）的情况下返回零字节（<strong>不鼓励在无错误的情况下返回零字节</strong>），所以我们不能将读取的零字节作为 <code>EOF</code> 的标志。当然，包装器也保持了错误的区分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</div><div class="line">    r   io.Reader</div><div class="line">    eof <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *MyReader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, left <span class="keyword">bool</span>, err error)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> mr.eof &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>, !mr.eof, <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    n, err = mr.r.Read(b)</div><div class="line">    mr.eof = err == io.EOF</div><div class="line">    left = !mr.eof</div><div class="line">    <span class="keyword">if</span> mr.eof &#123;</div><div class="line">        err = <span class="literal">nil</span></div><div class="line">        left = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们做了一个错误区分规则，错误和成功的结果是排他的。我们也对返回值 <code>left</code> 进行了区分。当我们已经读取了所有的数据，我们会将其设置为 <code>false</code>，使得函数变得更加易用，这在下面的 <code>for</code> 循环中可以看到：只有在 <code>left</code> 设为 <code>true</code> ，即数据可用时，才需要处理传入的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> n, left, err := src.Read(dst); err == <span class="literal">nil</span> &amp;&amp; left; n, left, err = src.Read(dst) &#123;</div><div class="line">    fmt.Printf(<span class="string">"read: %d, data left: %v, err: %v\n"</span>, n, left, err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如示例代码所示，它允许将正常路径（happy path）和错误控制流分开，这使得程序推导变得更加容易。我们在这里展示的解决方案并不完美，因为 Go 的多个返回值之间并无区别。</p>
<p>在我们这里，它们都应该是这样的。无论如何，我们已经了解到，每个新人（包括刚接触 Go 的人）都可以在没有文档或示例代码的情况下使用我们新的 <code>Read</code> 函数。这就是一个很好的例子，说明 <strong>正常路径和错误路径的语义区分是多么重要</strong>。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们可以说 <code>io.EOF</code> 是一个错误吗？我想说是的。这里有一个错误应该与预期的返回（expected returns）区分开的完美的理由。我们应该始终构建 鼓励正确路径（praise happy path）和 <a href="https://github.com/97-things/97-things-every-programmer-should-know/blob/master/en/thing_66/README.md" target="_blank" rel="external">防止错误</a> 的算法。</p>
<p>Go 的错误处理实践还缺少语言特性来帮助语义的区分。幸运的是，我们大多数人已经在清楚区分的控制流中处理错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;strong&gt;Billion-Dollar Mistake in Go ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc&quot;&gt;https://hackernoon.com/billion-dollar-mistake-in-go-ll1s3tkc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;strong&gt;Harri Lainio&lt;/strong&gt;（&lt;a href=&quot;https://hackernoon.com/u/lainio&quot;&gt;@lainio&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
      <category term="翻译" scheme="https://jaycechant.info/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（3）： 类型</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-3/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-3/</id>
    <published>2020-09-10T09:14:28.000Z</published>
    <updated>2020-09-24T18:44:56.149Z</updated>
    
    <content type="html"><![CDATA[<p>这期讲 Go 的类型。</p>
<p>Go 的数据类型分为基本类型和派生类型。篇幅关系，这期主要讲 基本类型，派生类型简单带过。</p>
<a id="more"></a>
<p>往期内容：</p>
<ul>
<li><a href="../../categories/Go-语言实战/">Go 语言实战</a></li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>下面的内容，会反复提到一个词：零值。如果声明一个变量，却不指定它的值，又或者直接 <code>new(T)</code> （T 是某个类型）申请一块内存，Go 会把这块内存置零。但同样是 0，在不同的类型下，会有不同的语义。了解零值，就是要知道不同类型的默认值的含义和行为。</p>
<h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><p>基本类型又分为 布尔类型、数字类型 和 字符串类型。</p>
<h4 id="1-1-布尔类型"><a href="#1-1-布尔类型" class="headerlink" title="1.1 布尔类型"></a>1.1 布尔类型</h4><p>类型标识符 <code>bool</code>，零值为 false。bool 没有直接的字面量，<code>true</code> 和 <code>false</code> 在 Go 是预定义的 bool 常量，不过使用上跟字面量没有太大区别。而很多时候，用到的不是这两个常量，而是 关系运算的结果 （关系运算符 <code>==</code> ， <code>!=</code> ，<code>&gt;</code> ， <code>&gt;=</code> ， <code>&lt;</code> ， <code>&lt;=</code>）和 函数返回值。</p>
<p>要注意的是，不像有些语言 bool 其实是数值类型的一种特例，可以或显式或隐式转换成数值。<strong>Go 的 bool 不是数值，也无法转换为数值，无法参与任何 数值运算（加减乘除） 和 位运算（按位与、或、取反等）；反之，数值也不能转换为 bool</strong>。</p>
<p>假设现在有 int 数组 <code>nums</code> ，要统计其中大于 0 的数的个数：</p>
<p>C 里面可以这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">    <span class="comment">// C 里面没有专门的布尔值，所以 true 本来就以整型数 1 代表</span></div><div class="line">    <span class="comment">// 反过来，所有非零值都会被看作 true</span></div><div class="line">    <span class="comment">// 括号非必要，只是为了看起来清晰</span></div><div class="line">    count += (nums[i] &gt; <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但在 Go 里会报错</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</div><div class="line">    <span class="comment">// 编译器报错 cannot convert nums[i] &gt; 0 (untyped bool value) to int</span></div><div class="line">    <span class="comment">// 即使加上显式转换 int(nums[i] &gt; 0) 也不行</span></div><div class="line">    count += (nums[i] &gt; <span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只能老老实实用 <code>if</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</div><div class="line">    <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</div><div class="line">        count++</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-数字类型"><a href="#1-2-数字类型" class="headerlink" title="1.2 数字类型"></a>1.2 数字类型</h4><p>包括整型数、浮点数、复数等，区分有符号、无符号，还有不同字节长度选择（对应不同的内存占用和数值范围），有多种组合，具体看表格。</p>
<table>
<thead>
<tr>
<th></th>
<th>1 字节</th>
<th>2 字节</th>
<th>4 字节</th>
<th>8 字节</th>
<th>16字节</th>
<th>架构相关</th>
</tr>
</thead>
<tbody>
<tr>
<td>无符号整型</td>
<td>uint8</td>
<td>uint16</td>
<td>uint32</td>
<td>uint64</td>
<td></td>
<td>uint</td>
</tr>
<tr>
<td>有符号整型</td>
<td>int8</td>
<td>int16</td>
<td>int32</td>
<td>int64</td>
<td></td>
<td>int</td>
</tr>
<tr>
<td>浮点数</td>
<td></td>
<td></td>
<td>float32</td>
<td>float64</td>
<td></td>
<td></td>
</tr>
<tr>
<td>复数</td>
<td></td>
<td></td>
<td></td>
<td>complex64</td>
<td>complex128</td>
<td></td>
</tr>
<tr>
<td>特殊类型</td>
<td>byte</td>
<td></td>
<td>rune</td>
<td></td>
<td></td>
<td>uintptr</td>
</tr>
</tbody>
</table>
<ul>
<li>数字类型的零值均为 0，各种意义上的零（整数零 <code>0</code> ，浮点数零  <code>0.0</code> ， 复数零 <code>0+0i</code>）。</li>
<li>数字类型的字面量，涉及类型推断，参考上一期的字面量部分。</li>
<li><code>byte</code> 是 <code>uint8</code> 的别名，<code>rune</code> 是 <code>int32</code> 的别名。类型别名以后再详细展开，你只要知道它们是同一个类型就可以了。</li>
<li><strong>除了复数以外，所有数值类型的变量之间可以互相转换。</strong> 规则参考上期的类型转换部分。</li>
<li>复数需要经由内置函数提取 实部 和 虚部（都是浮点数），或者将两个浮点数组合成复数。如果不是科学计算，一般很少用到复数，可以留个印象，用到再查。</li>
</ul>
<h5 id="位宽、范围与精度"><a href="#位宽、范围与精度" class="headerlink" title="位宽、范围与精度"></a>位宽、范围与精度</h5><p>位宽是类型后面的数字，它表示该类型占用了多少个二进制位。因为计算机以 字节（byte，等于 8 bit）为组织单位，位宽总是 8 的 2 整数次方倍。</p>
<p><code>uint</code> 、<code>int</code> 和 <code>uintptr</code> 三个类型的位宽与系统架构相关。其中 <code>uint</code> 和 <code>int</code> 不小于 32 位，在 64 位系统则为 64 位；但需要注意它们是独立的类型，以 <code>int</code> 在 64 位系统为例，尽管范围完全一样，<code>int</code> 变量跟 <code>int64</code> 变量之间仍需转换。</p>
<p><code>uintptr</code> 的范围则保证可以存下当前系统架构下的地址，无需特别考虑。</p>
<p>既然有不同的字节长度，就涉及到表示范围。范围太小，会导致数字溢出；范围太大，则引起内存的浪费。当然，如果只是个别变量，几个字节的差异可以忽略，可以直接用范围较大的类型；但涉及大数组或者大量生成的结构体的字段，则最好确定数据范围然后挑选合适的类型。（事实上，如果真的有需要节省空间和访问时间，还得考虑 内存对齐（memory alignment）或者 数据结构对齐（data structure alignment），那又是另一个话题了。）</p>
<ul>
<li>对于无符号整型，假设位宽为 N（下同），表示范围为 $ 0 \sim 2^N - 1 $ ，如 <code>uint8</code> 表示的最大值为 $ 2^8 - 1 = 255 $ 。这个值除了自己算，也可以通过 <code>math</code> 包的常量 <code>math.MaxUint8</code> 获得。16、32、64 位以此类推。</li>
<li>对于有符号整型，最高位表示符号位，正负数的范围分别只有无符号数的一半（实际上因为不需要表示 负零，负数范围多一个），表示范围为 $ -2^{N-1} \sim 2^{N-1} - 1 $ ，如 <code>int8</code> 最小值为 -128，最大值为 127。这两个值也可以通过 <code>math</code> 包的常量 <code>math.MinInt8</code> 和 <code>math.MaxInt8</code> 获得。其它有符号整型以此类推。</li>
<li>浮点数实际上是 科学记数法 的二进制实现，二进制位除了最高位的符号位，剩下的分成了 尾数 和 指数 两部分。跟整型不同的是，浮点数的范围包括 绝对值最大值 和 非零绝对值最小值（跟指数位宽有关），还有小数精度的问题（跟尾数位宽有关）。这些规范其实是 IEEE-754 国际标准规定的。因为精度还涉及进制转换问题，就不在这里展开。<code>float32</code> 的绝对值范围可以通过 <code>math.SmallestNonzeroFloat32</code> 和 <code>math.MaxFloat32</code> 获得。64 位以此类推。</li>
<li>复数实际上由实部和虚部两个浮点数（各占一半位宽）组成，具体范围参考浮点数。</li>
</ul>
<p>既然数字类型都有表示范围，而浮点数还可能有精度损失（有可能是超出尾数范围，也可能是进制转换造成），那么就有可能表示范围或者精度不足。如果需要表示超出范围的值，或者涉及金钱等业务需要非常高的精度，则需要用到 <code>math/big</code> 包的几个大数类型，包括整型 <code>big.Int</code> 、浮点型 <code>big.Float</code> 和 分数 <code>big.Rat</code> 。留个印象，后续再介绍。</p>
<h4 id="1-3-字符串类型"><a href="#1-3-字符串类型" class="headerlink" title="1.3 字符串类型"></a>1.3 字符串类型</h4><p>类型标识符 <code>string</code> ，就是一串有固定长度的字符序列。</p>
<ul>
<li>字符串的底层是一个 byte 数组（以 UTF-8 编码，所以支持中文），可以当做 byte 数组访问读取。例如读取 <code>str[i]</code> 得到的就是一个 byte 类型的值。 </li>
<li><strong>字符串是不可变类型，内容不可修改；对字符串变量的修改实质上是整个替换</strong>。试图修改字符串的内容（如 <code>str[0] = &#39;a&#39;</code>），会引起报错。而 <code>str1 = str1 + str2</code> 中则是合法，因为 <code>str1</code> 和 <code>str2</code> 的内存都没有被修改，而是开辟新的内存存放拼接后的字符串，然后 <code>str1</code> 指向新的内存。原来 <code>str1</code> 的内存如果没有被其它地方引用，会在后续的 GC 被回收。这点有点像 Java 的 String。大量频繁拼接字符串的场景，需要考虑优化。</li>
<li>如果需要修改，则要转换成切片 <code>[]byte</code> 或者 <code>[]rune</code> ；修改完之后也可以重新转换为 <code>string</code>。<strong>无论哪个方向的转换，内存都发生了拷贝（copy），返回的新切片 / 新字符串指向新分配的内存，所以互不影响。</strong> 频繁转换时需要考虑性能损耗。</li>
<li><code>[]byte</code> 和 <code>[]rune</code> 差别是前者每个字符的范围是只有一个字节的 Unicode （只存得下 ASCII 码 + 拉丁符号扩展1），后者则是 四个字节的 Unicode。包含中文等等内容、字符编码可能大于一个字节的字符串只能转换为 <code>[]rune</code> 否则会出现乱码；反之 ASCII 码的内容转换为 <code>[]rune</code> 并不影响内容正确性，只是有一定的性能浪费而已。</li>
<li><strong>跟很多语言不同，Go 字符串的零值是空串 <code>&quot;&quot;</code> 。</strong> 而不是特殊的空值 <code>nil</code>、<code>null</code>、<code>None</code> 等。未初始化的字符串和空白字符串不像 Java 那样需要区分，判断都是 <code>if str == &quot;&quot;</code> 。</li>
<li>字符串有两种字面量形式，除了以双引号包裹内容，还可以用反引号（&#96; ，<code>Esc</code> 下方的键）包裹。区别是双引号内支持转义，不支持换行；反引号字符串恰恰相反，不支持转义，所有字符都会原样保留，包括换行（但为了跨平台兼容性，换行符统一替换成 <code>newline</code>，去掉 <code>carriage return</code>）。反引号字符串常用于一大段的内容（为了保留换行）和 正则表达式（为了保留特殊符号不被转义）。</li>
<li>字符串支持的转义字符跟字符字面量一致，只有一个差别：不支持 <code>\&#39;</code> 改为支持 <code>\&quot;</code> ；这是因为字符串以双引号界定，单引号不再是特殊字符。</li>
</ul>
<p>string 本身值得专门开一篇文章，先说这么多。</p>
<h3 id="2-派生类型"><a href="#2-派生类型" class="headerlink" title="2. 派生类型"></a>2. 派生类型</h3><p>派生类型，又叫衍生类型。顾名思义，它是在其它类型的基础上衍生出来的。</p>
<p>一个派生类型，严格来说，是一个大类，底下可以包含多种具体类型。例如 <code>*int</code> 和 <code>*bool</code> 虽然同为指针类型，但由于指向的类型不同，它们也是不同的类型（称作 <code>int</code> 指针 和 <code>bool</code> 指针）；<code>int</code> 数组 和 <code>bool</code> 数组也是不同的类型；甚至，长度为 10 的 <code>int</code> 数组 <code>[10]int</code> 和 长度为 11 的数组 <code>[11]int</code> 也是不同的类型。</p>
<p>派生类型是个比较大的话题，个别类型光一个类型就够写一篇文章，所以这里不详细展开，只作简单罗列：</p>
<ul>
<li><p>指针：从 C / C++ 一脉相承，内存管理的高阶操作；不过 Go 的指针比 C / C++ 要简单和安全得多，类型安全，也不用关心内存的释放和悬挂指针。</p>
<p>  <code>var iptr *int</code> 声明了一个指向 <code>int</code> 的指针 <code>iptr</code> ，零值为 <code>nil</code> （相当于某些语言的 <code>null</code> ，<code>None</code> ）。</p>
</li>
<li><p>数组（array）和 切片（slice）：类似其它语言的数组和动态数组。（注意这是两个不同类型，只是性质相近一起介绍）</p>
<p>  <code>var a [10]int</code> 声明了一个长度为 10 的 <code>int</code> 数组 <code>a</code>，零值为成员都是零值的数组，可以直接使用。</p>
<p>  <code>var s []int</code> 则声明了一个 <code>int</code> 切片 <code>s</code>，零值为 <code>nil</code> 。</p>
</li>
<li><p>映射（map）：类似其它语言的 map。不过不像 C++ 和 Java 作为库引入，Go 的 map 是语言内置的。因为 Go 没有 集合（set），很多时候也需要用 map 模拟。</p>
<p>  <code>var m map[string]int</code> 声明了一个 key 为 <code>string</code> ，value 为 <code>int</code> 的 map <code>m</code> ，零值为 <code>nil</code> 。</p>
</li>
<li><p>函数（function）：Go 里面函数也是第一等公民。函数既然是一种类型，那么就可以作为变量和参数。Go 支持函数式编程。</p>
<p>  <code>var f func(int)bool</code> 声明了一个 『接受一个 <code>int</code> 参数并返回一个 <code>bool</code> 值的函数』变量 <code>f</code> ，零值为 <code>nil</code> 。</p>
<p>  当然你也可以用 <code>func</code> 关键字直接声明一个函数 <code>f</code> ：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">    <span class="comment">// 函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  两者都是通过 <code>f()</code> 调用（当然，实际调用要提供一个 <code>int</code> 参数）。后者只能用于全局（包级）函数，必须给出函数体，<code>f</code> 不是一个变量，<code>f</code> 的值是一个具体的函数而且不能修改。从效果上接近一个函数常量（但不是）。</p>
</li>
<li><p>结构体（struct）：类似 C / C++ 的结构体，但是可以定义行为（方法）。Go 没有 类（class）和 继承（inheritance），而是通过 结构体 和 组合（composition）实现面向对象。</p>
<p>  下面声明了一个『拥有一个 <code>string</code> 字段 和一个 <code>int</code> 字段 的结构体』的变量 <code>alice</code> ，零值是所有字段都为对应零值的结构体：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> alice <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    age  <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  但这样写，每次声明都要把结构体重新写一遍，啰嗦还容易错——只要字段的名称、类型或者顺序，随便一样有差别，都会被认为是不同的类型。一般情况下，除非这个结构体只使用这么一次，否则都不应该这样写。</p>
<p>  正确的做法，是给结构体一个类型名，然后用名字来声明：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    age  <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    alice person</div><div class="line">    bob   person</div><div class="line">)</div></pre></td></tr></table></figure>
<p>  在这里 <code>person</code> 成了一个新的自定义类型，与之相对应，前面没有定义名称的结构体称为匿名结构体。</p>
</li>
<li><p>接口（interface）：接口是一系列行为（方法签名，方法是一种特殊的函数）的集合。跟其它语言不同，Go 的接口不需要显式声明实现（implementation），一个类型只要实现了接口的所有方法，它就隐式地满足接口。是否满足接口可以在编译期静态检查，所以是类型安全的。<strong>Go 实现了类型安全的鸭子类型（duck typing）</strong> 。这种设计是 Go 的组合式面向对象的重要组成部分。</p>
<p>  跟结构体类似，接口的定义比较长，也应该定义成一个自定义类型：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> runner <span class="keyword">interface</span> &#123;</div><div class="line">    <span class="comment">// 满足 runner 接口的类型，应该具有 walk() 和 run() 两个方法</span></div><div class="line">    walk() <span class="comment">// walk 是一个没有参数也没有返回值的方法</span></div><div class="line">    run(<span class="keyword">int</span>)<span class="keyword">bool</span> <span class="comment">// run 方法接收一个 int 参数，并返回一个 bool 值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    cindy runner</div><div class="line">    danny runner</div><div class="line">)</div></pre></td></tr></table></figure>
<p>  这里声明了两个 『拥有两个方法的接口』的变量。接口变量的零值是 <code>nil</code> ，可以接受任何满足接口的类型的值。</p>
</li>
<li><p>通道（channel）：channel 用于并发时在协程间通信，是 CSP 模型的重要部分。</p>
<p>  channel 除了区分传递的消息的类型，还分读写和缓冲区大小。其中缓冲区在初始化时决定，剩下的在类型上体现：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">    ich <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 可以读写的通道，消息类型是 int</span></div><div class="line">    bch &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span> <span class="comment">// 只读的通道，消息类型是 bool</span></div><div class="line">    fch <span class="keyword">chan</span>&lt;- <span class="keyword">float64</span> <span class="comment">// 只写的通道，消息类型是 float64</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>  channel 的零值为 <code>nil</code> 。</p>
</li>
</ul>
<p>关于派生类型，最后补充两点：</p>
<ol>
<li><p>所有零值不是 <code>nil</code> 的变量，都可以声明之后直接使用（只不过值都是零）；而零值为 <code>nil</code> 的类型，意味着需要额外的初始化，其中 切片（slice）、映射（map）和 通道（channel）都是通过内置函数 <code>make()</code> 申请内存并初始化。</p>
</li>
<li><p>先定义为自定义类型，再用新类型声明变量，对 结构体 和 接口 来说，既不是必选项，也不是特权。这句话的意思是：</p>
<ul>
<li>不是必选项：匿名结构体 和 匿名接口 也是合法的代码。只不过由于这两种类型的定义太长（一定会换行），匿名使用会有很多麻烦，还是推荐先定义类型。这虽然不是强制选项，却是最佳实践。</li>
<li>不是特权：只要你愿意，所有类型都可以定义为自定义类型（参考下一节），只不过有没有必要而已。</li>
</ul>
</li>
</ol>
<p>这部分内容只是为了让大家对派生类型有一个整体的印象。细节会在用到这些类型时详细展开。</p>
<h3 id="3-自定义类型"><a href="#3-自定义类型" class="headerlink" title="3. 自定义类型"></a>3. 自定义类型</h3><p>Go 使用 <code>type</code> 关键字自定义类型，有两种用法：</p>
<h4 id="3-1-类型定义"><a href="#3-1-类型定义" class="headerlink" title="3.1 类型定义"></a>3.1 类型定义</h4><p>语法 <code>type TypeName TypeDefinition</code></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NewInt <span class="keyword">int64</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> NewStruct <span class="keyword">struct</span> &#123;</div><div class="line">    val <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Bitmap []<span class="keyword">uint64</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Runner <span class="keyword">interface</span> &#123;</div><div class="line">    Run()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Handler <span class="function"><span class="keyword">func</span><span class="params">(req Request)</span><span class="title">Response</span></span></div></pre></td></tr></table></figure>
<p><strong>类型定义</strong> 看起来很像 C / C++ ，只是把名字移到了前面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">&#125; NewStruct;</div></pre></td></tr></table></figure>
<p>或者 Java 的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewStruct</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然像，差别也很明显：</p>
<ul>
<li>Java 里，新名字只能是一个类（即使里面只有一个值）；Go 既能创建新结构体 / 接口，也能复用已有的类型——包括基本类型和内置的派生类型。</li>
<li>C 的 <code>typedef</code> 倒是也可以用于基本类型，但得到的实际上是一个别名，新旧类型仍然是同一种类型；而 Go 声明了一种新的类型。</li>
</ul>
<p>以 <code>type NewInt int64</code> 举例，虽然它们共享同样的内存实现（8 个字节的连续内存），在基本运算符上有同样的结果，但是 <code>NewInt</code> 被认为是跟 <code>int</code> 不同的一个类型，可以拥有自己的方法。两种类型不能直接一起运算，也不能用作另一种类型的参数，需要经过转换。</p>
<p>不直接使用原类型，而是定义命名的新类型，我认为有以下几个原因：</p>
<ol>
<li><p>使用方便。</p>
<p> 这是对冗长的派生类型——尤其是 结构体 和 接口 而言的。简洁的名字当然比冗长的结构方便且不易出错。</p>
</li>
<li><p>自注释。</p>
<p> 名字可以体现用途和意图。</p>
</li>
<li><p>借用静态检查发现错误。</p>
<p> 将底层实现一样但是业务逻辑不一致的类型分别定义为不同的类型，可以借由静态检查发现逻辑错误。这在上一期类型转换部分，我用 砧板 和 地板 的 底层类型都是 木板 做了一个类比。</p>
</li>
<li><p>添加方法。</p>
<p> Go 可以（且只可以）给当前包定义的类型添加方法。内置类型和导入类型定义成新类型之后，就可以给新类型添加方法，实现面向对象编程。</p>
<p> 需要注意的是，定义成新类型之后，原来类型的方法就全部丢失，不能再访问了（毕竟已经不是同一个类型）。如果需要保留原来的方法，应该选择将旧类型匿名嵌入新类型的结构体。匿名嵌入效果上接近继承，实际上是组合，只是跟一般成员组合相比，被匿名嵌入类型的成员和方法可以直接访问。具体在 方法 和 结构体 部分展开。</p>
</li>
</ol>
<h4 id="3-2-类型别名"><a href="#3-2-类型别名" class="headerlink" title="3.2 类型别名"></a>3.2 类型别名</h4><p>语法 <code>type TypeAlias = AnotherType</code></p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> IntAlias = <span class="keyword">int</span></div><div class="line"><span class="keyword">type</span> StructAlias = NewStruct</div></pre></td></tr></table></figure>
<p><strong>类型别名</strong> <code>type IntAlias = int</code> 中，<code>IntAlias</code> 被认为是 <code>int</code> 的别名，看作是同一类型，可以直接一起运算或者作为参数，无需转换。类型别名自 Go 1.9 引入，用来解决迁移、升级等重构场景下，类型重命名的兼容性问题，以及方便引用外部导入的类型。</p>
<p><strong>实际上，类型别名仅在代码中存在，编译时会全部替换成实际的类型。只有类型定义产生了新的类型。</strong></p>
<h3 id="4-枚举（模拟）"><a href="#4-枚举（模拟）" class="headerlink" title="4. 枚举（模拟）"></a>4. 枚举（模拟）</h3><p>说到自定义类型，就顺便提一下枚举。</p>
<p>在数学和计算机科学上，枚举是指列出一个有限集合的所有成员。而枚举类型是一种特殊的类型，只能取限定的某几个值。有些语言只是限定了枚举类型的取值（C / C++）；而有些语言则（以常量的形式）直接预先初始化了枚举类型所有可能值的实例，变量不仅仅只能取有限的值，而是只能是这几个实例之一（Java，Python）。</p>
<p><strong>Go 没有提供对枚举的支持</strong>。是的，Go 跟谁都不像，根本没有枚举。相对应地，在 Go 里一般通过 自定义类型 + 常量 模拟枚举。我们来看看官方库里面 <code>time</code> 包对 月份 <code>Month</code> 和 周几 <code>Weekday</code> 的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> time</div><div class="line"></div><div class="line"><span class="comment">// A Month specifies a month of the year (January = 1, ...).</span></div><div class="line"><span class="keyword">type</span> Month <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 如果理解不了这部分，请翻看上一期常量部分关于自动补全和 iota 的内容</span></div><div class="line">    January Month = <span class="number">1</span> + <span class="literal">iota</span></div><div class="line">    February</div><div class="line">    March</div><div class="line">    April</div><div class="line">    May</div><div class="line">    June</div><div class="line">    July</div><div class="line">    August</div><div class="line">    September</div><div class="line">    October</div><div class="line">    November</div><div class="line">    December</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// String returns the English name of the month ("January", "February", ...).</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Month)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> January &lt;= m &amp;&amp; m &lt;= December &#123;</div><div class="line">        <span class="comment">// longMonthNames 是一个预先定义的字符串切片，里面按顺序保存了每个月份的字符串</span></div><div class="line">        <span class="keyword">return</span> longMonthNames[m<span class="number">-1</span>]</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果 m 的值不在范围内，返回表示错误的字符串</span></div><div class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">20</span>)</div><div class="line">    n := fmtInt(buf, <span class="keyword">uint64</span>(m))</div><div class="line">    <span class="keyword">return</span> <span class="string">"%!Month("</span> + <span class="keyword">string</span>(buf[n:]) + <span class="string">")"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// A Weekday specifies a day of the week (Sunday = 0, ...).</span></div><div class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Sunday Weekday = <span class="literal">iota</span></div><div class="line">    Monday</div><div class="line">    Tuesday</div><div class="line">    Wednesday</div><div class="line">    Thursday</div><div class="line">    Friday</div><div class="line">    Saturday</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// String returns the English name of the day ("Sunday", "Monday", ...).</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Weekday)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> Sunday &lt;= d &amp;&amp; d &lt;= Saturday &#123;</div><div class="line">        <span class="comment">// 跟月份类似，longDayNames 也是预先定义好的字符串切片</span></div><div class="line">        <span class="keyword">return</span> longDayNames[d]</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 同样地，超出范围就返回表示错误的字符串</span></div><div class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">20</span>)</div><div class="line">    n := fmtInt(buf, <span class="keyword">uint64</span>(d))</div><div class="line">    <span class="keyword">return</span> <span class="string">"%!Weekday("</span> + <span class="keyword">string</span>(buf[n:]) + <span class="string">")"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子里，<code>Month</code> 和 <code>Weekday</code> 都是底层类型为 <code>int</code> 的自定义类型；然后这两个类型定义了一系列的常量作为取值范围，并且定义了一个 <code>String()</code> 方法，返回对应值的字符串形式。</p>
<p>在 1.4 之后，Go 工具链提供了 <code>go generate</code> 命令，配合 <code>stringer</code> 工具可以自动生成常量的 <code>String()</code> 方法。除此之外，也可以按需给新类型添加各种方法，模拟其他语言里的枚举，或者增加需要的功能。详情可以自己查阅，这里不再展开。</p>
<p>有独立的类型、通过常量给定取值、能返回字符串，肯定比直接用一个整型数来表示要强。自定义类型被认为是跟原来不一样的类型，在赋值或者传参过程中，如果使用了不同类型的变量，直接在编译时就报错了；另一方面，如果只通过常量引用这些 “枚举类型” 的值，取值范围也限制住了。基本实现了枚举的目的。</p>
<p>但也只能说部分实现。提供的常量只是给出了范围的建议值，而不是强制值。Go 没有提供『把类型的取值范围硬性限制在某几个值』的语义。新类型的取值范围仍然是和底层类型一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 这是合法的，-1 作为字面量是 untyped 的，可以自动转换类型</span></div><div class="line">    <span class="keyword">var</span> m1 time.Month = <span class="number">-1</span></div><div class="line">    </div><div class="line">    <span class="comment">// 又或者是忘了赋值，那么 m2 的值就为 零值，即 0，也不在常量范围内</span></div><div class="line">    <span class="keyword">var</span> m2 time.Month</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果说 <code>m1</code> 是违反了（模拟的）枚举类型只使用常量引用的原则，注意一下就可以避免；那么 <code>m2</code> 这种忘记赋值的情况可能更难发现一些。</p>
<p>既然没有办法通过类型安全本身限制取值，就只能在使用时注意判断值的范围，特别要处理意外的情况。在判断枚举值时，一般使用 <code>if-else</code> 或者 <code>switch-case</code>  代码块，这时记得加上一个 <code>else</code> 或者 <code>default</code> 处理无效值。又或者干脆给类型添加一个 <code>IsValid()bool</code> 方法，判断值是否有效。</p>
<p>当然这种实现方式也并不全是坏处。Go 没有限定枚举必须是什么样子，就可以按自己的需要设计：</p>
<ul>
<li>枚举的底层值不一定是整数，可以是任意基本类型。</li>
<li>枚举的值允许重复；这个有些时候可能会引起错误，有些时候又可能有用。</li>
<li>没有增加特殊情况，保持了类型系统的简单和高效；引入专门的枚举类型其实涉及很多问题，例如序列化和反序列化怎么处理。</li>
</ul>
<p>总的来说，我个人觉得在枚举这个问题上处理得不够好，好像不太符合 Go 一向强类型和自带最佳实践的风格。当然也有可能是我理解得不够深入。但无论怎么说，目前的实现方式在官方库非常普遍，出于兼容性的考虑，至少在 Go 1.x 阶段不太会改动的样子。那就接受这个设定，并且小心避开潜在的坑吧。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>问题1 ：</p>
<p>假设程序中需要储存一个状态，有 待办、进行中、完成 三种状态，应该怎么样定义类型？</p>
<p>如果这样的状态需要储存非常多个，定义成一个大数组储存，该如何节省空间？</p>
<p>问题 2：</p>
<p>问以下程序的输出，为什么。老规矩，不用运行就得出答案更佳。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> str1 = <span class="string">"hello world"</span></div><div class="line">    <span class="keyword">var</span> tmp1 = <span class="string">"hello"</span></div><div class="line">    <span class="keyword">var</span> tmp2 = <span class="string">"world"</span></div><div class="line">    <span class="keyword">var</span> str2 = tmp1 + <span class="string">" "</span> + tmp2</div><div class="line">    fmt.Println(str1 == str2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<hr>
<h2 id="上期练习答案"><a href="#上期练习答案" class="headerlink" title="上期练习答案"></a>上期练习答案</h2><p>第二期最后的练习，答案如下</p>
<p>如果还没做练习，不要直接看答案</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局常量和变量是经过依赖分析后统一初始化的</span></div><div class="line"><span class="comment">// 只要没有依赖环，声明先后不影响引用</span></div><div class="line"><span class="comment">// 但局部常量和变量不能这样做</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    A <span class="keyword">uint8</span> = B <span class="comment">// uint8, 255</span></div><div class="line">    B       = <span class="number">255</span> <span class="comment">// 整型字面量默认类型为 untyped int，255</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    a <span class="keyword">uint64</span> = A / <span class="number">2</span> <span class="comment">// 类型报错！A 的 uint8 是显式类型，2 自动转换为 uint8 参与运算，所以 A / 2 表达式整体也是 uint8，不能自动转换为 uint64</span></div><div class="line">    b <span class="keyword">int8</span>   = B / <span class="number">2</span> <span class="comment">// B 是 untyped 无类型，表达式整体也是 untyped int，结果自动转换为 int8，结果为 127（整数除法），刚好不超过 int8 的范围</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 以下的 A, B, a, b 均没有重复声明，这是因为作用域不同，发生了 shadow</span></div><div class="line">    </div><div class="line">    A := <span class="keyword">byte</span>(<span class="string">'0'</span>) <span class="comment">// '0' 为 untyped rune，显式转换为 byte，值范围没有超出，所以类型为 byte；byte 实际是 uint8 的别名，'0' 的值为 48，只有作为字符格式化时才输出字符 '0'</span></div><div class="line">    B := <span class="keyword">byte</span>(<span class="string">'1'</span>) <span class="comment">// 类型同上，值为 49</span></div><div class="line">    C := A - B <span class="comment">// A, B 均为 byte 类型，所以表达式的结果也是 byte，C 也是 byte；计算结果为 -1，但 byte（即 uint8，无符号 8 位整型）最小值是 0，下溢出，截取得到 255 （惊不惊喜，意不意外）；这种截取很容易导致意料以外的结果，需要尽量避免</span></div><div class="line">    fmt.Println(C) <span class="comment">// 输出 255</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> a = <span class="string">'0'</span> <span class="comment">// 没有指定类型，类型为 untyped rune，值为 48</span></div><div class="line">    <span class="keyword">const</span> b = <span class="string">'1'</span> <span class="comment">// 类型为 untyped rune，值为 49</span></div><div class="line">    fmt.Println(<span class="keyword">byte</span>(a - b)) <span class="comment">// 类型转换错误！a - b 的结果类型为 untyped rune，值为 -1，转换成 byte 会下溢出；常量在转换中不允许溢出</span></div><div class="line"></div><div class="line">    i := <span class="number">0x1e</span>+<span class="number">2</span> <span class="comment">// 这其实是一个表达式，格式化后会自动在加号两边添加空格；加号前面的数是十六进制的 30，整体就是 30 + 2；两个数都是整型字面量，所以表达式和变量的类型都是 untyped int，值为 32</span></div><div class="line">    j := <span class="number">1e+2</span> <span class="comment">// 浮点数字面量，表示 1 x 10^2，即 100，类型为 untyped float；注意 j 没有任何有效使用，会报 not used 错误！</span></div><div class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ &#123; <span class="comment">// i 在这里是赋值，在循环条件 i &lt; 1 中算有效使用（涉及到了循环，略有超纲，但有其它语言经验的话问题不大）</span></div><div class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1</span>; j++ &#123; <span class="comment">// 短声明产生了一个新的 j ，跟前面的 j 无关</span></div><div class="line">            <span class="comment">// 空循环体</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 现在 i, j 分别是多少</span></div><div class="line">    <span class="comment">// i 在循环中先是被赋值为 0，然后自增，到 1 时不满足循环条件退出，所以 i 为 1</span></div><div class="line">    <span class="comment">// （外层）j 没有被使用，还是 1e+2 （100）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你答对了吗？</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这期讲 Go 的类型。&lt;/p&gt;
&lt;p&gt;Go 的数据类型分为基本类型和派生类型。篇幅关系，这期主要讲 基本类型，派生类型简单带过。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（2）： 常量与变量</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-2/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-2/</id>
    <published>2020-08-30T04:15:12.000Z</published>
    <updated>2020-09-22T04:16:44.541Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇《<a href="../golang-in-action-day-1/">Go 语言实战（1）： 初识</a>》开了头，今天我们接着打卡。</p>
<a id="more"></a>
<blockquote>
<p>注意，文中出现的大多数代码都只是关键片段，如果想尝试运行，需要补充程序的必要成分。关于一个完整 Go 程序的结构，请看第一期的内容。</p>
</blockquote>
<h2 id="Go-的定位"><a href="#Go-的定位" class="headerlink" title="Go 的定位"></a>Go 的定位</h2><p>接着上一期，这期还是先介绍一些概念性的话题。</p>
<p>如果用一句话来描述，Go 的定位就是 <del>保留 C 语言的简洁性和执行效率的前提下，重新设计放下历史包袱，增加现代特性，表达力和易用性向 Python 等现代语言靠拢</del> <strong>服务于软件工程的语言设计</strong>。（划掉的是我啰嗦又辞不达意的总结，加粗的是 Rob Pike 2012 年一个演讲的主题。）</p>
<p>我在写这一段时，发现无论如何都很难概括好。然后我就放弃了自己概括，改为学习大佬讲话了。我还把这个演讲翻译了分享给大家：</p>
<p><a href="../translation-language-design-in-the-service-of-software-engineering/">Go 在 Google：服务于软件工程的语言设计（翻译）</a></p>
<p>我个人看这篇文章的感受是受益匪浅。Rob 在 8 年前 Go 1 时提到的内容，8 年后仍然有效。8 年里 Go 的语言设计只是在保持兼容的基础上做了微调，更多的投入，是在运行时和工具链的改进上。他们从一开始就知道要做什么，怎么到达。作为对比，很多语言流行后的主要用途跟当年创造的目的大相径庭：一开始的目标没有达成，却意外收获了一个新阵地，然后被新的状况推着前进。</p>
<p>而这几个从 贝尔实验室 干到 Google ，参与过创造 Unix、Plan 9、UTF-8 再到 Go 的老大爷（Ken 今年 77 岁，Rob 也 64 岁了），四五十年的开发生涯，清楚地知道在工程实践中，什么是重要的。</p>
<h2 id="语法与风格"><a href="#语法与风格" class="headerlink" title="语法与风格"></a>语法与风格</h2><p>Go 的语法大致是类似 C 语言的，有 C 族语言经验的话，很容易习惯，没有也不难学。这里只是提几个比较特别的点。这些语言风格和惯例的内容，一开始就要接触到，又很难归入哪个话题，先留个印象，后续如果涉及到会再次说明。</p>
<h3 id="命名在前的声明"><a href="#命名在前的声明" class="headerlink" title="命名在前的声明"></a>命名在前的声明</h3><p>这可能是最显眼的差别。Go 里面所有的声明，都是统一的 <code>关键字 命名 定义内容</code> 这样的顺序。Rob 称这样的语法为『类型语法（type syntax）』，而是 C 的语法是『表达式语法（expression syntax）』。</p>
<p>Go 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常量</span></div><div class="line"><span class="comment">// 声明是 = 前面部分。常量必须在声明同时绑定值，否则编译器会报 'missing constant value'</span></div><div class="line"><span class="keyword">const</span> Pi <span class="keyword">float64</span> = <span class="number">3.14</span></div><div class="line"></div><div class="line"><span class="comment">// 变量</span></div><div class="line"><span class="comment">// 变量可以只声明，此时变量的值为对应类型的零值。</span></div><div class="line"><span class="keyword">var</span> Name <span class="keyword">string</span></div><div class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span></div><div class="line"><span class="keyword">var</span> iPtr *<span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="comment">// 类型</span></div><div class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></div><div class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">// 结构体内部也是名称在前</span></div><div class="line">    <span class="comment">// 只是外面已经有了 struct &#123;&#125;，不需要再给关键字了</span></div><div class="line">    Count <span class="keyword">int</span></div><div class="line">    Price <span class="keyword">float64</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数</span></div><div class="line"><span class="comment">// func 可以当做关键字</span></div><div class="line"><span class="comment">// 只是名称 Add 和 函数体定义之间没有空格隔开而已</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> a + b</div><div class="line">&#125;</div><div class="line"><span class="comment">// func 也可以当做类型</span></div><div class="line"><span class="keyword">var</span> mul <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><span class="title">int</span> = <span class="title">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> a * b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 甚至连 import 语句都满足这个规则</span></div><div class="line"><span class="comment">// 当然，多数情况下，用默认包名即可，不需要给包命名，所以中间的命名可以省略</span></div><div class="line"><span class="keyword">import</span> mylog <span class="string">"example.com/lib/log"</span></div><div class="line"><span class="comment">// 没有指定名称，就是用它原来的包名，一般为路径最后一级目录，即 log</span></div><div class="line"><span class="keyword">import</span> <span class="string">"another.com/different/log"</span></div></pre></td></tr></table></figure>
<p>阅读代码时，经历一个『是什么——什么名字——具体内容』理解的过程，还是很自然的。关键是，不同的声明都很统一，不需要切换思维模式。用 Rob 的话说，无论对人对计算机来说，都好解析。</p>
<p>C 的表达式语法，大部分情况下不过不失，但是考虑上数组和指针，情况就变得脑筋急转弯起来：</p>
<p>（如果你没有接触过 C 族语言，以下对比可以先跳过）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI = <span class="number">3.14</span>;</div><div class="line"></div><div class="line"><span class="comment">// 变量（等于是因为变量最常用，比其他声明少一个关键字）</span></div><div class="line"><span class="keyword">int</span> val;</div><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> *iPtr</div><div class="line"></div><div class="line"><span class="comment">// 结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">float</span> price;</div><div class="line">&#125; Goods;</div></pre></td></tr></table></figure>
<p>C 是很多人接触计算机的第一门语言，不知道你初学时是否有过跟我类似的困惑：</p>
<p><code>array[10]</code> 的类型是 <code>int</code> ，这我知道了，数组在哪？是 <code>array[10]</code> 还是 <code>array</code> ？</p>
<p>同样 <code>*iPtr</code> 的类型也是 <code>int</code> ，但 <code>*iPtr</code> 是什么东西？指针在哪里？</p>
<p>表达式语法试图通过告诉我们『变量引用时指向什么』，来让我们知道『这是个什么变量』；下标引用得到 <code>int</code> ，就是 int 数组，这有点跳跃；声明的数字是大小而不是下标，容易产生 <code>array[10]</code> 是 <code>int</code>  那 0 到 9 呢的疑惑；最主要的问题，还是 <code>array[10]</code> 视觉上连在一起，需要特意去识别，这在复杂的函数指针上就更严重了。这是个历史遗留问题，这么多年我们早已习惯，但不代表这就不糟糕。</p>
<p>相比之下，<code>var array [10]int</code> 和 <code>var iPtr *int</code> 就直接多了，起码变量名一眼可见，没有粘连；类型也很好理解，<code>[10]int</code> 10 个 int 的数组，<code>*int</code> 指向 int 的指针。</p>
<p>好比向别人介绍一款他没见过的食物，正常情况应该是『它的名字叫饺子（array），馅料是猪肉末（[10]int）』；没有人会上来就『饺子馅（array[10]）是猪肉末（int）』，对方会疑惑，这个食物叫 饺子馅？</p>
<h3 id="首字母大小写控制可见性"><a href="#首字母大小写控制可见性" class="headerlink" title="首字母大小写控制可见性"></a>首字母大小写控制可见性</h3><p>Go 没有常见的 <code>public</code> 和 <code>private</code> 关键字，而是 <strong>靠名称首字母的大小写来控制可见性</strong>。因为代码组织的单位是包（package），包内都是可见的，区别在于是否能被包外面访问。</p>
<p>首字母大写的名称像 <code>Name</code> 称为导出（exported）标识符，包外可以访问，相当于 public；除此以外的情况，像 <code>name</code> 或者 <code>_name</code> 对包外都不可见，相当于 private。这条规则对所有标识符，包括常量、变量、类型、函数、方法、字段 …… 统统有效。你只要看一眼名字，就能知道是否可以被包外访问，不需要再查看声明。</p>
<p>唯一的例外是内置类型，像 <code>int</code> 、<code>float64</code>  、<code>string</code> 、 <code>map</code> 都是未导出标识符，但却可以全局访问，甚至连导入（import）都不用。</p>
<p>Go 支持下划线命名（又叫蛇形命名 snake case，像 <code>snake_case</code>），但不推荐。按惯例除模块名和包名以外，推荐所有标识符都是用驼峰式命名（camel case，像 <code>CamelCase</code> 或者 <code>camelCase</code>），包括常量。</p>
<h3 id="格式化工具-gofmt"><a href="#格式化工具-gofmt" class="headerlink" title="格式化工具 gofmt"></a>格式化工具 gofmt</h3><p>大多数 IDE 会在保存时自动执行。如果你习惯使用记事本，手动执行一下也不难。<code>gofmt</code> 会把合法的 Go 代码格式化为统一的规范。它多管闲事到，缩进是 Tab 而不是空格，左花括号 <code>{</code> 不用换行，哪些地方有空格哪些没有，代码块之间要不要空行空多少行 …… 都管。</p>
<p>不要以为只是自带了一个工具这么简单。因为自带了，所以大家都有，不用额外安装第三方和产生不同的规范（即使有第三方，也是考虑兼容官方规范之后再增强）；因为有官方规范，所以大家不用争论那种风格好；提交时不会产生因为格式不同产生的差异和冲突 …… 等等。</p>
<p>请务必把这个功能用上。要么打开 IDE 的自动格式化，要么记得手动执行一下。</p>
<h3 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h3><p>Go 总是以清晰明确为第一目标，让人易读无歧义，让机器好解析编译快。所以 Go 不一味追求表达力强，甚至有点逆潮流地刻意区分一些语句和表达式，以避免某些单行长表达式的写法。</p>
<p>既然反正都是要换行的，分号就给省掉了。</p>
<p>而上面提到的声明格式，其实有省略的余地。</p>
<p>第一个是类型推断：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 省略了类型，根据字面量推断</span></div><div class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></div><div class="line"><span class="keyword">var</span> Name = <span class="string">"Golang"</span></div><div class="line"></div><div class="line"><span class="comment">// 其中变量还能进一步省略 var 关键字，改用变量短声明 := （不能用于全局变量）</span></div><div class="line"><span class="comment">// 以下 i 自动推断为 int 型，f 为 float64 型</span></div><div class="line">i := <span class="number">0</span></div><div class="line">f := <span class="number">0.0</span></div></pre></td></tr></table></figure>
<p>第二个是集中声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Pi = <span class="number">3.1415</span></div><div class="line">    prefix = <span class="string">"go:"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    Name <span class="keyword">string</span></div><div class="line">    array [<span class="number">10</span>]<span class="keyword">int</span></div><div class="line">    iPtr *<span class="keyword">int</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> (</div><div class="line">    <span class="comment">// ...</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 除了 func，都可以集中声明</span></div></pre></td></tr></table></figure>
<p>集中声明除了节省敲几个关键字的时间，更重要的是让同类声明放在一起，更有条理。</p>
<h2 id="常量-与-变量"><a href="#常量-与-变量" class="headerlink" title="常量 与 变量"></a>常量 与 变量</h2><p>啰嗦一番之后，这里正式进入本期的主题。内容较多，如果通读有压力，可以跳着看留个印象，遇到问题回来翻阅。</p>
<p>在下一期的数据类型之前，先讲常量 和 变量。我们从 值（value）说起。</p>
<p>计算机科学中，值是指『无法进一步求值的表达式（expression）』。像 <code>1 + 3</code> 这个式子，可以进一步求值得到 <code>4</code>，但是 4 已经无法进一步简化，那么 4 就是一个值，是 <code>1 + 3</code> 这个表达式（还有 <code>2 + 2</code> 、 <code>5 - 1</code> …… 还有 <code>4</code> 本身）的值。简单一点理解，可以认为本质上就是一个 数。</p>
<p>当需要用到一个值，就需要表示、储存和引用它，涉及到三种量（quantity）：字面量、常量、变量。</p>
<h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1. 常量"></a>1. 常量</h3><p>广义上的常量包括 字面量。</p>
<p>字面量又被称作 <strong>无名常量（unnamed constant）或 字面常量 （literal constant）</strong>。与之对应，一般所说的常量因为关联了标识符，又被称作 <strong>有名常量（named constant）</strong>。</p>
<p>字面量 和 常量 在很多语言里，底层实现都类似甚至一致，都是 编译期确定、储存在静态只读数据区、值不能修改，而且很多使用场景，两者都能互相替代。</p>
<p>但是，多数语言（包括 Go）只支持基本类型的（有名）常量，所以严格来说，字面量 和 常量 不能等同。派生类型想表示一个固定的值，只能使用字面量，或者用变量的同时对修改加以限制。</p>
<h4 id="1-1-字面量"><a href="#1-1-字面量" class="headerlink" title="1.1 字面量"></a>1.1 字面量</h4><p><strong>字面量（literal）是源码中对一个固定值的表示</strong>。换言之，它的值，如字面所示。</p>
<p>几乎所有类型都有对应的字面量表示方法。基本类型的字面量举例：</p>
<ul>
<li>整型数（int）： <code>1</code> ， <code>2</code> ， <code>100</code> ， <code>1000</code> ， <code>0b101</code> （二进制 5）， <code>0xff</code> （十六进制 255）；</li>
<li>浮点数（float）： <code>1.0</code> ，<code>1.1</code> ，<code>1e4</code> （科学记数法 10000）；</li>
<li>字符（byte）：<code>&#39;a&#39;</code> ， <code>&#39;B&#39;</code> ；</li>
<li>字符串（string）：<code>&quot;字符串被双引号包围&quot;</code> ，还有一种反引号（<code>Esc</code> 键下方的键）包裹的字符串；</li>
<li>……</li>
</ul>
<p>需要注意的是，<code>bool</code> 没有字面量，在其它语言被定义为字面量的 <code>true</code> 和 <code>false</code> ， 在 Go 是内置的 <code>bool</code> 型的（有名）常量。</p>
<p>对于派生类型，字面量的表示是在类型后面加花括号 <code>{}</code> ，并在花括号内指定成员的值（如有），未指定的成员则为零值。例如 <code>a := [4]int{7}</code> 得到这样一个数组 <code>{7, 0, 0, 0}</code> 。具体到介绍具体类型时讨论。</p>
<p>在实际使用上，那些可以在编译期确定的值，像编译期求值的 表达式 和 内置函数返回值，也可以近似看作字面量（无名常量），因为编译器会求值并用得到的值替换它们。</p>
<h4 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h4><p>常量（constant，关键字 <code>const</code>）则是<strong>编译期就确定的，在程序运行中不能被修改的有名值</strong>。</p>
<p>因为需要在编译期就确定值，常量必须在声明时就指定它的值，而且只能是 <strong>引用 字面量 或其它 常量 的表达式 或 内置函数的返回值</strong> ；编译器会对表达式或内置函数求值，原来的表达式或函数不再保留：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    Pi        = <span class="number">3.14</span> <span class="comment">// 字面量</span></div><div class="line">    R         = <span class="number">1</span>&lt;&lt;<span class="number">2</span> <span class="comment">// 引用了字面量的表达式，等价于 R = 4</span></div><div class="line">    Area      = Pi * R * R <span class="comment">// 引用了其它常量的表达式，等价于 Area = 50.24</span></div><div class="line">    Name      = <span class="string">"Rob"</span> + <span class="string">" "</span> + <span class="string">"Pike"</span> <span class="comment">// 字符串字面量的连接表达式，等价于 Name = "Rob Pike"</span></div><div class="line">    NameLen   = <span class="built_in">len</span>(Name) <span class="comment">// 引用常量的内置函数返回值，等价于 NameLen = 8</span></div><div class="line">    ComplexA  = <span class="number">2</span> + <span class="number">3i</span> <span class="comment">// 复数字面量</span></div><div class="line">    RealA     = <span class="built_in">real</span>(ComplexA) <span class="comment">// 内置函数求实部，等价于 RealA = 2.0 （real 返回的是浮点数）</span></div><div class="line">    ImagA     = <span class="built_in">imag</span>(ComplexA) <span class="comment">// 内置函数求虚部，等价于 ImagA = 3.0</span></div><div class="line"></div><div class="line">    AreaSqrt  = math.Sqrt(Area) <span class="comment">// 报错！ math.Sqrt() 不是语言内置的函数</span></div><div class="line">    Perimeter = Pi * Diameter <span class="comment">// 报错！Diameter 是变量，编译时无法确定值</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    Diameter <span class="keyword">int</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// Go 支持局部声明的常量</span></div><div class="line">    <span class="comment">// 局部声明只是限定了有效作用域（这个例子里，main 函数以外无法引用 local）</span></div><div class="line">    <span class="comment">// 局部常量依然满足常量的所有特征，在编译期就确定值并且不再修改</span></div><div class="line">    <span class="keyword">const</span> local = <span class="number">42</span></div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所述，常量可以看作给字面量绑定了一个名称，后续用名称引用。</p>
<p>实际上，在程序里使用 <code>Pi</code> （声明为 <code>const Pi = 3.14</code>）和直接使用字面量 <code>3.14</code> 的效果是完全一样的。两种做法 在 Go 里，甚至连生成的汇编代码都几乎一样，常量名实际上只在代码里起作用，编译后都是替换成直接访问存放在 SRODATA （即 static read-only data，静态只读数据）区的值。</p>
<p>既然效果一样，为什么需要常量呢？一般基于以下两个理由：</p>
<ul>
<li><p>通过命名提高可读性：命名可以描述一个值的用途，提供值以外的信息，提高代码的可读性。</p>
<p>  试想在一个程序里，既需要用到 π 的近似值 3.14，然后刚好另外有一个常数也是 3.14 （例如，计算材料时，某种标准石膏柱的体积是 3.14 立方米）。那么如果都直接使用字面量 <code>3.14</code> ，编码中就需要额外的精力去区分 <code>3.14</code> 究竟是指哪一个。而如果改用标识符 <code>Pi</code> 和 <code>Volume</code> ，就非常明确了。</p>
<p>  这种光看字面量无法识别含义的值，称为魔数（Magic Number），是开发中需要避免的。</p>
</li>
<li><p>命名还能提高代码的可维护性：命名常量只需要修改声明处的值，就能改变所有引用的值。</p>
<p>  还是 3.14 的例子。如果后面石膏柱的体积改变了，变为 10。那么我们就要把所有含义为石膏柱体积的 <code>3.14</code> 改为 <code>10</code> ；与此同时，π 的值当然没有变，含义为 π 的 <code>3.14</code> 必须保持不变。又或者 π 的值需要提高精度到 <code>3.141593</code> ，保持另一个常数不变。 当这两个值在代码中被大量引用时，即使有搜索功能的辅助，要正确地把值改过来，既不遗漏也不错改，也是一件吃力不讨好的差事。</p>
<p>  如果使用了常量，就只需要修改常量声明处的值即可。</p>
</li>
</ul>
<p>反过来说，如果一个字面量满足以下至少一点，就应该考虑定义为常量：</p>
<ul>
<li>不能光从字面量和使用上下文看出含义（即魔数）；</li>
<li>相同含义的字面量在代码中多处反复出现。</li>
</ul>
<p><strong>再次提醒注意的是，在 Go 里面常量（的底层实现）只能为 基本类型</strong> （即 布尔型、数字类型、字符串类型 3 类，后面会讲到）， 不可以是各种派生类型。</p>
<h5 id="1-2-1-自动补全"><a href="#1-2-1-自动补全" class="headerlink" title="1.2.1 自动补全"></a>1.2.1 自动补全</h5><p>对于集中声明的常量，编译器允许省略标识符以外的内容，省略的部分自动补全为上一行的内容。注意，要自动补全， <strong>常量</strong> 和 <strong>集中声明</strong> （共用一个 <code>const</code> 关键字）这两个条件缺一不可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    b <span class="comment">// 自动补全 int64 = 1，注意，连类型信息也补全了</span></div><div class="line">    c <span class="comment">// 仍然 int64 = 1</span></div><div class="line">    </div><div class="line">    d <span class="comment">// 空行后补全仍然有效</span></div><div class="line">    </div><div class="line">    s, t = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    u, v <span class="comment">// 自动补全</span></div><div class="line">    w, _ <span class="comment">// 因为补全为两个右值，如果要跳过需要显式提供 空标识符（下划线 '_'）</span></div><div class="line">    _, x <span class="comment">// 当然也能跳过第一个</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    b <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    c <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    </div><div class="line">    d <span class="keyword">int64</span> = <span class="number">1</span></div><div class="line">    </div><div class="line">    s, t = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    u, v = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    w, _ = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">    _, x = <span class="string">"类型推断"</span>, <span class="string">"字符串"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>错误示范：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a <span class="keyword">int</span> = <span class="number">10</span></div><div class="line"><span class="keyword">const</span> b <span class="comment">// 不是集中声明，报错 'missing constant value'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    c = <span class="number">3.6</span></div><div class="line">    d <span class="keyword">float64</span> <span class="comment">// 只允许有标识符（命名），不能指定类型；指定了类型就不会自动补全，报错 'missing constant value'</span></div><div class="line">    </div><div class="line">    e, f = <span class="string">"允许同时声明多个不同类型"</span>, <span class="literal">true</span></div><div class="line">    g <span class="comment">// 报错！因为 true 没有标识符对应，需要空标识符显式跳过</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h5 id="1-2-2-常量计数器-iota"><a href="#1-2-2-常量计数器-iota" class="headerlink" title="1.2.2 常量计数器 iota"></a>1.2.2 常量计数器 iota</h5><p>除此之外，Go 还预定义了一个特殊的标识符 <code>iota</code> （iota 是第九个希腊字母的发音），来方便定义常量。</p>
<p><code>iota</code> 的值的变化规律是：遇到 <code>const</code> 就归零，每遇到一行常量声明（无论是否引用 <code>iota</code>）就加一。或者换句话说，<code>iota</code> 是 <code>const</code> 声明块的声明行行号（从 0 开始）。看例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a = <span class="literal">iota</span> <span class="comment">// 0</span></div><div class="line">    <span class="comment">// 空行、注释行不算</span></div><div class="line">    b = <span class="literal">iota</span> <span class="comment">// 1</span></div><div class="line">    c = <span class="number">999</span> <span class="comment">// 尽管没有引用 iota，iota 还是自增为 2</span></div><div class="line">    d = <span class="literal">iota</span> <span class="comment">// 3</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>结合 自动补全，能够大大简化一些有规律的常量声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A, B, C, D, E 五档评价</span></div><div class="line"><span class="comment">// A 最好加 2 分，C 不好不坏，E 最差 扣 2 分，以此类推</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    E = <span class="literal">iota</span> - <span class="number">2</span> <span class="comment">// 0 - 2</span></div><div class="line">    D <span class="comment">// 1 - 2</span></div><div class="line">    C <span class="comment">// 2 - 2</span></div><div class="line">    B <span class="comment">// 3 - 2</span></div><div class="line">    A <span class="comment">// 4 - 2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 声明 一个字节上 每个比特位的掩码</span></div><div class="line"><span class="comment">// 涉及左位移操作，有兴趣可以自行查阅位操作的知识，后续有机会再展开</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    mask0 <span class="keyword">uint8</span> = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span></div><div class="line">    mask1</div><div class="line">    mask2</div><div class="line">    mask3</div><div class="line">    mask4</div><div class="line">    mask5</div><div class="line">    mask6</div><div class="line">    mask7</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    a = <span class="literal">iota</span> <span class="comment">// 0</span></div><div class="line">    b <span class="comment">// 1</span></div><div class="line">    _ <span class="comment">// 可以用空标识符跳过，这里 iota 为 2</span></div><div class="line">    c <span class="comment">// 3</span></div><div class="line">    d, e = <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// 都是 4</span></div><div class="line">    f, g <span class="comment">// 都是 5</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>这样声明还有一个好处：有些常量对具体的值没有要求，但是要求一组常量之间总是保持一个先后关系；用 <code>iota</code> 声明，就不需要一个一个手动输入后续的值；而当需要加入新的常量时，直接插入中间，后续的值会自动后延。</p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p>因为常量要在编译期确定，而且后续无法修改，所以无法保存在运行时运算得到的值，也无法在运行过程中对值进行修改。这时就需要用到变量了。</p>
<p>变量（variable，关键字 <code>var</code>），本质上是 <strong>一个关联了标识符（命名）的储存地址，用来保存 允许运行时确定或者改变的值</strong>。稍复杂一点的程序，都很难不使用中间结果直接运算出最终结果，变量允许我们 储存、引用、修改 中间结果，把复杂的运算层层分解成简单运算，再把中间结果拼接成最终结果。所以变量是实际编程最常打交道的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">    <span class="comment">// 1. 仅声明，变量被初始化为类型对应的零值，这里 int 的零值为 0</span></div><div class="line">    a <span class="keyword">int</span></div><div class="line">    <span class="comment">// 2. 声明同时赋初始值</span></div><div class="line">    b <span class="keyword">float32</span> = <span class="number">3.14</span></div><div class="line">    <span class="comment">// 3. 类型推断</span></div><div class="line">    <span class="comment">// c 的类型跟 b 一致</span></div><div class="line">    c = b</div><div class="line">    <span class="comment">// d 的类型根据字面量 3.14 推断为 float64（下面讲为什么）</span></div><div class="line">    d = <span class="number">3.14</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    s := <span class="string">"局部变量可以使用 短声明"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 Go 的局部变量还有两个常量和全局变量没有的特点：</p>
<ul>
<li>可以使用短声明；</li>
<li>声明了必须使用。</li>
</ul>
<h4 id="2-1-短声明"><a href="#2-1-短声明" class="headerlink" title="2.1 短声明"></a>2.1 短声明</h4><p>前面在语法与风格部分有提到，可以省略常量和变量声明中的类型，让编译器根据赋值的字面量推断类型。</p>
<p>而局部变量还能更进一步，把 <code>var</code> 关键字也省略掉，改用短声明赋值符号 <code>:=</code> （就是冒号后面紧接等号），表示声明同时赋值的语义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 局部变量是指在函数或者代码块内部声明的变量，与之对应的是全局（包级）变量</span></div><div class="line"><span class="comment">// 只有局部变量可以使用短声明</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 1. 完整声明，赋值不是必须的；如果不赋值，则初始化为零值</span></div><div class="line">    <span class="keyword">var</span> a <span class="keyword">int</span></div><div class="line">    <span class="comment">// 2. 类型推断，根据赋值推断类型</span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">3.14</span></div><div class="line">    <span class="comment">// 3. 短声明，连 var 关键字也省略</span></div><div class="line">    c := <span class="string">"声明一个变量 c，同时根据赋值推断类型"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是严格来说，短声明跟 <code>var</code> + 类型推断还是有区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function2</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// var + 类型推断</span></div><div class="line">    <span class="keyword">var</span> a = <span class="number">1</span></div><div class="line">    <span class="keyword">var</span> a, b = <span class="number">2</span>, <span class="number">3</span> <span class="comment">// 报错，a 被重复声明了</span></div><div class="line">    </div><div class="line">    <span class="comment">// 短声明</span></div><div class="line">    x := <span class="number">2.78</span></div><div class="line">    x := <span class="number">3.14</span> <span class="comment">// 报错，x 被重复声明了</span></div><div class="line">    x, y := <span class="number">3.14</span>, <span class="string">"不会报错，短声明的左边只要至少声明了一个新变量即可"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>var</code> 关键字后面跟着的，都必须是新声明的变量；而短声明则意味着『至少声明了一个新变量』，不需要都是新变量。这种特性加上局部变量遮盖（shadow），容易产生一些非常难以察觉的错误，所以短声明要谨慎使用：</p>
<ul>
<li>引用范围很广，引用位置距离声明比较远的变量，不要用短声明；</li>
<li>除非是用完即弃的临时变量，不要用短声明同时声明 / 赋值 多个变量。</li>
</ul>
<h4 id="2-2-局部变量未使用错误"><a href="#2-2-局部变量未使用错误" class="headerlink" title="2.2 局部变量未使用错误"></a>2.2 局部变量未使用错误</h4><p>Go 不允许局部变量定义了却不使用。这是一个编译错误，不是警告。常量 和 全局（包级）变量 无此限制，只有局部变量有。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function3</span><span class="params">()</span></span> &#123;</div><div class="line">    a := <span class="number">2</span> <span class="comment">// 编译错误：'a declared but not used'</span></div><div class="line">    a = <span class="number">3</span> <span class="comment">// 赋值（写）不算，必须是引用了变量的值</span></div><div class="line">    </div><div class="line">    b := <span class="number">6.18</span></div><div class="line">    <span class="comment">// 以下任意一种都算对 b 有效使用</span></div><div class="line">    c := b <span class="comment">// 赋值给其它变量；不过这时 c 如果不用又要报错了</span></div><div class="line">    b + <span class="number">1</span> <span class="comment">// 作为表达式的一部分；不过这时 b + 1 作为一个整体 'is not used'</span></div><div class="line">    fmt.Println(b) <span class="comment">// 作为函数参数</span></div><div class="line">    _ = b <span class="comment">// 赋值给空标识符也算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-作用域（scope）-与-遮盖（shadow）"><a href="#3-作用域（scope）-与-遮盖（shadow）" class="headerlink" title="3. 作用域（scope） 与 遮盖（shadow）"></a>3. 作用域（scope） 与 遮盖（shadow）</h3><p>无论 常量 还是 变量，都不允许重复声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">777</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">888</span> <span class="comment">// 重复声明</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="number">3.14</span></div><div class="line"><span class="keyword">var</span> b = <span class="number">3.1415</span> <span class="comment">// 重复声明</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">    c := <span class="string">"第一次声明"</span></div><div class="line">    c := <span class="string">"重复声明，报错"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是以下代码却是合法的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">777</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="number">3.14</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">const</span> a = <span class="number">888</span> <span class="comment">// 正常</span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">3.1415</span> <span class="comment">// 正常</span></div><div class="line">    fmt.Println(a, b) <span class="comment">// 888 3.1415</span></div><div class="line"></div><div class="line">    c := <span class="string">"外部 c"</span></div><div class="line">    <span class="comment">// 这个 if 随便写的，纯粹为了制造一个新的代码块，switch、for 代码块也一样</span></div><div class="line">    <span class="keyword">if</span> b &gt; <span class="number">0</span> &#123;</div><div class="line">        c := <span class="string">"if 代码块里的 c"</span></div><div class="line">        fmt.Println(c) <span class="comment">// if 代码块里的 c</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(c) <span class="comment">// 外部 c</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">otherFunc</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 外部常量 / 变量的值并没有被覆盖</span></div><div class="line">    fmt.Println(a, b) <span class="comment">// 777 3.14</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是因为常量 / 变量有作用域。第二个例子里面，后声明的 <code>a, b, c</code> 实际上是 <strong>不同作用域下的新常量 / 变量</strong>，所以不会产生『重复声明』的错误，它们可以同时存在。</p>
<p>而在引用的时候，会从引用位置的作用域开始往外查找，引用最近作用域的值。一旦更内层的作用域声明了新的 常量 / 变量，外部的值就无法引用到，这种情况称为 遮盖（shadow，又译作 遮挡、隐藏）。</p>
<p>多数语言都是这样的设计。但是在 Go 里，遮盖 跟 变量短声明 放在一起，很容易产生不起眼的错误。先看正常的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    result := <span class="number">0</span></div><div class="line">    <span class="comment">// 省略一些中间过程</span></div><div class="line">    result, success := tryPerform() <span class="comment">// 只有 success 是新声明的变量</span></div><div class="line">    <span class="keyword">if</span> !success &#123;</div><div class="line">        <span class="comment">// 失败时的处理</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(result) <span class="comment">// 42</span></div><div class="line">    <span class="comment">// 后续用 result 参与其它运算...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryPerform</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">    <span class="comment">// 如果执行成功，返回 运算结果 和 true</span></div><div class="line">    <span class="comment">// 否则 返回 0 和 false</span></div><div class="line">    <span class="comment">// 这里为了简化逻辑，直接返回固定值</span></div><div class="line">    <span class="keyword">return</span> <span class="number">42</span>, <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后很自然地，随着其他代码的加入， <code>main</code> 函数改成了这样（<code>tryPerform</code> 函数不变）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    result := <span class="number">0</span></div><div class="line">    <span class="comment">// 尝试其它操作，结果保存在 result</span></div><div class="line">    <span class="comment">// result = ...</span></div><div class="line">    <span class="comment">// 这里假设 0 表示无效结果，还得继续尝试</span></div><div class="line">    <span class="keyword">if</span> result == <span class="number">0</span> &#123;</div><div class="line">        result, success := tryPerform() <span class="comment">// 注意，两个都是新变量，result 发生了 shadow</span></div><div class="line">        <span class="keyword">if</span> !success &#123;</div><div class="line">            <span class="comment">// 失败时的处理</span></div><div class="line">        &#125;</div><div class="line">        fmt.Println(result) <span class="comment">// 内层 result，42</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(result) <span class="comment">// 外层 result，还是 0</span></div><div class="line">    <span class="comment">// 后续用 result 参与其它运算都是错的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键是，这个错误编译器无法检查出来，因为 <code>:=</code> 有歧义，在声明多个变量时，同时混合了 <strong>赋值</strong> 和 <strong>声明</strong> 的语义。在第一份代码中，<code>result</code> 已经存在，同时新变量 <code>success</code> 满足了短声明至少声明一个新变量的要求，所以短声明『很聪明』地理解了 <code>result</code> 只是要赋值。当因为某些修改，创建新的作用域时，在这个作用域内 <code>result</code> 还没被声明（尽管可以访问到外层的 <code>result</code>），短声明又『很聪明』地声明了新的 <code>result</code> 。</p>
<p>这导致超出预期的行为。</p>
<p>解决办法也很简单：<strong>大跨度（特别是跨作用域）使用的变量，不要用短声明，老老实实用 <code>var</code> 关键字</strong>。<code>var</code> 很明确地告诉我们，是新声明的变量，没有 <code>var</code> 则只是赋值。视觉上，<code>var</code> 关键字比等号前的冒号好辨认；语义上不存在歧义，编译器很容易发现错误。</p>
<p>需要特别提醒一下的是，在代码块开头声明的变量，作用域也限于代码块内，哪怕声明位置在花括号 <code>{}</code> 以外：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> result, ok := tryPerform(); !ok &#123;</div><div class="line">        <span class="comment">// 失败处理</span></div><div class="line">        fmt.Println(result) <span class="comment">// 正常</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(result) <span class="comment">// result 未声明</span></div><div class="line">    </div><div class="line">    <span class="comment">// for 循环等代码块也一样</span></div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">        <span class="comment">// 循环体</span></div><div class="line">        fmt.Println(i) <span class="comment">// 正常</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(i) <span class="comment">// i 未声明</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果变量在代码块之后还需要引用，就应该在代码块之外事先声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// i 在 for 代码块之前声明</span></div><div class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</div><div class="line">        <span class="comment">// 循环体</span></div><div class="line">    &#125;</div><div class="line">    fmt.Println(i) <span class="comment">// 11</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-类型、推断与转换"><a href="#4-类型、推断与转换" class="headerlink" title="4. 类型、推断与转换"></a>4. 类型、推断与转换</h3><p>Go 是静态强类型（static strongly typed）语言。换句话说，Go 的类型是编译期确定的（静态），而且需要显式的类型转换（强类型）。在这个基础上，Go 又引入了类型推断（隐式类型 implicity typed，但类型仍然是在编译期可以推导得到，运行时不允许修改，仍然是静态强类型），加上 常量 和 变量 的处理不一样，显得好像有点复杂。下面梳理一下。</p>
<p>字面量、常量 和 变量 放在这里一起讲，做个对比。</p>
<p><strong>Go 有两种意义上类型</strong> ：</p>
<ul>
<li><p>一个是显式的类型 <code>type</code> 。</p>
<p>  它可以在声明时指定，也可以在赋值时推断出来。在绝大多数语境下，<strong>当我们提到『类型  type』这个术语，说的就是这个类型。没有指定类型称为无类型 <code>untyped</code></strong> 。</p>
</li>
<li><p>一个是编译器根据 字面量 或 表达式的值 推断得到的 <strong>常量专用类型</strong>  <code>Ctype</code> （constant type 的缩略）。</p>
<p>  编译器源码里的注释是：</p>
<blockquote>
<p>Ctype describes the constant kind of an “ideal” (untyped) constant.</p>
</blockquote>
<p>  翻译过来就是：Ctype 描述了一个理想情况下的（无类型）常量的常量种类。</p>
<p>  换言之，<code>Ctype</code> 是 <code>untyped</code> 常量（包括字面量）特有的，是作为没有显式 <code>type</code> 时的补充的隐式类型。一个值允许在逻辑上没有类型，也就是无类型 <code>untyped</code> ；但这个值又有储存、运算 的需要，所以编译器就给它推断一个 <code>Ctype</code> （和对应的默认 <code>type</code>）。</p>
</li>
</ul>
<p>一个常量，如果显式指定了 <code>type</code>，就没有 <code>Ctype</code>  的事；如果没有指定，则根据绑定的值确定，究竟是有类型 <code>type</code> 还是无类型 <code>untyped Ctype</code>。</p>
<p>对于绝大多数类型，这两者差别不大，只是 <code>untyped</code> 逻辑上没有类型，允许自动转换（当然还需要满足转换规则，除数字类型以外的类型，都必须底层类型一致才能转换），一般的使用没有差别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">bool</span> = <span class="literal">true</span> <span class="comment">// a 的类型是 bool；true 本身的类型是 untyped bool （后面的 bool 是 Ctype）</span></div><div class="line">    aa     = a <span class="comment">// aa 虽然没有指定类型，但跟 a 一样，类型是 bool</span></div><div class="line">    b      = <span class="literal">true</span> <span class="comment">// b 没有指定类型，类型是 untyped bool</span></div><div class="line">    bb     = b <span class="comment">// bb 和 b 都没有指定类型，类型是 untyped bool</span></div><div class="line">    </div><div class="line">    c <span class="keyword">string</span> = <span class="string">"有类型"</span> <span class="comment">// c 的类型是 string</span></div><div class="line">    d        = <span class="string">"无类型"</span> <span class="comment">// d （以及两个字符串字面量）的类型是 untyped string</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>a  和 b（以及 aa、bb），c 和 d， 在语义上有差别，但不涉及类型转换的话，使用上完全没差别。</p>
<p>因为不同的数字类型之间允许转换，<code>type</code> 和 <code>Ctype</code> 的差异 <strong>主要体现在数字类型上。</strong></p>
<p>因为还没讲到，先稍微列一下数字类型：</p>
<p><img src="../../images/golang-in-action-day2/number-type.png" alt=""></p>
<p>其中特殊类型里，<code>byte</code> 是 一个字节的 ASCII 字符（<code>uint8</code> 的别名）， <code>rune</code> 是四个字节的 Unicode 字符（<code>int32</code> 的别名），可以归为字符类型；<code>uintptr</code> 实际上也是一个整型，只是这个数字表示一个内存地址。</p>
<table>
<thead>
<tr>
<th>大类</th>
<th>type</th>
<th>Ctype（默认 type / 储存宽度）</th>
</tr>
</thead>
<tbody>
<tr>
<td>整型</td>
<td>uint8, int8, uint16, int16, uint32, int32, uint64, int64, uint, int, uintptr</td>
<td>int （int）</td>
</tr>
<tr>
<td>浮点数</td>
<td>float32, float64</td>
<td>float（float64）</td>
</tr>
<tr>
<td>复数</td>
<td>complex32, complex64</td>
<td>complex（complex64）</td>
</tr>
<tr>
<td>字符</td>
<td>byte, rune</td>
<td>rune（rune，即 int32）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>整型看起来很多类型，其实只是 有没有符号 和 位宽 的差别，下一期讲基本类型会讲。</p>
</blockquote>
<h4 id="4-1-字面量"><a href="#4-1-字面量" class="headerlink" title="4.1 字面量"></a>4.1 字面量</h4><p>字面量无法指定 <code>type</code> ，只有 <code>Ctype</code> 。</p>
<p>数字类型可以分为四个大类（kind），每个大类下面根据表示范围又可以分为很多个类型（type）。每个大类对应一个 <code>Ctype</code> ，同时对应一种默认的 <code>type</code> 。<strong>字面量会根据表示形式，自动推断为对应的 <code>Ctype</code> ，并以默认类型储存。</strong></p>
<h5 id="整型数"><a href="#整型数" class="headerlink" title="整型数"></a>整型数</h5><p>整型数字面量会被推断为 <code>untyped int</code> ，默认类型为 <code>int</code> （<code>int</code> 的位宽与架构相关，64 位系统为 64 位，32 位系统为 32 位）。</p>
<p>以下字面量都被认为是整型数（二进制和八进制从 1.13 开始支持）：</p>
<ul>
<li>十进制整数（即没有小数部分），如 <code>159</code> 。</li>
<li>二进制整数，为了区分以 <code>0b</code> 或 <code>0B</code> 开头（大写有效，但 <code>gofmt</code> 会自动格式化为小写，下同），如  <code>0b10011111</code> （即十进制 159）。</li>
<li>八进制整数，以 <code>0</code> 、 <code>0o</code> 或 <code>0O</code> 开头，如 <code>0o237</code> （即十进制 159）。</li>
<li>十六进制整数，以 <code>0x</code> 或 <code>0X</code> 开头，如  <code>0x9f</code> （即十进制 159）。</li>
</ul>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>浮点数字面量会被推断为 <code>untyped float</code> ，默认类型则为 <code>float64</code> 。</p>
<p>浮点数的字面量形式有：</p>
<ul>
<li><p>普通十进制小数，如 <code>15.9</code> ；整数和小数部分都可以为零，<code>1.0</code> 和 <code>0.0</code> 虽然 和 <code>1</code> 和 <code>0</code> 值是一样的，但是推断类型不同。</p>
</li>
<li><p>整数或者小数部分如果为零，可以省略，但不能同时省略（毕竟不能只剩下一个小数点），如 <code>.9</code> 等同于 <code>0.9</code> ， <code>1.</code> 等同于 <code>1.0</code> 。</p>
</li>
<li><p>科学记数法：十进制整数或符合前面两条的浮点数 + <code>e</code> / <code>E</code> + 十进制整数的指数，如 <code>1.59e2</code> 表示 $ 1.59 \times 10^2 $ 也就是 159，<code>314E-2</code> 表示 $ 314 \times 10^{-2} $ ，即 3.14 。 </p>
</li>
<li><p>从 1.13 开始，支持十六进制的科学记数法：十六进制的整数或小数 + <code>p</code> / <code>P</code> + 十进制整数作为指数，如 <code>15.9p7</code> 表示 $ (1 \times 16^1 + 5 \times 16^0 + 9 \times 16^{-1} ) \times 2^7 $ （即十进制的 2760）；<code>p</code> 后的指数是以 2 为底的，注意指数即使为 0 也不能省略。</p>
<p>  这种表示法用于二进制（十六进制）小数比十进制清晰简单，像 <code>0x.01p0</code> ，对应十进制的 0.00390625；一般很少用到，了解一下即可，不展开。</p>
</li>
</ul>
<h5 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h5><p>复数字面量会被推断为 <code>untyped complex</code> ，默认类型为 <code>complex128</code> 。</p>
<p>复数由实部和虚部组成。实部和虚部分别都是一个整型数或者浮点数，只是虚部后面跟着一个 <code>i</code>；实部和虚部允许用不同的进制分别表示，具体规则参考整型数和浮点数部分。只是为了兼容 1.13 以前的旧代码，虚部的八进制必须以 <code>0o</code> 或 <code>0O</code> 开头， <code>0</code> 开头会被当做十进制的前导零。</p>
<p>例如 <code>159 + 7i</code> ，实部 159，虚部 7；<code>0111 + 010i</code> 实部为 73（八进制），虚部为 10；等等。实部如果为零，可以省略；但虚部不可以省略：<code>0i</code> 会被认为是复数，<code>0</code> 和 <code>0.0</code> 则分别被认为是 整型数 和 浮点数——尽管它们都是零值，值是相等的。</p>
<p><br></p>
<p>从数学上讲，浮点数（小数）是复数的特例（虚部为 0）；整型数则是浮点数的特例（小数部分为 0）。但是从计算机更有效储存和运算的角度，需要把它们区分开来，一直为 0 的部分，就不必开辟储存空间。</p>
<p>从 1.13 开始，允许在数字中间加下划线 <code>_</code> 作为分段符来提升字面量的可读性。按英文惯例每三位加一个分段符，那么 十万八千 就写作 <code>108_000</code> ；对于十六进制数，一般每两位（一个字节）作为一个分段，如 <code>0x_15_ef</code>。当然这只是惯例，也可以根据需要分段。分段符每次只能加一个，只能加在数字之间或者进制前导符和数字之间。这个实际试一下就知道了。</p>
<h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><p>字符字面量会被推断为 <code>untyped rune</code> ，默认类型为 <code>rune</code>。</p>
<p>两种字符类型只是两种整型数的别名。</p>
<blockquote>
<p>字符及字符串相关部分会涉及到字符编码的知识，篇幅关系，不一一展开。初学者如果觉得难以理解，可以先跳过，先使用普通字符字面量。</p>
</blockquote>
<p><code>byte</code> 对应 <code>uint8</code> ，储存的是 1 字节长度的 Unicode 码（相当于 Unicode 开头 ASCII 码加上 Latin-1 辅助字符部分）；</p>
<p><code>rune</code> 对应 <code>int32</code> ，储存的是一个 4 字节长度的 Unicode 码。</p>
<p>字符型的字面量均以单引号 <code>&#39;</code> 包裹，形式有：</p>
<ul>
<li><p>普通字符，如 <code>&#39;a&#39;</code> （十进制码值 97），<code>&#39;汉&#39;</code> （十进制码值 27721，十六进制 0x6c49）。</p>
</li>
<li><p>码值转义，又分四种情况：</p>
<ul>
<li><code>\</code> 后接 3 位八进制数，前导零不能省略，如 <code>&#39;\141&#39;</code> 对应十进制码值为 97，即 <code>&#39;a&#39;</code> ；<code>&#39;\041&#39;</code> 对应十进制码值 33，即 <code>&#39;!&#39;</code> ，不能写作 <code>&#39;\41&#39;</code> ；3 位八进制数最大能表示十进制的 511，但由于这种表示法用来表示 1 字节的 Unicode，大于 377  （即十进制 255）的值均无效。</li>
<li><code>\x</code> 后接 2 位十六进制数，前导零不能省略，表示 1 字节长度的 Unicode，<code>&#39;a&#39;</code> 表示为 <code>&#39;\x61&#39;</code> 。</li>
<li><code>\u</code> 后接 4 位十六进制数，前导零不能省略，表示 2 字节长度的 Unicode （或者说高 2 位为 0 的 4 字节 Unicode），<code>&#39;a&#39;</code> 表示为 <code>&#39;\u0061&#39;</code> ；这个范围已经可以表示大部分的常用汉字了（严格说是『中日韩统一表意文字』的 初期统一汉字 + 扩展 A 区），如 <code>&#39;汉&#39;</code> 表示为 <code>&#39;\u6C49&#39;</code> 。</li>
<li><code>\U</code> （大写 U）后接 8 位十六进制数，前导零不能省略，表示完整 4 字节的 Unicode ，这个范围已经可以表示绝大多数的 Unicode 字符了（Unicode 标准仍在扩展中）， <code>&#39;a&#39;</code> 表示为 <code>&#39;\U00000061&#39;</code> ，<code>&#39;汉&#39;</code> 表示为 <code>&#39;\U00006C49&#39;</code> 。</li>
</ul>
</li>
<li><p>如果 <code>\</code> 后面接的字符不是 数字、<code>x</code> 、<code>u</code> 或 <code>U</code> ，则被当做转义字符。转义字符实际上是常用的不可见字符的表示方式，避免记忆 Unicode 码值，常见的转义有：</p>
<ul>
<li><code>&#39;\b&#39;</code> 退格符（backspace），对应 <code>&#39;\x08&#39;</code> ，作用是光标往左一个字符，有些情况下意味着删除一个字符；</li>
<li><code>&#39;\n&#39;</code> 换行符（newline），对应 <code>&#39;\x0A&#39;</code> ，作用是光标往下一行；</li>
<li><code>&#39;\r&#39;</code> 回车符（carriage return），对应 <code>&#39;\x0D&#39;</code> ，作用是光标回到行首；</li>
<li><p>……</p>
<p>比较特殊的是 <code>&#39;\\&#39;</code> 和 <code>&#39;\&#39;&#39;</code> ，就表示 <code>\</code> 和 <code>&#39;</code> ，并非不可见字符；但由于单个符号有特殊含义，必须转义才能原义输出。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>以上内容总结起来就是：数字类型的字面量，根据具体形式，会被推断为 4 种 <code>Ctype</code> ，并按范围最大的类型作为默认类型储存（整型除外，<code>int</code> 不能包含整型的最大范围）。</p>
<h5 id="值溢出（overflow）"><a href="#值溢出（overflow）" class="headerlink" title="值溢出（overflow）"></a>值溢出（overflow）</h5><p>超出默认类型范围的值，会引起溢出错误，无法储存和使用。整型比较特殊，默认底层类型是 <code>int</code> ：在 64 位系统为 64 位有符号数，<code>1 &lt;&lt; 63</code> 到 <code>1 &lt;&lt; 64 -1</code> 之间的数可以以 <code>uint64</code> 储存；在 32 位系统为 32 位有符号数，<code>uint32</code> 、<code>int64</code> 、<code>uint64</code> 都有超出 <code>int</code> 的范围；当然如果连 <code>int64</code> （负数最大范围）和 <code>uint64</code> （正数最大范围）都超了，还是只能溢出。</p>
<p>网上有教程说，<strong>字面量（和常量）不限范围，这种说法是错的</strong>。他们的依据是以下的代码可以正常编译运行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 超出了 int 的最大值 1 &lt;&lt; 63 - 1 （64 位系统）</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 其它操作，唯独没有引用 a</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子里，如果看了生成的汇编代码就会发现，<code>a</code> 和 <code>1 &lt;&lt; 64 - 1</code> 都不见了。因为编译器很聪明地发现，<code>a</code> 没有被引用到，在编译时就把它们优化删除掉了，所以没有报错。</p>
<p>还有这个例子也可以正常运行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 超出了 int 的最大值 1 &lt;&lt; 63 - 1 （64 位系统）</span></div><div class="line">    b = a &gt;&gt; <span class="number">2</span> <span class="comment">// 等价于 b = 1 &lt;&lt; 62</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看了汇编结果就会知道，编译器实际上把上面的代码里的 <code>a</code> 优化掉了，<code>b</code> 绑定的值变成了 <code>4611686018427387904</code> （<code>1 &lt;&lt; 62</code>）。</p>
<p>换言之，<strong>溢出的字面量只能存在于代码里，而且溢出值不能超出显式类型范围，不能被直接引用</strong> 。如果这个溢出的值，经过编译器求值之后发现，是一个可以优化的中间值，实际上没有被引用，编译器就不会报错；反之，如果有溢出值被引用到了，或者虽然没有直接引用溢出值，但超出了显式类型的范围，就会报 overflow：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 字面量被自动推断为 untyped int，报错 1 &lt;&lt; 64 - 1 (untyped int constant 18446744073709551615) overflows int</span></div><div class="line">    fmt.Println(<span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span>)</div><div class="line">    <span class="comment">// 显式转换为 uint64 后正常</span></div><div class="line">    fmt.Println(<span class="keyword">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span>))</div><div class="line"></div><div class="line">    <span class="comment">// 1&lt;&lt;64 连 uint64 的范围也超出了，报错 cannot convert uint64</span></div><div class="line">    fmt.Println(<span class="keyword">uint64</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span>))</div><div class="line">    <span class="comment">// float32 又可以了</span></div><div class="line">    fmt.Println(<span class="keyword">float32</span>(<span class="number">1</span>&lt;&lt;<span class="number">64</span>))</div><div class="line"></div><div class="line">    <span class="keyword">const</span> a <span class="keyword">int8</span> = <span class="number">128</span> <span class="comment">// 报错！虽然 a 会被优化掉，但因为指定了类型，超出显式类型范围可能隐藏着错误</span></div><div class="line">    <span class="keyword">const</span> b = a / <span class="number">2</span> <span class="comment">// b 的类型也是 int8，128 / 2 = 64 可以存得下</span></div><div class="line">    fmt.Println(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于转换，在下面会提到。</p>
<h4 id="4-2-常量"><a href="#4-2-常量" class="headerlink" title="4.2 常量"></a>4.2 常量</h4><p>（有名）常量则有可能有 <code>type</code> ，也可能无类型只有 <code>Ctype</code> 。</p>
<p>常量在声明时：</p>
<ul>
<li>没有指定 <code>type</code> ，常量的类型跟绑定的值一致，前面用 <code>bool</code> 和 <code>untyped bool</code> 、<code>string</code> 和 <code>untyped string</code> 举过例子；</li>
<li>指定了 <code>type</code> ，如果跟绑定的右值类型不一致，就涉及到转换；如果无法转换，就报错。</li>
</ul>
<p>常量被引用时，类型与所需类型不一致，就需要转换，这时要看常量的类型。</p>
<h5 id="无类型（untyped）"><a href="#无类型（untyped）" class="headerlink" title="无类型（untyped）"></a>无类型（untyped）</h5><p>Go 是强类型语言，必须显式转换类型，但这仅限于类型确定 <code>typed</code> 的情况，<code>untyped</code> 会隐式转换。<strong>常量的转换跟变量不同，要求值要相等</strong>。只要一个 <code>untyped</code> 值可以以另一种类型表示，编译器会做自动的隐式转换；但转换过程中不允许有任何溢出（和因此导致的截取（truncated））；而浮点数除了溢出，还有精度丢失，浮点数之间的转换中允许精度丢失。</p>
<p>溢出和精度丢失的差别，用一个简化的十进制字符串的例子来说明：</p>
<p>假定我们用一个长度为 8 的字符串储存一个小数，符号和小数点不能省略，那么可以表示的最大和最小的数分别是 “+999999.” 和 “-999999.” ，比前者大就是上溢出，比后者小就是下溢出。与此同时，最小精度（非零绝对值最小）是 “+.000001” ，比这更小的值无法表示。1000000（6 个 0）要转换为 “+000000.” 保存是溢出后截取低位，0.1234567 转换为 “+.123456” 保存则是精度丢失。</p>
<p>浮点数的二进制指数表示比这个复杂，还涉及到编码和进制转换，但溢出和精度丢失的原理是一致的。一句话总结就是，精度范围内超出是溢出，精度范围以外超出是精度丢失。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 整型</span></div><div class="line">    a        = <span class="number">1.0</span> <span class="comment">// a 为 untyped float，默认类型是 float64</span></div><div class="line">    b <span class="keyword">int</span>    = a <span class="comment">// 1.0 可以无截取转换为 int 类型 1，类型自动转换</span></div><div class="line">    c <span class="keyword">int</span>    = <span class="number">1.1</span> <span class="comment">// 报错！转换到 int 类型不允许截取整数部分丢弃小数</span></div><div class="line">    d <span class="keyword">int</span>    = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 报错！范围上溢出</span></div><div class="line">    e <span class="keyword">uint64</span> = <span class="number">1</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span> <span class="comment">// 正常</span></div><div class="line">    </div><div class="line">    f      = <span class="number">128</span> <span class="comment">// untyped int</span></div><div class="line">    g <span class="keyword">int8</span> = f <span class="comment">// 报错！上溢出， int8 的最大值为 127，即使 g int8 = int8(f) 显式转换也不行</span></div><div class="line">    </div><div class="line">    <span class="comment">// 浮点数</span></div><div class="line">    <span class="comment">// 注: float64 的最大值是 1.797693134862315708145274237317043567981e+308</span></div><div class="line">    h <span class="keyword">float64</span> = <span class="number">1.8e308</span> <span class="comment">// 报错！上溢出</span></div><div class="line">    i         = <span class="number">1.8e308</span> <span class="comment">// 也报错！类型为 untyped float，默认类型就是 float64</span></div><div class="line">    j         = <span class="number">1.79769313486231581e+308</span> <span class="comment">// 报错！上溢出</span></div><div class="line">    k         = <span class="number">1.7976931348623158e+308</span> <span class="comment">// 正常，但是后面部分在二进制上已经超出精度范围，超出部分已丢弃， k 的值 跟 float64 的最大值一样</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>从十进制角度看，浮点数在某一位左边就是溢出，右边就是精度丢失，会非常费解。因为实际上这些数是以二进制保存的，从二进制的角度看就会顺理成章。这里不展开，有兴趣的朋友可以自己去看 IEEE-754 的标准。</p>
<p>一般程序不容易超出这些范围，但还是需要知道范围的存在。<code>math</code> 包有一系列常量给出了不同数字类型的最小值（MinXXX）、最大值（MaxXXX）和浮点数的最小小数（SmallestXXX）。如果涉及大数运算和对精度有特殊需求，则需要用到 <code>math/big</code> 包。</p>
<p>理解 整型数 和 浮点数 的转换之后，复数 和 字符 也很好理解。</p>
<p>复数的实部和虚部分别是一个浮点数，复数之间的转换可以直接参考浮点数。虚部为 0 的复数可以向浮点数自动转换，实部如果没有小数部分还能向整型转换；但是虚部不为 0 不能被截断（truncated）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a         = <span class="number">256</span> + <span class="number">0i</span> <span class="comment">// untyped complex</span></div><div class="line">    b         = a <span class="comment">// 还是 untyped complex</span></div><div class="line">    c <span class="keyword">float64</span> = a <span class="comment">// 虚部为 0，自动转换</span></div><div class="line">    d <span class="keyword">int</span>     = a <span class="comment">// 实部的小数部分也为 0，可以转换为 int</span></div><div class="line">    </div><div class="line">    e <span class="keyword">float64</span> = <span class="number">256</span> + <span class="number">1i</span> <span class="comment">// 虚部不为 0，无法截断为浮点数</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>字符则本质上就是整型，只是字面量形式不同：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    <span class="comment">// 以下的自动转换都是合法的</span></div><div class="line">    a <span class="keyword">int</span>  = <span class="string">'a'</span> <span class="comment">// 97</span></div><div class="line">    b <span class="keyword">byte</span> = <span class="number">97</span> <span class="comment">// 也是 97，只是 用 %c 动词作为字符格式化会得到 a</span></div><div class="line">    </div><div class="line">    c <span class="keyword">int</span>   = <span class="string">'汉'</span> <span class="comment">// 27721</span></div><div class="line">    d <span class="keyword">rune</span>  = <span class="number">27721</span> <span class="comment">// 也是 27721，只是作为字符输出会得到 汉</span></div><div class="line">    e <span class="keyword">int16</span> = <span class="string">'汉'</span> <span class="comment">// '汉' 虽然是一个 rune（即 int32）字面量，但是 27721 没有超出 int16 的范围</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h5 id="确定类型（typed）"><a href="#确定类型（typed）" class="headerlink" title="确定类型（typed）"></a>确定类型（typed）</h5><p>自动转换限于 <code>untyped</code> ，如果一个常量已经指定了类型，那么哪怕值满足了转换条件，也必须显式转换；而且在显式转换中，值仍然要保持相等（显式转换是 <code>T(src)</code> ，T 是目标类型，src 是来源值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    a <span class="keyword">int16</span> = <span class="number">128</span> <span class="comment">// 明确给 a 指定了类型，不是 untyped int 了</span></div><div class="line">    b       = a <span class="comment">// b 的类型也是 int16</span></div><div class="line">    c <span class="keyword">int32</span> = a <span class="comment">// 报错！cannot use int16 as int32，尽管 int32 存 int16 完全存得下</span></div><div class="line">    d <span class="keyword">int32</span> = <span class="keyword">int32</span>(a) <span class="comment">// 显式转换，正常</span></div><div class="line">    e       = <span class="keyword">int32</span>(a) <span class="comment">// 反正都显式转换类型了，左边的类型声明可以省略</span></div><div class="line">    f       = <span class="keyword">int8</span>(a) <span class="comment">// 报错！显式转换也不行，int8 最大值是 127，常量不能截取值的一部分</span></div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3 变量"></a>4.3 变量</h4><p>变量一定有显式的类型 <code>type</code> ，不存在 <code>untyped</code> 的变量。</p>
<p>变量声明时，类型可以指定，也可以推断；如果声明时没有指定 <code>type</code> ，则类型跟赋值的右值一致；如果右值是 <code>untyped</code> 常量，则类型是对应的默认类型（而不是 <code>Ctype</code> ，数字类型的默认类型分别是 <code>int</code> ，<code>float64</code>，<code>complex128</code>，<code>rune</code>）。</p>
<p>跟常量类似，变量被引用时也会出现与需要的类型不一致，需要转换类型：</p>
<ul>
<li><p>由于变量一定有确定类型 （<code>typed</code>），只能是显式转换。</p>
</li>
<li><p>非常量（包括变量）的转换允许溢出也允许精度丢失：</p>
<ul>
<li>整型（包括字符型）在高位宽向低位宽类型转换时如果溢出，直接丢弃高位保留低位，如 256（二进制 100000000，8 个 0）向 <code>int8</code> 转换时，保留低 7 位（去掉一位符号位，<code>int8</code> 数字位只有 7 位），得到 0 。</li>
<li>浮点数转整型，直接丢弃小数部分（绝对值变小）；如果得到的整型还是溢出，参考上一条继续转换；如 257.1 向 <code>int8</code> 转换，得到 1。</li>
<li>整数或浮点数转浮点数，允许发生精度丢失，如 <code>1&lt;&lt;64 - 1</code> （18446744073709551615，最大的 <code>uint64</code>）转 <code>float32</code> 得到 <code>1.8446744e+19</code> ，73709551615 丢失。</li>
<li><strong>非常量的复数不允许直接转换成其他数值类型</strong>，只能通过内置函数 <code>real()</code> 和 <code>imag()</code> 提取实部和虚部；复数之间转换，实部和虚部分别是一个浮点数，跟浮点数之间的转换一致，也允许精度丢失。</li>
<li>除整型以外的转换，如果来源值溢出目标范围，结果不确定，依赖于具体的编译器实现；目前我测试的版本（1.15）是会产生无穷值（浮点数是 <code>+Inf</code>  和 <code>-Inf</code> ，复数则是具体实部或虚部是无穷）。</li>
</ul>
</li>
</ul>
<h4 id="4-4-其它情况"><a href="#4-4-其它情况" class="headerlink" title="4.4 其它情况"></a>4.4 其它情况</h4><p>注意到我在提到变量的转换时，提到了『非-常量』（注意断句），而不是直接说变量。</p>
<p>难道还存在常量和变量以外的量？是的。</p>
<p>首先是前面提到的，可以在编译期求值的 表达式 和 内置函数的返回值，实际使用上跟字面量一致，差别是 字面量一定是 <code>untyped</code> 的，而这种值视乎具体情况，有可能是有类型的。不过 <strong>转换规则仍然跟常量一致，差别仅仅是没有标识符，算广义的常量</strong>：</p>
<ul>
<li><p>仅引用了字面量 / 常量的 内置函数返回值，如 <code>len(&quot;1234&quot;)</code> ，字符串 <code>&quot;1234&quot;</code> 是字面量，<code>len()</code> 是内置函数，字符串的长度在编译期就可以算出来是 4，这个值在编译的时候就会替换掉函数；但类型受函数返回值影响为 <code>int</code> ，跟 <code>4</code> 这个整型字面量的 <code>untyped int</code> 仍然有差别（有了确定类型就不能自动转换）。</p>
<p>  相对地，如果 <code>a</code> 不是常量，那么 <code>len(a)</code> 就不能在编译期求值了；内置函数则是指不需要导入就可以调用的函数，<code>math.Abs()</code> 这样还要导入的函数不算（尽管是官方库）。</p>
</li>
<li><p>仅引用了字面量 / 常量的 表达式的值，如 <code>1 + 2 + 3</code> 就不必说了， <code>len(&quot;1234&quot;) + 1.1</code> 也是。</p>
<p>  类型方面，如果表达式引用了多种类型，则会往一个统一类型转换，然后以该类型运算。范围窄的向范围广的类型转，<code>untyped</code> 往 <code>typed</code> 转；如果有多个不同的 <code>type</code> ，则需要显式转换。如果无法统一类型，就会报错。如 <code>1 + 2</code> 的类型是 <code>untyped int</code> ；<code>1 + 2.0</code> 是 <code>untyped float</code> ；<code>len(&quot;1&quot;) + 1.0</code> 是 <code>int</code> ；而 <code>len(&quot;1&quot;) + 1.1</code> 会报错，因为确定类型 <code>int</code> 无法自动转换，而 <code>1.1</code> 自动转换成 <code>int</code> 会造成截取，丢弃小数。</p>
</li>
</ul>
<p>然后跟第一种情况相反，表达式或函数里出现了 <strong>非常量或者非内置函数</strong>，就无法编译期求值。它既不是常量，又没有像变量给一个内存空间，实际运行中可能会在编译器生成的临时变量或者寄存器上保存和运算。这就是前面提到的 『非-常量』。</p>
<p>不过这里只是提一下它们的存在，转换方式其实没有超出上述的情况的组合：</p>
<ul>
<li><p>看类型，如果是 <code>typed</code> 就必须显式转换；<code>untyped</code> 则可以自动转换；</p>
</li>
<li><p>看是否常量（广义的，包括字面量），是常量就必须值相等不允许值的截取；常量以外则允许值按一定规则截取。</p>
</li>
</ul>
<p>这样一组合，一共就四种情况而已，上面提到的那么多种情况都包括在内。</p>
<p>需要注意的是，当赋值时涉及转换，转换规则按 <strong>来源值</strong> 决定，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">1.1</span></div><div class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = a <span class="comment">// a 赋值给 b 类型不一致，涉及类型转换</span></div></pre></td></tr></table></figure>
<p>就属于 <code>untyped float</code>  常量 转换为 <code>int</code> ：<code>untyped</code> 允许自动转换，但是常量决定了不能截断小数，会报错。</p>
<h4 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h4><p>到这里，想再提一下强类型的显式转换。</p>
<p>可以看到， <code>untyped</code> 的值允许自动转换。字面上的理解，就是『无类型』（尽管底层实现需要保存需要运算，带着一个默认类型）没有类型限制，值可表达为对应类型，就可以自动转换。</p>
<p>那么相对地，有类型 <code>typed</code> 的值需要显式转换（程序员主动表达意图），就是一种设计上的有意为之，让类型系统承担了一部分的逻辑表达功能。</p>
<p>因为还没讲到，解释一下自定义类型： <code>type NewInt int</code> 定义了一个自定义类型 <code>NewInt</code>，它的底层类型是 <code>int</code> ，会具有 <code>int</code> 的内置行为，并且能增加自定义行为（方法）。但是 Go 会认为它们是完全不同的两个类型，直接运算会报错，必须显式转换；当然，两个底层类型同为 <code>int</code> 的自定义类型之间也是一样。 <code>int</code> 转 <code>int8</code> 虽然都是整型，毕竟位宽不同范围不同，需要显式转换还可以理解为担心值溢出；那么 <code>int</code> 和 <code>NewInt</code> 之间的转换，就是纯粹出于行为和逻辑上的考虑。</p>
<p>举个例子，地板、砧板 两种自定义类型，底层实现都是木板。为了简化讨论，我们姑且认为是一样的木板，并没有额外的特殊加工。即使是这样，在使用中，两者还是不能搞混。如果在弱类型环境中，不去检查木板的类型，只要能用就给你用，可能出现：『这砧板怎么有个鞋印』『这地板怎么有肉沫菜叶』这样的问题。</p>
<p>自动转换的假设是，程序员清楚知道自己要做什么，编译器不应该干预增加工作量；显式转换的假设是，程序员有可能出错，编译器要帮忙检查类型的不匹配，这里面可能隐藏着逻辑错误。</p>
<p>在需要快速写个脚本、刷个算法题的时候，强类型语言像自带啰嗦严谨的老管家，一旦做了不确定的事都要确认一下，写得很不爽。但如果是维护一个大型项目，在里面人工排查类型误用引起的错误，工作量可比增加一点确认大多了，最后往往还是得引入类型检查工具——等于最后还是去雇了一个管家，那为什么不一开始就让管家参与呢？老管家并不会真的干预你做事，只是需要你额外的确认；如果特殊情况，你明确表示要用地板切菜（显式转换），他也不会拦你。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>大家不要被上面的篇幅吓到，感觉光 常量 和 变量 都这么复杂。这是把 原理、边界情况 和 容易犯的错误 都给罗列出来。有些内容一般使用很难涉及，留个印象日后碰到知道往哪个方向排查；有些内容看着复杂，实际操作一遍其实很直观——<strong>IDE 都会有提示，并不需要人肉 check</strong>，这里只是让你知道为什么会报错。另外，还有部分内容涉及到类型系统的知识，需要结合下一篇类型的介绍一起理解。</p>
<p>下面给出一系列的 常量 和 变量声明，大家可以试着判断一下，哪些会报错、为什么；合法的声明具体是什么类型，值是多少。有自信的朋友可以试着人工检查一下，暂时做不到可以把代码补全之后实际运行一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写出以下 常量 和 变量 的类型和值，或者哪些声明会报错</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    A <span class="keyword">uint8</span> = B</div><div class="line">    B       = <span class="number">255</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    a <span class="keyword">uint64</span> = A / <span class="number">2</span></div><div class="line">    b <span class="keyword">int8</span>   = B / <span class="number">2</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    A := <span class="keyword">byte</span>(<span class="string">'0'</span>)</div><div class="line">    B := <span class="keyword">byte</span>(<span class="string">'1'</span>)</div><div class="line">    C := A - B</div><div class="line">    fmt.Println(C)</div><div class="line"></div><div class="line">    <span class="keyword">const</span> a = <span class="string">'0'</span></div><div class="line">    <span class="keyword">const</span> b = <span class="string">'1'</span></div><div class="line">    fmt.Println(<span class="keyword">byte</span>(a - b))</div><div class="line"></div><div class="line">    i := <span class="number">0x1e</span>+<span class="number">2</span></div><div class="line">    j := <span class="number">1e+2</span></div><div class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++ &#123;</div><div class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1</span>; j++ &#123;</div><div class="line">            <span class="comment">// 空循环体</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 现在 i, j 分别是多少</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Go语言101 / 《基本类型和它们的字面量表示》 ：<a href="https://gfw.go101.org/article/basic-types-and-value-literals.html" target="_blank" rel="external">https://gfw.go101.org/article/basic-types-and-value-literals.html</a></li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇《&lt;a href=&quot;../golang-in-action-day-1/&quot;&gt;Go 语言实战（1）： 初识&lt;/a&gt;》开了头，今天我们接着打卡。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 在 Google：服务于软件工程的语言设计（翻译）</title>
    <link href="https://jaycechant.info/2020/translation-language-design-in-the-service-of-software-engineering/"/>
    <id>https://jaycechant.info/2020/translation-language-design-in-the-service-of-software-engineering/</id>
    <published>2020-08-23T11:09:37.000Z</published>
    <updated>2020-10-26T09:45:49.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在写 Go 语言实战系列的文章，中间想聊一下 Go 的设计原则，发现自己理解得还是不够深入，写得辞不达意。然后找到了 Rob Pike 在 8 年前的演讲稿，拜读学习之后，想推荐给我的读者作为学习资料。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>结果在中文互联网只找到了 OSCHINA 上 13 年的众包翻译，再也没找到其他翻译版本。这个版本，不同译者，以及同一译者的不同段落，翻译水平差异极大：个别地方翻译得非常传神，更多时候是忠实的术语翻译，偶有生硬直译和机翻的感觉，同时也能找到一些明显的理解错误和低级的笔误。</p>
<p>总的来说，如果对 Go、C 家族语言 以及 并发、垃圾回收等 涉及的主题有一定了解，翻译的瑕疵不影响理解。译文翻译于 13 年，很早，应该对中文世界早期 Go 的推广起了一定的作用，向这些译者致谢。但是如果是刚接触编程或者 Go 语言的初学者，个别错误可能会让人看得云里雾里。</p>
<p>所以我不自量力地尝试自己翻译一遍。首先是试图提供一个质量稍微高一点点的版本（不一定能成功），其次也是希望通过这样再深入学习一遍。</p>
<p>为了符合中文的阅读习惯，在（尽量）不影响原意的前提下，一些句子（特别是长从句）的语序作了调整，个别不符合中文表达习惯的表述做了删减或者补充。文中的加粗也是我个人划的重点。水平所限，译文在（计算机）专业上和英语理解上不可避免地会有理解偏差乃至错误，存疑的地方请结合原文理解。翻译过程有借助 辞典 和 DeepL 翻译器作为参考，个别表述有借鉴 OSCHINA 版译文。</p>
</blockquote>
<p>原文：<strong>Go at Google: Language Design in the Service of Software Engineering</strong></p>
<p>地址：<a href="https://talks.golang.org/2012/splash.article" target="_blank" rel="external">https://talks.golang.org/2012/splash.article</a></p>
<p>作者：Rob Pike</p>
<p>翻译：Jayce Chant（博客：jaycechant.info，公众号ID： jayceio）</p>
<blockquote>
<p>Rob Pike：Unix 小组成员，参与了 Plan 9 计划，1992 年和 Ken Thompson 共同开发了 UTF-8。他和 Ken Thompson 也是 Go 语言最早期的设计者。</p>
</blockquote>
<h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h2><blockquote>
<p>这是 Rob Pike 2012 年 10 月 25 日在 亚利桑那州 图森市 举行的 SPLASH 2012 会议上发表的主题演讲稿的修订版。</p>
</blockquote>
<p>我们在 Google 开发软件基础设施时遇到一些问题，针对这些问题，Go 语言在 2007 年末被构思出来。今天的计算环境与正在使用的语言（主要是 C++、Java 和 Python）创建时的环境几乎毫无关系。多核处理器、网络系统、大规模计算集群和网络编程模型所带来的问题，人们只是用变通办法暂时绕开（being worked around），而不是正面解决（addressed head-on）。另外，软件的规模也发生了变化：今天的服务器程序由数千万行代码组成，需要成百上千的程序员共同协作，并且每天都在更新。更糟糕的是，即使是在大型编译集群上，构建（build）时间也会延长到几分钟，甚至几小时。</p>
<p><strong>设计和开发 Go 就是为了在这种环境下提高工作效率。</strong> Go 设计的考虑因素，除了众所周知的像 内置并发 和 垃圾回收，还包括 严格的依赖管理、软件架构在系统增长时的适应性，以及跨组件的健壮性。</p>
<p>本文将解释在构建一个高效的、编译型的、轻量级的、使人愉悦的编程语言的过程中，如何解决这些问题。例子 和 解释 都来自 Google 实际遇到的问题。</p>
<h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2. 简介"></a>2. 简介</h2><p>Go 是 Google 开发的一种编译型、支持并发、带垃圾回收、静态类型的语言。它是一个开源项目：Google 从公共代码库导入代码，而不是反过来。</p>
<p>Go 运行效率高、可伸缩性强，而且工作效率也高。有些程序员觉得用它干活很有趣；有些则觉得它缺乏想象力，甚至很无聊。在本文中，我们将解释为什么这些观点并不矛盾。<strong>Go 是为解决 Google 在软件开发中面临的问题而设计的，这导致 Go 并不是一门在研究领域有突破性的语言；尽管如此它仍是大型软件项目工程化的优秀工具。</strong></p>
<blockquote>
<p>译者注：这是 8 年前的演讲。Go 初期确实是为了解决 Google 内部的问题而诞生的。但如今已经是诞生的第 11 个年头，Go 早已被寄予更多的期待。它要解决的问题没变，只是不再局限于 Google 的内部场景。</p>
</blockquote>
<h2 id="3-Go-在-Google"><a href="#3-Go-在-Google" class="headerlink" title="3. Go 在 Google"></a>3. Go 在 Google</h2><p>Google 设计 Go 用来帮助解决 Google 自己的问题，而 Google 的问题很 <strong>大</strong>。</p>
<p>硬件大，软件也大。软件有好几百万行，服务器大部分用 C++，剩余的部分大量使用 Java 和 Python。成千上万的工程师在代码上工作，这些代码位于一个包含了所有软件的单棵大树的『头部』，所以树的各个层次一天到晚都有重要变更。使用大型的、定制的分布式构建系统使这种规模的开发变得可行，但它仍然很大。</p>
<p>当然，所有这些软件都运行在无数（zillions）台机器上，这些机器被看作数量不多的独立的、互相联网的计算集群。</p>
<p>简而言之，Google 的开发规模很大，速度可能很慢，而且经常显得很笨拙。但它是有效的。</p>
<p>Go 项目的目标，是消除 Google 软件开发中的缓慢和笨拙，从而使开发过程更加高效和获得更强的可伸缩性。<strong>这个语言是由编写、阅读、调试和维护大型软件系统的人设计的，也是为这些人设计的。</strong></p>
<p>因此，Go 的目的不是要做编程语言设计的研究，而是要改善语言设计者及其同事的工作环境。Go 考虑的更多是软件工程的问题，而不是编程语言方面的科研。换句话说，<strong>它围绕的是『服务于软件工程的语言设计』</strong>。</p>
<p>但是，一门语言如何对软件工程有所助益呢？本文剩下的内容就是对这个问题的回答。</p>
<h2 id="4-痛点"><a href="#4-痛点" class="headerlink" title="4. 痛点"></a>4. 痛点</h2><p>在 Go 刚推出时，有人声称，它缺少现代语言所必需的某些特性或方法论。缺少这些的 Go 能有什么价值呢？我们的回答是，Go 所具备的某些特性，可以解决严重困扰大规模软件开发的一些问题。这些问题包括</p>
<ul>
<li>构建速度慢</li>
<li>失控的依赖关系</li>
<li>每个程序员使用相同语言的不同子集</li>
<li>程序难以理解（代码难以阅读，文档不完善等）</li>
<li>重复劳动</li>
<li>更新代价大</li>
<li>版本偏斜（version skew）</li>
<li>难以编写自动化工具</li>
<li>跨语言构建</li>
</ul>
<p>一门语言的单个特性并不能解决这些问题。这需要有软件工程的大局观（larger view），所以在 Go 的设计中，我们试图把重点放在解决这些问题上。</p>
<p>作为一个简单而且独立的例子，我们来看一下程序结构的表示方式。一些观察者反对 Go 用花括号（<code>{...}</code>）来表示类似于 C 的块状结构，他们更喜欢用 Python 或 Haskell 风格的空格来缩进。然而，我们见过太多由跨语言构建引起的构建和测试失败：嵌入到另一种语言里的 Python 代码段（例如通过 SWIG 调用），会因为周围代码缩进的变化而被意外地破坏，而且非常难以察觉。因此，我们的观点是，虽然空格缩进对于小程序来说是不错的选择，但它并不具有大程序所需要的可伸缩性；而且代码库越大，异构性越强，就会带来越多的麻烦。<strong>为了安全和可靠，最好还是放弃这点便利</strong>，所以 Go 使用花括号表示的代码块。</p>
<h2 id="5-C-和-C-中的依赖关系"><a href="#5-C-和-C-中的依赖关系" class="headerlink" title="5. C 和 C++ 中的依赖关系"></a>5. C 和 C++ 中的依赖关系</h2><p>更能实质性地说明上面提到的可伸缩性和其他问题的，是包依赖关系的处理。我们从回顾 C 和 C++ 如何处理依赖关系开始讨论。</p>
<p>最早于 1989 年标准化的 ANSI C 在标准头文件里推广了 <code>#ifndef</code> 『防护（guards）』的概念。这个做法现在已经是无处不在，就是每个头文件都要用一个条件编译语句（clause）包裹起来，这样做就算这个头文件被多次包含（include）也不会出错。例如，Unix 头文件 <code>&lt;sys/stat.h&gt;</code> 的结构是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 大段的版权和许可证声明 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SYS_STAT_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _SYS_STAT_H_</span></div><div class="line"><span class="comment">/* 类型和其他定义 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>这样做的目的，是让 C 语言预处理器在第二次以及后续读到该文件时，忽略被包裹的内容。符号<code>_SYS_STAT_H_</code> 在第一次读取文件时被定义，避免（guards）了后续的调用。</p>
<p>这样设计有一些好处，最重要的是每个头文件可以安全地 <code>#include</code> 它所有的依赖，即使其他头文件也包含这些依赖，都不会有问题。如果遵循这个规则，并且按字母顺序排列 <code>#include</code> 语句，可以写出有条理的代码。</p>
<p><strong>但它的可伸缩性非常差。</strong></p>
<p>1984 年，有人发现编译 ps.c（Unix ps 命令的源码）时，整个预处理过程会遇到 37 次 <code>#include &lt;sys/stat.h&gt;</code> 。<strong>尽管后面 36 次头文件的内容都会被忽略，但大多数 C 语言的实现每次都会打开文件、读取文件、完整扫描内容，一连串动作下来，一共 37 次。</strong> 这样做非常不聪明，但是 C 预处理器需要处理非常复杂的宏语义，使它只能这样实现。</p>
<p>这对软件造成的影响是， C 程序里 <code>#include</code> 语句会不断累积。添加 <code>#include</code> 语句不会破坏程序，却很难知道什么时候不再需要它们。删除一条 <code>#include</code> 后再编译一次也检查不出来，因为可能另一条 <code>#include</code> 本身就包含你刚刚删除的那条  <code>#include</code>。</p>
<p>从技术的角度讲，没必要弄成这样子。意识到使用 <code>#ifndef</code> 防护的长期问题，Plan 9 库的设计者们采取了一种不同的、非 ANSI 标准的做法。在 Plan 9 里，头文件禁止包含更多的 <code>#include</code> 语句；所有的 <code>#include</code> 都要放在顶层 C 文件里。当然，这需要一些纪律：程序员需要按照正确的顺序、准确地列出必要的依赖关系；但文档可以帮上忙，而且在实践中效果非常好。这样做的结果是，无论一个 C 源文件有多少依赖，在编译该文件时，每个 <code>#include</code> 文件都只会被读取一次。而且，只要把 <code>#include</code> 语句先删掉就能很容易地看出来它是否必要：当且仅当删除的依赖不是必要的依赖时，编辑后的程序才能通过编译。</p>
<p>Plan 9 做法最重要的结果是编译速度更快：编译所需的 I/O 量比使用带有 <code>#ifndef</code> 防护的库时大大减少。</p>
<p>但在 Plan 9 之外，『防护』法仍是 C 和 C++ 的公认做法。事实上，<strong>C++ 在更细的粒度上使用同样的做法还加剧了这个问题</strong> 。按照惯例，C++ 程序的结构通常是每个类有一个头文件，也可能是一小组的相关类有一个头文件，这种分组方式比像 <code>&lt;stdio.h&gt;</code> 这样的头文件要小得多。因此，它的依赖树要复杂得多，反映的不是库之间的依赖关系，而是完整的类型层次结构。此外，C++ 头文件通常包含真正的代码——类型、方法和模板声明——而不仅仅是一般 C 头文件里常见的简单常量和函数签名。因此，C++ 不仅向编译器推送了更多的信息，而且推送的内容更难编译，编译器的每次调用都必须重新处理这些信息。在构建一个大型的 C++ 二进制文件时，编译器可能要成千上万次地处理头文件 <code>&lt;string&gt;</code> 去学会如何表示一个字符串。（据记录，1984 年左右，Tom Cargill 就提到，使用 C 预处理器进行依赖管理将是 C++ 的长期负担，应该加以解决。）</p>
<p>在 Google，构建一个 C++ 二进制文件，打开和读取不同的头文件可以达到数百个，次数可以达到数万次。2007 年，Google 的构建工程师对 Google 的一个主要二进制文件的编译进行了检测。这个二进制文件包含了大约两千个源文件，如果简单地连在一起，总共有 4.2 MB。在所有  <code>#include</code> 语句被展开后，超过 8 GB 内容被送到编译器的输入端，也就是源码里的每个字节膨胀了 2000 倍。</p>
<p>另一个数据是，2003 年，Google 的构建系统从单一的 Makefile 转变为每个目录都有 Makefile 的设计，有了更好的管理，更明确的依赖关系。仅仅是因为有了更精确的依赖关系记录，一个典型的二进制文件在文件大小上就缩减了 40%。即便如此，C++ （或 C 语言）的特性使得自动验证这些依赖关系难以实现，直到今天，我们对 Google 的大型 C++ 二进制文件的依赖关系需求仍然没有一个准确的把握。</p>
<p>依赖关系失控和规模太大的后果是，在单台计算机上构建 Google 服务器的二进制文件变得不切实际，一个大型的分布式编译系统应运而生。有了这个加了很多机器、很多缓存、很多复杂的东西的系统（构建系统本身就是一个大程序），Google 的构建总算可以进行，虽然还是很麻烦。</p>
<p>即使采用分布式构建系统，Google 的一次大型构建仍然需要很长时间。前面提到 2007 年的那个二进制程序使用上一版的分布式构建系统花了 45 分钟；同一程序今天的版本花了 27 分钟，当然这期间程序和它的依赖关系也还在增长。<strong>扩大构建系统的工程投入，只能勉强比它所构建的软件的增长速度领先一点。</strong></p>
<h2 id="6-走进-Go"><a href="#6-走进-Go" class="headerlink" title="6. 走进 Go"></a>6. 走进 Go</h2><p>当构建速度很慢时，就有了时间去思考。Go 有那么一个起源传说（origin myth），声称 Go 正是在其中一次 45 分钟的构建过程中被构思出来的。设计一门新的语言，使它适合编写像 Web 服务器这样的大型 Google 程序，同时考虑到软件工程的因素，可以提高 Google 程序员的生活质量。人们相信这个目标值得一试。</p>
<p>虽然到目前为止的讨论都集中在依赖关系上，但还有许多其他问题需要注意。一门语言要想在上述背景下取得成功，主要的考虑因素是：</p>
<ul>
<li>它必须适应大规模开发。能在有大量依赖关系、大量程序员团队一起协作的大型程序项目上很好地工作。</li>
<li>它必须是大家熟悉的，大致上类似于 C 语言的。在 Google 工作的程序员处于职业生涯的早期，对过程式编程语言（procedural languages），尤其是来自 C 家族的语言最熟悉。要想让程序员在新语言中快速提高工作效率，意味着语言不能太激进。</li>
<li>它必须是现代的。C、C++ 以及 Java 的某些方面都相当老旧，是在多核机器、网络 和 web 应用开发 出现之前设计的。新的做法可以更好地适应现代世界的一些特点，比如内置的并发支持。</li>
</ul>
<p>那么，在这样的背景下，让我们从软件工程的角度来看看 Go 的设计。</p>
<h2 id="7-Go-的依赖关系"><a href="#7-Go-的依赖关系" class="headerlink" title="7. Go 的依赖关系"></a>7. Go 的依赖关系</h2><p>既然我们已经详细了解过 C 和 C++ 中的依赖关系，那么我们可以从 Go 如何处理依赖关系开始。依赖关系是由语言在语法和语义上定义的。它们是明确的、清晰的和『可计算』的，也就是说，很容易写工具来分析。</p>
<p>Go 的语法是，在 <code>package</code> 语句（下一节的主题）之后，每个源文件可以有一个或多个导入语句，每个导入语句由 <code>import</code> 关键字和一个字符串常量组成，标识要导入到当前源文件（且只限当前源文件）的包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></div></pre></td></tr></table></figure>
<p>让 Go 可以做到规模化、依赖智能化的第一步，是语言将 <strong>未使用的依赖</strong> （unused dependencies）定义为编译期错误（注意不是警告，是错误）。如果源文件导入了一个它不用的包，程序就不会通过编译。这保证了任何 Go 程序构建中的依赖关系树都是精确的，没有多余的边。另一边又保证了在构建程序时不会有多余的代码被编译，从而最大限度地减少了编译时间。</p>
<p>第二步是在编译器的实现上，更进一步保证效率。假设一个有三个包的 Go 程序，依赖关系如下：</p>
<ul>
<li><code>A</code> 包导入了 <code>B</code> 包</li>
<li><code>B</code> 包导入了 <code>C</code> 包</li>
<li><code>A</code> 包没有导入 <code>C</code> 包</li>
</ul>
<p>这意味着 A 包只是在引用 B 包的过程中，间接地引用了 C 包；换句话说，尽管 A 引用的来自 B 的某些代码引用了 C，但在 A 的源码里没有直接涉及来自 C 的标识符。例如， A 包可能会引用一个在 B 里面定义的结构体类型，该结构体有一个字段的类型是在 C 里定义的，但 A 本身并不直接引用 C 里面的类型。一个更具体的例子是，A 导入了一个格式化 I/O 包 B，B 使用了 C 提供的缓冲 I/O 实现，但 A 本身并没有调用缓冲 I/O。</p>
<p>要构建这个程序，首先 C 被编译；被依赖的包必须在依赖它们的包之前构建。然后，B 被编译；最后 A 被编译，然后就可以链接程序。</p>
<p>在 A 被编译时，编译器读取的是 B 的目标文件而不是源代码。B 的目标文件包含了编译器在 A 的源代码里执行 <code>import &quot;B&quot;</code> 语句所需的所有类型信息。这些信息包括 B 的调用方（clients）在编译时需要的任何关于 C 的信息。换句话说，当 B 被编译时，生成的目标文件包含了 B 所有公共接口所需的依赖关系的类型信息。</p>
<p>这种设计的一个重要的效果，就是 <strong>当编译器执行一条 <code>import</code> 语句时，只会打开一个文件</strong> ，那就是导入语句里的字符串所标识的目标文件。这让人不由得想起 Plan 9 C（相对于 ANSI C）的依赖管理方法，但实际上编译器在编译 Go 源文件的时候就会写入头文件。考虑到导入时读取的数据只是『导出的（exported）』数据，而不是一般的程序源代码，这个过程比 Plan 9 C 更自动，甚至更高效。这对整体编译时间可以造成巨大的影响，还能随着代码库的增长弹性地伸缩。与 C 和 C++ 的 『include 文件里还有 include』的模式相比，生成依赖图（dependency graph）并编译的时间可以指数级地减少。</p>
<p>值得一提的是，这种通用的依赖管理方法并不是独创的，其思想可以追溯到 20 世纪 70 年代，流传于 Modula-2 和 Ada 等语言中。在 C 语言家族中，Java 也有这种方法的元素。</p>
<p>为了使编译更有效率，目标文件的内容是经过编排的，导出数据就在文件的开头，所以编译器只要读到导出数据的结尾就可以结束，不需要读取整个文件。</p>
<p>这种依赖管理方法是 Go 编译比 C 或 C++ 快的一个最大原因。另一个因素是 Go 把导出数据放在目标文件里，作为对比有些语言需要作者手写或编译器生成包含这些信息的另外的文件。这就需要打开两倍数量的文件。在 Go 里，导入一个包只需要打开一个文件。另外，单文件的方式意味着导出数据（类似 C / C++ 里的头文件）相对于目标文件来说，永远不会过时。</p>
<p>为了做一个对比，我们测量了一个用 Go 编写的大型 Google 程序的编译情况，看看源代码的扇出量与前面做的 C++ 分析相比如何。（译者注：这里指第五节提到的 C++ 头文件展开后的内容量和源代码的比值，为 2000 倍。）我们发现大约是 40 倍，比 C++ 好了 50 倍（同时也更简单，因此处理速度更快），但还是比我们预期的大。这有两个原因。首先，我们发现了一个 bug：Go 编译器在导出部分生成了大量不需要的数据。其次，导出数据使用的是一种冗长的编码，还有改进的余地。我们已经计划解决这些问题。（译者注：Go 在 2012 年 3 月才发布了 1.0 版本，到现在已经过去了 8 年多，到了 1.15 。这中间 Go 团队投入了大量时间在 编译器、运行时 和 工具链的优化上，这两个问题应该已经得到了很大的改善，甚至可能已经彻底解决。）</p>
<p>尽管如此，减少到五十分之一，就足以把几分钟变成几秒钟，把茶歇时间变成交互式构建。</p>
<p>Go 依赖图的另一个特点是它没有依赖环。<strong>语言定义了依赖中不能有循环导入</strong>，编译器和链接器都会检查确保不存在循环依赖。虽然循环导入偶尔有用，但它在规模上会带来严重的问题。循环导入要求编译器一次性处理更多的源文件，这就减缓了增量构建的速度。<strong>更重要的是，根据我们的经验，如果允许这样的导入，最终会把大片的源码树，纠缠成难以独立管理的几大块，使二进制文件膨胀，并使初始化、测试、重构、发布和其他软件开发任务变得复杂。</strong></p>
<p>缺少循环导入偶尔会造成烦恼，但却能保持依赖树的干净，迫使包之间有明确的边界。<strong>就像 Go 里的许多设计决策一样，它迫使程序员更早地考虑一个更大范围的问题（在这里，这个问题是包的边界），这些问题如果留到以后，可能永远不会得到令人满意的解决。</strong></p>
<p>Go 设计标准库的过程中，花费了大量精力在控制依赖关系上。<strong>如果只是需要一个函数，拷贝一点代码可能比直接拉来一个大库强。</strong>（如果出现新的核心依赖关系，系统构建中的测试就会报告问题。）依赖关系清晰胜过代码重用。实践中的一个例子是，（底层的）<code>net</code> 包有自己的 整型 到 小数 的转换程序，以避免依赖更大的、依赖关系更复杂的格式化 I/O 包。另一个例子是字符串转换包 <code>strconv</code> 有一个私有的 『可打印』字符定义的实现，而不是引入大块头的 Unicode 字符类表；<code>strconv</code> 通过包的测试来确保符合 Unicode 标准。</p>
<h2 id="8-包"><a href="#8-包" class="headerlink" title="8. 包"></a>8. 包</h2><p>Go 的包系统设计，将库、命名空间、模块的一些特性结合在一起，变成一个统一的结构。</p>
<blockquote>
<p>译者注：2012 年 Go 1.0 ，包管理使用的还是最简单的 GOPATH 模式。之后这种基于 Google 单一代码库的设计造成了各种不便，第三方包管理工具百花齐放。2015 年 Go 1.5 引入 Vendor 机制，到后面发现还是没有解决问题。第三方工具 dep 一度最有希望转正，结果 2018 年官方推出 vgo （后改名 Go Modules 并入 <code>go</code> 工具链）统一了机制，到 2020 年的 1.14 正式宣布 Go Modules “ready for production”。</p>
<p>跟 20102 相比，现在 Go 的包管理已经有了很多变化，最主要的是引入了 module 的概念。</p>
</blockquote>
<p>每一个 Go 源文件，例如 <code>&quot;encoding/json/json.go&quot;</code>，都会以一个 <code>package</code> 语句开始，像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> json</div></pre></td></tr></table></figure>
<p>其中 <code>json</code> 是 『包名』，一个简单的标识符。包名通常是简明扼要的。</p>
<p>要使用一个包，导入语句里的包路径标识了要导入的文件。『路径』的含义并未在语言中指定，但在实践中，按照惯例，它是源包在代码库里的目录路径，以斜杠 <code>/</code> 分隔，像：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></div></pre></td></tr></table></figure>
<p>然后，在导入的源文件（importing，调用方）里引用时，用包名（区别于路径）来修饰（qualify）被导入（imported）包的包中成员：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dec = json.NewDecoder(reader)</div></pre></td></tr></table></figure>
<p>这种设计清晰明确。<code>Name</code> 对比 <code>pkg.Name</code> ，人们总是可以从语法中判断出一个名字是否来自本地包。（这一点后面会有更多的介绍。）</p>
<p>在我们的例子中，包的路径是 <code>&quot;encoding/json&quot;</code>，而包名是 <code>json</code>。在标准仓库之外，惯例是将项目或公司名称放在命名空间的根部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"google/base/go/log"</span></div></pre></td></tr></table></figure>
<p>重要的是要认识到包的路径是唯一的，但对包名却没有这样的要求。路径必须唯一地标识要导入的包，而包名只是一个约定，让包的调用方可以引用它的内容。包名不需要是唯一的，可以在每个导入（importing）的源文件里，通过在导入语句中提供一个本地标识符来重命名。下面两个导入都引用了包名为 <code>log</code> 的包，但要在同一个源文件里导入它们，必须（在本地）重命名其中一个包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"log"</span> <span class="comment">// 标准包</span></div><div class="line"><span class="keyword">import</span> googlelog <span class="string">"google/base/go/log"</span> <span class="comment">// Google专用包</span></div></pre></td></tr></table></figure>
<p>每个公司可能都有自己的 <code>log</code> 包，没有必要让包名独一无二。恰恰相反：<strong>Go 的风格建议保持包名短小精悍、清晰明确，而不是担心重名</strong> 。</p>
<p>还有一个例子：在 Google 的代码库里，有很多个 <code>server</code> 包。</p>
<h2 id="9-远程包"><a href="#9-远程包" class="headerlink" title="9. 远程包"></a>9. 远程包</h2><p>Go 包系统的一个重要特性是，包的路径一般可以是任意字符串，可以用它标识托管代码仓库的站点 URL ，以此来引用远程代码库。</p>
<p>下面是使用 <code>github</code> 上的 <code>doozer</code> 包的方法。<code>go get</code> 命令使用 <code>go</code> 构建工具从站点获取仓库并安装它。一旦安装完毕，它就可以像其他普通的包一样被导入和使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get github.com/4ad/doozer // 获取包的 Shell 命令</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/4ad/doozer"</span> <span class="comment">// Doozer 调用方的 import 语句</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> client doozer.Conn         <span class="comment">// 调用方对包的引用</span></div></pre></td></tr></table></figure>
<p>值得注意的是，<code>go get</code> 命令以递归的方式下载依赖，正是因为依赖关系是显式的所以才可以这样实现。另外，区别于其它语言使用的集中式包注册，Go 导入路径的命名空间分配依赖于 URL，这使得包的命名是去中心化的，因而是可扩展的。</p>
<h2 id="10-语法"><a href="#10-语法" class="headerlink" title="10. 语法"></a>10. 语法</h2><p>语法就是一门编程语言的用户界面。<strong>尽管语法对语义影响有限，而语义很可能才是语言更重要的组成部分，但语法决定了语言的可读性，继而决定了语言的清晰度。</strong>同时，语法对工具链而言至关重要：如果一门语言难以解析，就很难为其编写自动化工具。</p>
<p>因此，Go 在设计时就考虑了语言的清晰度和工具链，并且拥有简洁的语法。与 C 家族的其他语言相比，它的语法规模不大，只有 25 个关键字（C99 有 37 个；C++11 有 84 个；而且这两个数字还在继续增加）。更重要的是，语法很规范，所以很容易解析（应该说大多数规范；也有个别怪异的语法我们本可以改善结果发现得太晚）。与 C 和 Java，尤其是 C++ 不同，Go 可以在没有类型信息或符号表的情况下进行解析；不需要类型相关的上下文。语法容易推导，工具自然就容易编写。</p>
<p>Go 语法里有一个细节会让 C 程序员感到惊讶，那就是声明语法更接近 Pascal 而不是 C。声明的名称出现在类型之前，并且使用了更多关键字（译者注：指 <code>var</code> 和 <code>type</code>关键字）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>)</span> <span class="title">int</span></span></div><div class="line"><span class="title">type</span> <span class="title">T</span> <span class="title">struct</span> &#123; a, b <span class="keyword">int</span> &#125;</div></pre></td></tr></table></figure>
<p>对比 C 语言</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*fn)(<span class="keyword">int</span>[]);</div><div class="line"><span class="keyword">struct</span> T &#123; <span class="keyword">int</span> a, b; &#125;</div></pre></td></tr></table></figure>
<p>无论对人还是对计算机来说，由关键字引入的声明都更容易解析，而且使用 <strong>类型语法</strong> 而不是 C 那样的 <strong>表达式语法</strong> ，对解析有很大的帮助：它增加了语法，但消除了歧义。你还有另外一个选择：对于初始化声明，可以丢弃 <code>var</code> 关键字，直接从表达式中推断变量的类型。这两个声明是等价的；第二个声明更短也更地道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buf *bytes.Buffer = bytes.NewBuffer(x) <span class="comment">// 显式指定类型</span></div><div class="line">buf := bytes.NewBuffer(x)                  <span class="comment">// 类型推断</span></div></pre></td></tr></table></figure>
<p>在 <a href="https://golang.org/s/decl-syntax" target="_blank" rel="external">golang.org/s/decl-syntax</a> 有一篇博客文章，详细介绍了 Go 的声明语法，以及为什么它与 C 语言如此不同。</p>
<p>对于简单的函数来说，函数语法是很直接的。这个例子声明了函数 <code>Abs</code>，它接受一个类型为 <code>T</code> 的变量 <code>x</code>，并返回一个 <code>float64</code> 的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(x T)</span> <span class="title">float64</span></span></div><div class="line"></div><div class="line">// 译者补充调用示例:</div><div class="line">// 假定已经初始化了一个变量 <span class="title">t</span>，类型为 <span class="title">T</span>，下同</div><div class="line"><span class="title">absT</span> := <span class="title">Abs</span><span class="params">(t)</span></div></pre></td></tr></table></figure>
<p>方法（method）只是有一个特殊参数的函数，这个特殊参数就是它的接收者（receiver），可以通过点号 <code>.</code> 传递给函数。方法声明的语法将接收者放在函数名前面的括号里。下面是同一个函数，现在定义成 <code>T</code> 类型的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x T)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span></div><div class="line"></div><div class="line">// 译者补充调用示例:</div><div class="line"><span class="title">absT</span> := <span class="title">t</span>.<span class="title">Abs</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>而这里是一个函数变量（闭包），参数类型为 <code>T</code>；Go 有一等函数（first-class function）和闭包：</p>
<blockquote>
<p>译者注：一等函数是指函数可以作为普通变量，可以作为其他函数的参数和返回值；作为对比， Java 只有类是一等公民，其他语言成分必须作为类的成员。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">negAbs := <span class="function"><span class="keyword">func</span><span class="params">(x T)</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> -Abs(x) &#125;</div><div class="line"></div><div class="line"><span class="comment">// 译者补充调用示例:</span></div><div class="line">negT := negAbs(t)</div></pre></td></tr></table></figure>
<p>最后，在 Go 里函数可以返回多个值。常见的做法是将函数结果和错误值作为一对返回，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></div><div class="line"></div><div class="line"><span class="title">c</span>, <span class="title">err</span> := <span class="title">ReadByte</span><span class="params">()</span></div><div class="line"><span class="title">if</span> <span class="title">err</span> != <span class="title">nil</span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>错误处理我们后面再聊。</p>
<p>Go 缺少了一个特性，那就是它不支持函数的默认参数（default function arguments）。这是一个故意的简化。经验告诉我们，默认参数会让修复 API 显得太容易，仿佛只要添加更多参数就可以弥补设计上的缺陷，结果导致添加了过多的参数，参数之间的关系变得难以拆分、甚至无法理解。缺少默认参数的情况下，因为一个函数无法承载整个接口，就需要定义更多的函数或方法，但这会导致 API 更清晰、更容易理解。这些函数也都需要单独命名，这使得有哪些函数、分别接受哪些参数一目了然，同时也鼓励人们对命名进行更多的思考，这是清晰度和可读性的一个关键方面。</p>
<p>作为缺少默认参数的补偿，Go 支持易用的、类型安全的可变参数函数（variadic functions）。</p>
<h2 id="11-命名"><a href="#11-命名" class="headerlink" title="11. 命名"></a>11. 命名</h2><p>Go 采用了一种不同寻常的方法来定义标识符的可见性（所谓可见性，是指一个包的调用方是否可以通过标识符使用包内的成员）。不同于使用 <code>private</code> 和 <code>public</code> 等关键字，在 Go 里，命名本身就带有信息：标识符首字母的大小写决定了标识符的可见性。如果首字母是大写字母，标识符就会被导出（公共）；否则就是私有的：</p>
<ul>
<li>首字母大写：<code>Name</code> 对包的调用方可见</li>
<li>首字母小写：<code>name</code> （或 <code>_Name</code>）对包的调用方不可见</li>
</ul>
<p>这条规则适用于变量、类型、函数、方法、常量、字段 …… 所有一切。这就是全部规则。</p>
<p>这个设计不是一个容易做的决定。我们纠结了一年多的时间，去考虑用什么符号指定标识符可见性。而一旦我们决定使用命名的大小写，我们很快就意识到它已经成为了语言里最重要的特性之一。名称毕竟是给包的调用方使用的；<strong>把可见性放在名称里而不是类型里，意味着只要看一眼，就能确定一个标识符是否公共 API 的一部分</strong> 。在使用 Go 一段时间之后，再去看其他语言，还要查找声明才能发现这些信息，就会觉得很累赘。</p>
<p>目标仍然是清晰度：程序源码要简单直接地表达程序员的意图。</p>
<p>另一个简化是，Go 有一个非常紧凑的作用域（scope）层次结构：</p>
<ul>
<li>全局（预先声明的标识符，像 <code>int</code> 和 <code>string</code>）</li>
<li>包（包的所有源文件都在同一个作用域）</li>
<li>文件（仅用于导入包的重命名，实践中不是特别重要）</li>
<li>函数（跟其它语言一样）</li>
<li>代码块（跟其它语言一样）</li>
</ul>
<p>没有什么命名空间（name space）作用域、类（class）作用域或者其它结构的作用域。在 Go 里，名称只来自很少的地方，而且所有名称都遵循相同的作用域层次：在源码的任意位置，一个标识符只表示一个语言对象，和它的用法无关。（唯一的例外是语句标签 （用作 <code>break</code> 等语句的目标）；它们总是具有函数作用域。）</p>
<p>这使代码更清晰。例如，请注意到方法声明了一个显式的接收者（explicit receiver），访问该类型的字段和方法必须用到它。没有隐式的（implicit） <code>this</code> 。也就是说，我们总是写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rcvr.Field</div></pre></td></tr></table></figure>
<p>（其中 <code>rcvr</code> 是给接收者变量随便起的名称）所以在词法上（lexically），该类型的所有元素，总是绑定到一个接收者类型的值上。类似地，对于导入的名称，包的限定符总是存在；人们写的是 <code>io.Reader</code> 而不是 <code>Reader</code> 。这样不仅清楚，而且释放了标识符 <code>Reader</code> 作为一个有用的名称，可以在任何包中使用。事实上，在标准库中有多个导出的标识符都叫 <code>Reader</code>，类似的还有很多 <code>Printf</code>，但具体引用了哪一个永远不会弄混。</p>
<p>最后，这些规则结合在一起，保证除了顶层的预定义名称如 <code>int</code> 之外，每个名称（点号 <code>.</code> 前的第一部分）总是在当前包中声明。</p>
<p>简而言之，名称总是本地的（local）。在 C、C++ 或 Java 里，名称 <code>y</code> 可以指向任何东西。在 Go 里，<code>y</code> （甚至大写的 <code>Y</code> ）总是在包内定义，而 <code>x.Y</code> 的解释很清楚：在本地找到<code>x</code> ，<code>Y</code> 就在里面。</p>
<p>这些规则为可伸缩性提供了很重要的特性，因为它们保证了在一个包里添加导出的名称永远不会破坏这个包的调用方。<strong>命名规则解耦了包，提供了可伸缩性、清晰度和健壮性。</strong></p>
<p>关于命名还有一个方面需要提及：方法查找总是只按名称，而不是按方法的签名（类型）。换句话说，一个类型永远不可能有两个同名的方法。给定一个方法 <code>x.M</code> ，永远只有一个 <code>M</code> 与 <code>x</code> 关联。同样，这使得只给定名称就能很容易地识别引用了哪个方法。这也使得方法调用的实现变得简单。</p>
<blockquote>
<p>译者注：换句话说，Go 不支持函数和方法重载。</p>
<p>Go 的内置函数其实是有重载的。<code>make</code> 和 <code>len</code> 这些函数，参数类型不同，具体的行为也不一样。<code>make</code> 甚至还有一个到三个参数的三个版本。这些函数根据参数不同，在编译时被替换成了不同的函数实现。</p>
<p>但为了保持代码清晰，实现简单和运行高效，Go 不支持用户代码的函数重载。</p>
</blockquote>
<h2 id="12-语义"><a href="#12-语义" class="headerlink" title="12. 语义"></a>12. 语义</h2><p>Go 语句的语义一般跟 C 语言类似。它是一种带有指针等特性的、编译型、静态类型的过程式语言。设计上，习惯 C 族语言的程序员应该会感到熟悉。在推出一门新语言时，目标受众能够快速学会它是很重要的；将 Go 植根于 C 家族有助于确保年轻程序员能很容易学会 Go（他们大多数都知道 Java、JavaScript，也许还有 C）。</p>
<p>尽管如此，Go 对 C 的语义还是做了很多小的改变，主要是出于健壮性的考虑。这些变化包括：</p>
<ul>
<li>没有指针运算</li>
<li>没有隐式数字转换</li>
<li>总是检查数组边界</li>
<li>没有类型别名（声明 <code>type X int</code> 之后， <code>X</code> 和 <code>int</code> 是不同的类型，而不是别名）</li>
<li><code>++</code> 和 <code>--</code> 是语句（statements）而不是表达式（expressions）</li>
<li>赋值不是表达式</li>
<li>对栈上变量取址是合法的（甚至是被鼓励的）</li>
<li>其它</li>
</ul>
<blockquote>
<p>译者注：</p>
<ol>
<li><p>Go 在 1.9 还是引入了类型别名，语法是 <code>type X = int</code> 。用来解决迁移、升级等重构场景下，类型重命名的兼容性问题，以及方便引用外部导入的类型。</p>
<p> 实际上，类型别名仅在代码中存在，编译时会全部替换成实际的类型，不会产生新类型。</p>
</li>
<li><p>语句和表达式的差别是：语句是计算机角度的一个可执行动作，不一定有值；表达式是数学角度的可求值算式，一定有值，这个值可以放在赋值符号的右边，或者成为更大的表达式的一部分。</p>
<p> 不再区分语句和表达式，是编程语言演化的其中一个趋势，这可以增强语言的表达能力。一般的做法，是增加求值规则（像语句的值是语句中最后一个表达式的值），给原本没有值的语句提供一个值，这样就可以通过拼接非常复杂的表达式，用很少的代码解决问题。例如，如果赋值语句有值，那么 <code>e = d = c = b = a = 10</code>  就是合法的；因为赋值运算符从右到左结合，这些赋值最后都会成功，都是 10。</p>
<p> 但这很容易引起表达式的 滥用 和 误用。人们有可能写出非常难以理解的复杂表达式。或者因为不熟悉某些（本来是语句的）表达式的求值规则而制造难以排查的错误。</p>
<p> Go 首先追求代码的清晰明确，而不是追求单纯的表达能力强或者代码行数少，所以反其道而行，反而去掉了某些语句的值。</p>
</li>
<li><p>栈上分配的内存会在函数返回后被回收，对栈上的变量取址并返回，会导致函数外部引用到已被回收的内存。这就是悬挂指针问题，困扰着大多数有指针的语言。Go 的解决方案是，在编译期做逃逸分析，识别出可能超出当前作用域的指针引用，将对应的内存分配到堆上。所以在 Go 里面，取址操作不用考虑变量究竟是栈上还是堆上的，编译器会反过来配合你。当然，如果是高频操作，可能要考虑一下拷贝和 GC 哪个开销大，传值（栈上分配，需要拷贝，不需要 GC）还是 传指针（如果发生逃逸，堆上分配，不需要拷贝，需要 GC）。</p>
</li>
</ol>
</blockquote>
<p>还有一些更大的变化，远离了传统的 C、C++ 甚至 Java 的模式。这些包括在语言级别上支持：</p>
<ul>
<li>并发</li>
<li>垃圾回收</li>
<li>接口类型</li>
<li>反射</li>
<li>类型判断（type switches）</li>
</ul>
<p>下面的章节主要从软件工程的角度简要讨论 Go 中的两个主题：并发 和 垃圾回收。关于语言语义和用途的完整讨论，请参见 <a href="https://golang.org" target="_blank" rel="external">golang.org</a> 网站上的更多资料。</p>
<h2 id="13-并发"><a href="#13-并发" class="headerlink" title="13. 并发"></a>13. 并发</h2><p>web 服务器运行在多核机器上，并有大量的调用方，这可以称之为一个典型的 Google 程序；而并发对于这种现代计算环境非常重要。C++ 或 Java 都不是特别适合这类软件，它们在语言层面上缺乏足够的并发支持。</p>
<p>Go 有作为一等公民的通道（channel），实现了 CSP （译者注：Communicating Sequential Processes，通信顺序进程）的一个变种。选择 CSP 的部分原因是熟悉（我们其中一个人曾经研究过某种基于 CSP 思想的前辈语言），同时也是因为 CSP 很容易被添加到过程化编程模型中，而无需对模型进行深入的修改。也就是说，<strong>给定一个类似于 C 的语言，CSP 基本就能够以正交的方式添加到语言中，提供额外的表达能力，而不限制该语言的其他用途。</strong> 总之，语言的其他部分可以保持『普通』。</p>
<p><strong>这个方法就是，将独立执行的函数，与其他普通的过程式代码结合。</strong></p>
<p>这样得到的语言允许我们将 并发 和 计算 平滑地结合起来。假设有一个 web 服务器，必须验证每次客户端调用的安全证书；在 Go 里面，很容易利用 CSP 来构造这样一个软件：用独立的执行过程来管理客户端，同时还能火力全开为昂贵的加密计算提供编译型语言的高执行效率。</p>
<p>综上所述，CSP 对于 Go 和 Google 来说都很实用。在编写 web 服务器这种典型的 Go 程序时，这个模型是再适合不过了。</p>
<p>有一个重要的注意事项：在并发的情况下，Go 并不是纯粹的内存安全（purely memory safe）语言。内存共享是合法的，在通道上传递指针也是符合惯例的（同时也是高效的）。</p>
<p>一些 并发 和 函数式编程 的专家对于 Go 在并发计算的上下文没有采用『只写一次（write-once）』来处理值语义感到失望，看起来没有其它并发语言（如 Erlang）那么像回事。同样地，原因主要还是在于对问题领域的熟悉度和适用性。Go 的并发特性在大多数程序员熟悉的上下文中都能很好地发挥作用。<strong>Go 可以实现简单、安全的并发编程，但并不禁止不良的编程方式。</strong> 我们提供约定俗成的做法作为弥补，训练程序员将消息传递视为所有权控制的一种实现方式。我们的座右铭是：『<strong>不要通过共享内存来通信，要通过通信来共享内存</strong>』。</p>
<blockquote>
<p>译者注：『只写一次（write-once）』变量，在某些语言的实现里又叫『单次赋值（single-assignment）』变量（Erlang），或者『不可变（immutable）』变量（函数式编程）。换言之，这种变量只能在初始化时赋值（写入）一次，之后不能再修改；如果需要新的值，只能创建新的变量。这样可以避免在并发上下文意外修改了变量的值。</p>
<p>虽然都不能修改，但还是要区分它和常量的区别。常量是在编译期就已经存在并确定了值；而不可变变量虽然赋值后不可修改，但其创建 / 赋值的时机和具体的值还是在运行时决定的。</p>
<p>这其实是来自函数式编程『无副作用（side effect）』和『不修改状态（state）』的概念，虽然可以保证程序的正确性，却跟 C 家族的过程式编程模型差异很大，照搬过来需要对这个模型进行比较大的改动，这就违背 Go 的设计初衷了。</p>
</blockquote>
<p>从我们对 Go 和 并发编程 的新手程序员的有限了解来看，这是一种实用的做法。程序员享受着并发支持给网络软件带来的简单性，而简单性产生了健壮性。</p>
<blockquote>
<p>译者在网上看到一种说法：『Java 里多种同步方法、各种 Lock、并发调度等一系列复杂的功能在 Golang 里 <strong>都不存在</strong>，只靠 goroutine 和 channel 去处理并发。』，这种说法是错的。</p>
<p>如上面所说，CSP 模型是以基本正交的方式添加到 C 家族的过程式编程模型里的，增加了新的、简洁的表达方式，但并没有限制原本的做法。</p>
<p>Go 常用的并发控制的工具，除了内置的消息通道 <code>chan</code> （CSP 模型），还有：</p>
<ul>
<li><code>sync</code> 包提供的同步原语（其中包括互斥锁和读写互斥锁 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code>，还有其它三个原语 <code>sync.WaitGroup</code> ， <code>sync.Once</code> 和 <code>sync.Cond</code> 。实际上你去看 <code>chan</code> 的源码，也是基于 runtime 内部的 <code>mutex</code> 实现的）；</li>
<li>上下文 <code>context.Context</code></li>
<li>其它扩展包中提供的工具</li>
</ul>
<p>可以看到，在 C 家族里常见的并发控制方式，基本都有提供，只是不再像 Java 那样以关键字的方式，而是以内置包的方式提供。</p>
<p>Go 把 CSP 模型实现并把支持上升到内置类型和关键字的层面，却并没有强迫程序员必须使用这个模型。</p>
</blockquote>
<h2 id="14-垃圾回收"><a href="#14-垃圾回收" class="headerlink" title="14. 垃圾回收"></a>14. 垃圾回收</h2><p>对于一门系统级编程语言来说，垃圾回收可能是一个有争议的特性，然而我们只花了很少时间就决定 Go 将是一门带垃圾回收的语言。Go 没有显式的内存释放操作：已分配的内存返回内存池的唯一途径就是垃圾回收器。</p>
<p>这是一个很容易做出的决定，因为内存管理对一门语言的实际工作方式有着深远的影响。在 C 和 C++ 中，编程时太多的精力都花在了内存的分配和释放上。这样的设计倾向于暴露本可以隐藏得很好的内存管理细节；但反过来说，对内存管理的过多顾虑又限制了内存的使用。相比之下，垃圾回收使得编程接口更清晰明确（garbage collection makes interfaces easier to specify）。</p>
<p>此外，在支持并发的面向对象语言中，自动内存管理几乎是必不可少的，因为当一块内存的所有权在并发执行中来回传递时，管理起来是很棘手的。<strong>将行为和资源管理分开是很重要的。</strong></p>
<p>一旦有了垃圾回收，语言使用起来就容易多了。</p>
<p>当然，垃圾回收会带来巨大的成本：资源开销、执行延迟和实现的复杂性。尽管如此，我们相信，主要由程序员感受到的好处，要大于主要由语言实现者承担的成本。</p>
<p>用 Java 作为服务器开发语言的经验，让一些人对面向用户的系统中的垃圾回收感到紧张。开销不可控，延迟随时可能变大，而且为了获得良好的性能，还需要进行很多参数调整。然而 Go 却不同，语言的特性能缓解其中一部分的担忧，虽然不是全部。</p>
<p>关键的一点是，<strong>Go 为程序员提供了工具，可以通过控制数据结构的布局来限制内存分配</strong> 。假设有一个简单的数据结构的类型定义，它包含一个字节型（数组）的缓冲区：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;</div><div class="line">    a, b, c <span class="keyword">int</span></div><div class="line">    buf [<span class="number">256</span>]<span class="keyword">byte</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Java 里，<code>buf</code> 字段需要第二次内存分配，对它的访问也需要第二层的间接访问。但在 Go 里面，缓冲区和包含它的结构体一起被分配在一个内存块中，不需要任何间接分配和访问。对于系统编程来说，这种设计可以获得更好的性能，同时减少回收器需要管理的内存块数量。在规模化的情况下，它可以带来显著的差异。</p>
<p>举个更直接的例子，在 Go 里面，提供二阶内存分配器（second-order allocators）是很容易和很高效的，例如一个 arena 内存分配器可以一口气分配一大组的结构体，并用一个空闲链表（free list）将它们连接起来。像这样要反复使用很多小结构体的库，只要做适当的提前安排，就可以不产生垃圾，还能保持高效和快速响应。</p>
<blockquote>
<p>译者注：arena 是 Go 里面用来分配内存的连续虚拟地址区域，堆中分配的内存都来自这一区域，可以近似地看作堆。Go 有自主内存管理策略（基于 Thread-Caching Malloc 改进），会一次性向系统预申请一大块内存，并将空闲内存用 free list 连在一起。分配内存时会按照一定策略，根据大小优先从 free list 获取内存；如果对象销毁，则把内存归还 free list。只有空闲内存不够才会向系统申请新的内存，只有空闲内存特别多才会向系统释放内存，减少内存申请和释放的系统调用。</p>
<p>这部分内容根据 Go 实现的改进可能会发生变化，请参考最新的文章，或者直接查看源码。 <code>https://github.com/golang/go/blob/master/src/runtime/malloc.go</code></p>
</blockquote>
<p>虽然 Go 是一种带垃圾回收的语言，但是一个资深的程序员可以通过减少施加给回收器的压力，来提高性能。（另外，Go 安装时还附带了很多好用的工具，可以用来分析程序运行时的动态内存性能。）</p>
<p>为了给程序员提供这种灵活性，Go 必须支持指向堆上分配对象的指针，我们称之为<strong>内部指针</strong>（interior pointers）。上面例子中的 <code>X.buf</code> 字段就存在于结构体内部，但获取这个内部字段的地址是合法的，例如将这个地址传递给一个 I/O 子程序。在 Java 以及很多支持垃圾回收的语言里，构造这样的内部指针是不可能，但在 Go 里面，这是很自然的做法。这个设计点会影响到可以使用哪些回收算法，并且可能会增加算法的实现难度，但是经过仔细考虑，我们决定有必要允许使用内部指针，因为这对程序员有好处，并且能够减少垃圾回收器的压力（尽管这样可能会让垃圾回收器更难实现）。到目前为止，我们将类似的 Go 和 Java 程序进行对比的经验表明，使用内部指针可以对总的 arena 大小、执行延迟 和 回收时间产生显著影响。</p>
<p>总而言之，Go 支持垃圾回收，但给程序员提供了一些工具来控制回收开销。</p>
<p>垃圾回收器仍然是一个活跃的开发领域。目前的设计是一个并行的标记并清理（mark-and-sweep）回收器，仍然有机会改进它的性能甚至设计。（语言规范并没有规定回收器必须要使用任何特定实现。） 不过，如果程序员注意更巧妙地使用内存，目前的实现已经可以在生产环境工作得很好。</p>
<blockquote>
<p>译者注：Go 1.3 以前使用 mark-and-sweep 回收器，整个过程需要 STW（stop the world），对于内存的申请和释放量比较大和频繁的程序而言，回收造成的停顿会比较明显。</p>
<p>后续的版本逐渐分离标记和清理过程，引入三色标记法，还有引入混合写屏障。总的趋势是将 GC 分散成多个可以（跟程序执行）并发的过程，将不得不 STW 的阶段和时间压缩到最小（通常小于 1ms），跟演讲发表时相比已经有了很大的改善。</p>
</blockquote>
<h2 id="15-组合，而不是继承"><a href="#15-组合，而不是继承" class="headerlink" title="15. 组合，而不是继承"></a>15. 组合，而不是继承</h2><p>Go 采用了一种不同寻常的面向对象编程方法，它允许在任何类型上添加方法，而不仅仅是类；但没有任何形式的基于类型的继承，比如子类。这意味着没有类型层次体系（type hierarchy）。这是一个有意的设计选择。虽然类型体系已经被用来构建了很多成功的软件，但我们认为这个模型已经被过度使用，应该后退一步。</p>
<p>取而代之的是 Go 的接口，这个想法在其他地方已经被详细讨论过了（例如参见<a href="https://research.swtch.com/interfaces" target="_blank" rel="external">research.swtch.com/interfaces</a>），但这里还是做一个简单的总结。</p>
<p>在 Go 里面，一个接口 <strong>仅仅</strong> 是一组方法的集合。例如，这里是标准库中 <code>Hash</code> 接口的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</div><div class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></div><div class="line">    Reset()</div><div class="line">    Size() <span class="keyword">int</span></div><div class="line">    BlockSize() <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有实现这些方法的数据类型都隐式地满足这个接口，没有 <code>implements</code> 声明。尽管如此，是否满足接口是在编译期静态检查的，所以接口是类型安全的。</p>
<p>一个类型通常会满足许多接口，每个接口对应于其方法的一个子集。例如，任何满足 <code>Hash</code> 接口的类型也会满足 <code>Writer</code> 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</div><div class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种接口满足的流动性鼓励了一种不同的软件构造方法。但在解释这个之前，我们应该先解释一下为什么 Go 没有子类。</p>
<p>面向对象编程提供了一个强大的洞见：<strong>数据的行为可以独立于数据的表示进行泛化（generalized）。</strong> 当行为（方法集）是固定的时候，这个模型的效果最好，但是一旦你对一个类型进行了子类化，并添加了一个方法，行为就不再相同。相反地如果行为集是固定的，就好像 Go 静态定义的接口那样，行为的统一性使得数据和程序可以统一、正交、安全地组合。</p>
<p>一个极端的例子是 Plan 9 内核，所有的系统数据项都实现了完全相同的接口，即由 14 个方法定义的文件系统 API。这种统一性允许的对象组合水平，即使在今天也极少能在其它系统上看到。这样的例子比比皆是。这里还有一个：一个系统可以将 TCP 协议栈导入（import，这是 Plan 9 的术语）到一台没有 TCP 甚至没有以太网（Ethernet）的计算机上，然后通过这个网络连接到一台 CPU 架构不同的机器上，导入它的 <code>/proc</code> 树，并运行一个本地调试器对远程进程进行断点调试。这种操作在 Plan 9 上简直稀松平常，根本没有任何特别之处。做这种事情的能力完全来自它的设计，不需要特殊的安排（而且都是用普通 C 语言代码完成的）。</p>
<p>我们认为，这种组合式的系统构造风格已经被那些推崇按类型体系设计的语言所忽视。<strong>类型体系会造就脆弱易碎的代码。</strong> 体系结构必须在早期设计，通常是作为设计程序的第一步，而一旦程序写好就很难改动早期的决定。<strong>因此，该模型鼓励在早期做过度设计，程序员试图预测软件可能需要的每一种使用方式，增加多个类型和抽象层，仅仅为了以防万一。这是本末倒置的做法。系统各个部分的交互方式应该随着系统的发展去适配，而不是在一开始就固定下来。</strong></p>
<p>因此，Go 鼓励组合而不是继承，使用简单的、通常只有一个方法的接口来定义琐碎的行为，作为组件之间干净、可理解的边界。</p>
<p>上面提到的 <code>Writer</code> 接口，它被定义在 <code>io</code> 包里：任何有 <code>Write</code> 方法的类型，只要有以下这个方法签名，就可以和补充的 <code>Reader</code> 接口一起工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个互补的方法可以类型安全地跟丰富的行为进行连接（chaining），就像通用的 Unix 管道（pipes）一样。文件、缓冲区、网络、加密器、压缩器、图像编码器等都可以连接在一起。格式化 I/O 子程序 <code>Fprintf</code> 采用一个 <code>io.Writer</code> 接口作为参数，而不是像在 C 语言里那样采用 <code>FILE*</code> 。格式化输出程序并不了解内容是写到了哪里，它可能是一个图像编码器，背后又输出给一个压缩器，压缩器又输出给一个加密器，加密器又输出给一个网络连接。</p>
<p>接口组合是一种不同的编程风格，习惯了类型层次体系的人需要调整思路才能适应，但这样可以获得设计的适应性，这是通过类型体系很难实现的。</p>
<p>还要注意的是，消除类型层次结构也消除了一种形式的依赖层次结构。接口的满足允许程序有机地生长，而不需要预先确定的合约。而且它是一种线性的增长形式，对一个接口的改变只影响该接口的直接用户，不需要再更新子树。缺乏 <code>implements</code> 声明会让一些人感到不安，但它能让程序自然、优雅、安全地生长。</p>
<p>Go 的接口对程序设计有重大影响。其中一个地方是用接口作为参数的函数的使用。这些不是方法，而是函数。一些例子应该可以说明它们的力量。<code>ReadAll</code> 返回一个字节切片（数组），包含了所有可以从 <code>io.Reader</code> 接口读取的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></div></pre></td></tr></table></figure>
<p>封装器（指接受一个接口参数并返回一个接口的函数）的使用也很普遍。下面是一些原型。 <code>LoggingReader</code> 记录传入的 <code>Reader</code> 的每个 <code>Read</code> 调用。 <code>LimitingReader</code> 在读取 <code>n</code> 个字节后停止。 <code>ErrorInjector</code> 通过模拟 I/O errors 来辅助测试。我们还能找到更多例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoggingReader</span><span class="params">(r io.Reader)</span> <span class="title">io</span>.<span class="title">Reader</span></span></div><div class="line"><span class="title">func</span> <span class="title">LimitingReader</span><span class="params">(r io.Reader, n <span class="keyword">int64</span>)</span> <span class="title">io</span>.<span class="title">Reader</span></div><div class="line"><span class="title">func</span> <span class="title">ErrorInjector</span><span class="params">(r io.Reader)</span> <span class="title">io</span>.<span class="title">Reader</span></div></pre></td></tr></table></figure>
<p>这些设计与分层的、子类型继承的方法完全不同，它们是更松散的（甚至是临时的）、有机的、解耦的、独立的，因此是可弹性伸缩的。</p>
<h2 id="16-错误处理"><a href="#16-错误处理" class="headerlink" title="16. 错误处理"></a>16. 错误处理</h2><p>Go 没有传统意义上的异常机制，也就是说，没有与错误处理相关的控制结构。（Go 确实提供了处理异常情况（例如除零异常）的机制。一对名为 <code>panic</code> 和 <code>recover</code> 的内置函数允许程序员处理类似的情况。然而，这些函数是故意设计得不好用，也很少使用，而且没有像 Java 库使用异常那样集成到代码库中。）</p>
<p>错误处理的关键语言特性是一个预先定义的接口类型 <code>error</code> ，它代表了一个有 <code>Error</code> 方法可以返回字符串的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</div><div class="line">    Error() <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码库使用 <code>error</code> 类型来返回错误的描述。结合函数多值返回的能力，很容易将计算结果与错误值（如果有）一起返回。例如，Go 里等价于 C 的 <code>getchar</code> 的函数不会在遇到 <code>EOF</code> 时返回一个超出范围的值，也不会抛出一个异常；它只是在字符旁返回一个 <code>error</code> 值， <code>nil error</code> 值表示成功。下面是缓冲 I/O 包的 <code>bufio.Reader</code> 接口类型的 <code>ReadByte</code> 方法的签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></div></pre></td></tr></table></figure>
<p>这是一个简单清晰的设计，很容易理解。错误只是值，程序用它们来计算，就像用任意其他类型的值来计算一样。</p>
<p>在 Go 中不加入异常是一个刻意的选择。虽然有很多批评者不同意这个决定，但有几个原因让我们相信它可以让软件变得更好。</p>
<p>首先，计算机程序中的错误并不是真的『异常』（nothing truly exceptional，译者注：也可以翻译成：没有什么特别，平平无奇，这里翻译成异常，是为了跟 exception 的中文术语对应）。例如，无法打开文件是一个常见的问题，不值得使用特殊的语言结构； <code>if</code> 和 <code>return</code> 就可以了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f, err := os.Open(fileName)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，如果使用特殊的控制结构，错误处理会扭曲（distorts）程序处理错误的控制流（control flow）。Java 风格的 <code>try-catch-finally</code> 块跟多个重叠的控制流互相交错，而这些控制流本身的交互就很复杂。相比之下，虽然 Go 使代码在检查错误时更加啰嗦，但显式的设计使控制流保持了真正的（literally）简单直接。</p>
<p>毫无疑问，由此产生的代码可能会更长，但这种代码的清晰和简单可以弥补它的啰嗦。<strong>明确的错误检查迫使程序员在错误出现时就考虑并处理它们。</strong> 异常太容易让人们忽略而不是处理它们，将责任推给调用栈，直到为时已晚，无法很好地修复乃至诊断问题。</p>
<h2 id="17-工具"><a href="#17-工具" class="headerlink" title="17. 工具"></a>17. 工具</h2><p>软件工程需要工具。每一种语言都是在一个有其他语言和大量工具的环境中运行，这些工具用来编译、编辑、调试、性能分析、测试和运行程序。</p>
<p>Go 的语法、包系统、命名惯例和其他特性在设计时就已经将工具易于编写考虑在内，库里面包括了 Go 的词法分析器、解析器和类型检查器。</p>
<p>控制 Go 程序的工具非常容易编写，以至于这样的工具现在已经有很多，有些工具对软件工程产生了很有趣的影响。</p>
<p>其中最著名的是 <code>gofmt</code> ，Go 的源代码格式化工具。从项目一开始，我们就打算用机器来格式化 Go 程序代码，从而消除程序员之间争论的一整个问题分类：该如何排版代码？ <code>gofmt</code> 运行在我们编写的所有 Go 程序上，大多数开源社区也在用它。它是作为代码仓库的『提交前（presubmit）』检查来运行的，以确保所有检入（check-in）的 Go 程序格式都是一样的。</p>
<p><code>gofmt</code> 经常被用户推崇为 Go 最好的特性之一，尽管它根本不是 Go 语言的一部分。 <code>gofmt</code> 的存在和使用意味着，从一开始，社区里看到的代码总是按照 <code>gofmt</code> 的格式，所以 Go 程序有一个现在大家都很熟悉的统一风格。统一的表现形式使得代码更容易阅读，因此工作起来也更快。不用花时间格式化代码，时间就可以节省下来干别的。 <code>gofmt</code> 还影响了可伸缩性：<strong>既然所有的代码看起来都是一样的，团队就更容易一起合作，也更容易使用其他人的代码</strong>。</p>
<blockquote>
<p>译者注：</p>
<p>这个功能虽然看起来不起眼，但在实际的团队开发中其实是很实用的。在使用别的没有统一风格的语言时，总是要为统一团队的代码风格付出额外的精力（尤其是有新成员加入时）。</p>
<p>我们要么给团队制定统一的风格规范，并落实到每个人（最好使用格式化插件并应用相同的配置）；要么忍受代码里同时存在好几种风格穿插，影响阅读。</p>
<p>更糟糕的情况是，几个人都启用了格式化插件，却应用了不同的配置，先后修改同一份代码，提交时就很容易出现大量差异乃至冲突，实际上仅仅是代码风格的差异。这些无关紧要的差异如果不小心提交到仓库，真正重要的修改就将被淹没其中，干扰我们日后查看历史分析问题。</p>
</blockquote>
<p><code>gofmt</code> 还使另一类我们之前没有清晰预见到的工具得以实现。 <code>gofmt</code> 的工作原理是解析源代码，并从解析树本身重新格式化。这使得在格式化之前可以编辑解析树，于是一套自动重构工具应运而生。这些工具很容易编写，由于它们直接在解析树上工作，所以语义丰富，可以自动生成规范格式化的代码。</p>
<p>第一个例子是 <code>gofmt</code> 本身的 <code>-r</code> （rewrite）标志参数，它使用简单的模式匹配语言来实现表达式级别的重写。比如有一天，我们为切片表达式的右侧引入了一个默认值：切片本身的长度。只需一条命令，整个 Go 源代码树就被更新为使用这个默认值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gofmt -r <span class="string">'a[b:len(a)] -&gt; a[b:]'</span></div></pre></td></tr></table></figure>
<p>这个转换的一个关键点是，因为输入和输出都是规范格式，所以对源代码所做的唯一改变是语义上的改变。</p>
<p>一个类似但更复杂的处理是，当 Go 语言里以换行结束的语句，不再需要分号作为终止符时， <code>gofmt</code> 可以用来更新源码树。</p>
<p>另一个重要的工具是 <code>gofix</code>，它可以运行用 Go 本身编写的『源码树重写模块（tree-rewriting modules）』，因此能够进行更高级的重构。 <code>gofix</code> 工具让我们在 Go 1 发布之前对 API 和 语言特性 进行了全面的修改，包括修改 map 删除条目的语法，为操作时间值引入全新的 API ，等等。随着这些变化的推出，用户只需要运行简单的命令就能更新他们的所有代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gofix</div></pre></td></tr></table></figure>
<p>请注意，这些工具允许我们，在旧代码仍然可以正常工作的前提下，更新代码。因此，Go 的代码仓库很容易随着库的演化保持更新。旧的 API 可以快速自动地被废弃，因此只需要维护一个版本的 API。例如，我们最近改变了 Go 的协议缓冲区实现，改为使用 “getter” 函数，而之前的接口并没有这些函数。我们在 Google 所有 Go 代码上运行 <code>gofix</code> 来更新所有使用协议缓冲区的程序，现在只有一个版本的 API 在使用。在 Google 的代码库规模下，对 C++ 或 Java 库进行类似的全面修改几乎是不可能实现的。</p>
<p>Go 标准库里的解析包，让其他一些工具也得以实现。例如 <code>go</code> 工具，它可以管理程序的构建，包括从远程代码仓库获取包；<code>godoc</code> 文档提取器，是一个验证 API 兼容性合约是否随着库的更新而得到维护的程序；等等。</p>
<p>虽然像这样的工具在语言设计中很少被提及，但它们是语言生态系统中不可缺少的一部分，事实上，Go 在设计时就考虑到了工具的问题，这对语言、库和社区的发展都有巨大的影响。</p>
<h2 id="18-结论"><a href="#18-结论" class="headerlink" title="18. 结论"></a>18. 结论</h2><p>Go 在 Google 内部用得越来越多。</p>
<p>一些面向用户的大型服务都在使用它，包括 <code>youtube.com</code> 和 <code>dl.google.com</code> （提供 Chrome、Android 和其他下载的下载服务器），以及我们自己的 <code>golang.org</code> 。当然也有很多小的服务，大多是使用 Google App Engine 对 Go 的原生支持构建的。</p>
<p>很多其他公司也在使用 Go；这个名单很长，但其中比较著名的几个是：</p>
<ul>
<li>BBC Worldwide</li>
<li>Canonical</li>
<li>Heroku</li>
<li>Nokia</li>
<li>SoundCloud</li>
</ul>
<p>看来，Go 正在实现它的目标。不过，现在宣布成功还为时过早。我们还没有足够的经验，尤其是在大型程序（数百万行代码那种）方面的经验，去断言我们已经成功创造了一门弹性可伸缩的语言。尽管所有的指标都是正面的。</p>
<p>在较小的范围内，一些小事情还不够好，可能会在 Go 以后的版本里微调（Go 2？）。例如，变量声明语法的形式太多，程序员很容易被非 nil 接口里面的 nil 值的行为搞糊涂，还有很多库和接口的细节可以再进行一轮设计。</p>
<p>不过值得注意的是， <code>gofix</code> 和 <code>gofmt</code> 在 Go 1 的前期给了我们修复许多其他问题的机会。正因为有这些工具，Go 在今天得以更接近它的设计者的期待，而这些工具本身也是由于语言的设计才得以实现。</p>
<p>不过，不是所有事情都已经确定。我们还在学习中（但语言暂时是冻结的）。</p>
<blockquote>
<p>译者注：根据译者的理解，这里的语言冻结，应该是指为了兑现 Go 1 backwards compatibility 的承诺，Go 1.x 的 API 已经基本固定，后续只会新增特性和对现有特性做兼容的微调，更多是在底层实现上做改进。破坏兼容性的修改，只能等到 Go 2。</p>
</blockquote>
<p>Go 语言的一个主要的弱点，是它的实现仍需努力改进。编译器生成的代码，尤其是运行时的性能应该更好，这方面的工作还在继续。目前已经取得了一些进展；事实上，一些基准测试显示，与 2012 年初发布的第一版 Go 相比，当前开发版的性能已经翻了一番。</p>
<h2 id="19-小结"><a href="#19-小结" class="headerlink" title="19. 小结"></a>19. 小结</h2><p>软件工程指导了 Go 的设计。与大多数通用编程语言相比，Go 的设计是为了解决我们在构建大型服务器软件时接触到的一系列软件工程问题。这么一说，这可能会让 Go 听起来相当沉闷和工业化，但事实上，在整个设计过程中，对清晰、简单和可组合性的关注反而导致了一门工作效率高且有趣的语言，很多程序员都觉得它表达力强而且功能强大。</p>
<p>造就这个结果的特性包括：</p>
<ul>
<li>清晰的依赖关系</li>
<li>清晰的语法</li>
<li>清晰的语义</li>
<li>组合而非继承</li>
<li>编程模型提供的简单性（垃圾回收、并发）</li>
<li>易用的工具（<code>go</code> 工具、<code>gofmt</code> 、 <code>godoc</code> 、 <code>gofix</code> ）</li>
</ul>
<p>如果你还没有尝试过 Go，我们建议你去尝试：</p>
<p><a href="https://golang.org" target="_blank" rel="external">https://golang.org</a></p>
<blockquote>
<p>译者小结：</p>
<p>一万八千多字，终于翻译完了。</p>
<p>一开始我没有留意原文的字数，以为最多花两个晚上，就能翻译完。实际上，如果不涉及那么多专业概念，没有那么多上下文省略和带歧义的表述，这个长度两晚也是可以勉强完成的。</p>
<p>可本文就是有很多地方，需要有相关的背景知识，无法单纯从原文确定作者的准确意思。没办法，有歧义又了解不够的地方，只好查资料、翻源码，猜测原作者最大可能想表达什么。所以导致翻译进度又慢又累。而即使这样，如开头所说，仍然无法避免会有理解偏差和错误。</p>
<p>这样一来，对之前的译文就变得更加宽容了。笔误和排版混乱仍然不应该。但那些在我看来像是显而易见的错误，也许只是刚好落入了我的知识范围；而我的译文里，可能也有落在我知识盲区最后只好瞎蒙的地方，成为别人眼里的低级错误。</p>
<p>欢迎留言指出错误，或者提出你不同的见解。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在写 Go 语言实战系列的文章，中间想聊一下 Go 的设计原则，发现自己理解得还是不够深入，写得辞不达意。然后找到了 Rob Pike 在 8 年前的演讲稿，拜读学习之后，想推荐给我的读者作为学习资料。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
      <category term="翻译" scheme="https://jaycechant.info/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言实战（1）： 初识</title>
    <link href="https://jaycechant.info/2020/golang-in-action-day-1/"/>
    <id>https://jaycechant.info/2020/golang-in-action-day-1/</id>
    <published>2020-08-18T04:15:12.000Z</published>
    <updated>2020-08-20T15:32:30.259Z</updated>
    
    <content type="html"><![CDATA[<p>前几年接触到 Go ，使用一段时间之后就发现这就是我需要的语言。作为一个诞生了只有 10 年的语言，Go 的上升趋势非常之快，尤其受到 web 后端开发者的欢迎。</p>
<a id="more"></a>
<p>可是根据我的了解，身边的朋友多数还是停留在听说的阶段。了解不多，好处不明确，看起来很折腾，然后就算了。所以我想写一个关于 Go 语言的系列，希望给大家一些直观的认识。</p>
<p>这个系列的标题『Go 语言实战』（英文 Golang In Action）跟一本 Go 的入门书撞了，但我实在觉得这个名字很好，也想提醒自己先实战落地，尽量不要一下子涉及太多干巴巴的理论，所以先用着。我没看过那本书，内容如有雷同，纯属巧合。</p>
<h2 id="目标读者"><a href="#目标读者" class="headerlink" title="目标读者"></a>目标读者</h2><p>本系列的目标读者，暂时定位是：</p>
<ul>
<li>有其它语言编程经历，对 Go 感兴趣，希望快速了解和上手 Go；</li>
<li>尝试过 Go，希望进一步系统了解和学习。</li>
</ul>
<p>对于零编程基础、希望同时学习如何编程的朋友来说，这些文章可能省略了部分编程的基础知识。我不确定是否能达到学习编程的效果。如果你们愿意，可以尝试关注我的文章，并参与讨论。文章没有涉及的基础知识和练习，我尝试给出自学建议，或者在评论、群聊中解答。</p>
<p>如果你不愿意或者抽不出时间练习和讨论，希望只是看文章就能学会，我想很难达到效果。</p>
<p>而如果你已经用 Go 写过一些项目，对 Go 有一定的认知，这个系列的文章为了迁就不同人的水平，对你来说也许会过于浅显。当然，如果有大佬愿意指正，甚至参与讨论，在群聊里指导，那是求之不得。</p>
<h2 id="为什么是-Go"><a href="#为什么是-Go" class="headerlink" title="为什么是 Go"></a>为什么是 Go</h2><h3 id="主流的语言"><a href="#主流的语言" class="headerlink" title="主流的语言"></a>主流的语言</h3><p>主流编程语言的排名，根据不同的统计口径略有差异，但前几名基本逃脱不了： C、C++、Java、Python、JavaScript。它们各有所长，互相补充，选择它们当中某几种的组合，就可以包揽几乎所有类型的开发：</p>
<ul>
<li><p>C / C++：硬件相关、操作系统相关、性能极端敏感</p>
<p>  直接跟硬件设备、系统接口打交道，亲自管理内存，避免中间层浪费性能。可以写驱动、嵌入式软件、系统组件、桌面软件和大型游戏。当然，如果对性能足够敏感，对开发成本不敏感，理论上除了 web 前端外的所有软件都可以用 C / C++ 完成。</p>
</li>
<li><p>Java：桌面、Android、web 服务</p>
<p>  如果不需要跟硬件和系统深入打交道，对性能要求不那么极端，又考虑开发效率，Java 则是最主流的选择。JVM 屏蔽了部分技术细节，背后又有多年积累的强大第三方类库（尤其是 Spring 的一系列框架），使 Java 成为企业级软件开发的不二之选。</p>
</li>
<li><p>Python：脚本、数据处理、web 服务</p>
<p>  如果对性能要求进一步放宽，希望提升开发效率，Python 就成了首选。在各种内部使用场景，或者是用户不多的小型服务，性能根本不重要；相反快速落地跑起来特别重要。Python 语法简洁直观，表达能力强，类库也相当丰富（尤其是数据处理、机器学习这一块），大幅降低了非计算机科学科班人员（统计学家、数学家、AI 研究员）的编程门槛，成为了计算机与其他学科交叉领域以及快速原型的第一语言。</p>
</li>
</ul>
<blockquote>
<p>JavaScript 比较特殊。它是 web 前端的唯一语言（浏览器不支持别的），不可被替代。另一方面，虽然通过 node.js 具备了全栈能力，js 的语言特性决定了在前端以外的领域跟专门的语言还是有一定差距，可以作为小团队或者小服务的快速落地选择，却很难替代其它语言。这两点决定了，js 跟其它语言的比较没有太大意义。</p>
</blockquote>
<p>你可能会产生一个疑问：</p>
<p><strong>这些语言还不够吗，为什么还要费劲巴拉再学一个 Go 语言？</strong> </p>
<h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>看一下这样的场景：</p>
<ul>
<li><p>C / C++ 适合开发偏底层、性能敏感的需求。C 简洁但表达力比较弱； C++ 范式较多容易出错；内存管理和并发都是大坑。</p>
<p>  一般的做法，是通过自行开发和引用第三方库，引入相关的类库和规范，去解决这些问题。小心翼翼地挑选库，没有合适的就自行开发，制定规范，说服团队的人达成一致，开发辅助工具和编写静态检查…… 然后，<strong>你基本上等于自行发明了 Go 的部分特性</strong> 。但肯定没有 Go 实现语言级支持那么简洁方便。</p>
<p>  实际上，前金山和盛大的架构师、现七牛云 CEO 许式伟就做过这种事，他用 C++ 开发出了 CERL 库。<strong>但在他用了一周 Go 之后，彻底放弃 CERL，改为使用 Go。</strong> 大家可以看他的自述 《<a href="https://mp.weixin.qq.com/s/_YsuoX4OyWT6CSXuOwc1EA" target="_blank" rel="external">许式伟：我与Go语言的这十年</a>》。</p>
</li>
<li><p>Java（实际上是 Spring 套件）是web 服务最主流的选择。Java 有大量从业人员、企业级的框架，也在过去积累了大量的成功案例。与这些优点相比，语法稍显啰嗦、新特性大幅改动语言、线程重所以大规模并发需要额外引入协程支持等等，都不算什么问题。</p>
<p>  让 Java 略显老态的，可能是（微）服务化 和 容器化 的大背景下，JVM 的摆放位置。从前，编译语言需要为不同平台解决依赖并编译，而 Java 只需要安装一个 JVM，就把平台差异给抹平。单体应用时代，服务器不多，JVM 是配置环境早期一劳永逸的事，当然比每个版本都折腾依赖和交叉编译省事。</p>
<p>  <strong>微服务 和 容器 把这个对比给逆转了。</strong> 微服务大量的应用实例，手动配置环境变得不再现实；JVM 对容器而言，无论容量还是启动速度，都有点太重。另一边，容器把依赖和编译变成了几个镜像的事，不再复杂，编译成二进制开始比虚拟机语言和解释器语言更便利。</p>
<p>  远程开发过一个系统，使用者毫无技术背景。服务除了部署在阿里云上，也有备份在个人电脑上离线演示的需求。很难想象该如何远程指导他们安装 JVM 并配置环境变量，可能还需要 Tomcat，然后正确启停服务。<strong>最后他们并没有去安装 JVM，只是直接运行收到的可执行文件，Go 写的。</strong> 注意这里还没有涉及服务化，没有 Docker 容器。这是我的亲身经历。</p>
</li>
<li><p>Python 分做大项目还是小工具。</p>
<p>  大项目的问题是，规模上去之后，难以通过静态分析发现潜在问题，后续对开发团队的素质要求会越来越高。因为这点，也因为性能问题，Python 开发大型项目似乎不是主流，更多用在脚本、小项目、内部工具上。坚持使用 Python 的团队，往往对代码简洁清晰有追求。这时候，简洁程度相近，更容易发现错误、速度更快的 Go，就很有诱惑力了。</p>
<p>  Python 也有一个运行时，有跟 JVM 类似的问题。Python 自然是脚本和小工具的首选语言，我曾经写过不少。在自己机器和固定几个服务器执行时，没有任何问题。可当需要把工具分享出去时，特别是分享给非开发岗的同事和朋友时，类似 JVM 的问题就出现了。<strong>这些需要分享出去的工具，最后都用 Go 重写了一遍。</strong></p>
</li>
</ul>
<p>借网上两张图来说明（来源：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65）" target="_blank" rel="external">https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65）</a></p>
<p>这篇文章我也做了简单的评论，请看《<a href="https://jaycechant.info/2020/review-why-should-you-learn-go/">为什么你应该学 Go？</a>》</p>
<p><img src="../../images/fast-for-human-vs-fast-for-computer.png" alt=""></p>
<blockquote>
<p>Go 寻求对人友好和对机器友好的平衡。</p>
</blockquote>
<p>Go 诞生得晚，所以对于并发的支持可以从一开始就考虑在内。协程（coroutine）和 CSP 等理论虽然很早就有，但是在早些年还不够流行。现在像 Java 也通过一些第三方库引入了对 协程 和 CSP 模型的支持，但这种支持肯定不如语言内置支持来得简洁有效。</p>
<p><img src="../../images/concurrency-vs-beautiful-code.png" alt=""></p>
<blockquote>
<p>Go 内置 goroutine（go 协程） 和 CSP （Communicating Sequential Processes 通信顺序进程）支持，帮助写出既直观又高效的并发代码。</p>
<p>左下角的语言在诞生之初就没有考虑并发的问题。</p>
</blockquote>
<p>这两张图可能略有点夸张，显得不需权衡就可以我都要；Go 比较靠近右上角，只是可能没有那么右上。但 Go 平衡得比较好，横轴和纵轴都有很好的表现是真的。</p>
<p>即使是 Go 吹，也得承认 Go 有很多不足。除非是底层技术或者计算理论的重大革新，<strong>新语言不过是重新做一次前人做过的选择题</strong>。Go 诞生得晚，吸收了更多经验教训，更符合一部分人的需要。但为了保持最主要的几个优势（像更快的编译和执行速度、更低的心智负担），也做出很多让步，有做不到做不好的地方（如泛型）。</p>
<p>这些选择解决了一批人的痛点，不可能满足所有应用场景和需要：</p>
<ul>
<li>设备或系统深度绑定、极端的性能或者资源要求，还是得 C 和 C++。Go 处理这些场景需要借助 cgo 访问 C，如果项目规模不大，还不如直接写 C。</li>
<li>对于性能、正确性、可用性要求非常苛刻的业务，特别是不必做服务治理的单体应用，Java 的开发框架久经考验，积累了更多成熟的类库和调优经验。相比之下年轻的 Go 虽然在快速追赶，类库的选择范围暂时还窄一些。</li>
<li>至于处理各种数据，追求快速改动、只在本地运行的脚本，Python 就很好。静态强类型反而是累赘。</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>我之前已经写过几篇关于 Go 语言环境配置的文章，在 1.13 包管理正式转向 go module 后，又重新写了两篇。</p>
<p>当前 Go 的最新版本是 1.15。Go 1 承诺接口稳定，向后兼容（backwards compatibility，兼容老代码），最近版本的改动主要集中在编译器、工具链 和 bug fix 上。从使用的角度最大的变动是 1.11 ~ 1.14 之间持续改进的 go module ，所以环境配置直接参考 1.13 时的文章即可。</p>
<p>请根据平台选择：（先把下面的配置教程看完，再接着往下走）</p>
<ul>
<li>Linux / Mac ：<a href="https://jaycechant.info/2020/setup-golang-env-for-1-13-and-above/">配置 1.13+ 的 golang 环境</a></li>
<li>Windows：<a href="https://jaycechant.info/2020/golang-1-13-env-for-win/">配置 1.13+ 的 golang 环境（Windows 篇）</a></li>
</ul>
<p>IDE 方面，大家普遍对 GoLand 和 VS Code 评价很高。不差钱可以选择前者，功能更强响应更快；开源的后者也很不错，机器配置低时偶有卡顿不至于影响使用。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>不能免俗地，我们从 Hello World 程序开始。</p>
<p>都这样开头是有原因的，打印一句话仅仅依赖一个函数，涉及的知识点最少。今天的导入有点长，尽量避免再展开更多复杂的内容。</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>这里假定你已经完成了环境配置，并按照建议将 <code>GO111MODULE</code> 设为 on。（国内为了默认启用 proxy，只能为 on。如果你不知道我说什么，请回到配置教程。）</p>
<p>换言之，包管理使用 Go Module 模式，哪怕只是写最简单的 Hello World，也需要建立 module。</p>
<p>Module 模式下，项目可以随便放在任何方便的地方。为项目新建一个目录，然后在根目录打开一个命令行（Win: cmd / Linux&amp;Mac: Terminal，你也可以在 IDE 里打开，VS Code: View &gt; Terminal，后续不再解释），执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go mod init hello</div></pre></td></tr></table></figure>
<p>你会看到根目录多了一个 <code>go.mod</code> 文件，里面记录了模块名、go 版本，以后还会用来记录依赖信息。</p>
<p>这就建立了一个名为 hello 的 module。这个名字你可以自己改。命名规范等讲到托管再说。现在可以先用小写字母、数字、减号<code>-</code> 的组合（字母开头）先随便起。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>然后新建一个 <code>main.go</code> 写代码。</p>
<p>以下代码请务必自己敲键盘输入。只有这样，才能明确了解这些到底都是什么符号。</p>
<p>如果误输了看起来相似的符号，像输入中文标点，就会出错。这是复制粘贴无法体会的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 程序必须以 main 包作为入口</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">// Println 函数在内置的 "fmt" 包，需要导入</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// main 包必须有一个 main 函数作为入口函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 调用 fmt 包下的 Println 函数，向标准输出打印一个字符串</span></div><div class="line">    <span class="comment">// Println 是 print line 的意思，自带换行</span></div><div class="line">    <span class="comment">// 你可以试着修改引号内的内容</span></div><div class="line">    <span class="comment">// 或者尝试换成 Print 函数看看效果</span></div><div class="line">    fmt.Println(<span class="string">"Hello World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码跑起来有几个选择，初期可以按方便的来。仍然是在刚才的命令行，为了熟悉，也请手敲不要复制：</p>
<ol>
<li><p>直接运行 <code>go run main.go</code></p>
</li>
<li><p>编译后运行</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先编译</span></div><div class="line">go build</div><div class="line"><span class="comment"># 编译结果是模块名，执行时替换成你的模块名</span></div><div class="line">./hello</div></pre></td></tr></table></figure>
</li>
<li><p>IDE 有执行插件，可以直接运行</p>
</li>
</ol>
<p>为了帮助理解后续的加载流程，试着加入 常量、变量和初始化函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 程序必须以 main 包作为入口</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="comment">// Println 函数在内置的 "fmt" 包，需要导入</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="comment">// 常量</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    prefix = <span class="string">"Go-in-action:"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// （包级）全局变量</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    sentence <span class="keyword">string</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// init 函数，包第一次加载初始化时调用</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 你可以试着修改引号内的内容</span></div><div class="line">    sentence = prefix + <span class="string">"第一天打卡！"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main 包必须有一个 main 函数作为入口函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 调用 fmt 包下的 Println 函数，向标准输出打印一个字符串</span></div><div class="line">    <span class="comment">// Println 是 print line 的意思，自带换行</span></div><div class="line">    fmt.Println(sentence)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>理论知识可能枯燥，但绕不过去，只好尽量分散每次讲一点。</p>
<p>现在你已经把第一个 Go 程序跑起来，我们接着聊聊一个程序的结构。</p>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>Go 语言程序组织的基本单位是包（package）。</p>
<p>这点有点像 Java，都是通过一个类似 URL 的地址来唯一确定一个包，并以此引用。但是两者又有很多的不同。</p>
<blockquote>
<p>以下对比主要方便有 Java 经验的朋友快速理解。没写过 Java 的朋友可以跳过 Java 部分。</p>
<p>myproj/src/com/example/foo/bar/pkg1/MyClass.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.foo.bar.pkg1;</div><div class="line"></div><div class="line"><span class="comment">// 导入包</span></div><div class="line"><span class="keyword">import</span> com.example.foo.bar.pkg2.MyClass2;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 各种成员必须从属于某个类</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    <span class="comment">// 已导入的类直接使用类名访问</span></div><div class="line">    MyClass2 mc2 = <span class="keyword">new</span> MyClass2();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>myproj/foo/bar/pkg1/whatever.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pkg1</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="comment">// 一般情况下，这个包就叫 pkg2</span></div><div class="line">    <span class="string">"example.com/myproj/foo/bar/pkg2"</span></div><div class="line">    <span class="comment">// 又来一个 pkg2，导入时可以指定一个名字，避免引用时跟上面重名</span></div><div class="line">    other <span class="string">"example.com/other/pkg2"</span></div><div class="line">    <span class="comment">// 下面这个包的包名定义为 "package special"，与路径不一致，一般不推荐这样定义</span></div><div class="line">    <span class="string">"example.com/other/dir"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 跟 Java 不同，常量、变量、类型、函数等成员可以作为『第一公民』</span></div><div class="line"><span class="comment">// 直接从属于包</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ( <span class="comment">// 常量</span></div><div class="line">    MyConst <span class="keyword">int</span> = <span class="number">1</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> ( <span class="comment">// 变量</span></div><div class="line">    MyVar float = <span class="number">2.3</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123; <span class="comment">// 结构体</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">    <span class="comment">// 引用 example.com/myproj/foo/bar/pkg2</span></div><div class="line">    <span class="keyword">var</span> ms2 pkg2.MyStruct2</div><div class="line">    pkg2.MyFunc2()</div><div class="line">    <span class="comment">// 引用 example.com/other/pkg2 （导入同时重命名为 other）</span></div><div class="line">    other.OtherFunc()</div><div class="line">    <span class="comment">// 引用的是 example.com/other/dir，为什么会这样，下面看它的定义</span></div><div class="line">    c := special.SomeConst</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>example.com/other/dir/file-name-not-matters.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入路径最后一级目录是 dir，包名却是 special</span></div><div class="line"><span class="comment">// 没有特殊理由不推荐这样操作，会给调用方造成困扰</span></div><div class="line"><span class="keyword">package</span> special</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    SomeConst = <span class="number">42</span></div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>包名<ul>
<li>Java 包名类似 URL 域名部分，以 <code>.</code> 隔开。为了确保全网唯一性，一般以作者的域名作为前缀（如 <code>example.com</code>，作为包名前缀时倒序从顶级域名写起）。无论声明还是导入，都需要写完整的包名。</li>
<li>Go （基于 Go Module 的包管理）则多出 module 这个概念：module 是一到多个放在一起的包的集合。完整的包路径包含 module 名 和 相对 module 的文件夹路径（module 名如 <code>example.com/myporj</code> ，在 module 根目录的 <code>go.mod</code> 里定义，一般对应托管地址）。<strong>Go 的 包名 与 包路径互相独立：声明、引用时用包名；导入时用包路径。没有特殊理由，包名一般与所在目录保持一致，避免调用方还要查看包名。</strong></li>
</ul>
</li>
<li>最小单位<ul>
<li>Java 中类（广义的类，包括 抽象类 和 接口）是唯一的一等公民，所有成员都无法脱离类存在。所以包管理的最小单位其实是 类。同一个包允许有多个 <code>.java</code> 文件，每个文件是一个类。导入时也是导入类。</li>
<li>Go 则以包为最小单位。同一个包允许有多个 <code>.go</code> 文件，但都属于同一个包，分开写只是方便管理，编译时会自动合并。导入包后，通过包名引用该包下的公开成员（更准确的说法是 exported 成员）。</li>
</ul>
</li>
</ul>
<p>对于 module 和 package ，这里先留个印象，如果觉得信息量大可以先不深究。更多关于 Go 包管理的讨论，可以看这篇 《<a href="https://jaycechant.info/2020/golang-1-13-module-VS-package/">golang 1.13 - module VS package</a>》。</p>
<h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p>Go 的可执行程序，必定包含一个 main 包，里面有一个签名为 <code>main()</code>  的函数。<strong>这就是程序的执行入口</strong>。这跟 C style 语言非常类似，不过 Go 的 main 函数既没有参数，也没有返回值。</p>
<p>如果需要解析命令行参数，需要导入 <code>os</code> 包通过 <code>os.Args</code> 获取（也有第三方包封装了更方便易用的接口）。类似地，如果错误退出想返回错误码，也是通过 <code>os</code> 包的 <code>os.Exit(code)</code> 进行。</p>
<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>会自动调用的特殊函数除了 main 包的 main 函数以外，还有就是签名为 <code>init()</code> 的函数。</p>
<p>每个包允许有零到多个 init 函数。它们会在包被第一次导入时，常量、变量初始化之后被调用。<strong>同包的多个 init 函数会按照某种顺序依次执行。官方没有对顺序作出任何保证，最好当作乱序执行，程序逻辑不要依赖执行顺序。</strong></p>
<p>整个程序的初始化顺序从加载 main 包开始，然后递归加载导入的包。</p>
<p>在被加载的包内部，先完成所有依赖包的加载和初始化（如果是加载过的包，则跳过初始化），然后初始化当前包的常量、变量，执行所有 init 函数。</p>
<p><img src="../../images/go-starter-package-init.svg" alt=""></p>
<blockquote>
<p>main 包 import pkg2 时，pkg2 已经完成了初始化，直接导入即可</p>
</blockquote>
<p>在依赖最底层的包（同时不依赖任何别的包）最晚被加载，却最早完成初始化。相反 main 包第一个被加载，却最后完成初始化，然后调用 main 函数。</p>
<p><strong>Go 不允许循环导入。</strong></p>
<p>被依赖方的初始化过程，不能依赖任何依赖方创建的东西。如， A import B，则不仅 B 不能导入 A，而且在 B 初始化的过程中要当 A 不存在，不能依赖于 A 创建的全局状态 或 依赖注入。</p>
<p>特别地，main 作为所有初始化完成之后才调用的函数，不能被任何初始化过程依赖。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>第一篇不可避免要导入一些概念，尽管一再删减，抽象的内容还是聊得有点多，先到这里。理论的内容，等接触一段时间，有了实际体会再补不迟。</p>
<p>因为照顾不同读者的需要，也因为是第一篇，我对内容的深浅繁简没有把握，需要根据反馈调整。没有涉及到的内容，只能通过评论和群聊补充。新朋友可以添加微信号『存档君（MrArchive）』，说明来意后加群讨论。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h3><p>掌握编程语言仅仅是软件开发的第一步，后面还要掌握一定的 数据结构、算法 以及 具体业务的知识。就像掌握了画笔和颜料的使用，不代表就能画出漂亮的画作。</p>
<p>从头学编程的朋友，推荐在掌握语言基础之后，尝试去解决 <a href="https://leetcode-cn.com/" target="_blank" rel="external">https://leetcode-cn.com/</a>  easy 的题目。</p>
<p>做现实中的项目，我们要先识别需求（有时产品的同学会帮忙），将需求转换为技术描述，定义和分解问题，然后把问题逐个解决，组装成最终的软件。新手可能还没开始写代码就被难住了。相比之下，LeetCode 将经典问题抽象简化，直接给定了输入输出的数据类型和范围，你只需要考虑代码的实现。这种命题作文乃至看图说话，是一个很好的开始。</p>
<p>有编程经验的朋友，当然也可以刷题来加强，难度根据自己的实际情况挑选。我也会不定期发布用 Go 刷 LeetCode 的题解。</p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p>推荐一些 Go 的学习资源作为补充：</p>
<ul>
<li><p>菜鸟教程：<a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="external">https://www.runoob.com/go/go-tutorial.html</a></p>
<p>  比较简略，很多知识没有涉及。但是胜在足够简略，初学者看了不会晕。可以当做入门的手册。</p>
</li>
<li><p>Go by samples：<a href="https://gobyexample.com/" target="_blank" rel="external">https://gobyexample.com/</a></p>
<p>  不废话，直接上例子。适合有一定基础的朋友，直接看例子学习。</p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几年接触到 Go ，使用一段时间之后就发现这就是我需要的语言。作为一个诞生了只有 10 年的语言，Go 的上升趋势非常之快，尤其受到 web 后端开发者的欢迎。&lt;/p&gt;
    
    </summary>
    
      <category term="Go 语言实战" scheme="https://jaycechant.info/categories/Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="golang" scheme="https://jaycechant.info/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 解题：统计全 1 子矩阵</title>
    <link href="https://jaycechant.info/2020/leetcode-1504-count-submatrices/"/>
    <id>https://jaycechant.info/2020/leetcode-1504-count-submatrices/</id>
    <published>2020-07-10T13:05:25.000Z</published>
    <updated>2020-08-12T09:21:58.819Z</updated>
    
    <content type="html"><![CDATA[<p>上周末试着参加了一下 LeetCode 的周赛。</p>
<a id="more"></a>
<blockquote>
<p>文章是 7/10 写的，所以这里指的是 7/5 的周赛</p>
</blockquote>
<p>90 分钟，总共四题，分别一题简单，两题中等，一题困难。在我看来，第 1、2 题都算简单，第 3 题的中等我很多年前做过；只有第 4 题最优解要用到比较少见的算法，不过还是有网友暴力解通过。</p>
<p>就是这样的难度，第 2 题一开始没反应过来，先做后面，然后在第 3 题耗费了太多时间（约 1H），留给 2 、4 的时间都不太够，最后只 AC  1、3。相比之下，最快的参加者 17 分钟全部 AC。自尊心受到暴击，只能用刚刚恢复刷题，太生疏给自己台阶。做的时候感觉很顺畅，回头一看时间，都不知道怎么跑掉的。是中年人反应迟钝了吗？</p>
<p>不管怎样，3、4 题还是值得说一下的。今天先讲第 3 题，对应 1504 号。</p>
<p>英文：<a href="https://leetcode.com/problems/count-submatrices-with-all-ones/" target="_blank" rel="external">https://leetcode.com/problems/count-submatrices-with-all-ones/</a></p>
<p>中文：<a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones/" target="_blank" rel="external">https://leetcode-cn.com/problems/count-submatrices-with-all-ones/</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h3><p>给定由 0, 1 组成的矩阵，<strong>求 元素全是 1 的子矩阵</strong> 的数量。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">输入：</div><div class="line">1,0,1</div><div class="line">1,1,0</div><div class="line">1,1,0</div><div class="line"></div><div class="line">输出：13</div><div class="line"></div><div class="line">解释：</div><div class="line">有 6 个 1x1 的矩形。</div><div class="line">有 2 个 1x2 的矩形。</div><div class="line">有 3 个 2x1 的矩形。</div><div class="line">有 1 个 2x2 的矩形。</div><div class="line">有 1 个 3x1 的矩形。</div><div class="line">矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13</div></pre></td></tr></table></figure>
<p>更多例子看测试用例</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul>
<li>行列最小 1，最大 150</li>
<li>矩阵元素只有 0 和 1</li>
</ul>
<p>为了后续方便讨论，约定行数为 R，列数为 C。</p>
<h2 id="测试代码先行"><a href="#测试代码先行" class="headerlink" title="测试代码先行"></a>测试代码先行</h2><blockquote>
<p>《<a href="../rapidly-generate-unit-tests-in-vs-code/">如何快速生成单元测试</a>》</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_numSubmat</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	tests := []<span class="keyword">struct</span> &#123;</div><div class="line">		name <span class="keyword">string</span></div><div class="line">		mat  [][]<span class="keyword">int</span></div><div class="line">		want <span class="keyword">int</span></div><div class="line">	&#125;&#123;</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"min0"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">0</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">0</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"min1"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">1</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"1"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">13</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"2"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">				&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">24</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"3"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">21</span>,</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			name: <span class="string">"4"</span>,</div><div class="line">			mat: [][]<span class="keyword">int</span>&#123;</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</div><div class="line">				&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</div><div class="line">				&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</div><div class="line">			&#125;,</div><div class="line">			want: <span class="number">5</span>,</div><div class="line">		&#125;,</div><div class="line">        <span class="comment">// 现在 LeetCode 周赛一次错误提交只罚时 5 分钟，代价不算大</span></div><div class="line">        <span class="comment">// 简单添加一些能马上想到的 case 即可，折腾超过 5 分钟不值</span></div><div class="line">        <span class="comment">// 能通过简单的 case 可以先提交一次，不行再针对强化</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</div><div class="line">		t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">			<span class="keyword">if</span> got := numSubmat(tt.mat); got != tt.want &#123;</div><div class="line">				t.Errorf(<span class="string">"numSubmat() = %v, want %v"</span>, got, tt.want)</div><div class="line">			&#125;</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>暴力做法非常简单，一句话带过：首先 O(RC) 遍历左上角选点，然后 O(RC) 遍历右下角选点，再用 O(RC) 判断选定的矩阵是否全 1，<strong>时间复杂度为 O((RC)^3)</strong> ，空间复杂度 O(1)。（提醒：R 是行数，C 是列数）也许数据弱的话能 AC（我没试），比赛时间不够也许可以蒙一下，但没有讨论价值。</p>
<p>这道题明显有大量重复子问题，稍有经验都应该马上往动态规划上靠。关于动态规划的基础常识，可以先看之前的文章：《<a href="../leetcode-10-regular-expression-matching/">LeetCode 题解： Regular Expression Matching</a>》，以后考虑围绕基础知识点写一些文章。</p>
<p>想到 DP 容易，难点是定义子问题，状态如何转移。多年前那次和这次，都第一时间知道是 DP 的题，仍然耗费不少时间想具体的状态转移方程。（虽然做过，相似的矩阵题太多，过了一阵才认出来，又花了一点时间回想有哪些方案。）</p>
<h3 id="思考方向"><a href="#思考方向" class="headerlink" title="思考方向"></a>思考方向</h3><p>最明显的重复运算，是对候选矩阵做全 1 判断。能否记录某些中间状态，根据少数点是否为 1， 结合这些中间状态得到下一个状态，避免前面判断过的 位置 再来一遍？</p>
<p>根据以往做 DP 的经验，一般是 <code>dp[r][c]</code> 代表到 r 行 c 列为止的某个结果。例如，我们定义两个矩阵 <code>width[r][c]</code> 和 <code>height[r][c]</code> 代表以 (r, c) 为右下角的矩阵的最大宽度和最大高度，从左上到右下运算。有没有可能从前面的状态，推算出以(r, c) 为右下角的极大矩阵呢？</p>
<p><img src="../../images/leetcode1504/leetcode1504-try-dp.svg" alt=""></p>
<blockquote>
<p>绿色表示已经处理过的点，白色表示待处理的点。下同。</p>
</blockquote>
<p>很难。我们找极大矩阵，是因为知道极大矩阵的大小，就很容易计算它有多少个子矩阵。但极大矩阵可以有很多个，光凭最大宽度和最大高度两个信息，无法计算出这么多个极大矩阵。那还要记录多少信息才够？</p>
<p><img src="../../images/leetcode1504/leetcode1504-extreme-matrix.svg" alt=""></p>
<blockquote>
<p>极大矩阵是指，这个矩阵在边界上碰到了 0，没办法变得更大了。但它不一定是最大的矩阵。</p>
<p>记录最大宽和最大高之所以很难用得上，是因为它们很可能不是在同一个矩阵上记录的，也很难用来计算那么多个极大矩阵。</p>
</blockquote>
<p>换一个角度看为什么这么难。假定可以用 O(1) 完成状态转移，计算出 (r, c) 点为右下角的所有极大矩阵，由于右下角只有 O(RC) 种情况，换言之时间复杂度从 O((RC)^3) 降到了 O(RC)，优化幅度非常大 。但多个极大矩阵真的能用 O(1) 时间就计算出来吗？要借用哪些中间结果？</p>
<p>事实上，这个方向是可行的。但我们先从简单一点的开始。</p>
<h2 id="压缩-DP"><a href="#压缩-DP" class="headerlink" title="压缩 + DP"></a>压缩 + DP</h2><p>二维的情况复杂，是因为长宽有多种组合；如果长宽不能同时达到最大，就会产生大量极大矩阵。</p>
<p>那就 <strong>从一维开始找规律</strong> 。</p>
<h3 id="一维问题：全-1-子段数"><a href="#一维问题：全-1-子段数" class="headerlink" title="一维问题：全 1 子段数"></a>一维问题：全 1 子段数</h3><p><img src="../../images/leetcode1504/leetcode1504-1d-dp.svg" alt=""></p>
<p>一维的情况，问题简化成『统计全 1 子段数』，其中任意长度不为 0 的连续区间 ，都是子段（interval）。假定数组长度为 N，Brute-Force 的做法是，O(N) 选左端点，O(N) 选右端点，O(N) 判断是否全 1，时间复杂度 O(N^3)。</p>
<p>这时用 DP，状态转移方程很好写。假定有一维数组 A，里面同样是 0 或 1。定义 L[i] 为 以第 i 个元素为右边界的子段的最大长度（换言之，连续多少个 1），很容易得到</p>
<p>$$<br>\left{<br>\begin{array}{lr}<br>L<em>i = L</em>{i-1} + 1, &amp; (A_i = 1)\<br>L_i = 0 &amp; (A_i = 0)<br>\end{array}<br>\right.<br>$$</p>
<p>大白话就是，<strong>遇到 1，最大长度加 1；遇到 0，长度清零</strong> 。</p>
<p>再定义 C[i] 为到 第 i 个元素为止，累计的的字段数，状态转移方程为</p>
<p>$$<br>\left{<br>\begin{array}{lr}<br>C<em>i = C</em>{i-1} + L_i, &amp; (A_i = 1)\<br>C<em>i = C</em>{i-1} &amp; (A_i = 0)<br>\end{array}<br>\right.<br>$$</p>
<p>大白话就是，遇到 1，就增加『当前子段最大长度 L[i] 这么多个子段数』；遇到 0，统计数字不变。为什么是 L[i] ？因为 <strong>以 A[i] 为右端点的子段刚好是 L[i] 个，分别为长度为 1、长度为 2、长度为 … 长度为 L[i] </strong> 。</p>
<p>DP 跟 BF 相比，省略了重复运算，但思维不严谨的话，很容易出现重复或者遗漏。我们来确认一下，是否每个左端点和右端点的组合都包含了一次：对于右端点，每个 A[i] = 1 ，都访问且只访问了一次；在确定右端点之后，每个和右端点连续（中间没有 0）的左端点都刚好统计了一次（L[i] 个）。</p>
<p>对于每个元素 A[i]，分别需要常数时间计算 L[i] 和 C[i] ，时间复杂度为 O(N)。由于 L 和 C 都只和当前元素和前一个状态相关，只需保留最后一个状态，没有必要保存数组，空间复杂度为 O(1)。</p>
<p>代码非常简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numInterval</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	length := <span class="number">0</span></div><div class="line">	count := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> _, elem := <span class="keyword">range</span> A &#123;</div><div class="line">		<span class="keyword">if</span> elem == <span class="number">1</span> &#123;</div><div class="line">			length++</div><div class="line">			count += length</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			length = <span class="number">0</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二维问题：压缩成一维"><a href="#二维问题：压缩成一维" class="headerlink" title="二维问题：压缩成一维"></a>二维问题：压缩成一维</h3><p>一维的情况简单，我还是尽量详细地讲，因为这是理解接下来内容的基础。</p>
<p>对于高度为 2 的矩阵，求全 1 子矩阵数。这些子矩阵，高度要么为 1，要么为 2。<strong>对于高度为 1 的子矩阵，情况退回到 一维，分别对每一行应用一维的算法即可</strong> 。而对于高度为 2 的子矩阵，可以『压缩』成高度为 1，再应用一维的算法。</p>
<p><img src="../../images/leetcode1504/leetcode1504-2d-to-1d.svg" alt=""></p>
<p><strong>以此类推，任意高度的子矩阵，也可以压缩成一行处理</strong> 。而且，<strong>R 行压缩成一行，并不需要每次从头开始压缩；只需要在前 R - 1 行的结果上，再合并一行</strong> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSubmat</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	count := <span class="number">0</span></div><div class="line">	rowNum := <span class="built_in">len</span>(mat)</div><div class="line">	colNum := <span class="built_in">len</span>(mat[<span class="number">0</span>])</div><div class="line"></div><div class="line">	<span class="comment">// 压缩的结果只需要保留一行进行运算</span></div><div class="line">	<span class="comment">// 用 bool 值保存节省空间</span></div><div class="line">	mymat := <span class="built_in">make</span>([]<span class="keyword">bool</span>, colNum)</div><div class="line"></div><div class="line">	<span class="comment">// 遍历开始压缩的行数</span></div><div class="line">	<span class="keyword">for</span> rowSt := <span class="number">0</span>; rowSt &lt; rowNum; rowSt++ &#123;</div><div class="line">		<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">			mymat[col] = <span class="literal">true</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 遍历结束的行数</span></div><div class="line">		<span class="keyword">for</span> rowEd := rowSt; rowEd &lt; rowNum; rowEd++ &#123;</div><div class="line">			length := <span class="number">0</span></div><div class="line">			<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">				<span class="keyword">if</span> mat[rowEd][col] == <span class="number">0</span> &#123;</div><div class="line">					<span class="comment">// 同一列上任意一行为0，这个位置就断开了</span></div><div class="line">					mymat[col] = <span class="literal">false</span></div><div class="line">				&#125;</div><div class="line">				<span class="comment">// 压缩后，应用一维的算法</span></div><div class="line">				<span class="keyword">if</span> mymat[col] &#123;</div><div class="line">					length++</div><div class="line">					count += length</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					length = <span class="number">0</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>O(R) 遍历开始行，O(R) 遍历结束行，O(C) 的时间压缩每一行并应用一维的算法，时间复杂度为 O(R^2 * C)。只用了一行的额外空间保存压缩行，空间复杂度为 O(C)。由于 R 比 C 遍历多了一层，如果行数比列数大得多，可以将行列交换运算。代码比较麻烦，不再展开。</p>
<p>回到正确性的问题，是否不重不漏？横向在一维时已经讨论过了。纵向，O(R^2) 把所有开始行和结束行的组合都遍历了。换言之，所有的左上角和右下角的组合，都刚好地访问了一遍。</p>
<h2 id="单调栈-DP"><a href="#单调栈-DP" class="headerlink" title="单调栈 + DP"></a>单调栈 + DP</h2><p>上述解法已经相当优秀，将六次方的 BF 解法，降了 3 个阶。（这里为了方便讨论，把 R、C 看做相近的数量级，都当成 N 处理，相当于从 O(N^6) 降到了 O(N^3) 时间复杂度）</p>
<p>当年第一次遇到这道题，我甚至都没能一下子想到这种办法，想通时已经不够时间实现和调试。还是事后同事 Lucy 跟我们讲了思路。之后很长一段时间，没有再细想，把这当成最优解。</p>
<p>直到这次，顺便逛了一下讨论区，居然发现还能 O(RC) ！？</p>
<blockquote>
<p>以下解法并非我的原创，而是看了 LeetCode 美国站讨论区后，根据网友提供的思路，重新实现和用自己的话解释一遍。主要为了分享和加深理解。</p>
<p>平时做的答案，其核心思想，其实也是学来的（主要是大学算法课）。毕竟常见，不需要特别声明。</p>
<p>这次的解法比较绕，不敢掠美，特此声明。</p>
</blockquote>
<h3 id="子问题：分割极大矩阵"><a href="#子问题：分割极大矩阵" class="headerlink" title="子问题：分割极大矩阵"></a>子问题：分割极大矩阵</h3><p>我们回到一开始想到用 动态规划 时提出的问题：『<strong>能不能遍历为 1 的点作为右下角，结合少量中间状态，算出新的中间状态，并逐渐推导出答案？</strong>』</p>
<p>这个问题难在子问题和中间状态的定义。怎么定义，中间状态定义多少个，才能应付最多时跟 R、C 同量级的极大矩阵？</p>
<p>我们把问题简化，先不想怎么判断和划分，假定已经找到了一个 r 行 c 列的极大全 1 矩阵，里面有多少个 <strong>包含右下角的点</strong> 的子矩阵？</p>
<p>答：r x c 个。</p>
<p><img src="../../images/leetcode1504/leetcode1504-submat-with-same-right-bottom-point.svg" alt=""></p>
<p>包含右下角（最后一行结束），子矩阵高度（开始行）有 r 种可能；包含右下角（最后一列结束），矩阵宽度（开始列）有 c 种可能。组成起来有 r x c 种 子矩阵。换言之，<strong>只要找到以当前点为右下角的极大子矩阵，就能直接算出以此为右下角的全部子矩阵数量</strong> 。</p>
<p><img src="../../images/leetcode1504/leetcode1504-extreme-matrix-2.svg" alt=""></p>
<p>难点在于极大子矩阵根本不止一个，叠在一起可能是锯齿状的，也可能是驼峰状的，极难记录和统计。不过只要用递归分治的思想划分一下子问题，难点就变简单了。</p>
<p><img src="../../images/leetcode1504/leetcode1504-extreme-matrix-3.svg" alt=""></p>
<p>我们定义 C[i][j] 为 『以点 (i, j) 为右下角的子矩阵数量』。mat[i][j] 为 0 时，这个点不能构成任何子矩阵，所以只讨论为 1 的情况。如图所示，以第一个白色点 (4, 5) 为右下角的极大子矩阵，一共有 3 种宽高组合（1x6, 2x4, 4x2），它们重叠在一起，构成了一个不规则的形状。将其纵向划分成 3 个互不重叠的 3 个矩阵 X, Y, Z。（不一定是 3 个，实际可能更多，最多时可以分成每列一个）</p>
<p>那么 C[4][5] 就等于 X （包含右下角）的子矩阵数（4x2），加上 C[4][3]。之所以这样算，是因为所有以 (4, 3) 为右下角的子矩阵，都可以列数加 2 ，变成以 (4, 5) 为右下角。通过这样划分子问题，<strong>无论有多少个极大子矩阵，我们只需要计算包含当前右下角最右（同时也是最高）的一个极大子矩阵，再引用之前的子问题即可</strong> 。</p>
<p>为什么最右的极大子矩阵一定是最高的呢？因为子矩阵的高度无法超过右下角所在列的高度。上图中 列4 的高度为 5 （蓝色的(0, 4)点），但是这个点无法跟右下角构成矩阵。</p>
<h3 id="引入-高度记录-和-高度栈"><a href="#引入-高度记录-和-高度栈" class="headerlink" title="引入 高度记录 和 高度栈"></a>引入 高度记录 和 高度栈</h3><p>不过问题还没解决：</p>
<ul>
<li>如何知道最右的极大子矩阵的宽高？（4 和 2 怎么得到）</li>
<li>如何知道上一个子问题是哪个？（怎么得知要引用 (4, 3) 的子问题） </li>
</ul>
<p>后面这个问题好回答，要引用的子问题，就是当前子问题减掉当前极大子矩阵宽度（2）的子问题。问题变成了：<strong>当前极大子矩阵的宽高如何获取</strong> 。</p>
<p>为此，引入两个记录：</p>
<ul>
<li>高度记录 h[i][j] ，记录每列到当前点的最大高度（连续 1 的个数）。</li>
<li>每行的高度栈，记录单调递增的高度序列。</li>
</ul>
<p>先说高度记录，计算方法跟上一个解法的最大长度一样，只是变成纵向。有了它，极大子矩阵的宽高都能获得：高，就是当前列的高度（例子中为 4）；宽则稍复杂一点，需要找到左边第一个比当前列低的列（例子中为 列 3），两列之间宽度就是极大子矩阵的宽度（5 - 3 = 2）。</p>
<p>如果不考虑时间复杂度，高度记录就足以解决问题。但是每次都要搜索左边的高度记录，导致每行的复杂度为 O(C^2) ，乘以行数后整体为 O(R*C^2)，则跟第一种解法相比并无改进。所以引入高度栈，维护一个严格单调递增的高度序列。每当拿到新一列的高度，先将栈里大于等于当前列的高度出栈，剩下的栈顶的列，就是左边第一个比当前列低的列。完成之后将当前列进栈，继续下一步。</p>
<blockquote>
<p>实际实践中，栈里一般储存列号，方便计算宽度，高度根据列号到 高度数组查询。</p>
</blockquote>
<p><img src="../../images/leetcode1504/leetcode1504-height-stack.svg" alt=""></p>
<p>由于高度一旦下降，之前更高的列就无法与后续的点构成矩阵，所以出栈的高度再也不会用到。每个列都只会进栈一次，也（最多）只会出栈一次，遍历一行的时间复杂度就降低到了 O(C)。</p>
<p>如果这部分感觉有点迷糊，跟其它难点混在一起难以理解，可以先尝试做 LeetCode 84 ，在一维的情况下，把高度栈搞懂。</p>
<p>上代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSubmat</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	count := <span class="number">0</span></div><div class="line">	rowNum := <span class="built_in">len</span>(mat)</div><div class="line">	colNum := <span class="built_in">len</span>(mat[<span class="number">0</span>])</div><div class="line"></div><div class="line">	<span class="comment">// 高度记录只用到最后一行，保留一行即可</span></div><div class="line">	heights := <span class="built_in">make</span>([]<span class="keyword">int</span>, colNum)</div><div class="line">	<span class="comment">// DP 解，以当前点为右下角的子矩阵数，同样只用到最后一行，只保留一行</span></div><div class="line">	dpCount := <span class="built_in">make</span>([]<span class="keyword">int</span>, colNum)</div><div class="line">	<span class="comment">// 高度栈，注意保存的是列号，列高还得到 heights 取</span></div><div class="line">	hStack := newStack()</div><div class="line">	<span class="comment">// 行循环</span></div><div class="line">	<span class="keyword">for</span> row := <span class="number">0</span>; row &lt; rowNum; row++ &#123;</div><div class="line">		<span class="comment">// 只有一个高度栈循环利用，每行开始前摇清空</span></div><div class="line">		hStack.clear()</div><div class="line"></div><div class="line">		<span class="comment">// 列循环</span></div><div class="line">		<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">			<span class="comment">// 计算当前列高度</span></div><div class="line">			<span class="keyword">if</span> mat[row][col] == <span class="number">1</span> &#123;</div><div class="line">				heights[col]++</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				heights[col] = <span class="number">0</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 将栈里高度 大于等于当前列 的列出栈</span></div><div class="line">			<span class="keyword">for</span> hStack.size() &gt; <span class="number">0</span> &amp;&amp; heights[hStack.top()] &gt;= heights[col] &#123;</div><div class="line">				hStack.pop()</div><div class="line">			&#125;</div><div class="line"></div><div class="line"></div><div class="line">			<span class="keyword">if</span> hStack.size() == <span class="number">0</span> &#123;</div><div class="line">				<span class="comment">// 一直到最左，没有列比当前列 低，宽度直接为 列号 + 1 （列号从 0 开始）</span></div><div class="line">				dpCount[col] = heights[col] * (col + <span class="number">1</span>)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="comment">// 找到左边第一个比当前列低的列，宽度为列号的差，并加上该列的子矩阵数</span></div><div class="line">				preCol := hStack.top()</div><div class="line">				dpCount[col] = dpCount[preCol] + heights[col]*(col-preCol)</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// 当前列进栈</span></div><div class="line">			hStack.push(col)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 结束本行前，将本行结果累计，下一循环就会被覆盖</span></div><div class="line">		<span class="keyword">for</span> col := <span class="number">0</span>; col &lt; colNum; col++ &#123;</div><div class="line">			count += dpCount[col]</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> count</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 基于切片自行实现了一个简单的栈</span></div><div class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</div><div class="line">	data []<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStack</span><span class="params">()</span> *<span class="title">stack</span></span>      &#123; <span class="keyword">return</span> &amp;stack&#123;data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)&#125; &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">size</span><span class="params">()</span> <span class="title">int</span></span>  &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s.data) &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123; s.data = <span class="built_in">append</span>(s.data, v) &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">top</span><span class="params">()</span> <span class="title">int</span></span>   &#123; <span class="keyword">return</span> s.data[<span class="built_in">len</span>(s.data)<span class="number">-1</span>] &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span></span>       &#123; s.data = s.data[:<span class="built_in">len</span>(s.data)<span class="number">-1</span>] &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">clear</span><span class="params">()</span></span>     &#123; s.data = s.data[:<span class="number">0</span>] &#125;</div></pre></td></tr></table></figure>
<p>正确性</p>
<ul>
<li>不重：右下角不同的子矩阵肯定不是同一个子矩阵。</li>
<li>不漏：每一个点都作为右下角遍历了一次，每次把以该点为右下角的子矩阵都计算在内。</li>
</ul>
<p>复杂度</p>
<ul>
<li><p>时间复杂度：最外层每行遍历一次，内层同时做两件事：</p>
<ul>
<li>每个点作为右下角计算一次，计算过程为常数；</li>
<li><p>每个列下标都进栈一次，最多出栈一次。（如果一直单调递增就不出栈）；</p>
<p>整体的复杂度为 O(RC)。</p>
</li>
</ul>
</li>
<li><p>空间复杂度：常数组辅助变量，每组变量大小为 C；单调栈也最多进栈 C 个列下标，复杂度为 O(C)。</p>
</li>
</ul>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周末试着参加了一下 LeetCode 的周赛。&lt;/p&gt;
    
    </summary>
    
      <category term="刷题" scheme="https://jaycechant.info/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="https://jaycechant.info/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>聊聊儿童安全座椅</title>
    <link href="https://jaycechant.info/2020/about-child-restraint-system/"/>
    <id>https://jaycechant.info/2020/about-child-restraint-system/</id>
    <published>2020-06-20T05:06:31.000Z</published>
    <updated>2020-06-21T15:53:35.827Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，我们这批人都到了养娃的年纪。进度快的，孩子都上小学了；稍慢的，也在这几年开始集中报喜。我也是一个父亲。</p>
<a id="more"></a>
<p>在等待孩子到来的时间里，我们跟所有家庭一样，紧张、忙碌、又期待，做了大量准备功课。现在作为过来人，看到身边正在迎接新生命的朋友，总忍不住提醒几句：这个必须买，那个智商税，这样做有危险，疫苗规划了吗……</p>
<p>这两天突然想起提醒他们买安全座椅。为了避免重复费口舌，写下来吧。</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我只是一个普通的父亲，并非汽车或者安全座椅的专业人士。以下内容仅来自我的亲身经历和有限的了解，希望给身边的朋友一个参考。</p>
<p>这篇文章希望引起大家对安全座椅的重视，让不知道安全座椅的家长知道，让不打算买的去买，让本来想随便买的认真考虑再买，但它不是：</p>
<ul>
<li>专业的科普；</li>
<li>购买指南；</li>
<li>型号推荐。</li>
</ul>
<p>我不打算查一堆案例，劝无论如何不想买的人买，毕竟那是你家人的安全；也不认为你看完跟着买就万无一失。如果有时间，你应该自己做功课，根据自己的经济条件和需求选择，这里只是开一个头。当然，如果你实在觉得无从下手，跟着流程走一遍，大概会比抓瞎乱买强。</p>
<h2 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h2><p>开头先强调一些基本常识。</p>
<h3 id="必须得买"><a href="#必须得买" class="headerlink" title="必须得买"></a>必须得买</h3><p><strong>只要孩子坐车，必须得有安全座椅</strong>。要不就别坐。</p>
<p>跟大人要系安全带一个道理，包括后排。如果觉得不系安全带没什么大不了，请关掉这篇文章，先去看安全带的教育宣传片，看看系与不系伤亡率差距有多大。</p>
<p>然后你说『我系好安全带，然后牢牢地抱住孩子』。</p>
<p>很遗憾，抱不住。试验表明，时速 50km 下的急刹就足以让孩子从大人怀里飞出去。遇到紧急情况急刹，煞停时间非常短，会造成极大的反向加速度，惯性力会变成体重的好几倍（最大时约 30 倍）。<strong>这是自然规律，抱不住就是抱不住，很爱孩子也抱不住。</strong> 爱又不能修改物理定律。</p>
<p>时速 30km 下的碰撞，也足以让孩子受伤。婴幼儿最大的特点之一，就是脑袋占身体的比例特别大（约 1/4），同时颈椎特别脆弱。30km 下，爱的抱抱可能抱住了，但是脑袋的惯性大，有可能造成颈椎的致命伤，也有可能头撞到车内的硬物。</p>
<p>凭记忆复述，数据未必非常精确，但结论是靠谱的。要不信自己搜试验和案例去。</p>
<p>所以也别说什么『刚出生还不用，等后面再买』。从医院回家不坐车？还是觉得新生儿有新手免疫头比较铁？要实在经济困难，别开车别打车，坐不会急刹的地铁，和低速的公共交通。</p>
<p>就这一段内容，大家要是听进去了，很大一部分目的就达到了。</p>
<h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>安全座椅 <strong>存在有效期</strong> （一般是出厂之后 6 年）。</p>
<p>时间长了，里面的工程塑料和缓冲装置会老化失效。如果发生过碰撞，部分缓冲装置也会失效。所以一般 <strong>不推荐使用二手产品</strong> 。除非知根知底，是没有发生过碰撞的，比较新的产品，剩余的有效期还能覆盖使用时间。</p>
<h3 id="拒绝前排"><a href="#拒绝前排" class="headerlink" title="拒绝前排"></a>拒绝前排</h3><p>首先儿童就是不能坐汽车前排座椅的，哪怕他已经可以不用安全座椅。因为安全气囊是基于成年人设计的。爆破的安全气囊在提供保护的同时，也有一定的危险性，对于成年人而言还是保护大于伤害，但对于儿童则可能变成致命武器。基于同样的理由，即使加上了安全座椅，也不应该坐前排。</p>
<p>如果没有安全气囊，则更不能坐了，难道前挡风玻璃和副驾台能提供更好的保护？</p>
<h3 id="不穿厚衣服"><a href="#不穿厚衣服" class="headerlink" title="不穿厚衣服"></a>不穿厚衣服</h3><p>使用安全座椅时，不要给孩子穿太厚的衣服，因为这样安全座椅很难把孩子固定好。安全座椅倒是把厚衣服固定住了，意外发生时，孩子却从弹性良好的厚衣服里飞出来，一切都白费了。如果温度实在低，开暖气。</p>
<h3 id="车内不堆放杂物"><a href="#车内不堆放杂物" class="headerlink" title="车内不堆放杂物"></a>车内不堆放杂物</h3><p>这条其实就算没有孩子，也是应该做到的。各种香水瓶、挂饰、串儿、摆件，木头的、玻璃的、水晶的、金银的，一旦发生意外，这些又重又硬的物件在车内横飞，造成二次伤害。只是有了孩子，这受伤的阈值一下子往下降。给大人砸个包的物件，换孩子身上就不是一回事了。</p>
<p>花大价钱把孩子固定好了不去撞别的东西，结果东西自己飞过来砸，又是白费力气。</p>
<h2 id="怎么挑"><a href="#怎么挑" class="headerlink" title="怎么挑"></a>怎么挑</h2><p>儿童安全座椅，术语叫 儿童约束系统（Child Restraint System，CRS）。顾名思义，就是一整套，将婴幼儿固定在车上，避免行车过程中受到伤害的装置。座椅是最常见的形式，但也有可能是提篮（婴儿）、床（婴儿）、增高垫（学童）等形式。中文用『儿童安全座椅』做关键词基本上都能搜到，外文可能要尝试不同的术语，而比较正式的统称，就是 CRS。</p>
<p>接下来看看都要做哪些选择题，每个答案代表什么。</p>
<h3 id="年龄段"><a href="#年龄段" class="headerlink" title="年龄段"></a>年龄段</h3><p>安全座椅对标的是成人的安全带。只是婴幼儿达不到使用安全带 140cm 以上的身高标准，而且婴幼儿有头重占比大、颈椎脆弱的特点，所以需要额外的固定和保护。更进一步地说，不仅婴幼儿跟成人要区别对待，不同年龄段的婴幼儿，也有各自的特点，需要分别对待。</p>
<p>最简便的划分，分 <strong>婴儿、幼儿、学童</strong> 三个阶段。这也是C-NCAP（中国新车评价规程）所使用的分组。</p>
<blockquote>
<p>在 <a href="http://www.c-ncap.org/cms/picture/215964820359352320.pdf" target="_blank" rel="external">C-NCAP 19 年版 CRS  评价规则</a> 中，三个分组分别对应：</p>
<ul>
<li>婴儿组：适用体重 13kg 以下，参考年龄 15 个月以下；</li>
<li>幼儿组：适用体重 9~18kg，参考年龄 9 个月至 4 岁；</li>
<li>学童组：适用体重 15~36kg，参考年龄 3 岁 ~ 12 岁。</li>
</ul>
</blockquote>
<p>ADAC （全德汽车协会）的分类则更细一些，分为 <strong>新生儿、1 岁前、1 岁半前、4 岁前、7 岁前、12 岁前</strong> 。</p>
<p>需要注意的是，这些分类主要为了方便分组测试和整理结果，并不指导具体的产品开发。列出来，也只是为了让大家对年龄分段有一个直观的感受。实际的产品设计有自己的考量，除了考虑年龄，还更多地考虑 <strong>体重和身高</strong> 。一些比较精细的产品，可能连一个年龄段都不能覆盖，而通用可调节的产品则可以覆盖多个阶段的使用。</p>
<p>对于年龄段这块，个人总结如下：</p>
<ul>
<li>从孩子出生到 12 岁（身高大于 140cm），<strong>买安全座椅不是一劳永逸的</strong> 。因为覆盖 新生儿 到 12 岁的产品很少，又存在有效期。至于究竟要换多少次，具体看你选的产品怎么划分。</li>
<li>越是精细化的产品，相对而言保护会更有针对性，乘坐更舒适，使用上也更简易（并非绝对），但适用时间也越短，性价比比较低。可以调节，能满足多个阶段的产品，保护的针对性也没那么强，使用上需要调节还会更复杂一些，但可以避免频繁更换造成的麻烦，也节约支出。</li>
<li>多数产品会同时给出 年龄、体重、身高 的参考，其中年龄会标得比较明显，也是测试和销售时的主要分类依据，但实际使用中，参考意义 <strong>体重 &gt; 身高 &gt; 年龄</strong> 。现在孩子生活环境好，营养充足，有可能发育得比较快。如果体重超出了对应年龄段产品的上限，缓冲能力可能不够，则要考虑换下一阶段的产品。身高超标，则影响舒适性，产生脚放不下、安全带压迫等问题。</li>
<li>但也不建议为了延长使用时间，特意买超出当前身高范围的产品，有可能导致限制装置太松，使孩子从安全座椅中滑出。</li>
</ul>
<h3 id="产品类型"><a href="#产品类型" class="headerlink" title="产品类型"></a>产品类型</h3><p>座椅是最常见的产品形态，根据特定年龄段，也会有特殊的产品。</p>
<ul>
<li><strong>提篮 / 睡篮</strong> 。主要供新生儿使用，特点有二：<ul>
<li>考虑新生儿脊椎还没发育好，无法坐起来，需要平躺，提篮把里面的座位放平，形成带安全带的躺椅形式。</li>
<li>考虑新生儿多数时间在睡觉，为了避免上下车把孩子弄醒，提篮做成可以通过底座（硬连接）或者安全带整体固定和分离，分离后可以直接提走。</li>
</ul>
</li>
<li><strong>增高垫</strong> 。主要给接近 12 岁的学童使用，通过增高座位，使儿童达到 140 cm 使用安全带的标准。这类产品提供的保护效果有限，但胜在小巧便携，安装方便，可以作为备选方案，在比较大的孩子乘坐其他汽车时使用。</li>
<li><strong>安全背心  / 其他安全带限位装置</strong> 。作用跟 增高垫 类似，都是针对接近 12 岁的学童。但作用原理刚好相反，通过给孩子穿上安全背心，或者安装别的限位器，引导安全带的走向，让安全带适合保护孩子的需要。优缺点也基本跟增高垫一致。</li>
</ul>
<p>主流还是座椅。增高垫和安全背心是给大孩子用的，而且坐自家车有条件安装安全座椅的情况下，还是推荐安全座椅，提一下就算了。</p>
<p>重点在于新生儿要不要选提篮。提篮有上述的两个优点，缺点也很明显，就是适用时间非常短。因为提篮（接近）平躺，适用身高非常有限，一般 9 个月到 15 个月就不能用。这么贵的安全用品却只能用一年左右，对于普通家庭压力还是不小。</p>
<p>相应地，也可以选适用范围 新生儿 ~ 4 岁的可调节产品。一般通过调节座位的角度和高度，适应不同阶段的孩子，范围最大的可以从平躺一直到坐直，有分档调节和无级调节，后者比较灵活也比较贵。</p>
<h3 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h3><p>这个比较简单，只有两种，（孩子脸）朝后（反向）和朝前（正向）。</p>
<p>原则也只有两条：</p>
<ul>
<li><strong>新生儿只能反向</strong> ！因为新生儿头比重大和颈椎脆弱，正向座椅光固定身体，遇到意外时还是容易把颈椎拉伤。我们又不能把脑袋也捆住。而反向座椅发生急停时，作用力通过椅背作用在整个身体上，不容易对单个部位造成伤害。</li>
<li>只要体重和身高允许，<strong>尽量延长使用反向座椅的时间</strong> 。由于上面提到的原因，在设计提供和身高允许的情况下，延长反向使用的时间比较好。</li>
</ul>
<p>一般情况下，先买给新生儿用的反向座椅。等到反向座椅坐不下时（因为安全座椅面向车上原来的座椅，长到一定程度脚会放不下），顺便换下一阶段的正向座椅。</p>
<p>也可以买双向安装（前后均有安装接口），或者可以旋转方向的产品，延长使用寿命。</p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>一共三种连接方式，要根据车子的情况选择：</p>
<ul>
<li><strong>ISOFIX</strong> ：欧标接口，有两个连接点。支持的车型会在后排座位靠背和坐垫中间有左右两个连接件（跟安全带扣差不多高度，但在缝隙里面，需要用力伸进去才能摸到），将座椅上的连接杆插到底变成绿色就可以固定。市面上的 ISOFIX 产品往往还会多一个支撑脚架伸到过道上，形成三点固定。</li>
<li><strong>LATCH</strong> ：美标接口，在 ISOFIX 的基础上多出一个头部连接点。多出的连接点在头枕后方，后挡风玻璃下面，一般从安全座椅的头部位置伸出钩子固定，加上底下的两个连接点，形成三点固定。</li>
</ul>
<p>这两种都是硬连接，正确安装的情况下，可以将安全座椅视作车辆的一部分。只是需要车子本身支持。<strong>其中支持 LATCH 的车型可以安装 ISOFIX 的座椅，反之则不行</strong> 。在车子支持的情况下，推荐 <strong>优先选择这两种连接方式</strong> 。</p>
<p>如果车子实在不支持，或者有别的考量，就只能选安全带固定的方式：</p>
<ul>
<li>安全带固定：安全座椅上有供汽车安全带穿过的限位器。按照指引，将安全带按顺序穿过多个限位器之后，再将安全带扣上，也就是把安全座椅+孩子作为整体，系上汽车的安全带。由于汽车安全带可以伸缩，安全座椅一定程度上是可以移动的，并非刚性连接。另外，这种安装方式要求按指引，正确给座椅穿好安全带。</li>
</ul>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p>还有一些零散的功能特性，放在这里过一下。</p>
<ul>
<li>侧向保护：大多数情况下，考虑的都是汽车急刹和正向碰撞。但其实侧向碰撞和翻侧的事故也并不少见。所以有些安全座椅会做成包围型，在遭受侧向的作用力时，也能起到一定程度的保护。平时也能作为孩子睡觉时头部的依靠。更进一步的产品，则会在座椅上伸出侧向的支撑杆，固定在靠近一侧的门上，提供进一步的支撑。</li>
<li>五点式安全带：源自赛车安全带的概念，通过双肩、双髋和裆部 五个点将孩子固定住。貌似现在已经成为标配，不怎么提起。倒是如果发现固定点连 5 个都不到，可能要考虑一下。</li>
<li>前置护体：在孩子前方设置一个缓冲块，发生意外时，缓冲块以整个面的方式缓冲受到的作用力。</li>
</ul>
<p>五点式安全带 和 前置护体 貌似不能同时设置，所以成为了互斥的选项。不同产品都宣扬自己选择方式好，指出另一种方式的缺点。</p>
<p>例如 五点式 虽然比老式的安全带增加了固定点，毕竟还是通过 5 个点受力，特别是头部缺少防护。（所以才要推迟正向安装。）而前置护体虽然以一个面承受冲击，但毕竟固定点少，极端情况下有从座椅脱出的风险，而且缓冲块比较碍事，孩子四肢活动相对不自由。</p>
<p>其实两种方式既然同时存在，就说明各有优缺点。哪种好还是看自己的实际情况 和 具体型号的测试结果。</p>
<p>可能还有其他的一些功能点，但我想不起来了，估计也不怎么重要。</p>
<h2 id="强制认证"><a href="#强制认证" class="headerlink" title="强制认证"></a>强制认证</h2><p>先说认证，这是上市的及格线。拿到了不代表什么，没有就问题很大。</p>
<ul>
<li>中国市场：3C 认证，全称是 <strong>中国强制性产品认证（China Compulsory Certification）</strong>。无论是国产还是进口，只要是国内销售的产品，都要拿到这个认证。</li>
<li>欧洲市场：ECE R44/04 认证，全称 <strong>欧洲经济委员会（Economic Commission of Europe）</strong> 认证，其中 R44/04 是针对儿童安全座椅的 44 号法令第 4 版标准。跟 3C 认证类似，这是欧洲执行的强制认证。从欧洲海淘的产品必须有这个认证。据称是目前全世界最严格的认证。</li>
<li>美国市场：ASTM 认证，全称 <strong>美国材料与实验协会（American Society for Testing and Materials）</strong> 认证。跟上面两个不一样，这是自愿认证。没有不代表有问题，有的话最好。</li>
</ul>
<p>很简单，在哪销售的产品，最低限度要拿到当地的强制认证。</p>
<p>国内销售的，可以到 全国认证认可信息公共服务平台查询 3C 认证号： <a href="http://cx.cnca.cn/" target="_blank" rel="external">http://cx.cnca.cn/</a> 。ECE 和 ASTM 貌似没有公开查询的平台（如果有，请在评论补充），但大牌子估计不敢拿品牌信誉开玩笑。</p>
<p>一个产品型号如果在多地上市，则最好每个市场都拿到了对应的认证。</p>
<p>需要特别指出的是，由于欧洲（准确说是欧经会成员国）是多个国家，ECE 还有在哪个国家通过的区别。其中发达国家的测试相对严谨和不容易被收买，网上一般认 <strong>E1德国、E4 荷兰、E11英国</strong> 这三个国家为主。</p>
<h2 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h2><p>认证是准入门槛，只有过和不过。如果想进一步了解不同产品之间的优劣，就要看进一步的安全测试了。</p>
<p>你可不要觉得是多此一举，今天为了给大家找测试网站的地址，进入 C-NCAP 官网第一条看到的就是这个消息：<a href="http://www.c-ncap.org/crs/content/b01b33c08c644cb9a79d9ced15de14a8" target="_blank" rel="external">超20%产品不合格，汽车儿童安全座椅坑在哪儿？</a> （这篇文章也有教挑选技巧，感兴趣可以看看）</p>
<p>这些可是通过了 3C 认证的产品，抽检仍然高达 20% 不合格。文中指出：</p>
<blockquote>
<p>还有一种可能，是生产厂家在后续生产过程未按送检标准进行，因为厂家在做3C认证一般都是送样的，即使送样产品达到认证标准要求，厂家在后期批量生产中出于节省成本偷工减料或其他方面原因，也会造成产品质量。</p>
</blockquote>
<h3 id="C-NCAP-CRS-评价"><a href="#C-NCAP-CRS-评价" class="headerlink" title="C-NCAP CRS 评价"></a>C-NCAP CRS 评价</h3><p>全称 中国新车评价规程（China-New Car Assessment Program）儿童约束系统评价。C-NCAP 是由国资委下的中国汽车技术研究中心建立的试验评价方法。</p>
<p>19 年版 CRS  评价规则：<a href="http://www.c-ncap.org/cms/picture/215964820359352320.pdf" target="_blank" rel="external">http://www.c-ncap.org/cms/picture/215964820359352320.pdf</a></p>
<p>CRS 成绩查询：<a href="http://www.c-ncap.org/crs/main" target="_blank" rel="external">http://www.c-ncap.org/crs/main</a></p>
<p>选择厂商和品牌之后，就可以查到对应的成绩，列表里有 产品商标及名称、组别、固定方式、总体评价 等信息，点击进入详情还能看到各个项目的具体评分。</p>
<p>当然，也可以不选品牌，选择孩子对应的组别和支持的固定方式，在结果里挑选成绩靠前的产品。</p>
<p>CRS 测试的产品是在不告知厂商的情况下，由市场随机购买的，结果比较可靠。目前来看，貌似主要测试国内生成的产品。</p>
<h3 id="ADAC-测试"><a href="#ADAC-测试" class="headerlink" title="ADAC 测试"></a>ADAC 测试</h3><p>全称是 全德汽车协会（Allgemeiner Deutscher Automobil-Club）测试。堪称全世界最严格的儿童安全座椅测试。</p>
<p>测试结果地址：<a href="https://www.adac.de/rund-ums-fahrzeug/tests/kindersicherheit/kindersitztest/" target="_blank" rel="external">https://www.adac.de/rund-ums-fahrzeug/tests/kindersicherheit/kindersitztest/</a></p>
<p>分组、测试项、评分都很精细，还定期曝光不合格的产品信息。</p>
<p>难点是，只有德语。你可能需要找会德语的朋友，或者翻译软件帮忙。更麻烦的是，偶尔网站还会改版，官网地址倒是不会变，具体的查询页变了（现在给出的地址就跟我买的时候不一样），要从主页找到对应的查询页，还真的不容易。</p>
<p>由于距离上次查完已经过了很久，我也不会德语，偏偏浏览器的翻译工具还罢工了，原谅我不打算详细介绍查询技巧。不过大致也是上面的两种思路，要么挑好型号看成绩，要么给定筛选条件挑高分。</p>
<p>ADAC 貌似欧洲常见型号都会测，适合在海淘时参考，或者买国产产品时参考相同型号。不过需要注意的是，国外型号国产化之后，产品未必能保持一致。一部分修改是为了符合国内的认证，一部分也可能存在降低成本的情况。除非在国产的产品信息上，也强调了 ADAC 的测试成绩，表示国内外的产品一致。否则只能用来参考，国产还是以 C-NCAP 为准。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>中国已经是儿童安全座椅产量最大的国家，包括很多外国品牌也交给中国厂商代工。只不过由于国人这方面意识比较欠缺，大多数产品（特别是高端型号）销往了海外。国内是有设计生产高质量产品的实力的。购买时也完全可以考虑国内头部品牌。</p>
<p>但正是因为消费者的认知程度不高，国内市场还是比较混乱，所以购买时要留意各种认证和测试。</p>
<p>在这里，我不打算推荐品牌和型号（厂家没给广告费，你也没给我推荐费）。每个家庭考量不同，取舍不同，而且离我购买也已经过去了一段时间。大家还是跟着这篇文章，自己做一些功课吧。</p>
<p>匆匆写就，挂一漏万，可能有认知盲区，也可能存在过时的信息和观点，如有更新的成果，欢迎留言打脸。</p>
<hr>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议"><br>本文为本人原创，采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享 “署名-非商业性使用-相同方式共享” 4.0 (CC BY-NC-SA 4.0)”许可协议</a>进行许可。<br>本作品可自由复制、传播及基于本作品进行演绎创作。如有以上需要，请留言告知，在文章开头明显位置加上署名（Jayce Chant）、原链接及许可协议信息，并明确指出修改（如有），不得用于商业用途。谢谢合作。<br>请点击查看<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="external">协议</a>的中文摘要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉，我们这批人都到了养娃的年纪。进度快的，孩子都上小学了；稍慢的，也在这几年开始集中报喜。我也是一个父亲。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
